(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
    get: (a2, b) => (typeof require !== "undefined" ? require : a2)[b]
  }) : x2)(function(x2) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x2 + '" is not supported');
  });
  var __commonJS = (cb, mod3) => function __require2() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name10 in all)
      __defProp(target, name10, { get: all[name10], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));
  var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // (disabled):../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/require-utils.node
  var require_require_utils = __commonJS({
    "(disabled):../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/require-utils.node"() {
    }
  });

  // ../../node_modules/hammerjs/hammer.js
  var require_hammer = __commonJS({
    "../../node_modules/hammerjs/hammer.js"(exports, module2) {
      (function(window3, document2, exportName, undefined2) {
        "use strict";
        var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
        var TEST_ELEMENT = document2.createElement("div");
        var TYPE_FUNCTION = "function";
        var round2 = Math.round;
        var abs = Math.abs;
        var now = Date.now;
        function setTimeoutContext(fn, timeout, context) {
          return setTimeout(bindFn(fn, context), timeout);
        }
        function invokeArrayArg(arg, fn, context) {
          if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
          }
          return false;
        }
        function each(obj, iterator, context) {
          var i3;
          if (!obj) {
            return;
          }
          if (obj.forEach) {
            obj.forEach(iterator, context);
          } else if (obj.length !== undefined2) {
            i3 = 0;
            while (i3 < obj.length) {
              iterator.call(context, obj[i3], i3, obj);
              i3++;
            }
          } else {
            for (i3 in obj) {
              obj.hasOwnProperty(i3) && iterator.call(context, obj[i3], i3, obj);
            }
          }
        }
        function deprecate(method, name10, message) {
          var deprecationMessage = "DEPRECATED METHOD: " + name10 + "\n" + message + " AT \n";
          return function() {
            var e2 = new Error("get-stack-trace");
            var stack2 = e2 && e2.stack ? e2.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
            var log4 = window3.console && (window3.console.warn || window3.console.log);
            if (log4) {
              log4.call(window3.console, deprecationMessage, stack2);
            }
            return method.apply(this, arguments);
          };
        }
        var assign;
        if (typeof Object.assign !== "function") {
          assign = function assign2(target) {
            if (target === undefined2 || target === null) {
              throw new TypeError("Cannot convert undefined or null to object");
            }
            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
              var source = arguments[index];
              if (source !== undefined2 && source !== null) {
                for (var nextKey in source) {
                  if (source.hasOwnProperty(nextKey)) {
                    output[nextKey] = source[nextKey];
                  }
                }
              }
            }
            return output;
          };
        } else {
          assign = Object.assign;
        }
        var extend = deprecate(function extend2(dest, src, merge2) {
          var keys = Object.keys(src);
          var i3 = 0;
          while (i3 < keys.length) {
            if (!merge2 || merge2 && dest[keys[i3]] === undefined2) {
              dest[keys[i3]] = src[keys[i3]];
            }
            i3++;
          }
          return dest;
        }, "extend", "Use `assign`.");
        var merge = deprecate(function merge2(dest, src) {
          return extend(dest, src, true);
        }, "merge", "Use `assign`.");
        function inherit(child, base, properties) {
          var baseP = base.prototype, childP;
          childP = child.prototype = Object.create(baseP);
          childP.constructor = child;
          childP._super = baseP;
          if (properties) {
            assign(childP, properties);
          }
        }
        function bindFn(fn, context) {
          return function boundFn() {
            return fn.apply(context, arguments);
          };
        }
        function boolOrFn(val2, args) {
          if (typeof val2 == TYPE_FUNCTION) {
            return val2.apply(args ? args[0] || undefined2 : undefined2, args);
          }
          return val2;
        }
        function ifUndefined(val1, val2) {
          return val1 === undefined2 ? val2 : val1;
        }
        function addEventListeners(target, types, handler) {
          each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
          });
        }
        function removeEventListeners(target, types, handler) {
          each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
          });
        }
        function hasParent(node2, parent) {
          while (node2) {
            if (node2 == parent) {
              return true;
            }
            node2 = node2.parentNode;
          }
          return false;
        }
        function inStr(str, find) {
          return str.indexOf(find) > -1;
        }
        function splitStr(str) {
          return str.trim().split(/\s+/g);
        }
        function inArray(src, find, findByKey) {
          if (src.indexOf && !findByKey) {
            return src.indexOf(find);
          } else {
            var i3 = 0;
            while (i3 < src.length) {
              if (findByKey && src[i3][findByKey] == find || !findByKey && src[i3] === find) {
                return i3;
              }
              i3++;
            }
            return -1;
          }
        }
        function toArray(obj) {
          return Array.prototype.slice.call(obj, 0);
        }
        function uniqueArray(src, key, sort) {
          var results = [];
          var values = [];
          var i3 = 0;
          while (i3 < src.length) {
            var val2 = key ? src[i3][key] : src[i3];
            if (inArray(values, val2) < 0) {
              results.push(src[i3]);
            }
            values[i3] = val2;
            i3++;
          }
          if (sort) {
            if (!key) {
              results = results.sort();
            } else {
              results = results.sort(function sortUniqueArray(a2, b) {
                return a2[key] > b[key];
              });
            }
          }
          return results;
        }
        function prefixed(obj, property) {
          var prefix, prop;
          var camelProp = property[0].toUpperCase() + property.slice(1);
          var i3 = 0;
          while (i3 < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i3];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
              return prop;
            }
            i3++;
          }
          return undefined2;
        }
        var _uniqueId = 1;
        function uniqueId() {
          return _uniqueId++;
        }
        function getWindowForElement(element) {
          var doc = element.ownerDocument || element;
          return doc.defaultView || doc.parentWindow || window3;
        }
        var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
        var SUPPORT_TOUCH = "ontouchstart" in window3;
        var SUPPORT_POINTER_EVENTS = prefixed(window3, "PointerEvent") !== undefined2;
        var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
        var INPUT_TYPE_TOUCH = "touch";
        var INPUT_TYPE_PEN = "pen";
        var INPUT_TYPE_MOUSE = "mouse";
        var INPUT_TYPE_KINECT = "kinect";
        var COMPUTE_INTERVAL = 25;
        var INPUT_START2 = 1;
        var INPUT_MOVE2 = 2;
        var INPUT_END2 = 4;
        var INPUT_CANCEL = 8;
        var DIRECTION_NONE = 1;
        var DIRECTION_LEFT = 2;
        var DIRECTION_RIGHT = 4;
        var DIRECTION_UP = 8;
        var DIRECTION_DOWN = 16;
        var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
        var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
        var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
        var PROPS_XY = ["x", "y"];
        var PROPS_CLIENT_XY = ["clientX", "clientY"];
        function Input2(manager, callback) {
          var self2 = this;
          this.manager = manager;
          this.callback = callback;
          this.element = manager.element;
          this.target = manager.options.inputTarget;
          this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
              self2.handler(ev);
            }
          };
          this.init();
        }
        Input2.prototype = {
          handler: function() {
          },
          init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          },
          destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          }
        };
        function createInputInstance(manager) {
          var Type2;
          var inputClass = manager.options.inputClass;
          if (inputClass) {
            Type2 = inputClass;
          } else if (SUPPORT_POINTER_EVENTS) {
            Type2 = PointerEventInput;
          } else if (SUPPORT_ONLY_TOUCH) {
            Type2 = TouchInput;
          } else if (!SUPPORT_TOUCH) {
            Type2 = MouseInput;
          } else {
            Type2 = TouchMouseInput;
          }
          return new Type2(manager, inputHandler);
        }
        function inputHandler(manager, eventType, input) {
          var pointersLen = input.pointers.length;
          var changedPointersLen = input.changedPointers.length;
          var isFirst = eventType & INPUT_START2 && pointersLen - changedPointersLen === 0;
          var isFinal = eventType & (INPUT_END2 | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
          input.isFirst = !!isFirst;
          input.isFinal = !!isFinal;
          if (isFirst) {
            manager.session = {};
          }
          input.eventType = eventType;
          computeInputData(manager, input);
          manager.emit("hammer.input", input);
          manager.recognize(input);
          manager.session.prevInput = input;
        }
        function computeInputData(manager, input) {
          var session = manager.session;
          var pointers = input.pointers;
          var pointersLength = pointers.length;
          if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
          }
          if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
          } else if (pointersLength === 1) {
            session.firstMultiple = false;
          }
          var firstInput = session.firstInput;
          var firstMultiple = session.firstMultiple;
          var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
          var center = input.center = getCenter(pointers);
          input.timeStamp = now();
          input.deltaTime = input.timeStamp - firstInput.timeStamp;
          input.angle = getAngle(offsetCenter, center);
          input.distance = getDistance(offsetCenter, center);
          computeDeltaXY(session, input);
          input.offsetDirection = getDirection(input.deltaX, input.deltaY);
          var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
          input.overallVelocityX = overallVelocity.x;
          input.overallVelocityY = overallVelocity.y;
          input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
          input.scale = firstMultiple ? getScale3(firstMultiple.pointers, pointers) : 1;
          input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
          input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
          computeIntervalInputData(session, input);
          var target = manager.element;
          if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
          }
          input.target = target;
        }
        function computeDeltaXY(session, input) {
          var center = input.center;
          var offset = session.offsetDelta || {};
          var prevDelta = session.prevDelta || {};
          var prevInput = session.prevInput || {};
          if (input.eventType === INPUT_START2 || prevInput.eventType === INPUT_END2) {
            prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
              x: center.x,
              y: center.y
            };
          }
          input.deltaX = prevDelta.x + (center.x - offset.x);
          input.deltaY = prevDelta.y + (center.y - offset.y);
        }
        function computeIntervalInputData(session, input) {
          var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
          if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
          } else {
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
          }
          input.velocity = velocity;
          input.velocityX = velocityX;
          input.velocityY = velocityY;
          input.direction = direction;
        }
        function simpleCloneInputData(input) {
          var pointers = [];
          var i3 = 0;
          while (i3 < input.pointers.length) {
            pointers[i3] = {
              clientX: round2(input.pointers[i3].clientX),
              clientY: round2(input.pointers[i3].clientY)
            };
            i3++;
          }
          return {
            timeStamp: now(),
            pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
          };
        }
        function getCenter(pointers) {
          var pointersLength = pointers.length;
          if (pointersLength === 1) {
            return {
              x: round2(pointers[0].clientX),
              y: round2(pointers[0].clientY)
            };
          }
          var x2 = 0, y2 = 0, i3 = 0;
          while (i3 < pointersLength) {
            x2 += pointers[i3].clientX;
            y2 += pointers[i3].clientY;
            i3++;
          }
          return {
            x: round2(x2 / pointersLength),
            y: round2(y2 / pointersLength)
          };
        }
        function getVelocity(deltaTime, x2, y2) {
          return {
            x: x2 / deltaTime || 0,
            y: y2 / deltaTime || 0
          };
        }
        function getDirection(x2, y2) {
          if (x2 === y2) {
            return DIRECTION_NONE;
          }
          if (abs(x2) >= abs(y2)) {
            return x2 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
          return y2 < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        }
        function getDistance(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x2 = p2[props[0]] - p1[props[0]], y2 = p2[props[1]] - p1[props[1]];
          return Math.sqrt(x2 * x2 + y2 * y2);
        }
        function getAngle(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x2 = p2[props[0]] - p1[props[0]], y2 = p2[props[1]] - p1[props[1]];
          return Math.atan2(y2, x2) * 180 / Math.PI;
        }
        function getRotation(start, end) {
          return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
        }
        function getScale3(start, end) {
          return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
        }
        var MOUSE_INPUT_MAP2 = {
          mousedown: INPUT_START2,
          mousemove: INPUT_MOVE2,
          mouseup: INPUT_END2
        };
        var MOUSE_ELEMENT_EVENTS = "mousedown";
        var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
        function MouseInput() {
          this.evEl = MOUSE_ELEMENT_EVENTS;
          this.evWin = MOUSE_WINDOW_EVENTS;
          this.pressed = false;
          Input2.apply(this, arguments);
        }
        inherit(MouseInput, Input2, {
          handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP2[ev.type];
            if (eventType & INPUT_START2 && ev.button === 0) {
              this.pressed = true;
            }
            if (eventType & INPUT_MOVE2 && ev.which !== 1) {
              eventType = INPUT_END2;
            }
            if (!this.pressed) {
              return;
            }
            if (eventType & INPUT_END2) {
              this.pressed = false;
            }
            this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
            });
          }
        });
        var POINTER_INPUT_MAP = {
          pointerdown: INPUT_START2,
          pointermove: INPUT_MOVE2,
          pointerup: INPUT_END2,
          pointercancel: INPUT_CANCEL,
          pointerout: INPUT_CANCEL
        };
        var IE10_POINTER_TYPE_ENUM = {
          2: INPUT_TYPE_TOUCH,
          3: INPUT_TYPE_PEN,
          4: INPUT_TYPE_MOUSE,
          5: INPUT_TYPE_KINECT
        };
        var POINTER_ELEMENT_EVENTS = "pointerdown";
        var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
        if (window3.MSPointerEvent && !window3.PointerEvent) {
          POINTER_ELEMENT_EVENTS = "MSPointerDown";
          POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
        }
        function PointerEventInput() {
          this.evEl = POINTER_ELEMENT_EVENTS;
          this.evWin = POINTER_WINDOW_EVENTS;
          Input2.apply(this, arguments);
          this.store = this.manager.session.pointerEvents = [];
        }
        inherit(PointerEventInput, Input2, {
          handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            var storeIndex = inArray(store, ev.pointerId, "pointerId");
            if (eventType & INPUT_START2 && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
              }
            } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
              removePointer = true;
            }
            if (storeIndex < 0) {
              return;
            }
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType,
              srcEvent: ev
            });
            if (removePointer) {
              store.splice(storeIndex, 1);
            }
          }
        });
        var SINGLE_TOUCH_INPUT_MAP = {
          touchstart: INPUT_START2,
          touchmove: INPUT_MOVE2,
          touchend: INPUT_END2,
          touchcancel: INPUT_CANCEL
        };
        var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
        var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
        function SingleTouchInput() {
          this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
          this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
          this.started = false;
          Input2.apply(this, arguments);
        }
        inherit(SingleTouchInput, Input2, {
          handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            if (type === INPUT_START2) {
              this.started = true;
            }
            if (!this.started) {
              return;
            }
            var touches = normalizeSingleTouches.call(this, ev, type);
            if (type & (INPUT_END2 | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function normalizeSingleTouches(ev, type) {
          var all = toArray(ev.touches);
          var changed = toArray(ev.changedTouches);
          if (type & (INPUT_END2 | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), "identifier", true);
          }
          return [all, changed];
        }
        var TOUCH_INPUT_MAP = {
          touchstart: INPUT_START2,
          touchmove: INPUT_MOVE2,
          touchend: INPUT_END2,
          touchcancel: INPUT_CANCEL
        };
        var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
        function TouchInput() {
          this.evTarget = TOUCH_TARGET_EVENTS;
          this.targetIds = {};
          Input2.apply(this, arguments);
        }
        inherit(TouchInput, Input2, {
          handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
              return;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function getTouches(ev, type) {
          var allTouches = toArray(ev.touches);
          var targetIds = this.targetIds;
          if (type & (INPUT_START2 | INPUT_MOVE2) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
          }
          var i3, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
          targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
          });
          if (type === INPUT_START2) {
            i3 = 0;
            while (i3 < targetTouches.length) {
              targetIds[targetTouches[i3].identifier] = true;
              i3++;
            }
          }
          i3 = 0;
          while (i3 < changedTouches.length) {
            if (targetIds[changedTouches[i3].identifier]) {
              changedTargetTouches.push(changedTouches[i3]);
            }
            if (type & (INPUT_END2 | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i3].identifier];
            }
            i3++;
          }
          if (!changedTargetTouches.length) {
            return;
          }
          return [
            uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
            changedTargetTouches
          ];
        }
        var DEDUP_TIMEOUT = 2500;
        var DEDUP_DISTANCE = 25;
        function TouchMouseInput() {
          Input2.apply(this, arguments);
          var handler = bindFn(this.handler, this);
          this.touch = new TouchInput(this.manager, handler);
          this.mouse = new MouseInput(this.manager, handler);
          this.primaryTouch = null;
          this.lastTouches = [];
        }
        inherit(TouchMouseInput, Input2, {
          handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
              return;
            }
            if (isTouch) {
              recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
              return;
            }
            this.callback(manager, inputEvent, inputData);
          },
          destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
          }
        });
        function recordTouches(eventType, eventData) {
          if (eventType & INPUT_START2) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
          } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
          }
        }
        function setLastTouch(eventData) {
          var touch = eventData.changedPointers[0];
          if (touch.identifier === this.primaryTouch) {
            var lastTouch = { x: touch.clientX, y: touch.clientY };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
              var i3 = lts.indexOf(lastTouch);
              if (i3 > -1) {
                lts.splice(i3, 1);
              }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
          }
        }
        function isSyntheticEvent(eventData) {
          var x2 = eventData.srcEvent.clientX, y2 = eventData.srcEvent.clientY;
          for (var i3 = 0; i3 < this.lastTouches.length; i3++) {
            var t2 = this.lastTouches[i3];
            var dx = Math.abs(x2 - t2.x), dy = Math.abs(y2 - t2.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
              return true;
            }
          }
          return false;
        }
        var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
        var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
        var TOUCH_ACTION_COMPUTE = "compute";
        var TOUCH_ACTION_AUTO = "auto";
        var TOUCH_ACTION_MANIPULATION = "manipulation";
        var TOUCH_ACTION_NONE = "none";
        var TOUCH_ACTION_PAN_X = "pan-x";
        var TOUCH_ACTION_PAN_Y = "pan-y";
        var TOUCH_ACTION_MAP = getTouchActionProps();
        function TouchAction(manager, value) {
          this.manager = manager;
          this.set(value);
        }
        TouchAction.prototype = {
          set: function(value) {
            if (value == TOUCH_ACTION_COMPUTE) {
              value = this.compute();
            }
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
          },
          update: function() {
            this.set(this.manager.options.touchAction);
          },
          compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
              }
            });
            return cleanTouchActions(actions.join(" "));
          },
          preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;
              if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
              }
            }
            if (hasPanX && hasPanY) {
              return;
            }
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
              return this.preventSrc(srcEvent);
            }
          },
          preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
          }
        };
        function cleanTouchActions(actions) {
          if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
          }
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
          if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
          }
          if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
          }
          if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
          }
          return TOUCH_ACTION_AUTO;
        }
        function getTouchActionProps() {
          if (!NATIVE_TOUCH_ACTION) {
            return false;
          }
          var touchMap = {};
          var cssSupports = window3.CSS && window3.CSS.supports;
          ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val2) {
            touchMap[val2] = cssSupports ? window3.CSS.supports("touch-action", val2) : true;
          });
          return touchMap;
        }
        var STATE_POSSIBLE = 1;
        var STATE_BEGAN = 2;
        var STATE_CHANGED = 4;
        var STATE_ENDED = 8;
        var STATE_RECOGNIZED = STATE_ENDED;
        var STATE_CANCELLED = 16;
        var STATE_FAILED = 32;
        function Recognizer(options) {
          this.options = assign({}, this.defaults, options || {});
          this.id = uniqueId();
          this.manager = null;
          this.options.enable = ifUndefined(this.options.enable, true);
          this.state = STATE_POSSIBLE;
          this.simultaneous = {};
          this.requireFail = [];
        }
        Recognizer.prototype = {
          defaults: {},
          set: function(options) {
            assign(this.options, options);
            this.manager && this.manager.touchAction.update();
            return this;
          },
          recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
              return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
            }
            return this;
          },
          dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
          },
          requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
              return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
            }
            return this;
          },
          dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
              this.requireFail.splice(index, 1);
            }
            return this;
          },
          hasRequireFailures: function() {
            return this.requireFail.length > 0;
          },
          canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
          },
          emit: function(input) {
            var self2 = this;
            var state = this.state;
            function emit(event) {
              self2.manager.emit(event, input);
            }
            if (state < STATE_ENDED) {
              emit(self2.options.event + stateStr(state));
            }
            emit(self2.options.event);
            if (input.additionalEvent) {
              emit(input.additionalEvent);
            }
            if (state >= STATE_ENDED) {
              emit(self2.options.event + stateStr(state));
            }
          },
          tryEmit: function(input) {
            if (this.canEmit()) {
              return this.emit(input);
            }
            this.state = STATE_FAILED;
          },
          canEmit: function() {
            var i3 = 0;
            while (i3 < this.requireFail.length) {
              if (!(this.requireFail[i3].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
              }
              i3++;
            }
            return true;
          },
          recognize: function(inputData) {
            var inputDataClone = assign({}, inputData);
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
            }
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
            }
            this.state = this.process(inputDataClone);
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
            }
          },
          process: function(inputData) {
          },
          getTouchAction: function() {
          },
          reset: function() {
          }
        };
        function stateStr(state) {
          if (state & STATE_CANCELLED) {
            return "cancel";
          } else if (state & STATE_ENDED) {
            return "end";
          } else if (state & STATE_CHANGED) {
            return "move";
          } else if (state & STATE_BEGAN) {
            return "start";
          }
          return "";
        }
        function directionStr(direction) {
          if (direction == DIRECTION_DOWN) {
            return "down";
          } else if (direction == DIRECTION_UP) {
            return "up";
          } else if (direction == DIRECTION_LEFT) {
            return "left";
          } else if (direction == DIRECTION_RIGHT) {
            return "right";
          }
          return "";
        }
        function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
          var manager = recognizer.manager;
          if (manager) {
            return manager.get(otherRecognizer);
          }
          return otherRecognizer;
        }
        function AttrRecognizer() {
          Recognizer.apply(this, arguments);
        }
        inherit(AttrRecognizer, Recognizer, {
          defaults: {
            pointers: 1
          },
          attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
          },
          process: function(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
              if (eventType & INPUT_END2) {
                return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
              }
              return state | STATE_CHANGED;
            }
            return STATE_FAILED;
          }
        });
        function PanRecognizer() {
          AttrRecognizer.apply(this, arguments);
          this.pX = null;
          this.pY = null;
        }
        inherit(PanRecognizer, AttrRecognizer, {
          defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
          },
          getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
          },
          directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance3 = input.distance;
            var direction = input.direction;
            var x2 = input.deltaX;
            var y2 = input.deltaY;
            if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                direction = x2 === 0 ? DIRECTION_NONE : x2 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x2 != this.pX;
                distance3 = Math.abs(input.deltaX);
              } else {
                direction = y2 === 0 ? DIRECTION_NONE : y2 < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y2 != this.pY;
                distance3 = Math.abs(input.deltaY);
              }
            }
            input.direction = direction;
            return hasMoved && distance3 > options.threshold && direction & options.direction;
          },
          attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
          },
          emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) {
              input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
          }
        });
        function PinchRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(PinchRecognizer, AttrRecognizer, {
          defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
          },
          emit: function(input) {
            if (input.scale !== 1) {
              var inOut = input.scale < 1 ? "in" : "out";
              input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
          }
        });
        function PressRecognizer() {
          Recognizer.apply(this, arguments);
          this._timer = null;
          this._input = null;
        }
        inherit(PressRecognizer, Recognizer, {
          defaults: {
            event: "press",
            pointers: 1,
            time: 251,
            threshold: 9
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_AUTO];
          },
          process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            if (!validMovement || !validPointers || input.eventType & (INPUT_END2 | INPUT_CANCEL) && !validTime) {
              this.reset();
            } else if (input.eventType & INPUT_START2) {
              this.reset();
              this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
              }, options.time, this);
            } else if (input.eventType & INPUT_END2) {
              return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
              return;
            }
            if (input && input.eventType & INPUT_END2) {
              this.manager.emit(this.options.event + "up", input);
            } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function RotateRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(RotateRecognizer, AttrRecognizer, {
          defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
          }
        });
        function SwipeRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(SwipeRecognizer, AttrRecognizer, {
          defaults: {
            event: "swipe",
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
          },
          getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
          },
          attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
            }
            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END2;
          },
          emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
              this.manager.emit(this.options.event + direction, input);
            }
            this.manager.emit(this.options.event, input);
          }
        });
        function TapRecognizer() {
          Recognizer.apply(this, arguments);
          this.pTime = false;
          this.pCenter = false;
          this._timer = null;
          this._input = null;
          this.count = 0;
        }
        inherit(TapRecognizer, Recognizer, {
          defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 9,
            posThreshold: 10
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION];
          },
          process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START2 && this.count === 0) {
              return this.failTimeout();
            }
            if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END2) {
                return this.failTimeout();
              }
              var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
              this.pTime = input.timeStamp;
              this.pCenter = input.center;
              if (!validMultiTap || !validInterval) {
                this.count = 1;
              } else {
                this.count += 1;
              }
              this._input = input;
              var tapCount = this.count % options.taps;
              if (tapCount === 0) {
                if (!this.hasRequireFailures()) {
                  return STATE_RECOGNIZED;
                } else {
                  this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                  }, options.interval, this);
                  return STATE_BEGAN;
                }
              }
            }
            return STATE_FAILED;
          },
          failTimeout: function() {
            this._timer = setTimeoutContext(function() {
              this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function() {
            if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function Hammer(element, options) {
          options = options || {};
          options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
          return new Manager2(element, options);
        }
        Hammer.VERSION = "2.0.7";
        Hammer.defaults = {
          domEvents: false,
          touchAction: TOUCH_ACTION_COMPUTE,
          enable: true,
          inputTarget: null,
          inputClass: null,
          preset: [
            [RotateRecognizer, { enable: false }],
            [PinchRecognizer, { enable: false }, ["rotate"]],
            [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
            [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
            [TapRecognizer],
            [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
            [PressRecognizer]
          ],
          cssProps: {
            userSelect: "none",
            touchSelect: "none",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
          }
        };
        var STOP = 1;
        var FORCED_STOP = 2;
        function Manager2(element, options) {
          this.options = assign({}, Hammer.defaults, options || {});
          this.options.inputTarget = this.options.inputTarget || element;
          this.handlers = {};
          this.session = {};
          this.recognizers = [];
          this.oldCssProps = {};
          this.element = element;
          this.input = createInputInstance(this);
          this.touchAction = new TouchAction(this, this.options.touchAction);
          toggleCssProps(this, true);
          each(this.options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
          }, this);
        }
        Manager2.prototype = {
          set: function(options) {
            assign(this.options, options);
            if (options.touchAction) {
              this.touchAction.update();
            }
            if (options.inputTarget) {
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
            }
            return this;
          },
          stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
          },
          recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
              return;
            }
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            var curRecognizer = session.curRecognizer;
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
              curRecognizer = session.curRecognizer = null;
            }
            var i3 = 0;
            while (i3 < recognizers.length) {
              recognizer = recognizers[i3];
              if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                recognizer.recognize(inputData);
              } else {
                recognizer.reset();
              }
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
              }
              i3++;
            }
          },
          get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
              return recognizer;
            }
            var recognizers = this.recognizers;
            for (var i3 = 0; i3 < recognizers.length; i3++) {
              if (recognizers[i3].options.event == recognizer) {
                return recognizers[i3];
              }
            }
            return null;
          },
          add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) {
              return this;
            }
            var existing = this.get(recognizer.options.event);
            if (existing) {
              this.remove(existing);
            }
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
          },
          remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) {
              return this;
            }
            recognizer = this.get(recognizer);
            if (recognizer) {
              var recognizers = this.recognizers;
              var index = inArray(recognizers, recognizer);
              if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
              }
            }
            return this;
          },
          on: function(events, handler) {
            if (events === undefined2) {
              return;
            }
            if (handler === undefined2) {
              return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
            });
            return this;
          },
          off: function(events, handler) {
            if (events === undefined2) {
              return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
              if (!handler) {
                delete handlers[event];
              } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
            });
            return this;
          },
          emit: function(event, data) {
            if (this.options.domEvents) {
              triggerDomEvent(event, data);
            }
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
              return;
            }
            data.type = event;
            data.preventDefault = function() {
              data.srcEvent.preventDefault();
            };
            var i3 = 0;
            while (i3 < handlers.length) {
              handlers[i3](data);
              i3++;
            }
          },
          destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
          }
        };
        function toggleCssProps(manager, add7) {
          var element = manager.element;
          if (!element.style) {
            return;
          }
          var prop;
          each(manager.options.cssProps, function(value, name10) {
            prop = prefixed(element.style, name10);
            if (add7) {
              manager.oldCssProps[prop] = element.style[prop];
              element.style[prop] = value;
            } else {
              element.style[prop] = manager.oldCssProps[prop] || "";
            }
          });
          if (!add7) {
            manager.oldCssProps = {};
          }
        }
        function triggerDomEvent(event, data) {
          var gestureEvent = document2.createEvent("Event");
          gestureEvent.initEvent(event, true, true);
          gestureEvent.gesture = data;
          data.target.dispatchEvent(gestureEvent);
        }
        assign(Hammer, {
          INPUT_START: INPUT_START2,
          INPUT_MOVE: INPUT_MOVE2,
          INPUT_END: INPUT_END2,
          INPUT_CANCEL,
          STATE_POSSIBLE,
          STATE_BEGAN,
          STATE_CHANGED,
          STATE_ENDED,
          STATE_RECOGNIZED,
          STATE_CANCELLED,
          STATE_FAILED,
          DIRECTION_NONE,
          DIRECTION_LEFT,
          DIRECTION_RIGHT,
          DIRECTION_UP,
          DIRECTION_DOWN,
          DIRECTION_HORIZONTAL,
          DIRECTION_VERTICAL,
          DIRECTION_ALL,
          Manager: Manager2,
          Input: Input2,
          TouchAction,
          TouchInput,
          MouseInput,
          PointerEventInput,
          TouchMouseInput,
          SingleTouchInput,
          Recognizer,
          AttrRecognizer,
          Tap: TapRecognizer,
          Pan: PanRecognizer,
          Swipe: SwipeRecognizer,
          Pinch: PinchRecognizer,
          Rotate: RotateRecognizer,
          Press: PressRecognizer,
          on: addEventListeners,
          off: removeEventListeners,
          each,
          merge,
          extend,
          assign,
          inherit,
          bindFn,
          prefixed
        });
        var freeGlobal = typeof window3 !== "undefined" ? window3 : typeof self !== "undefined" ? self : {};
        freeGlobal.Hammer = Hammer;
        if (undefined2 === "function" && define.amd) {
          define(function() {
            return Hammer;
          });
        } else if (typeof module2 != "undefined" && module2.exports) {
          module2.exports = Hammer;
        } else {
          window3[exportName] = Hammer;
        }
      })(window, document, "Hammer");
    }
  });

  // ../layers/node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "../layers/node_modules/earcut/src/earcut.js"(exports, module2) {
      "use strict";
      module2.exports = earcut3;
      module2.exports.default = earcut3;
      function earcut3(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList2(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x2, y2, invSize;
        if (hasHoles)
          outerNode = eliminateHoles2(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i3 = dim; i3 < outerLen; i3 += dim) {
            x2 = data[i3];
            y2 = data[i3 + 1];
            if (x2 < minX)
              minX = x2;
            if (y2 < minY)
              minY = y2;
            if (x2 > maxX)
              maxX = x2;
            if (y2 > maxY)
              maxY = y2;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked2(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList2(data, start, end, dim, clockwise) {
        var i3, last;
        if (clockwise === signedArea2(data, start, end, dim) > 0) {
          for (i3 = start; i3 < end; i3 += dim)
            last = insertNode2(i3, data[i3], data[i3 + 1], last);
        } else {
          for (i3 = end - dim; i3 >= start; i3 -= dim)
            last = insertNode2(i3, data[i3], data[i3 + 1], last);
        }
        if (last && equals5(last, last.next)) {
          removeNode2(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints2(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p2 = start, again;
        do {
          again = false;
          if (!p2.steiner && (equals5(p2, p2.next) || area2(p2.prev, p2, p2.next) === 0)) {
            removeNode2(p2);
            p2 = end = p2.prev;
            if (p2 === p2.next)
              break;
            again = true;
          } else {
            p2 = p2.next;
          }
        } while (again || p2 !== end);
        return end;
      }
      function earcutLinked2(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve2(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed2(ear, minX, minY, invSize) : isEar2(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode2(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked2(filterPoints2(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections2(filterPoints2(ear), triangles, dim);
              earcutLinked2(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut2(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar2(ear) {
        var a2 = ear.prev, b = ear, c = ear.next;
        if (area2(a2, b, c) >= 0)
          return false;
        var ax = a2.x, bx = b.x, cx = c.x, ay = a2.y, by = b.y, cy = c.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p2 = c.next;
        while (p2 !== a2) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle2(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area2(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.next;
        }
        return true;
      }
      function isEarHashed2(ear, minX, minY, invSize) {
        var a2 = ear.prev, b = ear, c = ear.next;
        if (area2(a2, b, c) >= 0)
          return false;
        var ax = a2.x, bx = b.x, cx = c.x, ay = a2.y, by = b.y, cy = c.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder2(x0, y0, minX, minY, invSize), maxZ = zOrder2(x1, y1, minX, minY, invSize);
        var p2 = ear.prevZ, n2 = ear.nextZ;
        while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c && pointInTriangle2(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area2(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.prevZ;
          if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c && pointInTriangle2(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area2(n2.prev, n2, n2.next) >= 0)
            return false;
          n2 = n2.nextZ;
        }
        while (p2 && p2.z >= minZ) {
          if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c && pointInTriangle2(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area2(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.prevZ;
        }
        while (n2 && n2.z <= maxZ) {
          if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c && pointInTriangle2(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area2(n2.prev, n2, n2.next) >= 0)
            return false;
          n2 = n2.nextZ;
        }
        return true;
      }
      function cureLocalIntersections2(start, triangles, dim) {
        var p2 = start;
        do {
          var a2 = p2.prev, b = p2.next.next;
          if (!equals5(a2, b) && intersects2(a2, p2, p2.next, b) && locallyInside2(a2, b) && locallyInside2(b, a2)) {
            triangles.push(a2.i / dim | 0);
            triangles.push(p2.i / dim | 0);
            triangles.push(b.i / dim | 0);
            removeNode2(p2);
            removeNode2(p2.next);
            p2 = start = b;
          }
          p2 = p2.next;
        } while (p2 !== start);
        return filterPoints2(p2);
      }
      function splitEarcut2(start, triangles, dim, minX, minY, invSize) {
        var a2 = start;
        do {
          var b = a2.next.next;
          while (b !== a2.prev) {
            if (a2.i !== b.i && isValidDiagonal2(a2, b)) {
              var c = splitPolygon2(a2, b);
              a2 = filterPoints2(a2, a2.next);
              c = filterPoints2(c, c.next);
              earcutLinked2(a2, triangles, dim, minX, minY, invSize, 0);
              earcutLinked2(c, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b = b.next;
          }
          a2 = a2.next;
        } while (a2 !== start);
      }
      function eliminateHoles2(data, holeIndices, outerNode, dim) {
        var queue = [], i3, len3, start, end, list;
        for (i3 = 0, len3 = holeIndices.length; i3 < len3; i3++) {
          start = holeIndices[i3] * dim;
          end = i3 < len3 - 1 ? holeIndices[i3 + 1] * dim : data.length;
          list = linkedList2(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost2(list));
        }
        queue.sort(compareX2);
        for (i3 = 0; i3 < queue.length; i3++) {
          outerNode = eliminateHole2(queue[i3], outerNode);
        }
        return outerNode;
      }
      function compareX2(a2, b) {
        return a2.x - b.x;
      }
      function eliminateHole2(hole, outerNode) {
        var bridge = findHoleBridge2(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon2(bridge, hole);
        filterPoints2(bridgeReverse, bridgeReverse.next);
        return filterPoints2(bridge, bridge.next);
      }
      function findHoleBridge2(hole, outerNode) {
        var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
          if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
            var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
            if (x2 <= hx && x2 > qx) {
              qx = x2;
              m = p2.x < p2.next.x ? p2 : p2.next;
              if (x2 === hx)
                return m;
            }
          }
          p2 = p2.next;
        } while (p2 !== outerNode);
        if (!m)
          return null;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan2;
        p2 = m;
        do {
          if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle2(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
            tan2 = Math.abs(hy - p2.y) / (hx - p2.x);
            if (locallyInside2(p2, hole) && (tan2 < tanMin || tan2 === tanMin && (p2.x > m.x || p2.x === m.x && sectorContainsSector2(m, p2)))) {
              m = p2;
              tanMin = tan2;
            }
          }
          p2 = p2.next;
        } while (p2 !== stop);
        return m;
      }
      function sectorContainsSector2(m, p2) {
        return area2(m.prev, m, p2.prev) < 0 && area2(p2.next, m, m.next) < 0;
      }
      function indexCurve2(start, minX, minY, invSize) {
        var p2 = start;
        do {
          if (p2.z === 0)
            p2.z = zOrder2(p2.x, p2.y, minX, minY, invSize);
          p2.prevZ = p2.prev;
          p2.nextZ = p2.next;
          p2 = p2.next;
        } while (p2 !== start);
        p2.prevZ.nextZ = null;
        p2.prevZ = null;
        sortLinked2(p2);
      }
      function sortLinked2(list) {
        var i3, p2, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p2 = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p2) {
            numMerges++;
            q = p2;
            pSize = 0;
            for (i3 = 0; i3 < inSize; i3++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
                e2 = p2;
                p2 = p2.nextZ;
                pSize--;
              } else {
                e2 = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e2;
              else
                list = e2;
              e2.prevZ = tail;
              tail = e2;
            }
            p2 = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder2(x2, y2, minX, minY, invSize) {
        x2 = (x2 - minX) * invSize | 0;
        y2 = (y2 - minY) * invSize | 0;
        x2 = (x2 | x2 << 8) & 16711935;
        x2 = (x2 | x2 << 4) & 252645135;
        x2 = (x2 | x2 << 2) & 858993459;
        x2 = (x2 | x2 << 1) & 1431655765;
        y2 = (y2 | y2 << 8) & 16711935;
        y2 = (y2 | y2 << 4) & 252645135;
        y2 = (y2 | y2 << 2) & 858993459;
        y2 = (y2 | y2 << 1) & 1431655765;
        return x2 | y2 << 1;
      }
      function getLeftmost2(start) {
        var p2 = start, leftmost = start;
        do {
          if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
            leftmost = p2;
          p2 = p2.next;
        } while (p2 !== start);
        return leftmost;
      }
      function pointInTriangle2(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal2(a2, b) {
        return a2.next.i !== b.i && a2.prev.i !== b.i && !intersectsPolygon2(a2, b) && (locallyInside2(a2, b) && locallyInside2(b, a2) && middleInside2(a2, b) && (area2(a2.prev, a2, b.prev) || area2(a2, b.prev, b)) || equals5(a2, b) && area2(a2.prev, a2, a2.next) > 0 && area2(b.prev, b, b.next) > 0);
      }
      function area2(p2, q, r2) {
        return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
      }
      function equals5(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects2(p1, q1, p2, q2) {
        var o1 = sign2(area2(p1, q1, p2));
        var o2 = sign2(area2(p1, q1, q2));
        var o3 = sign2(area2(p2, q2, p1));
        var o4 = sign2(area2(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment2(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment2(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment2(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment2(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment2(p2, q, r2) {
        return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
      }
      function sign2(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon2(a2, b) {
        var p2 = a2;
        do {
          if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b.i && p2.next.i !== b.i && intersects2(p2, p2.next, a2, b))
            return true;
          p2 = p2.next;
        } while (p2 !== a2);
        return false;
      }
      function locallyInside2(a2, b) {
        return area2(a2.prev, a2, a2.next) < 0 ? area2(a2, b, a2.next) >= 0 && area2(a2, a2.prev, b) >= 0 : area2(a2, b, a2.prev) < 0 || area2(a2, a2.next, b) < 0;
      }
      function middleInside2(a2, b) {
        var p2 = a2, inside = false, px = (a2.x + b.x) / 2, py = (a2.y + b.y) / 2;
        do {
          if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
            inside = !inside;
          p2 = p2.next;
        } while (p2 !== a2);
        return inside;
      }
      function splitPolygon2(a2, b) {
        var a22 = new Node2(a2.i, a2.x, a2.y), b2 = new Node2(b.i, b.x, b.y), an = a2.next, bp = b.prev;
        a2.next = b;
        b.prev = a2;
        a22.next = an;
        an.prev = a22;
        b2.next = a22;
        a22.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode2(i3, x2, y2, last) {
        var p2 = new Node2(i3, x2, y2);
        if (!last) {
          p2.prev = p2;
          p2.next = p2;
        } else {
          p2.next = last.next;
          p2.prev = last;
          last.next.prev = p2;
          last.next = p2;
        }
        return p2;
      }
      function removeNode2(p2) {
        p2.next.prev = p2.prev;
        p2.prev.next = p2.next;
        if (p2.prevZ)
          p2.prevZ.nextZ = p2.nextZ;
        if (p2.nextZ)
          p2.nextZ.prevZ = p2.prevZ;
      }
      function Node2(i3, x2, y2) {
        this.i = i3;
        this.x = x2;
        this.y = y2;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut3.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea2(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i3 = 0, len3 = holeIndices.length; i3 < len3; i3++) {
            var start = holeIndices[i3] * dim;
            var end = i3 < len3 - 1 ? holeIndices[i3 + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea2(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i3 = 0; i3 < triangles.length; i3 += 3) {
          var a2 = triangles[i3] * dim;
          var b = triangles[i3 + 1] * dim;
          var c = triangles[i3 + 2] * dim;
          trianglesArea += Math.abs((data[a2] - data[c]) * (data[b + 1] - data[a2 + 1]) - (data[a2] - data[b]) * (data[c + 1] - data[a2 + 1]));
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea2(data, start, end, dim) {
        var sum = 0;
        for (var i3 = start, j = end - dim; i3 < end; i3 += dim) {
          sum += (data[j] - data[i3]) * (data[i3 + 1] + data[j + 1]);
          j = i3;
        }
        return sum;
      }
      earcut3.flatten = function(data) {
        var dim = data[0][0].length, result = {
          vertices: [],
          holes: [],
          dimensions: dim
        }, holeIndex = 0;
        for (var i3 = 0; i3 < data.length; i3++) {
          for (var j = 0; j < data[i3].length; j++) {
            for (var d = 0; d < dim; d++)
              result.vertices.push(data[i3][j][d]);
          }
          if (i3 > 0) {
            holeIndex += data[i3 - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // ../../node_modules/fast-xml-parser/src/util.js
  var require_util = __commonJS({
    "../../node_modules/fast-xml-parser/src/util.js"(exports) {
      "use strict";
      var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
      var regexName = new RegExp("^" + nameRegexp + "$");
      var getAllMatches = function(string, regex) {
        const matches3 = [];
        let match = regex.exec(string);
        while (match) {
          const allmatches = [];
          allmatches.startIndex = regex.lastIndex - match[0].length;
          const len3 = match.length;
          for (let index = 0; index < len3; index++) {
            allmatches.push(match[index]);
          }
          matches3.push(allmatches);
          match = regex.exec(string);
        }
        return matches3;
      };
      var isName = function(string) {
        const match = regexName.exec(string);
        return !(match === null || typeof match === "undefined");
      };
      exports.isExist = function(v) {
        return typeof v !== "undefined";
      };
      exports.isEmptyObject = function(obj) {
        return Object.keys(obj).length === 0;
      };
      exports.merge = function(target, a2, arrayMode) {
        if (a2) {
          const keys = Object.keys(a2);
          const len3 = keys.length;
          for (let i3 = 0; i3 < len3; i3++) {
            if (arrayMode === "strict") {
              target[keys[i3]] = [a2[keys[i3]]];
            } else {
              target[keys[i3]] = a2[keys[i3]];
            }
          }
        }
      };
      exports.getValue = function(v) {
        if (exports.isExist(v)) {
          return v;
        } else {
          return "";
        }
      };
      exports.isName = isName;
      exports.getAllMatches = getAllMatches;
      exports.nameRegexp = nameRegexp;
    }
  });

  // ../../node_modules/fast-xml-parser/src/validator.js
  var require_validator = __commonJS({
    "../../node_modules/fast-xml-parser/src/validator.js"(exports) {
      "use strict";
      var util = require_util();
      var defaultOptions = {
        allowBooleanAttributes: false,
        unpairedTags: []
      };
      exports.validate = function(xmlData, options) {
        options = Object.assign({}, defaultOptions, options);
        const tags = [];
        let tagFound = false;
        let reachedRoot = false;
        if (xmlData[0] === "\uFEFF") {
          xmlData = xmlData.substr(1);
        }
        for (let i3 = 0; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<" && xmlData[i3 + 1] === "?") {
            i3 += 2;
            i3 = readPI(xmlData, i3);
            if (i3.err)
              return i3;
          } else if (xmlData[i3] === "<") {
            let tagStartPos = i3;
            i3++;
            if (xmlData[i3] === "!") {
              i3 = readCommentAndCDATA(xmlData, i3);
              continue;
            } else {
              let closingTag = false;
              if (xmlData[i3] === "/") {
                closingTag = true;
                i3++;
              }
              let tagName = "";
              for (; i3 < xmlData.length && xmlData[i3] !== ">" && xmlData[i3] !== " " && xmlData[i3] !== "	" && xmlData[i3] !== "\n" && xmlData[i3] !== "\r"; i3++) {
                tagName += xmlData[i3];
              }
              tagName = tagName.trim();
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substring(0, tagName.length - 1);
                i3--;
              }
              if (!validateTagName(tagName)) {
                let msg;
                if (tagName.trim().length === 0) {
                  msg = "Invalid space after '<'.";
                } else {
                  msg = "Tag '" + tagName + "' is an invalid name.";
                }
                return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i3));
              }
              const result = readAttributeStr(xmlData, i3);
              if (result === false) {
                return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i3));
              }
              let attrStr = result.value;
              i3 = result.index;
              if (attrStr[attrStr.length - 1] === "/") {
                const attrStrStart = i3 - attrStr.length;
                attrStr = attrStr.substring(0, attrStr.length - 1);
                const isValid = validateAttributeString(attrStr, options);
                if (isValid === true) {
                  tagFound = true;
                } else {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
                }
              } else if (closingTag) {
                if (!result.tagClosed) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i3));
                } else if (attrStr.trim().length > 0) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
                } else {
                  const otg = tags.pop();
                  if (tagName !== otg.tagName) {
                    let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                    return getErrorObject("InvalidTag", "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
                  }
                  if (tags.length == 0) {
                    reachedRoot = true;
                  }
                }
              } else {
                const isValid = validateAttributeString(attrStr, options);
                if (isValid !== true) {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i3 - attrStr.length + isValid.err.line));
                }
                if (reachedRoot === true) {
                  return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i3));
                } else if (options.unpairedTags.indexOf(tagName) !== -1) {
                } else {
                  tags.push({
                    tagName,
                    tagStartPos
                  });
                }
                tagFound = true;
              }
              for (i3++; i3 < xmlData.length; i3++) {
                if (xmlData[i3] === "<") {
                  if (xmlData[i3 + 1] === "!") {
                    i3++;
                    i3 = readCommentAndCDATA(xmlData, i3);
                    continue;
                  } else if (xmlData[i3 + 1] === "?") {
                    i3 = readPI(xmlData, ++i3);
                    if (i3.err)
                      return i3;
                  } else {
                    break;
                  }
                } else if (xmlData[i3] === "&") {
                  const afterAmp = validateAmpersand(xmlData, i3);
                  if (afterAmp == -1)
                    return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i3));
                  i3 = afterAmp;
                } else {
                  if (reachedRoot === true && !isWhiteSpace(xmlData[i3])) {
                    return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i3));
                  }
                }
              }
              if (xmlData[i3] === "<") {
                i3--;
              }
            }
          } else {
            if (isWhiteSpace(xmlData[i3])) {
              continue;
            }
            return getErrorObject("InvalidChar", "char '" + xmlData[i3] + "' is not expected.", getLineNumberForPosition(xmlData, i3));
          }
        }
        if (!tagFound) {
          return getErrorObject("InvalidXml", "Start tag expected.", 1);
        } else if (tags.length == 1) {
          return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
        } else if (tags.length > 0) {
          return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t2) => t2.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", {
            line: 1,
            col: 1
          });
        }
        return true;
      };
      function isWhiteSpace(char) {
        return char === " " || char === "	" || char === "\n" || char === "\r";
      }
      function readPI(xmlData, i3) {
        const start = i3;
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] == "?" || xmlData[i3] == " ") {
            const tagname = xmlData.substr(start, i3 - start);
            if (i3 > 5 && tagname === "xml") {
              return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i3));
            } else if (xmlData[i3] == "?" && xmlData[i3 + 1] == ">") {
              i3++;
              break;
            } else {
              continue;
            }
          }
        }
        return i3;
      }
      function readCommentAndCDATA(xmlData, i3) {
        if (xmlData.length > i3 + 5 && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === "-") {
          for (i3 += 3; i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "-" && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === ">") {
              i3 += 2;
              break;
            }
          }
        } else if (xmlData.length > i3 + 8 && xmlData[i3 + 1] === "D" && xmlData[i3 + 2] === "O" && xmlData[i3 + 3] === "C" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "Y" && xmlData[i3 + 6] === "P" && xmlData[i3 + 7] === "E") {
          let angleBracketsCount = 1;
          for (i3 += 8; i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "<") {
              angleBracketsCount++;
            } else if (xmlData[i3] === ">") {
              angleBracketsCount--;
              if (angleBracketsCount === 0) {
                break;
              }
            }
          }
        } else if (xmlData.length > i3 + 9 && xmlData[i3 + 1] === "[" && xmlData[i3 + 2] === "C" && xmlData[i3 + 3] === "D" && xmlData[i3 + 4] === "A" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "A" && xmlData[i3 + 7] === "[") {
          for (i3 += 8; i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "]" && xmlData[i3 + 1] === "]" && xmlData[i3 + 2] === ">") {
              i3 += 2;
              break;
            }
          }
        }
        return i3;
      }
      var doubleQuote = '"';
      var singleQuote = "'";
      function readAttributeStr(xmlData, i3) {
        let attrStr = "";
        let startChar = "";
        let tagClosed = false;
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === doubleQuote || xmlData[i3] === singleQuote) {
            if (startChar === "") {
              startChar = xmlData[i3];
            } else if (startChar !== xmlData[i3]) {
            } else {
              startChar = "";
            }
          } else if (xmlData[i3] === ">") {
            if (startChar === "") {
              tagClosed = true;
              break;
            }
          }
          attrStr += xmlData[i3];
        }
        if (startChar !== "") {
          return false;
        }
        return {
          value: attrStr,
          index: i3,
          tagClosed
        };
      }
      var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
      function validateAttributeString(attrStr, options) {
        const matches3 = util.getAllMatches(attrStr, validAttrStrRegxp);
        const attrNames = {};
        for (let i3 = 0; i3 < matches3.length; i3++) {
          if (matches3[i3][1].length === 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches3[i3][2] + "' has no space in starting.", getPositionFromMatch(matches3[i3]));
          } else if (matches3[i3][3] !== void 0 && matches3[i3][4] === void 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches3[i3][2] + "' is without value.", getPositionFromMatch(matches3[i3]));
          } else if (matches3[i3][3] === void 0 && !options.allowBooleanAttributes) {
            return getErrorObject("InvalidAttr", "boolean attribute '" + matches3[i3][2] + "' is not allowed.", getPositionFromMatch(matches3[i3]));
          }
          const attrName = matches3[i3][2];
          if (!validateAttrName(attrName)) {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches3[i3]));
          }
          if (!attrNames.hasOwnProperty(attrName)) {
            attrNames[attrName] = 1;
          } else {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches3[i3]));
          }
        }
        return true;
      }
      function validateNumberAmpersand(xmlData, i3) {
        let re = /\d/;
        if (xmlData[i3] === "x") {
          i3++;
          re = /[\da-fA-F]/;
        }
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === ";")
            return i3;
          if (!xmlData[i3].match(re))
            break;
        }
        return -1;
      }
      function validateAmpersand(xmlData, i3) {
        i3++;
        if (xmlData[i3] === ";")
          return -1;
        if (xmlData[i3] === "#") {
          i3++;
          return validateNumberAmpersand(xmlData, i3);
        }
        let count2 = 0;
        for (; i3 < xmlData.length; i3++, count2++) {
          if (xmlData[i3].match(/\w/) && count2 < 20)
            continue;
          if (xmlData[i3] === ";")
            break;
          return -1;
        }
        return i3;
      }
      function getErrorObject(code, message, lineNumber) {
        return {
          err: {
            code,
            msg: message,
            line: lineNumber.line || lineNumber,
            col: lineNumber.col
          }
        };
      }
      function validateAttrName(attrName) {
        return util.isName(attrName);
      }
      function validateTagName(tagname) {
        return util.isName(tagname);
      }
      function getLineNumberForPosition(xmlData, index) {
        const lines = xmlData.substring(0, index).split(/\r?\n/);
        return {
          line: lines.length,
          col: lines[lines.length - 1].length + 1
        };
      }
      function getPositionFromMatch(match) {
        return match.startIndex + match[1].length;
      }
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
  var require_OptionsBuilder = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
      var defaultOptions = {
        preserveOrder: false,
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        removeNSPrefix: false,
        allowBooleanAttributes: false,
        parseTagValue: true,
        parseAttributeValue: false,
        trimValues: true,
        cdataPropName: false,
        numberParseOptions: {
          hex: true,
          leadingZeros: true,
          eNotation: true
        },
        tagValueProcessor: function(tagName, val2) {
          return val2;
        },
        attributeValueProcessor: function(attrName, val2) {
          return val2;
        },
        stopNodes: [],
        alwaysCreateTextNode: false,
        isArray: () => false,
        commentPropName: false,
        unpairedTags: [],
        processEntities: true,
        htmlEntities: false,
        ignoreDeclaration: false,
        ignorePiTags: false,
        transformTagName: false,
        transformAttributeName: false,
        updateTag: function(tagName, jPath, attrs) {
          return tagName;
        }
      };
      var buildOptions = function(options) {
        return Object.assign({}, defaultOptions, options);
      };
      exports.buildOptions = buildOptions;
      exports.defaultOptions = defaultOptions;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
  var require_xmlNode = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module2) {
      "use strict";
      var XmlNode = class {
        constructor(tagname) {
          this.tagname = tagname;
          this.child = [];
          this[":@"] = {};
        }
        add(key, val2) {
          if (key === "__proto__")
            key = "#__proto__";
          this.child.push({
            [key]: val2
          });
        }
        addChild(node2) {
          if (node2.tagname === "__proto__")
            node2.tagname = "#__proto__";
          if (node2[":@"] && Object.keys(node2[":@"]).length > 0) {
            this.child.push({
              [node2.tagname]: node2.child,
              [":@"]: node2[":@"]
            });
          } else {
            this.child.push({
              [node2.tagname]: node2.child
            });
          }
        }
      };
      module2.exports = XmlNode;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
  var require_DocTypeReader = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module2) {
      function readDocType(xmlData, i3) {
        const entities = {};
        if (xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "C" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "Y" && xmlData[i3 + 7] === "P" && xmlData[i3 + 8] === "E") {
          i3 = i3 + 9;
          let angleBracketsCount = 1;
          let hasBody = false, comment = false;
          let exp = "";
          for (; i3 < xmlData.length; i3++) {
            if (xmlData[i3] === "<" && !comment) {
              if (hasBody && isEntity(xmlData, i3)) {
                i3 += 7;
                [entityName, val, i3] = readEntityExp(xmlData, i3 + 1);
                if (val.indexOf("&") === -1)
                  entities[entityName] = {
                    regx: RegExp(`&${entityName};`, "g"),
                    val
                  };
              } else if (hasBody && isElement(xmlData, i3))
                i3 += 8;
              else if (hasBody && isAttlist(xmlData, i3))
                i3 += 8;
              else if (hasBody && isNotation(xmlData, i3))
                i3 += 9;
              else if (isComment)
                comment = true;
              else
                throw new Error("Invalid DOCTYPE");
              angleBracketsCount++;
              exp = "";
            } else if (xmlData[i3] === ">") {
              if (comment) {
                if (xmlData[i3 - 1] === "-" && xmlData[i3 - 2] === "-") {
                  comment = false;
                  angleBracketsCount--;
                }
              } else {
                angleBracketsCount--;
              }
              if (angleBracketsCount === 0) {
                break;
              }
            } else if (xmlData[i3] === "[") {
              hasBody = true;
            } else {
              exp += xmlData[i3];
            }
          }
          if (angleBracketsCount !== 0) {
            throw new Error(`Unclosed DOCTYPE`);
          }
        } else {
          throw new Error(`Invalid Tag instead of DOCTYPE`);
        }
        return {
          entities,
          i: i3
        };
      }
      function readEntityExp(xmlData, i3) {
        let entityName2 = "";
        for (; i3 < xmlData.length && xmlData[i3] !== "'" && xmlData[i3] !== '"'; i3++) {
          entityName2 += xmlData[i3];
        }
        entityName2 = entityName2.trim();
        if (entityName2.indexOf(" ") !== -1)
          throw new Error("External entites are not supported");
        const startChar = xmlData[i3++];
        let val2 = "";
        for (; i3 < xmlData.length && xmlData[i3] !== startChar; i3++) {
          val2 += xmlData[i3];
        }
        return [entityName2, val2, i3];
      }
      function isComment(xmlData, i3) {
        if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "-" && xmlData[i3 + 3] === "-")
          return true;
        return false;
      }
      function isEntity(xmlData, i3) {
        if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "N" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "I" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "Y")
          return true;
        return false;
      }
      function isElement(xmlData, i3) {
        if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "L" && xmlData[i3 + 4] === "E" && xmlData[i3 + 5] === "M" && xmlData[i3 + 6] === "E" && xmlData[i3 + 7] === "N" && xmlData[i3 + 8] === "T")
          return true;
        return false;
      }
      function isAttlist(xmlData, i3) {
        if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "A" && xmlData[i3 + 3] === "T" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "L" && xmlData[i3 + 6] === "I" && xmlData[i3 + 7] === "S" && xmlData[i3 + 8] === "T")
          return true;
        return false;
      }
      function isNotation(xmlData, i3) {
        if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "N" && xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "A" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "I" && xmlData[i3 + 8] === "O" && xmlData[i3 + 9] === "N")
          return true;
        return false;
      }
      module2.exports = readDocType;
    }
  });

  // ../../node_modules/strnum/strnum.js
  var require_strnum = __commonJS({
    "../../node_modules/strnum/strnum.js"(exports, module2) {
      var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
      var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
      if (!Number.parseInt && window.parseInt) {
        Number.parseInt = window.parseInt;
      }
      if (!Number.parseFloat && window.parseFloat) {
        Number.parseFloat = window.parseFloat;
      }
      var consider = {
        hex: true,
        leadingZeros: true,
        decimalPoint: ".",
        eNotation: true
      };
      function toNumber2(str, options = {}) {
        options = Object.assign({}, consider, options);
        if (!str || typeof str !== "string")
          return str;
        let trimmedStr = str.trim();
        if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
          return str;
        else if (options.hex && hexRegex.test(trimmedStr)) {
          return Number.parseInt(trimmedStr, 16);
        } else {
          const match = numRegex.exec(trimmedStr);
          if (match) {
            const sign2 = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]);
            const eNotation = match[4] || match[6];
            if (!options.leadingZeros && leadingZeros.length > 0 && sign2 && trimmedStr[2] !== ".")
              return str;
            else if (!options.leadingZeros && leadingZeros.length > 0 && !sign2 && trimmedStr[1] !== ".")
              return str;
            else {
              const num = Number(trimmedStr);
              const numStr = "" + num;
              if (numStr.search(/[eE]/) !== -1) {
                if (options.eNotation)
                  return num;
                else
                  return str;
              } else if (eNotation) {
                if (options.eNotation)
                  return num;
                else
                  return str;
              } else if (trimmedStr.indexOf(".") !== -1) {
                if (numStr === "0" && numTrimmedByZeros === "")
                  return num;
                else if (numStr === numTrimmedByZeros)
                  return num;
                else if (sign2 && numStr === "-" + numTrimmedByZeros)
                  return num;
                else
                  return str;
              }
              if (leadingZeros) {
                if (numTrimmedByZeros === numStr)
                  return num;
                else if (sign2 + numTrimmedByZeros === numStr)
                  return num;
                else
                  return str;
              }
              if (trimmedStr === numStr)
                return num;
              else if (trimmedStr === sign2 + numStr)
                return num;
              return str;
            }
          } else {
            return str;
          }
        }
      }
      function trimZeros(numStr) {
        if (numStr && numStr.indexOf(".") !== -1) {
          numStr = numStr.replace(/0+$/, "");
          if (numStr === ".")
            numStr = "0";
          else if (numStr[0] === ".")
            numStr = "0" + numStr;
          else if (numStr[numStr.length - 1] === ".")
            numStr = numStr.substr(0, numStr.length - 1);
          return numStr;
        }
        return numStr;
      }
      module2.exports = toNumber2;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
  var require_OrderedObjParser = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module2) {
      "use strict";
      var util = require_util();
      var xmlNode = require_xmlNode();
      var readDocType = require_DocTypeReader();
      var toNumber2 = require_strnum();
      var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
      var OrderedObjParser = class {
        constructor(options) {
          this.options = options;
          this.currentNode = null;
          this.tagsNodeStack = [];
          this.docTypeEntities = {};
          this.lastEntities = {
            "apos": {
              regex: /&(apos|#39|#x27);/g,
              val: "'"
            },
            "gt": {
              regex: /&(gt|#62|#x3E);/g,
              val: ">"
            },
            "lt": {
              regex: /&(lt|#60|#x3C);/g,
              val: "<"
            },
            "quot": {
              regex: /&(quot|#34|#x22);/g,
              val: '"'
            }
          };
          this.ampEntity = {
            regex: /&(amp|#38|#x26);/g,
            val: "&"
          };
          this.htmlEntities = {
            "space": {
              regex: /&(nbsp|#160);/g,
              val: " "
            },
            "cent": {
              regex: /&(cent|#162);/g,
              val: "\xA2"
            },
            "pound": {
              regex: /&(pound|#163);/g,
              val: "\xA3"
            },
            "yen": {
              regex: /&(yen|#165);/g,
              val: "\xA5"
            },
            "euro": {
              regex: /&(euro|#8364);/g,
              val: "\u20AC"
            },
            "copyright": {
              regex: /&(copy|#169);/g,
              val: "\xA9"
            },
            "reg": {
              regex: /&(reg|#174);/g,
              val: "\xAE"
            },
            "inr": {
              regex: /&(inr|#8377);/g,
              val: "\u20B9"
            }
          };
          this.addExternalEntities = addExternalEntities;
          this.parseXml = parseXml;
          this.parseTextData = parseTextData;
          this.resolveNameSpace = resolveNameSpace;
          this.buildAttributesMap = buildAttributesMap;
          this.isItStopNode = isItStopNode;
          this.replaceEntitiesValue = replaceEntitiesValue;
          this.readStopNodeData = readStopNodeData;
          this.saveTextToParentTag = saveTextToParentTag;
          this.addChild = addChild;
        }
      };
      function addExternalEntities(externalEntities) {
        const entKeys = Object.keys(externalEntities);
        for (let i3 = 0; i3 < entKeys.length; i3++) {
          const ent = entKeys[i3];
          this.lastEntities[ent] = {
            regex: new RegExp("&" + ent + ";", "g"),
            val: externalEntities[ent]
          };
        }
      }
      function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
        if (val2 !== void 0) {
          if (this.options.trimValues && !dontTrim) {
            val2 = val2.trim();
          }
          if (val2.length > 0) {
            if (!escapeEntities)
              val2 = this.replaceEntitiesValue(val2);
            const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
            if (newval === null || newval === void 0) {
              return val2;
            } else if (typeof newval !== typeof val2 || newval !== val2) {
              return newval;
            } else if (this.options.trimValues) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              const trimmedVal = val2.trim();
              if (trimmedVal === val2) {
                return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
              } else {
                return val2;
              }
            }
          }
        }
      }
      function resolveNameSpace(tagname) {
        if (this.options.removeNSPrefix) {
          const tags = tagname.split(":");
          const prefix = tagname.charAt(0) === "/" ? "/" : "";
          if (tags[0] === "xmlns") {
            return "";
          }
          if (tags.length === 2) {
            tagname = prefix + tags[1];
          }
        }
        return tagname;
      }
      var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
      function buildAttributesMap(attrStr, jPath, tagName) {
        if (!this.options.ignoreAttributes && typeof attrStr === "string") {
          const matches3 = util.getAllMatches(attrStr, attrsRegx);
          const len3 = matches3.length;
          const attrs = {};
          for (let i3 = 0; i3 < len3; i3++) {
            const attrName = this.resolveNameSpace(matches3[i3][1]);
            let oldVal = matches3[i3][4];
            let aName = this.options.attributeNamePrefix + attrName;
            if (attrName.length) {
              if (this.options.transformAttributeName) {
                aName = this.options.transformAttributeName(aName);
              }
              if (aName === "__proto__")
                aName = "#__proto__";
              if (oldVal !== void 0) {
                if (this.options.trimValues) {
                  oldVal = oldVal.trim();
                }
                oldVal = this.replaceEntitiesValue(oldVal);
                const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
                if (newVal === null || newVal === void 0) {
                  attrs[aName] = oldVal;
                } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                  attrs[aName] = newVal;
                } else {
                  attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
                }
              } else if (this.options.allowBooleanAttributes) {
                attrs[aName] = true;
              }
            }
          }
          if (!Object.keys(attrs).length) {
            return;
          }
          if (this.options.attributesGroupName) {
            const attrCollection = {};
            attrCollection[this.options.attributesGroupName] = attrs;
            return attrCollection;
          }
          return attrs;
        }
      }
      var parseXml = function(xmlData) {
        xmlData = xmlData.replace(/\r\n?/g, "\n");
        const xmlObj = new xmlNode("!xml");
        let currentNode = xmlObj;
        let textData = "";
        let jPath = "";
        for (let i3 = 0; i3 < xmlData.length; i3++) {
          const ch = xmlData[i3];
          if (ch === "<") {
            if (xmlData[i3 + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i3, "Closing Tag is not closed.");
              let tagName = xmlData.substring(i3 + 2, closeIndex).trim();
              if (this.options.removeNSPrefix) {
                const colonIndex = tagName.indexOf(":");
                if (colonIndex !== -1) {
                  tagName = tagName.substr(colonIndex + 1);
                }
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode) {
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
              }
              const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
              if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
                throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
              }
              let propIndex = 0;
              if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
                propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
                this.tagsNodeStack.pop();
              } else {
                propIndex = jPath.lastIndexOf(".");
              }
              jPath = jPath.substring(0, propIndex);
              currentNode = this.tagsNodeStack.pop();
              textData = "";
              i3 = closeIndex;
            } else if (xmlData[i3 + 1] === "?") {
              let tagData = readTagExp(xmlData, i3, false, "?>");
              if (!tagData)
                throw new Error("Pi Tag is not closed.");
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
              } else {
                const childNode = new xmlNode(tagData.tagName);
                childNode.add(this.options.textNodeName, "");
                if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
                }
                this.addChild(currentNode, childNode, jPath);
              }
              i3 = tagData.closeIndex + 1;
            } else if (xmlData.substr(i3 + 1, 3) === "!--") {
              const endIndex = findClosingIndex(xmlData, "-->", i3 + 4, "Comment is not closed.");
              if (this.options.commentPropName) {
                const comment = xmlData.substring(i3 + 4, endIndex - 2);
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
                currentNode.add(this.options.commentPropName, [{
                  [this.options.textNodeName]: comment
                }]);
              }
              i3 = endIndex;
            } else if (xmlData.substr(i3 + 1, 2) === "!D") {
              const result = readDocType(xmlData, i3);
              this.docTypeEntities = result.entities;
              i3 = result.i;
            } else if (xmlData.substr(i3 + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i3, "CDATA is not closed.") - 2;
              const tagExp = xmlData.substring(i3 + 9, closeIndex);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.cdataPropName) {
                currentNode.add(this.options.cdataPropName, [{
                  [this.options.textNodeName]: tagExp
                }]);
              } else {
                let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
                if (val2 == void 0)
                  val2 = "";
                currentNode.add(this.options.textNodeName, val2);
              }
              i3 = closeIndex + 2;
            } else {
              let result = readTagExp(xmlData, i3, this.options.removeNSPrefix);
              let tagName = result.tagName;
              let tagExp = result.tagExp;
              let attrExpPresent = result.attrExpPresent;
              let closeIndex = result.closeIndex;
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode && textData) {
                if (currentNode.tagname !== "!xml") {
                  textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
                }
              }
              const lastTag = currentNode;
              if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
                currentNode = this.tagsNodeStack.pop();
                jPath = jPath.substring(0, jPath.lastIndexOf("."));
              }
              if (tagName !== xmlObj.tagname) {
                jPath += jPath ? "." + tagName : tagName;
              }
              if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
                let tagContent = "";
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  i3 = result.closeIndex;
                } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                  i3 = result.closeIndex;
                } else {
                  const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                  if (!result2)
                    throw new Error(`Unexpected end of ${tagName}`);
                  i3 = result2.i;
                  tagContent = result2.tagContent;
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                if (tagContent) {
                  tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                childNode.add(this.options.textNodeName, tagContent);
                this.addChild(currentNode, childNode, jPath);
              } else {
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  if (tagName[tagName.length - 1] === "/") {
                    tagName = tagName.substr(0, tagName.length - 1);
                    tagExp = tagName;
                  } else {
                    tagExp = tagExp.substr(0, tagExp.length - 1);
                  }
                  if (this.options.transformTagName) {
                    tagName = this.options.transformTagName(tagName);
                  }
                  const childNode = new xmlNode(tagName);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  jPath = jPath.substr(0, jPath.lastIndexOf("."));
                } else {
                  const childNode = new xmlNode(tagName);
                  this.tagsNodeStack.push(currentNode);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  currentNode = childNode;
                }
                textData = "";
                i3 = closeIndex;
              }
            }
          } else {
            textData += xmlData[i3];
          }
        }
        return xmlObj.child;
      };
      function addChild(currentNode, childNode, jPath) {
        const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
        if (result === false) {
        } else if (typeof result === "string") {
          childNode.tagname = result;
          currentNode.addChild(childNode);
        } else {
          currentNode.addChild(childNode);
        }
      }
      var replaceEntitiesValue = function(val2) {
        if (this.options.processEntities) {
          for (let entityName2 in this.docTypeEntities) {
            const entity = this.docTypeEntities[entityName2];
            val2 = val2.replace(entity.regx, entity.val);
          }
          for (let entityName2 in this.lastEntities) {
            const entity = this.lastEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
          if (this.options.htmlEntities) {
            for (let entityName2 in this.htmlEntities) {
              const entity = this.htmlEntities[entityName2];
              val2 = val2.replace(entity.regex, entity.val);
            }
          }
          val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
        }
        return val2;
      };
      function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
        if (textData) {
          if (isLeafNode === void 0)
            isLeafNode = Object.keys(currentNode.child).length === 0;
          textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
          if (textData !== void 0 && textData !== "")
            currentNode.add(this.options.textNodeName, textData);
          textData = "";
        }
        return textData;
      }
      function isItStopNode(stopNodes, jPath, currentTagName) {
        const allNodesExp = "*." + currentTagName;
        for (const stopNodePath in stopNodes) {
          const stopNodeExp = stopNodes[stopNodePath];
          if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
            return true;
        }
        return false;
      }
      function tagExpWithClosingIndex(xmlData, i3, closingChar = ">") {
        let attrBoundary;
        let tagExp = "";
        for (let index = i3; index < xmlData.length; index++) {
          let ch = xmlData[index];
          if (attrBoundary) {
            if (ch === attrBoundary)
              attrBoundary = "";
          } else if (ch === '"' || ch === "'") {
            attrBoundary = ch;
          } else if (ch === closingChar[0]) {
            if (closingChar[1]) {
              if (xmlData[index + 1] === closingChar[1]) {
                return {
                  data: tagExp,
                  index
                };
              }
            } else {
              return {
                data: tagExp,
                index
              };
            }
          } else if (ch === "	") {
            ch = " ";
          }
          tagExp += ch;
        }
      }
      function findClosingIndex(xmlData, str, i3, errMsg) {
        const closingIndex = xmlData.indexOf(str, i3);
        if (closingIndex === -1) {
          throw new Error(errMsg);
        } else {
          return closingIndex + str.length - 1;
        }
      }
      function readTagExp(xmlData, i3, removeNSPrefix, closingChar = ">") {
        const result = tagExpWithClosingIndex(xmlData, i3 + 1, closingChar);
        if (!result)
          return;
        let tagExp = result.data;
        const closeIndex = result.index;
        const separatorIndex = tagExp.search(/\s/);
        let tagName = tagExp;
        let attrExpPresent = true;
        if (separatorIndex !== -1) {
          tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
          tagExp = tagExp.substr(separatorIndex + 1);
        }
        if (removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
          }
        }
        return {
          tagName,
          tagExp,
          closeIndex,
          attrExpPresent
        };
      }
      function readStopNodeData(xmlData, tagName, i3) {
        const startIndex = i3;
        let openTagCount = 1;
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<") {
            if (xmlData[i3 + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i3, `${tagName} is not closed`);
              let closeTagName = xmlData.substring(i3 + 2, closeIndex).trim();
              if (closeTagName === tagName) {
                openTagCount--;
                if (openTagCount === 0) {
                  return {
                    tagContent: xmlData.substring(startIndex, i3),
                    i: closeIndex
                  };
                }
              }
              i3 = closeIndex;
            } else if (xmlData[i3 + 1] === "?") {
              const closeIndex = findClosingIndex(xmlData, "?>", i3 + 1, "StopNode is not closed.");
              i3 = closeIndex;
            } else if (xmlData.substr(i3 + 1, 3) === "!--") {
              const closeIndex = findClosingIndex(xmlData, "-->", i3 + 3, "StopNode is not closed.");
              i3 = closeIndex;
            } else if (xmlData.substr(i3 + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i3, "StopNode is not closed.") - 2;
              i3 = closeIndex;
            } else {
              const tagData = readTagExp(xmlData, i3, ">");
              if (tagData) {
                const openTagName = tagData && tagData.tagName;
                if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                  openTagCount++;
                }
                i3 = tagData.closeIndex;
              }
            }
          }
        }
      }
      function parseValue(val2, shouldParse, options) {
        if (shouldParse && typeof val2 === "string") {
          const newval = val2.trim();
          if (newval === "true")
            return true;
          else if (newval === "false")
            return false;
          else
            return toNumber2(val2, options);
        } else {
          if (util.isExist(val2)) {
            return val2;
          } else {
            return "";
          }
        }
      }
      module2.exports = OrderedObjParser;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/node2json.js
  var require_node2json = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
      "use strict";
      function prettify(node2, options) {
        return compress(node2, options);
      }
      function compress(arr, options, jPath) {
        let text;
        const compressedObj = {};
        for (let i3 = 0; i3 < arr.length; i3++) {
          const tagObj = arr[i3];
          const property = propName(tagObj);
          let newJpath = "";
          if (jPath === void 0)
            newJpath = property;
          else
            newJpath = jPath + "." + property;
          if (property === options.textNodeName) {
            if (text === void 0)
              text = tagObj[property];
            else
              text += "" + tagObj[property];
          } else if (property === void 0) {
            continue;
          } else if (tagObj[property]) {
            let val2 = compress(tagObj[property], options, newJpath);
            const isLeaf = isLeafTag(val2, options);
            if (tagObj[":@"]) {
              assignAttributes(val2, tagObj[":@"], newJpath, options);
            } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
              val2 = val2[options.textNodeName];
            } else if (Object.keys(val2).length === 0) {
              if (options.alwaysCreateTextNode)
                val2[options.textNodeName] = "";
              else
                val2 = "";
            }
            if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
              if (!Array.isArray(compressedObj[property])) {
                compressedObj[property] = [compressedObj[property]];
              }
              compressedObj[property].push(val2);
            } else {
              if (options.isArray(property, newJpath, isLeaf)) {
                compressedObj[property] = [val2];
              } else {
                compressedObj[property] = val2;
              }
            }
          }
        }
        if (typeof text === "string") {
          if (text.length > 0)
            compressedObj[options.textNodeName] = text;
        } else if (text !== void 0)
          compressedObj[options.textNodeName] = text;
        return compressedObj;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i3 = 0; i3 < keys.length; i3++) {
          const key = keys[i3];
          if (key !== ":@")
            return key;
        }
      }
      function assignAttributes(obj, attrMap, jpath, options) {
        if (attrMap) {
          const keys = Object.keys(attrMap);
          const len3 = keys.length;
          for (let i3 = 0; i3 < len3; i3++) {
            const atrrName = keys[i3];
            if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
              obj[atrrName] = [attrMap[atrrName]];
            } else {
              obj[atrrName] = attrMap[atrrName];
            }
          }
        }
      }
      function isLeafTag(obj, options) {
        const {
          textNodeName
        } = options;
        const propCount = Object.keys(obj).length;
        if (propCount === 0) {
          return true;
        }
        if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
          return true;
        }
        return false;
      }
      exports.prettify = prettify;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
  var require_XMLParser = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module2) {
      var {
        buildOptions
      } = require_OptionsBuilder();
      var OrderedObjParser = require_OrderedObjParser();
      var {
        prettify
      } = require_node2json();
      var validator = require_validator();
      var XMLParser = class {
        constructor(options) {
          this.externalEntities = {};
          this.options = buildOptions(options);
        }
        parse(xmlData, validationOption) {
          if (typeof xmlData === "string") {
          } else if (xmlData.toString) {
            xmlData = xmlData.toString();
          } else {
            throw new Error("XML data is accepted in String or Bytes[] form.");
          }
          if (validationOption) {
            if (validationOption === true)
              validationOption = {};
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
            }
          }
          const orderedObjParser = new OrderedObjParser(this.options);
          orderedObjParser.addExternalEntities(this.externalEntities);
          const orderedResult = orderedObjParser.parseXml(xmlData);
          if (this.options.preserveOrder || orderedResult === void 0)
            return orderedResult;
          else
            return prettify(orderedResult, this.options);
        }
        addEntity(key, value) {
          if (value.indexOf("&") !== -1) {
            throw new Error("Entity value can't have '&'");
          } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
          } else if (value === "&") {
            throw new Error("An entity with value '&' is not permitted");
          } else {
            this.externalEntities[key] = value;
          }
        }
      };
      module2.exports = XMLParser;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
  var require_orderedJs2Xml = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module2) {
      var EOL = "\n";
      function toXml(jArray, options) {
        let indentation = "";
        if (options.format && options.indentBy.length > 0) {
          indentation = EOL;
        }
        return arrToStr(jArray, options, "", indentation);
      }
      function arrToStr(arr, options, jPath, indentation) {
        let xmlStr = "";
        let isPreviousElementTag = false;
        for (let i3 = 0; i3 < arr.length; i3++) {
          const tagObj = arr[i3];
          const tagName = propName(tagObj);
          let newJPath = "";
          if (jPath.length === 0)
            newJPath = tagName;
          else
            newJPath = `${jPath}.${tagName}`;
          if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
              tagText = options.tagValueProcessor(tagName, tagText);
              tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
          } else if (tagName[0] === "?") {
            const attStr2 = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
            isPreviousElementTag = true;
            continue;
          }
          let newIdentation = indentation;
          if (newIdentation !== "") {
            newIdentation += options.indentBy;
          }
          const attStr = attr_to_str(tagObj[":@"], options);
          const tagStart = indentation + `<${tagName}${attStr}`;
          const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
          if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode)
              xmlStr += tagStart + ">";
            else
              xmlStr += tagStart + "/>";
          } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
          } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
          } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
              xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
              xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
          }
          isPreviousElementTag = true;
        }
        return xmlStr;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i3 = 0; i3 < keys.length; i3++) {
          const key = keys[i3];
          if (key !== ":@")
            return key;
        }
      }
      function attr_to_str(attrMap, options) {
        let attrStr = "";
        if (attrMap && !options.ignoreAttributes) {
          for (let attr in attrMap) {
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
          }
        }
        return attrStr;
      }
      function isStopNode(jPath, options) {
        jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
        let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
        for (let index in options.stopNodes) {
          if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
            return true;
        }
        return false;
      }
      function replaceEntitiesValue(textValue, options) {
        if (textValue && textValue.length > 0 && options.processEntities) {
          for (let i3 = 0; i3 < options.entities.length; i3++) {
            const entity = options.entities[i3];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      }
      module2.exports = toXml;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
  var require_json2xml = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module2) {
      "use strict";
      var buildFromOrderedJs = require_orderedJs2Xml();
      var defaultOptions = {
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        cdataPropName: false,
        format: false,
        indentBy: "  ",
        suppressEmptyNode: false,
        suppressUnpairedNode: true,
        suppressBooleanAttributes: true,
        tagValueProcessor: function(key, a2) {
          return a2;
        },
        attributeValueProcessor: function(attrName, a2) {
          return a2;
        },
        preserveOrder: false,
        commentPropName: false,
        unpairedTags: [],
        entities: [
          {
            regex: new RegExp("&", "g"),
            val: "&amp;"
          },
          {
            regex: new RegExp(">", "g"),
            val: "&gt;"
          },
          {
            regex: new RegExp("<", "g"),
            val: "&lt;"
          },
          {
            regex: new RegExp("'", "g"),
            val: "&apos;"
          },
          {
            regex: new RegExp('"', "g"),
            val: "&quot;"
          }
        ],
        processEntities: true,
        stopNodes: [],
        oneListGroup: false
      };
      function Builder(options) {
        this.options = Object.assign({}, defaultOptions, options);
        if (this.options.ignoreAttributes || this.options.attributesGroupName) {
          this.isAttribute = function() {
            return false;
          };
        } else {
          this.attrPrefixLen = this.options.attributeNamePrefix.length;
          this.isAttribute = isAttribute;
        }
        this.processTextOrObjNode = processTextOrObjNode;
        if (this.options.format) {
          this.indentate = indentate;
          this.tagEndChar = ">\n";
          this.newLine = "\n";
        } else {
          this.indentate = function() {
            return "";
          };
          this.tagEndChar = ">";
          this.newLine = "";
        }
      }
      Builder.prototype.build = function(jObj) {
        if (this.options.preserveOrder) {
          return buildFromOrderedJs(jObj, this.options);
        } else {
          if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
            jObj = {
              [this.options.arrayNodeName]: jObj
            };
          }
          return this.j2x(jObj, 0).val;
        }
      };
      Builder.prototype.j2x = function(jObj, level) {
        let attrStr = "";
        let val2 = "";
        for (let key in jObj) {
          if (typeof jObj[key] === "undefined") {
          } else if (jObj[key] === null) {
            if (key[0] === "?")
              val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            else
              val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          } else if (jObj[key] instanceof Date) {
            val2 += this.buildTextValNode(jObj[key], key, "", level);
          } else if (typeof jObj[key] !== "object") {
            const attr = this.isAttribute(key);
            if (attr) {
              attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
            } else {
              if (key === this.options.textNodeName) {
                let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
                val2 += this.replaceEntitiesValue(newval);
              } else {
                val2 += this.buildTextValNode(jObj[key], key, "", level);
              }
            }
          } else if (Array.isArray(jObj[key])) {
            const arrLen = jObj[key].length;
            let listTagVal = "";
            for (let j = 0; j < arrLen; j++) {
              const item = jObj[key][j];
              if (typeof item === "undefined") {
              } else if (item === null) {
                if (key[0] === "?")
                  val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
                else
                  val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
              } else if (typeof item === "object") {
                if (this.options.oneListGroup) {
                  listTagVal += this.j2x(item, level + 1).val;
                } else {
                  listTagVal += this.processTextOrObjNode(item, key, level);
                }
              } else {
                listTagVal += this.buildTextValNode(item, key, "", level);
              }
            }
            if (this.options.oneListGroup) {
              listTagVal = this.buildObjectNode(listTagVal, key, "", level);
            }
            val2 += listTagVal;
          } else {
            if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
              const Ks = Object.keys(jObj[key]);
              const L = Ks.length;
              for (let j = 0; j < L; j++) {
                attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
              }
            } else {
              val2 += this.processTextOrObjNode(jObj[key], key, level);
            }
          }
        }
        return {
          attrStr,
          val: val2
        };
      };
      Builder.prototype.buildAttrPairStr = function(attrName, val2) {
        val2 = this.options.attributeValueProcessor(attrName, "" + val2);
        val2 = this.replaceEntitiesValue(val2);
        if (this.options.suppressBooleanAttributes && val2 === "true") {
          return " " + attrName;
        } else
          return " " + attrName + '="' + val2 + '"';
      };
      function processTextOrObjNode(object, key, level) {
        const result = this.j2x(object, level + 1);
        if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
          return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
        } else {
          return this.buildObjectNode(result.val, key, result.attrStr, level);
        }
      }
      Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
        if (val2 === "") {
          if (key[0] === "?")
            return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
          else {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          }
        } else {
          let tagEndExp = "</" + key + this.tagEndChar;
          let piClosingChar = "";
          if (key[0] === "?") {
            piClosingChar = "?";
            tagEndExp = "";
          }
          if (attrStr && val2.indexOf("<") === -1) {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
          } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
            return this.indentate(level) + `<!--${val2}-->` + this.newLine;
          } else {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
          }
        }
      };
      Builder.prototype.closeTag = function(key) {
        let closeTag = "";
        if (this.options.unpairedTags.indexOf(key) !== -1) {
          if (!this.options.suppressUnpairedNode)
            closeTag = "/";
        } else if (this.options.suppressEmptyNode) {
          closeTag = "/";
        } else {
          closeTag = `></${key}`;
        }
        return closeTag;
      };
      Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
        if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
          return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else if (key[0] === "?") {
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        } else {
          let textValue = this.options.tagValueProcessor(key, val2);
          textValue = this.replaceEntitiesValue(textValue);
          if (textValue === "") {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          } else {
            return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
          }
        }
      };
      Builder.prototype.replaceEntitiesValue = function(textValue) {
        if (textValue && textValue.length > 0 && this.options.processEntities) {
          for (let i3 = 0; i3 < this.options.entities.length; i3++) {
            const entity = this.options.entities[i3];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      };
      function indentate(level) {
        return this.options.indentBy.repeat(level);
      }
      function isAttribute(name10) {
        if (name10.startsWith(this.options.attributeNamePrefix)) {
          return name10.substr(this.attrPrefixLen);
        } else {
          return false;
        }
      }
      module2.exports = Builder;
    }
  });

  // ../../node_modules/fast-xml-parser/src/fxp.js
  var require_fxp = __commonJS({
    "../../node_modules/fast-xml-parser/src/fxp.js"(exports, module2) {
      "use strict";
      var validator = require_validator();
      var XMLParser = require_XMLParser();
      var XMLBuilder = require_json2xml();
      module2.exports = {
        XMLParser,
        XMLValidator: validator,
        XMLBuilder
      };
    }
  });

  // ../../node_modules/long/dist/long.js
  var require_long = __commonJS({
    "../../node_modules/long/dist/long.js"(exports, module2) {
      (function(global2, factory) {
        if (typeof define === "function" && define["amd"])
          define([], factory);
        else if (typeof __require === "function" && typeof module2 === "object" && module2 && module2["exports"])
          module2["exports"] = factory();
        else
          (global2["dcodeIO"] = global2["dcodeIO"] || {})["Long"] = factory();
      })(exports, function() {
        "use strict";
        function Long4(low, high, unsigned) {
          this.low = low | 0;
          this.high = high | 0;
          this.unsigned = !!unsigned;
        }
        Long4.prototype.__isLong__;
        Object.defineProperty(Long4.prototype, "__isLong__", {
          value: true,
          enumerable: false,
          configurable: false
        });
        function isLong2(obj) {
          return (obj && obj["__isLong__"]) === true;
        }
        Long4.isLong = isLong2;
        var INT_CACHE2 = {};
        var UINT_CACHE2 = {};
        function fromInt2(value, unsigned) {
          var obj, cachedObj, cache4;
          if (unsigned) {
            value >>>= 0;
            if (cache4 = 0 <= value && value < 256) {
              cachedObj = UINT_CACHE2[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = fromBits2(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache4)
              UINT_CACHE2[value] = obj;
            return obj;
          } else {
            value |= 0;
            if (cache4 = -128 <= value && value < 128) {
              cachedObj = INT_CACHE2[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = fromBits2(value, value < 0 ? -1 : 0, false);
            if (cache4)
              INT_CACHE2[value] = obj;
            return obj;
          }
        }
        Long4.fromInt = fromInt2;
        function fromNumber2(value, unsigned) {
          if (isNaN(value) || !isFinite(value))
            return unsigned ? UZERO2 : ZERO5;
          if (unsigned) {
            if (value < 0)
              return UZERO2;
            if (value >= TWO_PWR_64_DBL2)
              return MAX_UNSIGNED_VALUE2;
          } else {
            if (value <= -TWO_PWR_63_DBL2)
              return MIN_VALUE2;
            if (value + 1 >= TWO_PWR_63_DBL2)
              return MAX_VALUE2;
          }
          if (value < 0)
            return fromNumber2(-value, unsigned).neg();
          return fromBits2(value % TWO_PWR_32_DBL2 | 0, value / TWO_PWR_32_DBL2 | 0, unsigned);
        }
        Long4.fromNumber = fromNumber2;
        function fromBits2(lowBits, highBits, unsigned) {
          return new Long4(lowBits, highBits, unsigned);
        }
        Long4.fromBits = fromBits2;
        var pow_dbl2 = Math.pow;
        function fromString2(str, unsigned, radix) {
          if (str.length === 0)
            throw Error("empty string");
          if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return ZERO5;
          if (typeof unsigned === "number") {
            radix = unsigned, unsigned = false;
          } else {
            unsigned = !!unsigned;
          }
          radix = radix || 10;
          if (radix < 2 || 36 < radix)
            throw RangeError("radix");
          var p2;
          if ((p2 = str.indexOf("-")) > 0)
            throw Error("interior hyphen");
          else if (p2 === 0) {
            return fromString2(str.substring(1), unsigned, radix).neg();
          }
          var radixToPower = fromNumber2(pow_dbl2(radix, 8));
          var result = ZERO5;
          for (var i3 = 0; i3 < str.length; i3 += 8) {
            var size = Math.min(8, str.length - i3), value = parseInt(str.substring(i3, i3 + size), radix);
            if (size < 8) {
              var power = fromNumber2(pow_dbl2(radix, size));
              result = result.mul(power).add(fromNumber2(value));
            } else {
              result = result.mul(radixToPower);
              result = result.add(fromNumber2(value));
            }
          }
          result.unsigned = unsigned;
          return result;
        }
        Long4.fromString = fromString2;
        function fromValue2(val2) {
          if (val2 instanceof Long4)
            return val2;
          if (typeof val2 === "number")
            return fromNumber2(val2);
          if (typeof val2 === "string")
            return fromString2(val2);
          return fromBits2(val2.low, val2.high, val2.unsigned);
        }
        Long4.fromValue = fromValue2;
        var TWO_PWR_16_DBL2 = 1 << 16;
        var TWO_PWR_24_DBL2 = 1 << 24;
        var TWO_PWR_32_DBL2 = TWO_PWR_16_DBL2 * TWO_PWR_16_DBL2;
        var TWO_PWR_64_DBL2 = TWO_PWR_32_DBL2 * TWO_PWR_32_DBL2;
        var TWO_PWR_63_DBL2 = TWO_PWR_64_DBL2 / 2;
        var TWO_PWR_242 = fromInt2(TWO_PWR_24_DBL2);
        var ZERO5 = fromInt2(0);
        Long4.ZERO = ZERO5;
        var UZERO2 = fromInt2(0, true);
        Long4.UZERO = UZERO2;
        var ONE2 = fromInt2(1);
        Long4.ONE = ONE2;
        var UONE2 = fromInt2(1, true);
        Long4.UONE = UONE2;
        var NEG_ONE2 = fromInt2(-1);
        Long4.NEG_ONE = NEG_ONE2;
        var MAX_VALUE2 = fromBits2(4294967295 | 0, 2147483647 | 0, false);
        Long4.MAX_VALUE = MAX_VALUE2;
        var MAX_UNSIGNED_VALUE2 = fromBits2(4294967295 | 0, 4294967295 | 0, true);
        Long4.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE2;
        var MIN_VALUE2 = fromBits2(0, 2147483648 | 0, false);
        Long4.MIN_VALUE = MIN_VALUE2;
        var LongPrototype2 = Long4.prototype;
        LongPrototype2.toInt = function toInt2() {
          return this.unsigned ? this.low >>> 0 : this.low;
        };
        LongPrototype2.toNumber = function toNumber2() {
          if (this.unsigned)
            return (this.high >>> 0) * TWO_PWR_32_DBL2 + (this.low >>> 0);
          return this.high * TWO_PWR_32_DBL2 + (this.low >>> 0);
        };
        LongPrototype2.toString = function toString2(radix) {
          radix = radix || 10;
          if (radix < 2 || 36 < radix)
            throw RangeError("radix");
          if (this.isZero())
            return "0";
          if (this.isNegative()) {
            if (this.eq(MIN_VALUE2)) {
              var radixLong = fromNumber2(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
              return div.toString(radix) + rem1.toInt().toString(radix);
            } else
              return "-" + this.neg().toString(radix);
          }
          var radixToPower = fromNumber2(pow_dbl2(radix, 6), this.unsigned), rem = this;
          var result = "";
          while (true) {
            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
              return digits + result;
            else {
              while (digits.length < 6)
                digits = "0" + digits;
              result = "" + digits + result;
            }
          }
        };
        LongPrototype2.getHighBits = function getHighBits2() {
          return this.high;
        };
        LongPrototype2.getHighBitsUnsigned = function getHighBitsUnsigned2() {
          return this.high >>> 0;
        };
        LongPrototype2.getLowBits = function getLowBits2() {
          return this.low;
        };
        LongPrototype2.getLowBitsUnsigned = function getLowBitsUnsigned2() {
          return this.low >>> 0;
        };
        LongPrototype2.getNumBitsAbs = function getNumBitsAbs2() {
          if (this.isNegative())
            return this.eq(MIN_VALUE2) ? 64 : this.neg().getNumBitsAbs();
          var val2 = this.high != 0 ? this.high : this.low;
          for (var bit = 31; bit > 0; bit--)
            if ((val2 & 1 << bit) != 0)
              break;
          return this.high != 0 ? bit + 33 : bit + 1;
        };
        LongPrototype2.isZero = function isZero2() {
          return this.high === 0 && this.low === 0;
        };
        LongPrototype2.isNegative = function isNegative2() {
          return !this.unsigned && this.high < 0;
        };
        LongPrototype2.isPositive = function isPositive2() {
          return this.unsigned || this.high >= 0;
        };
        LongPrototype2.isOdd = function isOdd2() {
          return (this.low & 1) === 1;
        };
        LongPrototype2.isEven = function isEven2() {
          return (this.low & 1) === 0;
        };
        LongPrototype2.equals = function equals5(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
            return false;
          return this.high === other.high && this.low === other.low;
        };
        LongPrototype2.eq = LongPrototype2.equals;
        LongPrototype2.notEquals = function notEquals2(other) {
          return !this.eq(other);
        };
        LongPrototype2.neq = LongPrototype2.notEquals;
        LongPrototype2.lessThan = function lessThan2(other) {
          return this.comp(other) < 0;
        };
        LongPrototype2.lt = LongPrototype2.lessThan;
        LongPrototype2.lessThanOrEqual = function lessThanOrEqual2(other) {
          return this.comp(other) <= 0;
        };
        LongPrototype2.lte = LongPrototype2.lessThanOrEqual;
        LongPrototype2.greaterThan = function greaterThan2(other) {
          return this.comp(other) > 0;
        };
        LongPrototype2.gt = LongPrototype2.greaterThan;
        LongPrototype2.greaterThanOrEqual = function greaterThanOrEqual2(other) {
          return this.comp(other) >= 0;
        };
        LongPrototype2.gte = LongPrototype2.greaterThanOrEqual;
        LongPrototype2.compare = function compare2(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          if (this.eq(other))
            return 0;
          var thisNeg = this.isNegative(), otherNeg = other.isNegative();
          if (thisNeg && !otherNeg)
            return -1;
          if (!thisNeg && otherNeg)
            return 1;
          if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
          return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
        };
        LongPrototype2.comp = LongPrototype2.compare;
        LongPrototype2.negate = function negate4() {
          if (!this.unsigned && this.eq(MIN_VALUE2))
            return MIN_VALUE2;
          return this.not().add(ONE2);
        };
        LongPrototype2.neg = LongPrototype2.negate;
        LongPrototype2.add = function add7(addend) {
          if (!isLong2(addend))
            addend = fromValue2(addend);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = addend.high >>> 16;
          var b32 = addend.high & 65535;
          var b16 = addend.low >>> 16;
          var b00 = addend.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 + b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 + b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 + b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 + b48;
          c48 &= 65535;
          return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype2.subtract = function subtract4(subtrahend) {
          if (!isLong2(subtrahend))
            subtrahend = fromValue2(subtrahend);
          return this.add(subtrahend.neg());
        };
        LongPrototype2.sub = LongPrototype2.subtract;
        LongPrototype2.multiply = function multiply6(multiplier) {
          if (this.isZero())
            return ZERO5;
          if (!isLong2(multiplier))
            multiplier = fromValue2(multiplier);
          if (multiplier.isZero())
            return ZERO5;
          if (this.eq(MIN_VALUE2))
            return multiplier.isOdd() ? MIN_VALUE2 : ZERO5;
          if (multiplier.eq(MIN_VALUE2))
            return this.isOdd() ? MIN_VALUE2 : ZERO5;
          if (this.isNegative()) {
            if (multiplier.isNegative())
              return this.neg().mul(multiplier.neg());
            else
              return this.neg().mul(multiplier).neg();
          } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();
          if (this.lt(TWO_PWR_242) && multiplier.lt(TWO_PWR_242))
            return fromNumber2(this.toNumber() * multiplier.toNumber(), this.unsigned);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = multiplier.high >>> 16;
          var b32 = multiplier.high & 65535;
          var b16 = multiplier.low >>> 16;
          var b00 = multiplier.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 * b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 * b00;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c16 += a00 * b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 * b00;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a16 * b16;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a00 * b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
          c48 &= 65535;
          return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype2.mul = LongPrototype2.multiply;
        LongPrototype2.divide = function divide2(divisor) {
          if (!isLong2(divisor))
            divisor = fromValue2(divisor);
          if (divisor.isZero())
            throw Error("division by zero");
          if (this.isZero())
            return this.unsigned ? UZERO2 : ZERO5;
          var approx, rem, res;
          if (!this.unsigned) {
            if (this.eq(MIN_VALUE2)) {
              if (divisor.eq(ONE2) || divisor.eq(NEG_ONE2))
                return MIN_VALUE2;
              else if (divisor.eq(MIN_VALUE2))
                return ONE2;
              else {
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO5)) {
                  return divisor.isNegative() ? ONE2 : NEG_ONE2;
                } else {
                  rem = this.sub(divisor.mul(approx));
                  res = approx.add(rem.div(divisor));
                  return res;
                }
              }
            } else if (divisor.eq(MIN_VALUE2))
              return this.unsigned ? UZERO2 : ZERO5;
            if (this.isNegative()) {
              if (divisor.isNegative())
                return this.neg().div(divisor.neg());
              return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
              return this.div(divisor.neg()).neg();
            res = ZERO5;
          } else {
            if (!divisor.unsigned)
              divisor = divisor.toUnsigned();
            if (divisor.gt(this))
              return UZERO2;
            if (divisor.gt(this.shru(1)))
              return UONE2;
            res = UZERO2;
          }
          rem = this;
          while (rem.gte(divisor)) {
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
            var log23 = Math.ceil(Math.log(approx) / Math.LN2), delta = log23 <= 48 ? 1 : pow_dbl2(2, log23 - 48), approxRes = fromNumber2(approx), approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
              approx -= delta;
              approxRes = fromNumber2(approx, this.unsigned);
              approxRem = approxRes.mul(divisor);
            }
            if (approxRes.isZero())
              approxRes = ONE2;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
          }
          return res;
        };
        LongPrototype2.div = LongPrototype2.divide;
        LongPrototype2.modulo = function modulo2(divisor) {
          if (!isLong2(divisor))
            divisor = fromValue2(divisor);
          return this.sub(this.div(divisor).mul(divisor));
        };
        LongPrototype2.mod = LongPrototype2.modulo;
        LongPrototype2.not = function not2() {
          return fromBits2(~this.low, ~this.high, this.unsigned);
        };
        LongPrototype2.and = function and2(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          return fromBits2(this.low & other.low, this.high & other.high, this.unsigned);
        };
        LongPrototype2.or = function or2(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          return fromBits2(this.low | other.low, this.high | other.high, this.unsigned);
        };
        LongPrototype2.xor = function xor2(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          return fromBits2(this.low ^ other.low, this.high ^ other.high, this.unsigned);
        };
        LongPrototype2.shiftLeft = function shiftLeft2(numBits) {
          if (isLong2(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return fromBits2(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
          else
            return fromBits2(0, this.low << numBits - 32, this.unsigned);
        };
        LongPrototype2.shl = LongPrototype2.shiftLeft;
        LongPrototype2.shiftRight = function shiftRight2(numBits) {
          if (isLong2(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return fromBits2(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
          else
            return fromBits2(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
        };
        LongPrototype2.shr = LongPrototype2.shiftRight;
        LongPrototype2.shiftRightUnsigned = function shiftRightUnsigned2(numBits) {
          if (isLong2(numBits))
            numBits = numBits.toInt();
          numBits &= 63;
          if (numBits === 0)
            return this;
          else {
            var high = this.high;
            if (numBits < 32) {
              var low = this.low;
              return fromBits2(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
            } else if (numBits === 32)
              return fromBits2(high, 0, this.unsigned);
            else
              return fromBits2(high >>> numBits - 32, 0, this.unsigned);
          }
        };
        LongPrototype2.shru = LongPrototype2.shiftRightUnsigned;
        LongPrototype2.toSigned = function toSigned2() {
          if (!this.unsigned)
            return this;
          return fromBits2(this.low, this.high, false);
        };
        LongPrototype2.toUnsigned = function toUnsigned2() {
          if (this.unsigned)
            return this;
          return fromBits2(this.low, this.high, true);
        };
        LongPrototype2.toBytes = function(le) {
          return le ? this.toBytesLE() : this.toBytesBE();
        };
        LongPrototype2.toBytesLE = function() {
          var hi = this.high, lo = this.low;
          return [
            lo & 255,
            lo >>> 8 & 255,
            lo >>> 16 & 255,
            lo >>> 24 & 255,
            hi & 255,
            hi >>> 8 & 255,
            hi >>> 16 & 255,
            hi >>> 24 & 255
          ];
        };
        LongPrototype2.toBytesBE = function() {
          var hi = this.high, lo = this.low;
          return [
            hi >>> 24 & 255,
            hi >>> 16 & 255,
            hi >>> 8 & 255,
            hi & 255,
            lo >>> 24 & 255,
            lo >>> 16 & 255,
            lo >>> 8 & 255,
            lo & 255
          ];
        };
        return Long4;
      });
    }
  });

  // external-global-plugin:h3-js
  var require_h3_js = __commonJS({
    "external-global-plugin:h3-js"(exports, module2) {
      module2.exports = globalThis.h3 || {};
    }
  });

  // ../../node_modules/pbf/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "../../node_modules/pbf/node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e2, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i3 = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i3];
        i3 += d;
        e2 = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i3], i3 += d, nBits -= 8) {
        }
        m = e2 & (1 << -nBits) - 1;
        e2 >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i3], i3 += d, nBits -= 8) {
        }
        if (e2 === 0) {
          e2 = 1 - eBias;
        } else if (e2 === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e2 = e2 - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e2 - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e2, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i3 = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e2 = eMax;
        } else {
          e2 = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e2)) < 1) {
            e2--;
            c *= 2;
          }
          if (e2 + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e2++;
            c /= 2;
          }
          if (e2 + eBias >= eMax) {
            m = 0;
            e2 = eMax;
          } else if (e2 + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e2 = e2 + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e2 = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i3] = m & 255, i3 += d, m /= 256, mLen -= 8) {
        }
        e2 = e2 << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i3] = e2 & 255, i3 += d, e2 /= 256, eLen -= 8) {
        }
        buffer[offset + i3 - d] |= s2 * 128;
      };
    }
  });

  // ../../node_modules/pbf/index.js
  var require_pbf = __commonJS({
    "../../node_modules/pbf/index.js"(exports, module2) {
      "use strict";
      module2.exports = Pbf;
      var ieee754 = require_ieee754();
      function Pbf(buf) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
        this.pos = 0;
        this.type = 0;
        this.length = this.buf.length;
      }
      Pbf.Varint = 0;
      Pbf.Fixed64 = 1;
      Pbf.Bytes = 2;
      Pbf.Fixed32 = 5;
      var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
      var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
      var TEXT_DECODER_MIN_LENGTH = 12;
      var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
      Pbf.prototype = {
        destroy: function() {
          this.buf = null;
        },
        readFields: function(readField, result, end) {
          end = end || this.length;
          while (this.pos < end) {
            var val2 = this.readVarint(), tag = val2 >> 3, startPos = this.pos;
            this.type = val2 & 7;
            readField(tag, result, this);
            if (this.pos === startPos)
              this.skip(val2);
          }
          return result;
        },
        readMessage: function(readField, result) {
          return this.readFields(readField, result, this.readVarint() + this.pos);
        },
        readFixed32: function() {
          var val2 = readUInt32(this.buf, this.pos);
          this.pos += 4;
          return val2;
        },
        readSFixed32: function() {
          var val2 = readInt32(this.buf, this.pos);
          this.pos += 4;
          return val2;
        },
        readFixed64: function() {
          var val2 = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val2;
        },
        readSFixed64: function() {
          var val2 = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val2;
        },
        readFloat: function() {
          var val2 = ieee754.read(this.buf, this.pos, true, 23, 4);
          this.pos += 4;
          return val2;
        },
        readDouble: function() {
          var val2 = ieee754.read(this.buf, this.pos, true, 52, 8);
          this.pos += 8;
          return val2;
        },
        readVarint: function(isSigned) {
          var buf = this.buf, val2, b;
          b = buf[this.pos++];
          val2 = b & 127;
          if (b < 128)
            return val2;
          b = buf[this.pos++];
          val2 |= (b & 127) << 7;
          if (b < 128)
            return val2;
          b = buf[this.pos++];
          val2 |= (b & 127) << 14;
          if (b < 128)
            return val2;
          b = buf[this.pos++];
          val2 |= (b & 127) << 21;
          if (b < 128)
            return val2;
          b = buf[this.pos];
          val2 |= (b & 15) << 28;
          return readVarintRemainder(val2, isSigned, this);
        },
        readVarint64: function() {
          return this.readVarint(true);
        },
        readSVarint: function() {
          var num = this.readVarint();
          return num % 2 === 1 ? (num + 1) / -2 : num / 2;
        },
        readBoolean: function() {
          return Boolean(this.readVarint());
        },
        readString: function() {
          var end = this.readVarint() + this.pos;
          var pos = this.pos;
          this.pos = end;
          if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            return readUtf8TextDecoder(this.buf, pos, end);
          }
          return readUtf8(this.buf, pos, end);
        },
        readBytes: function() {
          var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
          this.pos = end;
          return buffer;
        },
        readPackedVarint: function(arr, isSigned) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readVarint(isSigned));
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readVarint(isSigned));
          return arr;
        },
        readPackedSVarint: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSVarint());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSVarint());
          return arr;
        },
        readPackedBoolean: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readBoolean());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readBoolean());
          return arr;
        },
        readPackedFloat: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFloat());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFloat());
          return arr;
        },
        readPackedDouble: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readDouble());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readDouble());
          return arr;
        },
        readPackedFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed32());
          return arr;
        },
        readPackedSFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed32());
          return arr;
        },
        readPackedFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed64());
          return arr;
        },
        readPackedSFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed64());
          return arr;
        },
        skip: function(val2) {
          var type = val2 & 7;
          if (type === Pbf.Varint)
            while (this.buf[this.pos++] > 127) {
            }
          else if (type === Pbf.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (type === Pbf.Fixed32)
            this.pos += 4;
          else if (type === Pbf.Fixed64)
            this.pos += 8;
          else
            throw new Error("Unimplemented type: " + type);
        },
        writeTag: function(tag, type) {
          this.writeVarint(tag << 3 | type);
        },
        realloc: function(min) {
          var length7 = this.length || 16;
          while (length7 < this.pos + min)
            length7 *= 2;
          if (length7 !== this.length) {
            var buf = new Uint8Array(length7);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length7;
          }
        },
        finish: function() {
          this.length = this.pos;
          this.pos = 0;
          return this.buf.subarray(0, this.length);
        },
        writeFixed32: function(val2) {
          this.realloc(4);
          writeInt32(this.buf, val2, this.pos);
          this.pos += 4;
        },
        writeSFixed32: function(val2) {
          this.realloc(4);
          writeInt32(this.buf, val2, this.pos);
          this.pos += 4;
        },
        writeFixed64: function(val2) {
          this.realloc(8);
          writeInt32(this.buf, val2 & -1, this.pos);
          writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeSFixed64: function(val2) {
          this.realloc(8);
          writeInt32(this.buf, val2 & -1, this.pos);
          writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeVarint: function(val2) {
          val2 = +val2 || 0;
          if (val2 > 268435455 || val2 < 0) {
            writeBigVarint(val2, this);
            return;
          }
          this.realloc(4);
          this.buf[this.pos++] = val2 & 127 | (val2 > 127 ? 128 : 0);
          if (val2 <= 127)
            return;
          this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
          if (val2 <= 127)
            return;
          this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
          if (val2 <= 127)
            return;
          this.buf[this.pos++] = val2 >>> 7 & 127;
        },
        writeSVarint: function(val2) {
          this.writeVarint(val2 < 0 ? -val2 * 2 - 1 : val2 * 2);
        },
        writeBoolean: function(val2) {
          this.writeVarint(Boolean(val2));
        },
        writeString: function(str) {
          str = String(str);
          this.realloc(str.length * 4);
          this.pos++;
          var startPos = this.pos;
          this.pos = writeUtf8(this.buf, str, this.pos);
          var len3 = this.pos - startPos;
          if (len3 >= 128)
            makeRoomForExtraLength(startPos, len3, this);
          this.pos = startPos - 1;
          this.writeVarint(len3);
          this.pos += len3;
        },
        writeFloat: function(val2) {
          this.realloc(4);
          ieee754.write(this.buf, val2, this.pos, true, 23, 4);
          this.pos += 4;
        },
        writeDouble: function(val2) {
          this.realloc(8);
          ieee754.write(this.buf, val2, this.pos, true, 52, 8);
          this.pos += 8;
        },
        writeBytes: function(buffer) {
          var len3 = buffer.length;
          this.writeVarint(len3);
          this.realloc(len3);
          for (var i3 = 0; i3 < len3; i3++)
            this.buf[this.pos++] = buffer[i3];
        },
        writeRawMessage: function(fn, obj) {
          this.pos++;
          var startPos = this.pos;
          fn(obj, this);
          var len3 = this.pos - startPos;
          if (len3 >= 128)
            makeRoomForExtraLength(startPos, len3, this);
          this.pos = startPos - 1;
          this.writeVarint(len3);
          this.pos += len3;
        },
        writeMessage: function(tag, fn, obj) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeRawMessage(fn, obj);
        },
        writePackedVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedVarint, arr);
        },
        writePackedSVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSVarint, arr);
        },
        writePackedBoolean: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedBoolean, arr);
        },
        writePackedFloat: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFloat, arr);
        },
        writePackedDouble: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedDouble, arr);
        },
        writePackedFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed32, arr);
        },
        writePackedSFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed32, arr);
        },
        writePackedFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed64, arr);
        },
        writePackedSFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed64, arr);
        },
        writeBytesField: function(tag, buffer) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeBytes(buffer);
        },
        writeFixed32Field: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFixed32(val2);
        },
        writeSFixed32Field: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeSFixed32(val2);
        },
        writeFixed64Field: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeFixed64(val2);
        },
        writeSFixed64Field: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeSFixed64(val2);
        },
        writeVarintField: function(tag, val2) {
          this.writeTag(tag, Pbf.Varint);
          this.writeVarint(val2);
        },
        writeSVarintField: function(tag, val2) {
          this.writeTag(tag, Pbf.Varint);
          this.writeSVarint(val2);
        },
        writeStringField: function(tag, str) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeString(str);
        },
        writeFloatField: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFloat(val2);
        },
        writeDoubleField: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeDouble(val2);
        },
        writeBooleanField: function(tag, val2) {
          this.writeVarintField(tag, Boolean(val2));
        }
      };
      function readVarintRemainder(l2, s2, p2) {
        var buf = p2.buf, h, b;
        b = buf[p2.pos++];
        h = (b & 112) >> 4;
        if (b < 128)
          return toNum(l2, h, s2);
        b = buf[p2.pos++];
        h |= (b & 127) << 3;
        if (b < 128)
          return toNum(l2, h, s2);
        b = buf[p2.pos++];
        h |= (b & 127) << 10;
        if (b < 128)
          return toNum(l2, h, s2);
        b = buf[p2.pos++];
        h |= (b & 127) << 17;
        if (b < 128)
          return toNum(l2, h, s2);
        b = buf[p2.pos++];
        h |= (b & 127) << 24;
        if (b < 128)
          return toNum(l2, h, s2);
        b = buf[p2.pos++];
        h |= (b & 1) << 31;
        if (b < 128)
          return toNum(l2, h, s2);
        throw new Error("Expected varint not more than 10 bytes");
      }
      function readPackedEnd(pbf) {
        return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
      }
      function toNum(low, high, isSigned) {
        if (isSigned) {
          return high * 4294967296 + (low >>> 0);
        }
        return (high >>> 0) * 4294967296 + (low >>> 0);
      }
      function writeBigVarint(val2, pbf) {
        var low, high;
        if (val2 >= 0) {
          low = val2 % 4294967296 | 0;
          high = val2 / 4294967296 | 0;
        } else {
          low = ~(-val2 % 4294967296);
          high = ~(-val2 / 4294967296);
          if (low ^ 4294967295) {
            low = low + 1 | 0;
          } else {
            low = 0;
            high = high + 1 | 0;
          }
        }
        if (val2 >= 18446744073709552e3 || val2 < -18446744073709552e3) {
          throw new Error("Given varint doesn't fit into 10 bytes");
        }
        pbf.realloc(10);
        writeBigVarintLow(low, high, pbf);
        writeBigVarintHigh(high, pbf);
      }
      function writeBigVarintLow(low, high, pbf) {
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos] = low & 127;
      }
      function writeBigVarintHigh(high, pbf) {
        var lsb2 = (high & 7) << 4;
        pbf.buf[pbf.pos++] |= lsb2 | ((high >>>= 3) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127;
      }
      function makeRoomForExtraLength(startPos, len3, pbf) {
        var extraLen = len3 <= 16383 ? 1 : len3 <= 2097151 ? 2 : len3 <= 268435455 ? 3 : Math.floor(Math.log(len3) / (Math.LN2 * 7));
        pbf.realloc(extraLen);
        for (var i3 = pbf.pos - 1; i3 >= startPos; i3--)
          pbf.buf[i3 + extraLen] = pbf.buf[i3];
      }
      function writePackedVarint(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeVarint(arr[i3]);
      }
      function writePackedSVarint(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeSVarint(arr[i3]);
      }
      function writePackedFloat(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeFloat(arr[i3]);
      }
      function writePackedDouble(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeDouble(arr[i3]);
      }
      function writePackedBoolean(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeBoolean(arr[i3]);
      }
      function writePackedFixed32(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeFixed32(arr[i3]);
      }
      function writePackedSFixed32(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeSFixed32(arr[i3]);
      }
      function writePackedFixed64(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeFixed64(arr[i3]);
      }
      function writePackedSFixed64(arr, pbf) {
        for (var i3 = 0; i3 < arr.length; i3++)
          pbf.writeSFixed64(arr[i3]);
      }
      function readUInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
      }
      function writeInt32(buf, val2, pos) {
        buf[pos] = val2;
        buf[pos + 1] = val2 >>> 8;
        buf[pos + 2] = val2 >>> 16;
        buf[pos + 3] = val2 >>> 24;
      }
      function readInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
      }
      function readUtf8(buf, pos, end) {
        var str = "";
        var i3 = pos;
        while (i3 < end) {
          var b0 = buf[i3];
          var c = null;
          var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
          if (i3 + bytesPerSequence > end)
            break;
          var b1, b2, b3;
          if (bytesPerSequence === 1) {
            if (b0 < 128) {
              c = b0;
            }
          } else if (bytesPerSequence === 2) {
            b1 = buf[i3 + 1];
            if ((b1 & 192) === 128) {
              c = (b0 & 31) << 6 | b1 & 63;
              if (c <= 127) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 3) {
            b1 = buf[i3 + 1];
            b2 = buf[i3 + 2];
            if ((b1 & 192) === 128 && (b2 & 192) === 128) {
              c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
              if (c <= 2047 || c >= 55296 && c <= 57343) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 4) {
            b1 = buf[i3 + 1];
            b2 = buf[i3 + 2];
            b3 = buf[i3 + 3];
            if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
              c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
              if (c <= 65535 || c >= 1114112) {
                c = null;
              }
            }
          }
          if (c === null) {
            c = 65533;
            bytesPerSequence = 1;
          } else if (c > 65535) {
            c -= 65536;
            str += String.fromCharCode(c >>> 10 & 1023 | 55296);
            c = 56320 | c & 1023;
          }
          str += String.fromCharCode(c);
          i3 += bytesPerSequence;
        }
        return str;
      }
      function readUtf8TextDecoder(buf, pos, end) {
        return utf8TextDecoder.decode(buf.subarray(pos, end));
      }
      function writeUtf8(buf, str, pos) {
        for (var i3 = 0, c, lead; i3 < str.length; i3++) {
          c = str.charCodeAt(i3);
          if (c > 55295 && c < 57344) {
            if (lead) {
              if (c < 56320) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
                lead = c;
                continue;
              } else {
                c = lead - 55296 << 10 | c - 56320 | 65536;
                lead = null;
              }
            } else {
              if (c > 56319 || i3 + 1 === str.length) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
              } else {
                lead = c;
              }
              continue;
            }
          } else if (lead) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
            lead = null;
          }
          if (c < 128) {
            buf[pos++] = c;
          } else {
            if (c < 2048) {
              buf[pos++] = c >> 6 | 192;
            } else {
              if (c < 65536) {
                buf[pos++] = c >> 12 | 224;
              } else {
                buf[pos++] = c >> 18 | 240;
                buf[pos++] = c >> 12 & 63 | 128;
              }
              buf[pos++] = c >> 6 & 63 | 128;
            }
            buf[pos++] = c & 63 | 128;
          }
        }
        return pos;
      }
    }
  });

  // ../../node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "../../node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          var hasSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
          function isValidElementType(type) {
            return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE);
          }
          var lowPriorityWarningWithoutStack = function() {
          };
          {
            var printWarning = function(format) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              var argIndex = 0;
              var message = "Warning: " + format.replace(/%s/g, function() {
                return args[argIndex++];
              });
              if (typeof console !== "undefined") {
                console.warn(message);
              }
              try {
                throw new Error(message);
              } catch (x2) {
              }
            };
            lowPriorityWarningWithoutStack = function(condition, format) {
              if (format === void 0) {
                throw new Error("`lowPriorityWarningWithoutStack(condition, format, ...args)` requires a warning message argument");
              }
              if (!condition) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                  args[_key2 - 2] = arguments[_key2];
                }
                printWarning.apply(void 0, [format].concat(args));
              }
            };
          }
          var lowPriorityWarningWithoutStack$1 = lowPriorityWarningWithoutStack;
          function typeOf(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                lowPriorityWarningWithoutStack$1(false, "The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          exports.typeOf = typeOf;
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isValidElementType = isValidElementType;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
        })();
      }
    }
  });

  // ../../node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "../../node_modules/react-is/index.js"(exports, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_is_development();
      }
    }
  });

  // ../../node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "../../node_modules/object-assign/index.js"(exports, module2) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val2) {
        if (val2 === null || val2 === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val2);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i3 = 0; i3 < 10; i3++) {
            test2["_" + String.fromCharCode(i3)] = i3;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
            return test2[n2];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s2 = 1; s2 < arguments.length; s2++) {
          from = Object(arguments[s2]);
          for (var key in from) {
            if (hasOwnProperty2.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i3 = 0; i3 < symbols.length; i3++) {
              if (propIsEnumerable.call(from, symbols[i3])) {
                to[symbols[i3]] = from[symbols[i3]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // ../../node_modules/prop-types/lib/ReactPropTypesSecret.js
  var require_ReactPropTypesSecret = __commonJS({
    "../../node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module2) {
      "use strict";
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      module2.exports = ReactPropTypesSecret;
    }
  });

  // ../../node_modules/prop-types/checkPropTypes.js
  var require_checkPropTypes = __commonJS({
    "../../node_modules/prop-types/checkPropTypes.js"(exports, module2) {
      "use strict";
      var printWarning = function() {
      };
      if (true) {
        ReactPropTypesSecret = require_ReactPropTypesSecret();
        loggedTypeFailures = {};
        has = Function.call.bind(Object.prototype.hasOwnProperty);
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x2) {
          }
        };
      }
      var ReactPropTypesSecret;
      var loggedTypeFailures;
      var has;
      function checkPropTypes2(typeSpecs, values, location, componentName, getStack) {
        if (true) {
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error2;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error(
                    (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`."
                  );
                  err.name = "Invariant Violation";
                  throw err;
                }
                error2 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
              } catch (ex) {
                error2 = ex;
              }
              if (error2 && !(error2 instanceof Error)) {
                printWarning(
                  (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error2 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
                );
              }
              if (error2 instanceof Error && !(error2.message in loggedTypeFailures)) {
                loggedTypeFailures[error2.message] = true;
                var stack2 = getStack ? getStack() : "";
                printWarning(
                  "Failed " + location + " type: " + error2.message + (stack2 != null ? stack2 : "")
                );
              }
            }
          }
        }
      }
      checkPropTypes2.resetWarningCache = function() {
        if (true) {
          loggedTypeFailures = {};
        }
      };
      module2.exports = checkPropTypes2;
    }
  });

  // ../../node_modules/prop-types/factoryWithTypeCheckers.js
  var require_factoryWithTypeCheckers = __commonJS({
    "../../node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module2) {
      "use strict";
      var ReactIs = require_react_is();
      var assign = require_object_assign();
      var ReactPropTypesSecret = require_ReactPropTypesSecret();
      var checkPropTypes2 = require_checkPropTypes();
      var has = Function.call.bind(Object.prototype.hasOwnProperty);
      var printWarning = function() {
      };
      if (true) {
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x2) {
          }
        };
      }
      function emptyFunctionThatReturnsNull() {
        return null;
      }
      module2.exports = function(isValidElement, throwOnDirectAccess) {
        var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        var ANONYMOUS = "<<anonymous>>";
        var ReactPropTypes = {
          array: createPrimitiveTypeChecker("array"),
          bool: createPrimitiveTypeChecker("boolean"),
          func: createPrimitiveTypeChecker("function"),
          number: createPrimitiveTypeChecker("number"),
          object: createPrimitiveTypeChecker("object"),
          string: createPrimitiveTypeChecker("string"),
          symbol: createPrimitiveTypeChecker("symbol"),
          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          elementType: createElementTypeTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker
        };
        function is(x2, y2) {
          if (x2 === y2) {
            return x2 !== 0 || 1 / x2 === 1 / y2;
          } else {
            return x2 !== x2 && y2 !== y2;
          }
        }
        function PropTypeError(message) {
          this.message = message;
          this.stack = "";
        }
        PropTypeError.prototype = Error.prototype;
        function createChainableTypeChecker(validate2) {
          if (true) {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
              if (throwOnDirectAccess) {
                var err = new Error(
                  "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                );
                err.name = "Invariant Violation";
                throw err;
              } else if (typeof console !== "undefined") {
                var cacheKey = componentName + ":" + propName;
                if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                  printWarning(
                    "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                  );
                  manualPropTypeCallCache[cacheKey] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                }
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
              }
              return null;
            } else {
              return validate2(props, propName, componentName, location, propFullName);
            }
          }
          var chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);
          return chainedCheckType;
        }
        function createPrimitiveTypeChecker(expectedType) {
          function validate2(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
              var preciseType = getPreciseType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."));
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createAnyTypeChecker() {
          return createChainableTypeChecker(emptyFunctionThatReturnsNull);
        }
        function createArrayOfTypeChecker(typeChecker) {
          function validate2(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for (var i3 = 0; i3 < propValue.length; i3++) {
              var error2 = typeChecker(propValue, i3, componentName, location, propFullName + "[" + i3 + "]", ReactPropTypesSecret);
              if (error2 instanceof Error) {
                return error2;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createElementTypeChecker() {
          function validate2(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createElementTypeTypeChecker() {
          function validate2(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createInstanceTypeChecker(expectedClass) {
          function validate2(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              var expectedClassName = expectedClass.name || ANONYMOUS;
              var actualClassName = getClassName(props[propName]);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            if (true) {
              if (arguments.length > 1) {
                printWarning(
                  "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
                );
              } else {
                printWarning("Invalid argument supplied to oneOf, expected an array.");
              }
            }
            return emptyFunctionThatReturnsNull;
          }
          function validate2(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for (var i3 = 0; i3 < expectedValues.length; i3++) {
              if (is(propValue, expectedValues[i3])) {
                return null;
              }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
              var type = getPreciseType(value);
              if (type === "symbol") {
                return String(value);
              }
              return value;
            });
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
          }
          return createChainableTypeChecker(validate2);
        }
        function createObjectOfTypeChecker(typeChecker) {
          function validate2(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            }
            for (var key in propValue) {
              if (has(propValue, key)) {
                var error2 = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                if (error2 instanceof Error) {
                  return error2;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
            return emptyFunctionThatReturnsNull;
          }
          for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
            var checker = arrayOfTypeCheckers[i3];
            if (typeof checker !== "function") {
              printWarning(
                "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i3 + "."
              );
              return emptyFunctionThatReturnsNull;
            }
          }
          function validate2(props, propName, componentName, location, propFullName) {
            for (var i4 = 0; i4 < arrayOfTypeCheckers.length; i4++) {
              var checker2 = arrayOfTypeCheckers[i4];
              if (checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
                return null;
              }
            }
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`."));
          }
          return createChainableTypeChecker(validate2);
        }
        function createNodeChecker() {
          function validate2(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createShapeTypeChecker(shapeTypes) {
          function validate2(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            for (var key in shapeTypes) {
              var checker = shapeTypes[key];
              if (!checker) {
                continue;
              }
              var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error2) {
                return error2;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function createStrictShapeTypeChecker(shapeTypes) {
          function validate2(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            var allKeys = assign({}, props[propName], shapeTypes);
            for (var key in allKeys) {
              var checker = shapeTypes[key];
              if (!checker) {
                return new PropTypeError(
                  "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
                );
              }
              var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error2) {
                return error2;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate2);
        }
        function isNode(propValue) {
          switch (typeof propValue) {
            case "number":
            case "string":
            case "undefined":
              return true;
            case "boolean":
              return !propValue;
            case "object":
              if (Array.isArray(propValue)) {
                return propValue.every(isNode);
              }
              if (propValue === null || isValidElement(propValue)) {
                return true;
              }
              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                var iterator = iteratorFn.call(propValue);
                var step;
                if (iteratorFn !== propValue.entries) {
                  while (!(step = iterator.next()).done) {
                    if (!isNode(step.value)) {
                      return false;
                    }
                  }
                } else {
                  while (!(step = iterator.next()).done) {
                    var entry = step.value;
                    if (entry) {
                      if (!isNode(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }
              return true;
            default:
              return false;
          }
        }
        function isSymbol(propType, propValue) {
          if (propType === "symbol") {
            return true;
          }
          if (!propValue) {
            return false;
          }
          if (propValue["@@toStringTag"] === "Symbol") {
            return true;
          }
          if (typeof Symbol === "function" && propValue instanceof Symbol) {
            return true;
          }
          return false;
        }
        function getPropType(propValue) {
          var propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return "array";
          }
          if (propValue instanceof RegExp) {
            return "object";
          }
          if (isSymbol(propType, propValue)) {
            return "symbol";
          }
          return propType;
        }
        function getPreciseType(propValue) {
          if (typeof propValue === "undefined" || propValue === null) {
            return "" + propValue;
          }
          var propType = getPropType(propValue);
          if (propType === "object") {
            if (propValue instanceof Date) {
              return "date";
            } else if (propValue instanceof RegExp) {
              return "regexp";
            }
          }
          return propType;
        }
        function getPostfixForTypeWarning(value) {
          var type = getPreciseType(value);
          switch (type) {
            case "array":
            case "object":
              return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
              return "a " + type;
            default:
              return type;
          }
        }
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }
        ReactPropTypes.checkPropTypes = checkPropTypes2;
        ReactPropTypes.resetWarningCache = checkPropTypes2.resetWarningCache;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
    }
  });

  // ../../node_modules/prop-types/index.js
  var require_prop_types = __commonJS({
    "../../node_modules/prop-types/index.js"(exports, module2) {
      if (true) {
        ReactIs = require_react_is();
        throwOnDirectAccess = true;
        module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
      } else {
        module2.exports = null();
      }
      var ReactIs;
      var throwOnDirectAccess;
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    AGGREGATION_OPERATION: () => AGGREGATION_OPERATION,
    AmbientLight: () => AmbientLight,
    ArcLayer: () => ArcLayer,
    AttributeManager: () => AttributeManager,
    BitmapLayer: () => BitmapLayer,
    BrushingExtension: () => BrushingExtension,
    COORDINATE_SYSTEM: () => COORDINATE_SYSTEM,
    CPUGridLayer: () => CPUGridLayer,
    ClipExtension: () => ClipExtension,
    CollisionFilterExtension: () => CollisionFilterExtension,
    ColumnLayer: () => ColumnLayer,
    CompositeLayer: () => CompositeLayer,
    ContourLayer: () => ContourLayer,
    Controller: () => Controller,
    DataFilterExtension: () => DataFilterExtension,
    Deck: () => Deck,
    DeckGL: () => DeckGL,
    DeckRenderer: () => DeckRenderer,
    DirectionalLight: () => DirectionalLight,
    FillStyleExtension: () => FillStyleExtension,
    FirstPersonController: () => FirstPersonController,
    FirstPersonView: () => FirstPersonView,
    FirstPersonViewport: () => FirstPersonViewport,
    FlyToInterpolator: () => FlyToInterpolator,
    Fp64Extension: () => Fp64Extension,
    GPUGridLayer: () => GPUGridLayer,
    GeoJsonLayer: () => GeoJsonLayer,
    GeohashLayer: () => GeohashLayer,
    GoogleMapsOverlay: () => GoogleMapsOverlay,
    GreatCircleLayer: () => GreatCircleLayer,
    GridCellLayer: () => GridCellLayer,
    GridLayer: () => GridLayer,
    H3ClusterLayer: () => H3ClusterLayer,
    H3HexagonLayer: () => H3HexagonLayer,
    HeatmapLayer: () => HeatmapLayer,
    HexagonLayer: () => HexagonLayer,
    IconLayer: () => IconLayer,
    Layer: () => Layer,
    LayerExtension: () => LayerExtension,
    LayerManager: () => LayerManager,
    LightingEffect: () => LightingEffect,
    LineLayer: () => LineLayer,
    LinearInterpolator: () => LinearInterpolator,
    MVTLayer: () => MVTLayer,
    MapController: () => MapController,
    MapView: () => MapView,
    MapboxLayer: () => MapboxLayer,
    MapboxOverlay: () => MapboxOverlay,
    MaskExtension: () => MaskExtension,
    OPERATION: () => OPERATION,
    OrbitController: () => OrbitController,
    OrbitView: () => OrbitView,
    OrbitViewport: () => OrbitViewport,
    OrthographicController: () => OrthographicController,
    OrthographicView: () => OrthographicView,
    OrthographicViewport: () => OrthographicViewport,
    PathLayer: () => PathLayer,
    PathStyleExtension: () => PathStyleExtension,
    PointCloudLayer: () => PointCloudLayer,
    PointLight: () => PointLight,
    PolygonLayer: () => PolygonLayer,
    PostProcessEffect: () => PostProcessEffect,
    QuadkeyLayer: () => QuadkeyLayer,
    S2Layer: () => S2Layer,
    ScatterplotLayer: () => ScatterplotLayer,
    ScenegraphLayer: () => ScenegraphLayer,
    ScreenGridLayer: () => ScreenGridLayer,
    SimpleMeshLayer: () => SimpleMeshLayer,
    SolidPolygonLayer: () => SolidPolygonLayer,
    TRANSITION_EVENTS: () => TRANSITION_EVENTS,
    TerrainLayer: () => TerrainLayer,
    Tesselator: () => Tesselator,
    TextLayer: () => TextLayer,
    Tile3DLayer: () => Tile3DLayer,
    TileLayer: () => TileLayer,
    TransitionInterpolator: () => TransitionInterpolator,
    TripsLayer: () => TripsLayer,
    UNIT: () => UNIT,
    VERSION: () => VERSION6,
    View: () => View,
    Viewport: () => Viewport,
    WebMercatorViewport: () => WebMercatorViewport2,
    _AggregationLayer: () => AggregationLayer,
    _BinSorter: () => BinSorter,
    _CPUAggregator: () => CPUAggregator,
    _CameraLight: () => CameraLight,
    _GPUGridAggregator: () => GPUGridAggregator,
    _GeoCellLayer: () => GeoCellLayer,
    _GlobeController: () => GlobeController,
    _GlobeView: () => GlobeView,
    _GlobeViewport: () => GlobeViewport,
    _LayersPass: () => LayersPass,
    _MultiIconLayer: () => MultiIconLayer,
    _PickLayersPass: () => PickLayersPass,
    _SunLight: () => SunLight,
    _TerrainExtension: () => TerrainExtension,
    _TextBackgroundLayer: () => TextBackgroundLayer,
    _Tile2DHeader: () => Tile2DHeader,
    _Tileset2D: () => Tileset2D,
    _WMSLayer: () => WMSLayer,
    _compareProps: () => compareProps,
    _count: () => count,
    _deepEqual: () => deepEqual,
    _fillArray: () => fillArray2,
    _flatten: () => flatten,
    _getURLFromTemplate: () => getURLFromTemplate,
    _memoize: () => memoize,
    _mergeShaders: () => mergeShaders,
    _registerLoggers: () => register,
    assert: () => assert11,
    createIterable: () => createIterable,
    fp64LowPart: () => fp64LowPart2,
    gouraudLighting: () => gouraudLighting,
    log: () => log_default,
    phongLighting: () => phongLighting,
    picking: () => picking_default,
    project: () => project_default,
    project32: () => project32_default,
    project64: () => project64_default,
    shadow: () => shadow_default
  });

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js
  function assert2(condition, message) {
    if (!condition) {
      throw new Error(message || "loader assertion failed.");
    }
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js
  var globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_ = globals.self || globals.window || globals.global || {};
  var window_ = globals.window || globals.self || globals.global || {};
  var global_ = globals.global || globals.self || globals.window || {};
  var document_ = globals.document || {};
  var isBrowser = Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser);
  var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion = matches && parseFloat(matches[1]) || 0;

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/option-utils/merge-loader-options.js
  function mergeLoaderOptions(baseOptions, newOptions) {
    const options = {
      ...baseOptions
    };
    for (const [key, newValue] of Object.entries(newOptions)) {
      if (newValue && typeof newValue === "object") {
        options[key] = options[key] || {};
        Object.assign(options[key], newOptions[key]);
      } else {
        options[key] = newOptions[key];
      }
    }
    return options;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js
  var VERSION = true ? "3.4.2" : DEFAULT_VERSION;
  if (false) {
    console.error("loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.");
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js
  function assert3(condition, message) {
    if (!condition) {
      throw new Error(message || "loaders.gl assertion failed.");
    }
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js
  var globals2 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_2 = globals2.self || globals2.window || globals2.global || {};
  var window_2 = globals2.window || globals2.self || globals2.global || {};
  var global_2 = globals2.global || globals2.self || globals2.window || {};
  var document_2 = globals2.document || {};
  var isBrowser2 = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
  var isWorker = typeof importScripts === "function";
  var isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
  var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

  // ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js
  var WorkerJob = class {
    constructor(jobName, workerThread) {
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "workerThread", void 0);
      _defineProperty(this, "isRunning", true);
      _defineProperty(this, "result", void 0);
      _defineProperty(this, "_resolve", () => {
      });
      _defineProperty(this, "_reject", () => {
      });
      this.name = jobName;
      this.workerThread = workerThread;
      this.result = new Promise((resolve2, reject) => {
        this._resolve = resolve2;
        this._reject = reject;
      });
    }
    postMessage(type, payload) {
      this.workerThread.postMessage({
        source: "loaders.gl",
        type,
        payload
      });
    }
    done(value) {
      assert3(this.isRunning);
      this.isRunning = false;
      this._resolve(value);
    }
    error(error2) {
      assert3(this.isRunning);
      this.isRunning = false;
      this._reject(error2);
    }
  };

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js
  var Worker2 = class {
    terminate() {
    }
  };

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js
  var workerURLCache = /* @__PURE__ */ new Map();
  function getLoadableWorkerURL(props) {
    assert3(props.source && !props.url || !props.source && props.url);
    let workerURL = workerURLCache.get(props.source || props.url);
    if (!workerURL) {
      if (props.url) {
        workerURL = getLoadableWorkerURLFromURL(props.url);
        workerURLCache.set(props.url, workerURL);
      }
      if (props.source) {
        workerURL = getLoadableWorkerURLFromSource(props.source);
        workerURLCache.set(props.source, workerURL);
      }
    }
    assert3(workerURL);
    return workerURL;
  }
  function getLoadableWorkerURLFromURL(url) {
    if (!url.startsWith("http")) {
      return url;
    }
    const workerSource = buildScriptSource(url);
    return getLoadableWorkerURLFromSource(workerSource);
  }
  function getLoadableWorkerURLFromSource(workerSource) {
    const blob = new Blob([workerSource], {
      type: "application/javascript"
    });
    return URL.createObjectURL(blob);
  }
  function buildScriptSource(workerUrl) {
    return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js
  function getTransferList(object) {
    let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let transfers = arguments.length > 2 ? arguments[2] : void 0;
    const transfersSet = transfers || /* @__PURE__ */ new Set();
    if (!object) {
    } else if (isTransferable(object)) {
      transfersSet.add(object);
    } else if (isTransferable(object.buffer)) {
      transfersSet.add(object.buffer);
    } else if (ArrayBuffer.isView(object)) {
    } else if (recursive && typeof object === "object") {
      for (const key in object) {
        getTransferList(object[key], recursive, transfersSet);
      }
    }
    return transfers === void 0 ? Array.from(transfersSet) : [];
  }
  function isTransferable(object) {
    if (!object) {
      return false;
    }
    if (object instanceof ArrayBuffer) {
      return true;
    }
    if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
      return true;
    }
    if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
      return true;
    }
    if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
      return true;
    }
    return false;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js
  var NOOP = () => {
  };
  var WorkerThread = class {
    static isSupported() {
      return typeof Worker !== "undefined" && isBrowser2 || typeof Worker2 !== "undefined" && !isBrowser2;
    }
    constructor(props) {
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "source", void 0);
      _defineProperty(this, "url", void 0);
      _defineProperty(this, "terminated", false);
      _defineProperty(this, "worker", void 0);
      _defineProperty(this, "onMessage", void 0);
      _defineProperty(this, "onError", void 0);
      _defineProperty(this, "_loadableURL", "");
      const {
        name: name10,
        source,
        url
      } = props;
      assert3(source || url);
      this.name = name10;
      this.source = source;
      this.url = url;
      this.onMessage = NOOP;
      this.onError = (error2) => console.log(error2);
      this.worker = isBrowser2 ? this._createBrowserWorker() : this._createNodeWorker();
    }
    destroy() {
      this.onMessage = NOOP;
      this.onError = NOOP;
      this.worker.terminate();
      this.terminated = true;
    }
    get isRunning() {
      return Boolean(this.onMessage);
    }
    postMessage(data, transferList) {
      transferList = transferList || getTransferList(data);
      this.worker.postMessage(data, transferList);
    }
    _getErrorFromErrorEvent(event) {
      let message = "Failed to load ";
      message += "worker ".concat(this.name, " from ").concat(this.url, ". ");
      if (event.message) {
        message += "".concat(event.message, " in ");
      }
      if (event.lineno) {
        message += ":".concat(event.lineno, ":").concat(event.colno);
      }
      return new Error(message);
    }
    _createBrowserWorker() {
      this._loadableURL = getLoadableWorkerURL({
        source: this.source,
        url: this.url
      });
      const worker = new Worker(this._loadableURL, {
        name: this.name
      });
      worker.onmessage = (event) => {
        if (!event.data) {
          this.onError(new Error("No data received"));
        } else {
          this.onMessage(event.data);
        }
      };
      worker.onerror = (error2) => {
        this.onError(this._getErrorFromErrorEvent(error2));
        this.terminated = true;
      };
      worker.onmessageerror = (event) => console.error(event);
      return worker;
    }
    _createNodeWorker() {
      let worker;
      if (this.url) {
        const absolute = this.url.includes(":/") || this.url.startsWith("/");
        const url = absolute ? this.url : "./".concat(this.url);
        worker = new Worker2(url, {
          eval: false
        });
      } else if (this.source) {
        worker = new Worker2(this.source, {
          eval: true
        });
      } else {
        throw new Error("no worker");
      }
      worker.on("message", (data) => {
        this.onMessage(data);
      });
      worker.on("error", (error2) => {
        this.onError(error2);
      });
      worker.on("exit", (code) => {
      });
      return worker;
    }
  };

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js
  var WorkerPool = class {
    static isSupported() {
      return WorkerThread.isSupported();
    }
    constructor(props) {
      _defineProperty(this, "name", "unnamed");
      _defineProperty(this, "source", void 0);
      _defineProperty(this, "url", void 0);
      _defineProperty(this, "maxConcurrency", 1);
      _defineProperty(this, "maxMobileConcurrency", 1);
      _defineProperty(this, "onDebug", () => {
      });
      _defineProperty(this, "reuseWorkers", true);
      _defineProperty(this, "props", {});
      _defineProperty(this, "jobQueue", []);
      _defineProperty(this, "idleQueue", []);
      _defineProperty(this, "count", 0);
      _defineProperty(this, "isDestroyed", false);
      this.source = props.source;
      this.url = props.url;
      this.setProps(props);
    }
    destroy() {
      this.idleQueue.forEach((worker) => worker.destroy());
      this.isDestroyed = true;
    }
    setProps(props) {
      this.props = {
        ...this.props,
        ...props
      };
      if (props.name !== void 0) {
        this.name = props.name;
      }
      if (props.maxConcurrency !== void 0) {
        this.maxConcurrency = props.maxConcurrency;
      }
      if (props.maxMobileConcurrency !== void 0) {
        this.maxMobileConcurrency = props.maxMobileConcurrency;
      }
      if (props.reuseWorkers !== void 0) {
        this.reuseWorkers = props.reuseWorkers;
      }
      if (props.onDebug !== void 0) {
        this.onDebug = props.onDebug;
      }
    }
    async startJob(name10) {
      let onMessage2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (job, type, data) => job.done(data);
      let onError = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (job, error2) => job.error(error2);
      const startPromise = new Promise((onStart) => {
        this.jobQueue.push({
          name: name10,
          onMessage: onMessage2,
          onError,
          onStart
        });
        return this;
      });
      this._startQueuedJob();
      return await startPromise;
    }
    async _startQueuedJob() {
      if (!this.jobQueue.length) {
        return;
      }
      const workerThread = this._getAvailableWorker();
      if (!workerThread) {
        return;
      }
      const queuedJob = this.jobQueue.shift();
      if (queuedJob) {
        this.onDebug({
          message: "Starting job",
          name: queuedJob.name,
          workerThread,
          backlog: this.jobQueue.length
        });
        const job = new WorkerJob(queuedJob.name, workerThread);
        workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
        workerThread.onError = (error2) => queuedJob.onError(job, error2);
        queuedJob.onStart(job);
        try {
          await job.result;
        } finally {
          this.returnWorkerToQueue(workerThread);
        }
      }
    }
    returnWorkerToQueue(worker) {
      const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
      if (shouldDestroyWorker) {
        worker.destroy();
        this.count--;
      } else {
        this.idleQueue.push(worker);
      }
      if (!this.isDestroyed) {
        this._startQueuedJob();
      }
    }
    _getAvailableWorker() {
      if (this.idleQueue.length > 0) {
        return this.idleQueue.shift() || null;
      }
      if (this.count < this._getMaxConcurrency()) {
        this.count++;
        const name10 = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
        return new WorkerThread({
          name: name10,
          source: this.source,
          url: this.url
        });
      }
      return null;
    }
    _getMaxConcurrency() {
      return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
    }
  };

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js
  var DEFAULT_PROPS = {
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: true,
    onDebug: () => {
    }
  };
  var WorkerFarm = class {
    static isSupported() {
      return WorkerThread.isSupported();
    }
    static getWorkerFarm() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
      WorkerFarm._workerFarm.setProps(props);
      return WorkerFarm._workerFarm;
    }
    constructor(props) {
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "workerPools", /* @__PURE__ */ new Map());
      this.props = {
        ...DEFAULT_PROPS
      };
      this.setProps(props);
      this.workerPools = /* @__PURE__ */ new Map();
    }
    destroy() {
      for (const workerPool of this.workerPools.values()) {
        workerPool.destroy();
      }
      this.workerPools = /* @__PURE__ */ new Map();
    }
    setProps(props) {
      this.props = {
        ...this.props,
        ...props
      };
      for (const workerPool of this.workerPools.values()) {
        workerPool.setProps(this._getWorkerPoolProps());
      }
    }
    getWorkerPool(options) {
      const {
        name: name10,
        source,
        url
      } = options;
      let workerPool = this.workerPools.get(name10);
      if (!workerPool) {
        workerPool = new WorkerPool({
          name: name10,
          source,
          url
        });
        workerPool.setProps(this._getWorkerPoolProps());
        this.workerPools.set(name10, workerPool);
      }
      return workerPool;
    }
    _getWorkerPoolProps() {
      return {
        maxConcurrency: this.props.maxConcurrency,
        maxMobileConcurrency: this.props.maxMobileConcurrency,
        reuseWorkers: this.props.reuseWorkers,
        onDebug: this.props.onDebug
      };
    }
  };
  _defineProperty(WorkerFarm, "_workerFarm", void 0);

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js
  var NPM_TAG = "latest";
  function getWorkerURL(worker) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const workerOptions = options[worker.id] || {};
    const workerFile = "".concat(worker.id, "-worker.js");
    let url = workerOptions.workerUrl;
    if (!url && worker.id === "compression") {
      url = options.workerUrl;
    }
    if (options._workerType === "test") {
      url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
    }
    if (!url) {
      let version = worker.version;
      if (version === "latest") {
        version = NPM_TAG;
      }
      const versionTag = version ? "@".concat(version) : "";
      url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
    }
    assert3(url);
    return url;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js
  function validateWorkerVersion(worker) {
    let coreVersion = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : VERSION;
    assert3(worker, "no worker provided");
    const workerVersion = worker.version;
    if (!coreVersion || !workerVersion) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js
  var node = __toESM(require_require_utils());
  var VERSION2 = true ? "3.4.2" : LATEST;
  var loadLibraryPromises = {};
  async function loadLibrary(libraryUrl) {
    let moduleName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (moduleName) {
      libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
    }
    loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
    return await loadLibraryPromises[libraryUrl];
  }
  function getLibraryUrl(library, moduleName, options) {
    if (library.startsWith("http")) {
      return library;
    }
    const modules = options.modules || {};
    if (modules[library]) {
      return modules[library];
    }
    if (!isBrowser2) {
      return "modules/".concat(moduleName, "/dist/libs/").concat(library);
    }
    if (options.CDN) {
      assert3(options.CDN.startsWith("http"));
      return "".concat(options.CDN, "/").concat(moduleName, "@").concat(VERSION2, "/dist/libs/").concat(library);
    }
    if (isWorker) {
      return "../src/libs/".concat(library);
    }
    return "modules/".concat(moduleName, "/src/libs/").concat(library);
  }
  async function loadLibraryFromFile(libraryUrl) {
    if (libraryUrl.endsWith("wasm")) {
      const response2 = await fetch(libraryUrl);
      return await response2.arrayBuffer();
    }
    if (!isBrowser2) {
      try {
        return node && node.requireFromFile && await node.requireFromFile(libraryUrl);
      } catch {
        return null;
      }
    }
    if (isWorker) {
      return importScripts(libraryUrl);
    }
    const response = await fetch(libraryUrl);
    const scriptSource = await response.text();
    return loadLibraryFromString(scriptSource, libraryUrl);
  }
  function loadLibraryFromString(scriptSource, id) {
    if (!isBrowser2) {
      return node.requireFromString && node.requireFromString(scriptSource, id);
    }
    if (isWorker) {
      eval.call(global_2, scriptSource);
      return null;
    }
    const script = document.createElement("script");
    script.id = id;
    try {
      script.appendChild(document.createTextNode(scriptSource));
    } catch (e2) {
      script.text = scriptSource;
    }
    document.body.appendChild(script);
    return null;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js
  function canParseWithWorker(loader, options) {
    if (!WorkerFarm.isSupported()) {
      return false;
    }
    if (!isBrowser2 && !(options !== null && options !== void 0 && options._nodeWorkers)) {
      return false;
    }
    return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
  }
  async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
    const name10 = loader.id;
    const url = getWorkerURL(loader, options);
    const workerFarm = WorkerFarm.getWorkerFarm(options);
    const workerPool = workerFarm.getWorkerPool({
      name: name10,
      url
    });
    options = JSON.parse(JSON.stringify(options));
    context = JSON.parse(JSON.stringify(context || {}));
    const job = await workerPool.startJob("process-on-worker", onMessage.bind(null, parseOnMainThread));
    job.postMessage("process", {
      input: data,
      options,
      context
    });
    const result = await job.result;
    return await result.result;
  }
  async function onMessage(parseOnMainThread, job, type, payload) {
    switch (type) {
      case "done":
        job.done(payload);
        break;
      case "error":
        job.error(new Error(payload.error));
        break;
      case "process":
        const {
          id,
          input,
          options
        } = payload;
        try {
          const result = await parseOnMainThread(input, options);
          job.postMessage("done", {
            id,
            result
          });
        } catch (error2) {
          const message = error2 instanceof Error ? error2.message : "unknown error";
          job.postMessage("error", {
            id,
            error: message
          });
        }
        break;
      default:
        console.warn("parse-with-worker unknown message ".concat(type));
    }
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js
  function getFirstCharacters(data) {
    let length7 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
    if (typeof data === "string") {
      return data.slice(0, length7);
    } else if (ArrayBuffer.isView(data)) {
      return getMagicString(data.buffer, data.byteOffset, length7);
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      return getMagicString(data, byteOffset, length7);
    }
    return "";
  }
  function getMagicString(arrayBuffer2, byteOffset, length7) {
    if (arrayBuffer2.byteLength <= byteOffset + length7) {
      return "";
    }
    const dataView = new DataView(arrayBuffer2);
    let magic = "";
    for (let i3 = 0; i3 < length7; i3++) {
      magic += String.fromCharCode(dataView.getUint8(byteOffset + i3));
    }
    return magic;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js
  function parseJSON(string) {
    try {
      return JSON.parse(string);
    } catch (_) {
      throw new Error('Failed to parse JSON from data starting with "'.concat(getFirstCharacters(string), '"'));
    }
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js
  function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
    byteLength = byteLength || arrayBuffer1.byteLength;
    if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
      return false;
    }
    const array12 = new Uint8Array(arrayBuffer1);
    const array2 = new Uint8Array(arrayBuffer2);
    for (let i3 = 0; i3 < array12.length; ++i3) {
      if (array12[i3] !== array2[i3]) {
        return false;
      }
    }
    return true;
  }
  function concatenateArrayBuffers() {
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
    const byteLength = sourceArrays.reduce((length7, typedArray) => length7 + typedArray.byteLength, 0);
    const result = new Uint8Array(byteLength);
    let offset = 0;
    for (const sourceArray of sourceArrays) {
      result.set(sourceArray, offset);
      offset += sourceArray.byteLength;
    }
    return result.buffer;
  }
  function concatenateTypedArrays() {
    for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      typedArrays[_key2] = arguments[_key2];
    }
    const arrays = typedArrays;
    const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;
    if (!TypedArrayConstructor) {
      throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
    }
    const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);
    const result = new TypedArrayConstructor(sumLength);
    let offset = 0;
    for (const array of arrays) {
      result.set(array, offset);
      offset += array.length;
    }
    return result;
  }
  function sliceArrayBuffer(arrayBuffer2, byteOffset, byteLength) {
    const subArray = byteLength !== void 0 ? new Uint8Array(arrayBuffer2).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer2).subarray(byteOffset);
    const arrayCopy = new Uint8Array(subArray);
    return arrayCopy.buffer;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js
  function padToNBytes(byteLength, padding) {
    assert2(byteLength >= 0);
    assert2(padding > 0);
    return byteLength + (padding - 1) & ~(padding - 1);
  }
  function copyToArray(source, target, targetOffset) {
    let sourceArray;
    if (source instanceof ArrayBuffer) {
      sourceArray = new Uint8Array(source);
    } else {
      const srcByteOffset = source.byteOffset;
      const srcByteLength = source.byteLength;
      sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
    }
    target.set(sourceArray, targetOffset);
    return targetOffset + padToNBytes(sourceArray.byteLength, 4);
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js
  async function concatenateArrayBuffersAsync(asyncIterator) {
    const arrayBuffers = [];
    for await (const chunk of asyncIterator) {
      arrayBuffers.push(chunk);
    }
    return concatenateArrayBuffers(...arrayBuffers);
  }

  // ../../node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) {
      timestamp = window.performance.now();
    } else if (typeof process !== "undefined" && process.hrtime) {
      const timeParts = process.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/lib/stat.js
  var Stat = class {
    constructor(name10, type) {
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "sampleSize", 1);
      _defineProperty(this, "time", 0);
      _defineProperty(this, "count", 0);
      _defineProperty(this, "samples", 0);
      _defineProperty(this, "lastTiming", 0);
      _defineProperty(this, "lastSampleTime", 0);
      _defineProperty(this, "lastSampleCount", 0);
      _defineProperty(this, "_count", 0);
      _defineProperty(this, "_time", 0);
      _defineProperty(this, "_samples", 0);
      _defineProperty(this, "_startTime", 0);
      _defineProperty(this, "_timerPending", false);
      this.name = name10;
      this.type = type;
      this.reset();
    }
    reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
    setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
    incrementCount() {
      this.addCount(1);
      return this;
    }
    decrementCount() {
      this.subtractCount(1);
      return this;
    }
    addCount(value) {
      this._count += value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    subtractCount(value) {
      this._count -= value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;
      this._checkSampling();
      return this;
    }
    timeStart() {
      this._startTime = getHiResTimestamp();
      this._timerPending = true;
      return this;
    }
    timeEnd() {
      if (!this._timerPending) {
        return this;
      }
      this.addTime(getHiResTimestamp() - this._startTime);
      this._timerPending = false;
      this._checkSampling();
      return this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  };

  // ../../node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/lib/stats.js
  var Stats = class {
    constructor(options) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "stats", {});
      this.id = options.id;
      this.stats = {};
      this._initializeStats(options.stats);
      Object.seal(this);
    }
    get(name10) {
      let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
      return this._getOrCreate({
        name: name10,
        type
      });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    reset() {
      for (const stat of Object.values(this.stats)) {
        stat.reset();
      }
      return this;
    }
    forEach(fn) {
      for (const stat of Object.values(this.stats)) {
        fn(stat);
      }
    }
    getTable() {
      const table = {};
      this.forEach((stat) => {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
    _initializeStats() {
      let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      stats.forEach((stat) => this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
      const {
        name: name10,
        type
      } = stat;
      let result = this.stats[name10];
      if (!result) {
        if (stat instanceof Stat) {
          result = stat;
        } else {
          result = new Stat(name10, type);
        }
        this.stats[name10] = result;
      }
      return result;
    }
  };

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js
  var STAT_QUEUED_REQUESTS = "Queued Requests";
  var STAT_ACTIVE_REQUESTS = "Active Requests";
  var STAT_CANCELLED_REQUESTS = "Cancelled Requests";
  var STAT_QUEUED_REQUESTS_EVER = "Queued Requests Ever";
  var STAT_ACTIVE_REQUESTS_EVER = "Active Requests Ever";
  var DEFAULT_PROPS2 = {
    id: "request-scheduler",
    throttleRequests: true,
    maxRequests: 6
  };
  var RequestScheduler = class {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "stats", void 0);
      _defineProperty(this, "activeRequestCount", 0);
      _defineProperty(this, "requestQueue", []);
      _defineProperty(this, "requestMap", /* @__PURE__ */ new Map());
      _defineProperty(this, "deferredUpdate", null);
      this.props = {
        ...DEFAULT_PROPS2,
        ...props
      };
      this.stats = new Stats({
        id: this.props.id
      });
      this.stats.get(STAT_QUEUED_REQUESTS);
      this.stats.get(STAT_ACTIVE_REQUESTS);
      this.stats.get(STAT_CANCELLED_REQUESTS);
      this.stats.get(STAT_QUEUED_REQUESTS_EVER);
      this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
    }
    scheduleRequest(handle) {
      let getPriority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;
      if (!this.props.throttleRequests) {
        return Promise.resolve({
          done: () => {
          }
        });
      }
      if (this.requestMap.has(handle)) {
        return this.requestMap.get(handle);
      }
      const request = {
        handle,
        priority: 0,
        getPriority
      };
      const promise = new Promise((resolve2) => {
        request.resolve = resolve2;
        return request;
      });
      this.requestQueue.push(request);
      this.requestMap.set(handle, promise);
      this._issueNewRequests();
      return promise;
    }
    _issueRequest(request) {
      const {
        handle,
        resolve: resolve2
      } = request;
      let isDone = false;
      const done = () => {
        if (!isDone) {
          isDone = true;
          this.requestMap.delete(handle);
          this.activeRequestCount--;
          this._issueNewRequests();
        }
      };
      this.activeRequestCount++;
      return resolve2 ? resolve2({
        done
      }) : Promise.resolve({
        done
      });
    }
    _issueNewRequests() {
      if (!this.deferredUpdate) {
        this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);
      }
    }
    _issueNewRequestsAsync() {
      this.deferredUpdate = null;
      const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
      if (freeSlots === 0) {
        return;
      }
      this._updateAllRequests();
      for (let i3 = 0; i3 < freeSlots; ++i3) {
        const request = this.requestQueue.shift();
        if (request) {
          this._issueRequest(request);
        }
      }
    }
    _updateAllRequests() {
      const requestQueue = this.requestQueue;
      for (let i3 = 0; i3 < requestQueue.length; ++i3) {
        const request = requestQueue[i3];
        if (!this._updateRequest(request)) {
          requestQueue.splice(i3, 1);
          this.requestMap.delete(request.handle);
          i3--;
        }
      }
      requestQueue.sort((a2, b) => a2.priority - b.priority);
    }
    _updateRequest(request) {
      request.priority = request.getPriority(request.handle);
      if (request.priority < 0) {
        request.resolve(null);
        return false;
      }
      return true;
    }
  };

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js
  var pathPrefix = "";
  var fileAliases = {};
  function resolvePath(filename2) {
    for (const alias in fileAliases) {
      if (filename2.startsWith(alias)) {
        const replacement = fileAliases[alias];
        filename2 = filename2.replace(alias, replacement);
      }
    }
    if (!filename2.startsWith("http://") && !filename2.startsWith("https://")) {
      filename2 = "".concat(pathPrefix).concat(filename2);
    }
    return filename2;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer.browser.js
  function toArrayBuffer(buffer) {
    return buffer;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-conversion-utils.js
  function isBuffer(value) {
    return value && typeof value === "object" && value.isBuffer;
  }
  function toArrayBuffer2(data) {
    if (isBuffer(data)) {
      return toArrayBuffer(data);
    }
    if (data instanceof ArrayBuffer) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
        return data.buffer;
      }
      return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
    }
    if (typeof data === "string") {
      const text = data;
      const uint8Array = new TextEncoder().encode(text);
      return uint8Array.buffer;
    }
    if (data && typeof data === "object" && data._toArrayBuffer) {
      return data._toArrayBuffer();
    }
    throw new Error("toArrayBuffer");
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
  var path_exports = {};
  __export(path_exports, {
    dirname: () => dirname,
    filename: () => filename,
    join: () => join,
    resolve: () => resolve
  });

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/get-cwd.js
  function getCWD() {
    var _window$location;
    if (typeof process !== "undefined" && typeof process.cwd !== "undefined") {
      return process.cwd();
    }
    const pathname = (_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.pathname;
    return (pathname === null || pathname === void 0 ? void 0 : pathname.slice(0, pathname.lastIndexOf("/") + 1)) || "";
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
  function filename(url) {
    const slashIndex = url ? url.lastIndexOf("/") : -1;
    return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
  }
  function dirname(url) {
    const slashIndex = url ? url.lastIndexOf("/") : -1;
    return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
  }
  function join() {
    for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
      parts[_key] = arguments[_key];
    }
    const separator = "/";
    parts = parts.map((part, index) => {
      if (index) {
        part = part.replace(new RegExp("^".concat(separator)), "");
      }
      if (index !== parts.length - 1) {
        part = part.replace(new RegExp("".concat(separator, "$")), "");
      }
      return part;
    });
    return parts.join(separator);
  }
  function resolve() {
    const paths = [];
    for (let _i = 0; _i < arguments.length; _i++) {
      paths[_i] = _i < 0 || arguments.length <= _i ? void 0 : arguments[_i];
    }
    let resolvedPath = "";
    let resolvedAbsolute = false;
    let cwd;
    for (let i3 = paths.length - 1; i3 >= -1 && !resolvedAbsolute; i3--) {
      let path;
      if (i3 >= 0) {
        path = paths[i3];
      } else {
        if (cwd === void 0) {
          cwd = getCWD();
        }
        path = cwd;
      }
      if (path.length === 0) {
        continue;
      }
      resolvedPath = "".concat(path, "/").concat(resolvedPath);
      resolvedAbsolute = path.charCodeAt(0) === SLASH;
    }
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
      return "/".concat(resolvedPath);
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    }
    return ".";
  }
  var SLASH = 47;
  var DOT = 46;
  function normalizeStringPosix(path, allowAboveRoot) {
    let res = "";
    let lastSlash = -1;
    let dots = 0;
    let code;
    let isAboveRoot = false;
    for (let i3 = 0; i3 <= path.length; ++i3) {
      if (i3 < path.length) {
        code = path.charCodeAt(i3);
      } else if (code === SLASH) {
        break;
      } else {
        code = SLASH;
      }
      if (code === SLASH) {
        if (lastSlash === i3 - 1 || dots === 1) {
        } else if (lastSlash !== i3 - 1 && dots === 2) {
          if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
            if (res.length > 2) {
              const start = res.length - 1;
              let j = start;
              for (; j >= 0; --j) {
                if (res.charCodeAt(j) === SLASH) {
                  break;
                }
              }
              if (j !== start) {
                res = j === -1 ? "" : res.slice(0, j);
                lastSlash = i3;
                dots = 0;
                isAboveRoot = false;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSlash = i3;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            isAboveRoot = true;
          }
        } else {
          const slice = path.slice(lastSlash + 1, i3);
          if (res.length > 0) {
            res += "/".concat(slice);
          } else {
            res = slice;
          }
          isAboveRoot = false;
        }
        lastSlash = i3;
        dots = 0;
      } else if (code === DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js
  var isBoolean = (x2) => typeof x2 === "boolean";
  var isFunction = (x2) => typeof x2 === "function";
  var isObject = (x2) => x2 !== null && typeof x2 === "object";
  var isPureObject = (x2) => isObject(x2) && x2.constructor === {}.constructor;
  var isIterable = (x2) => x2 && typeof x2[Symbol.iterator] === "function";
  var isAsyncIterable = (x2) => x2 && typeof x2[Symbol.asyncIterator] === "function";
  var isResponse = (x2) => typeof Response !== "undefined" && x2 instanceof Response || x2 && x2.arrayBuffer && x2.text && x2.json;
  var isBlob = (x2) => typeof Blob !== "undefined" && x2 instanceof Blob;
  var isBuffer2 = (x2) => x2 && typeof x2 === "object" && x2.isBuffer;
  var isReadableDOMStream = (x2) => typeof ReadableStream !== "undefined" && x2 instanceof ReadableStream || isObject(x2) && isFunction(x2.tee) && isFunction(x2.cancel) && isFunction(x2.getReader);
  var isReadableNodeStream = (x2) => isObject(x2) && isFunction(x2.read) && isFunction(x2.pipe) && isBoolean(x2.readable);
  var isReadableStream = (x2) => isReadableDOMStream(x2) || isReadableNodeStream(x2);

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js
  var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
  var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
  function parseMIMEType(mimeString) {
    const matches3 = MIME_TYPE_PATTERN.exec(mimeString);
    if (matches3) {
      return matches3[1];
    }
    return mimeString;
  }
  function parseMIMETypeFromURL(url) {
    const matches3 = DATA_URL_PATTERN.exec(url);
    if (matches3) {
      return matches3[1];
    }
    return "";
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/utils/url-utils.js
  var QUERY_STRING_PATTERN = /\?.*/;
  function extractQueryString(url) {
    const matches3 = url.match(QUERY_STRING_PATTERN);
    return matches3 && matches3[0];
  }
  function stripQueryString(url) {
    return url.replace(QUERY_STRING_PATTERN, "");
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js
  function getResourceUrl(resource) {
    if (isResponse(resource)) {
      const response = resource;
      return response.url;
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.name || "";
    }
    if (typeof resource === "string") {
      return resource;
    }
    return "";
  }
  function getResourceMIMEType(resource) {
    if (isResponse(resource)) {
      const response = resource;
      const contentTypeHeader = response.headers.get("content-type") || "";
      const noQueryUrl = stripQueryString(response.url);
      return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.type || "";
    }
    if (typeof resource === "string") {
      return parseMIMETypeFromURL(resource);
    }
    return "";
  }
  function getResourceContentLength(resource) {
    if (isResponse(resource)) {
      const response = resource;
      return response.headers["content-length"] || -1;
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.size;
    }
    if (typeof resource === "string") {
      return resource.length;
    }
    if (resource instanceof ArrayBuffer) {
      return resource.byteLength;
    }
    if (ArrayBuffer.isView(resource)) {
      return resource.byteLength;
    }
    return -1;
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js
  async function makeResponse(resource) {
    if (isResponse(resource)) {
      return resource;
    }
    const headers = {};
    const contentLength = getResourceContentLength(resource);
    if (contentLength >= 0) {
      headers["content-length"] = String(contentLength);
    }
    const url = getResourceUrl(resource);
    const type = getResourceMIMEType(resource);
    if (type) {
      headers["content-type"] = type;
    }
    const initialDataUrl = await getInitialDataUrl(resource);
    if (initialDataUrl) {
      headers["x-first-bytes"] = initialDataUrl;
    }
    if (typeof resource === "string") {
      resource = new TextEncoder().encode(resource);
    }
    const response = new Response(resource, {
      headers
    });
    Object.defineProperty(response, "url", {
      value: url
    });
    return response;
  }
  async function checkResponse(response) {
    if (!response.ok) {
      const message = await getResponseError(response);
      throw new Error(message);
    }
  }
  async function getResponseError(response) {
    let message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
    try {
      const contentType = response.headers.get("Content-Type");
      let text = response.statusText;
      if (contentType.includes("application/json")) {
        text += " ".concat(await response.text());
      }
      message += text;
      message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
    } catch (error2) {
    }
    return message;
  }
  async function getInitialDataUrl(resource) {
    const INITIAL_DATA_LENGTH = 5;
    if (typeof resource === "string") {
      return "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH));
    }
    if (resource instanceof Blob) {
      const blobSlice = resource.slice(0, 5);
      return await new Promise((resolve2) => {
        const reader = new FileReader();
        reader.onload = (event) => {
          var _event$target;
          return resolve2(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
        };
        reader.readAsDataURL(blobSlice);
      });
    }
    if (resource instanceof ArrayBuffer) {
      const slice = resource.slice(0, INITIAL_DATA_LENGTH);
      const base64 = arrayBufferToBase64(slice);
      return "data:base64,".concat(base64);
    }
    return null;
  }
  function arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    for (let i3 = 0; i3 < bytes.byteLength; i3++) {
      binary += String.fromCharCode(bytes[i3]);
    }
    return btoa(binary);
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js
  async function fetchFile(url, options) {
    if (typeof url === "string") {
      url = resolvePath(url);
      let fetchOptions = options;
      if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== "function") {
        fetchOptions = options.fetch;
      }
      return await fetch(url, fetchOptions);
    }
    return await makeResponse(url);
  }

  // ../../node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions["electron"])) {
      return true;
    }
    const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    const userAgent2 = mockUserAgent || realUserAgent;
    if (userAgent2 && userAgent2.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }

  // ../../node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-browser.js
  function isBrowser3() {
    const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
    return !isNode || isElectron();
  }

  // ../../node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/globals.js
  var self_3 = globalThis.self || globalThis.window || globalThis.global;
  var window_3 = globalThis.window || globalThis.self || globalThis.global;
  var document_3 = globalThis.document || {};
  var process_ = globalThis.process || {};
  var console_ = globalThis.console;
  var navigator_ = globalThis.navigator || {};

  // ../../node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/utils/globals.js
  var VERSION3 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
  var isBrowser4 = isBrowser3();

  // ../../node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/local-storage.js
  function getStorage(type) {
    try {
      const storage = window[type];
      const x2 = "__storage_test__";
      storage.setItem(x2, x2);
      storage.removeItem(x2);
      return storage;
    } catch (e2) {
      return null;
    }
  }
  var LocalStorage = class {
    constructor(id, defaultConfig) {
      let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
      _defineProperty(this, "storage", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "config", void 0);
      this.storage = getStorage(type);
      this.id = id;
      this.config = defaultConfig;
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
    }
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // ../../node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/formatters.js
  function formatTime(ms) {
    let formatted;
    if (ms < 10) {
      formatted = "".concat(ms.toFixed(2), "ms");
    } else if (ms < 100) {
      formatted = "".concat(ms.toFixed(1), "ms");
    } else if (ms < 1e3) {
      formatted = "".concat(ms.toFixed(0), "ms");
    } else {
      formatted = "".concat((ms / 1e3).toFixed(2), "s");
    }
    return formatted;
  }
  function leftPad(string) {
    let length7 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
    const padLength = Math.max(length7 - string.length, 0);
    return "".concat(" ".repeat(padLength)).concat(string);
  }
  function formatImage(image, message, scale8) {
    let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
    const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) {
      scale8 = Math.min(scale8, maxWidth / image.width);
    }
    const width = image.width * scale8;
    const height = image.height * scale8;
    const style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
    return ["".concat(message, " %c+"), style];
  }

  // ../../node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/color.js
  var COLOR;
  (function(COLOR3) {
    COLOR3[COLOR3["BLACK"] = 30] = "BLACK";
    COLOR3[COLOR3["RED"] = 31] = "RED";
    COLOR3[COLOR3["GREEN"] = 32] = "GREEN";
    COLOR3[COLOR3["YELLOW"] = 33] = "YELLOW";
    COLOR3[COLOR3["BLUE"] = 34] = "BLUE";
    COLOR3[COLOR3["MAGENTA"] = 35] = "MAGENTA";
    COLOR3[COLOR3["CYAN"] = 36] = "CYAN";
    COLOR3[COLOR3["WHITE"] = 37] = "WHITE";
    COLOR3[COLOR3["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR3[COLOR3["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR3[COLOR3["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR3[COLOR3["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR3[COLOR3["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR3[COLOR3["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR3[COLOR3["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR3[COLOR3["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR || (COLOR = {}));
  var BACKGROUND_INCREMENT = 10;
  function getColor(color) {
    if (typeof color !== "string") {
      return color;
    }
    color = color.toUpperCase();
    return COLOR[color] || COLOR.WHITE;
  }
  function addColor(string, color, background) {
    if (!isBrowser3 && typeof string === "string") {
      if (color) {
        const colorCode = getColor(color);
        string = "\x1B[".concat(colorCode, "m").concat(string, "\x1B[39m");
      }
      if (background) {
        const colorCode = getColor(background);
        string = "\x1B[".concat(colorCode + BACKGROUND_INCREMENT, "m").concat(string, "\x1B[49m");
      }
    }
    return string;
  }

  // ../../node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/autobind.js
  function autobind(obj) {
    let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    const object = obj;
    for (const key of propNames) {
      const value = object[key];
      if (typeof value === "function") {
        if (!predefined.find((name10) => key === name10)) {
          object[key] = value.bind(obj);
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/assert.js
  function assert4(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }

  // ../../node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp2() {
    let timestamp;
    if (isBrowser3() && window_3.performance) {
      var _window$performance, _window$performance$n;
      timestamp = window_3 === null || window_3 === void 0 ? void 0 : (_window$performance = window_3.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
    } else if ("hrtime" in process_) {
      var _process$hrtime;
      const timeParts = process_ === null || process_ === void 0 ? void 0 : (_process$hrtime = process_.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_);
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/log.js
  var originalConsole = {
    debug: isBrowser3() ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_LOG_CONFIGURATION = {
    enabled: true,
    level: 0
  };
  function noop() {
  }
  var cache = {};
  var ONCE = {
    once: true
  };
  var Log = class {
    constructor() {
      let {
        id
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        id: ""
      };
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "VERSION", VERSION3);
      _defineProperty(this, "_startTs", getHiResTimestamp2());
      _defineProperty(this, "_deltaTs", getHiResTimestamp2());
      _defineProperty(this, "_storage", void 0);
      _defineProperty(this, "userData", {});
      _defineProperty(this, "LOG_THROTTLE_TIMEOUT", 0);
      this.id = id;
      this.userData = {};
      this._storage = new LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_LOG_CONFIGURATION);
      this.timeStamp("".concat(this.id, " started"));
      autobind(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((getHiResTimestamp2() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((getHiResTimestamp2() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
      this.level = newPriority;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this._storage.setConfiguration({
        enabled
      });
      return this;
    }
    setLevel(level) {
      this._storage.setConfiguration({
        level
      });
      return this;
    }
    get(setting) {
      return this._storage.config[setting];
    }
    set(setting, value) {
      this._storage.setConfiguration({
        [setting]: value
      });
    }
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    assert(condition, message) {
      assert4(condition, message);
    }
    warn(message) {
      return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
    error(message) {
      return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
    removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
    probe(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
    info(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
          tag: getTableHeader(table)
        });
      }
      return noop;
    }
    image(_ref) {
      let {
        logLevel,
        priority,
        image,
        message = "",
        scale: scale8 = 1
      } = _ref;
      if (!this._shouldLog(logLevel || priority)) {
        return noop;
      }
      return isBrowser3() ? logImageInBrowser({
        image,
        message,
        scale: scale8
      }) : logImageInNode({
        image,
        message,
        scale: scale8
      });
    }
    time(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
    group(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        collapsed: false
      };
      const options = normalizeArguments({
        logLevel,
        message,
        opts
      });
      const {
        collapsed
      } = opts;
      options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.group(logLevel, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop);
    }
    withGroup(logLevel, message, func) {
      this.group(logLevel, message)();
      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments({
          logLevel,
          message,
          args,
          opts
        });
        method = method || opts.method;
        assert4(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp2();
        const tag = opts.tag || opts.message;
        if (opts.once && tag) {
          if (!cache[tag]) {
            cache[tag] = getHiResTimestamp2();
          } else {
            return noop;
          }
        }
        message = decorateMessage(this.id, opts.message, opts);
        return method.bind(console, message, ...opts.args);
      }
      return noop;
    }
  };
  _defineProperty(Log, "VERSION", VERSION3);
  function normalizeLogLevel(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert4(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments(opts) {
    const {
      logLevel,
      message
    } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message !== void 0) {
          args.unshift(message);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert4(messageType === "string" || messageType === "object");
    return Object.assign(opts, {
      args
    }, opts.opts);
  }
  function decorateMessage(id, message, opts) {
    if (typeof message === "string") {
      const time = opts.time ? leftPad(formatTime(opts.total)) : "";
      message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
      message = addColor(message, opts.color, opts.background);
    }
    return message;
  }
  function logImageInNode(_ref2) {
    let {
      image,
      message = "",
      scale: scale8 = 1
    } = _ref2;
    console.warn("removed");
    return noop;
  }
  function logImageInBrowser(_ref3) {
    let {
      image,
      message = "",
      scale: scale8 = 1
    } = _ref3;
    if (typeof image === "string") {
      const img = new Image();
      img.onload = () => {
        const args = formatImage(img, message, scale8);
        console.log(...args);
      };
      img.src = image;
      return noop;
    }
    const element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
      console.log(...formatImage(image, message, scale8));
      return noop;
    }
    if (element.toLowerCase() === "canvas") {
      const img = new Image();
      img.onload = () => console.log(...formatImage(img, message, scale8));
      img.src = image.toDataURL();
      return noop;
    }
    return noop;
  }
  function getTableHeader(table) {
    for (const key in table) {
      for (const title in table[key]) {
        return title || "untitled";
      }
    }
    return "empty";
  }

  // ../../node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/index.js
  var dist_default = new Log({
    id: "@probe.gl/log"
  });

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js
  var probeLog = new Log({
    id: "loaders.gl"
  });
  var NullLog = class {
    log() {
      return () => {
      };
    }
    info() {
      return () => {
      };
    }
    warn() {
      return () => {
      };
    }
    error() {
      return () => {
      };
    }
  };
  var ConsoleLog = class {
    constructor() {
      _defineProperty(this, "console", void 0);
      this.console = console;
    }
    log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.console.log.bind(this.console, ...args);
    }
    info() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.console.info.bind(this.console, ...args);
    }
    warn() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.console.warn.bind(this.console, ...args);
    }
    error() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.console.error.bind(this.console, ...args);
    }
  };

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js
  var DEFAULT_LOADER_OPTIONS = {
    fetch: null,
    mimeType: void 0,
    nothrow: false,
    log: new ConsoleLog(),
    CDN: "https://unpkg.com/@loaders.gl",
    worker: true,
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: isBrowser,
    _nodeWorkers: false,
    _workerType: "",
    limit: 0,
    _limitMB: 0,
    batchSize: "auto",
    batchDebounceMs: 0,
    metadata: false,
    transforms: []
  };
  var REMOVED_LOADER_OPTIONS = {
    throws: "nothrow",
    dataType: "(no longer used)",
    uri: "baseUri",
    method: "fetch.method",
    headers: "fetch.headers",
    body: "fetch.body",
    mode: "fetch.mode",
    credentials: "fetch.credentials",
    cache: "fetch.cache",
    redirect: "fetch.redirect",
    referrer: "fetch.referrer",
    referrerPolicy: "fetch.referrerPolicy",
    integrity: "fetch.integrity",
    keepalive: "fetch.keepalive",
    signal: "fetch.signal"
  };

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js
  function getGlobalLoaderState() {
    globalThis.loaders = globalThis.loaders || {};
    const {
      loaders
    } = globalThis;
    loaders._state = loaders._state || {};
    return loaders._state;
  }
  var getGlobalLoaderOptions = () => {
    const state = getGlobalLoaderState();
    state.globalOptions = state.globalOptions || {
      ...DEFAULT_LOADER_OPTIONS
    };
    return state.globalOptions;
  };
  function normalizeOptions(options, loader, loaders, url) {
    loaders = loaders || [];
    loaders = Array.isArray(loaders) ? loaders : [loaders];
    validateOptions(options, loaders);
    return normalizeOptionsInternal(loader, options, url);
  }
  function validateOptions(options, loaders) {
    validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
    for (const loader of loaders) {
      const idOptions = options && options[loader.id] || {};
      const loaderOptions = loader.options && loader.options[loader.id] || {};
      const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
      validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
    }
  }
  function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
    const loaderName = id || "Top level";
    const prefix = id ? "".concat(id, ".") : "";
    for (const key in options) {
      const isSubOptions = !id && isObject(options[key]);
      const isBaseUriOption = key === "baseUri" && !id;
      const isWorkerUrlOption = key === "workerUrl" && id;
      if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
        if (key in deprecatedOptions) {
          probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' no longer supported, use '").concat(deprecatedOptions[key], "'"))();
        } else if (!isSubOptions) {
          const suggestion = findSimilarOption(key, loaders);
          probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' not recognized. ").concat(suggestion))();
        }
      }
    }
  }
  function findSimilarOption(optionKey, loaders) {
    const lowerCaseOptionKey = optionKey.toLowerCase();
    let bestSuggestion = "";
    for (const loader of loaders) {
      for (const key in loader.options) {
        if (optionKey === key) {
          return "Did you mean '".concat(loader.id, ".").concat(key, "'?");
        }
        const lowerCaseKey = key.toLowerCase();
        const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
        if (isPartialMatch) {
          bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(key, "'?");
        }
      }
    }
    return bestSuggestion;
  }
  function normalizeOptionsInternal(loader, options, url) {
    const loaderDefaultOptions = loader.options || {};
    const mergedOptions = {
      ...loaderDefaultOptions
    };
    addUrlOptions(mergedOptions, url);
    if (mergedOptions.log === null) {
      mergedOptions.log = new NullLog();
    }
    mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
    mergeNestedFields(mergedOptions, options);
    return mergedOptions;
  }
  function mergeNestedFields(mergedOptions, options) {
    for (const key in options) {
      if (key in options) {
        const value = options[key];
        if (isPureObject(value) && isPureObject(mergedOptions[key])) {
          mergedOptions[key] = {
            ...mergedOptions[key],
            ...options[key]
          };
        } else {
          mergedOptions[key] = options[key];
        }
      }
    }
  }
  function addUrlOptions(options, url) {
    if (url && !("baseUri" in options)) {
      options.baseUri = url;
    }
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js
  function isLoaderObject(loader) {
    var _loader;
    if (!loader) {
      return false;
    }
    if (Array.isArray(loader)) {
      loader = loader[0];
    }
    const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
    return hasExtensions;
  }
  function normalizeLoader(loader) {
    var _loader2, _loader3;
    assert2(loader, "null loader");
    assert2(isLoaderObject(loader), "invalid loader");
    let options;
    if (Array.isArray(loader)) {
      options = loader[1];
      loader = loader[0];
      loader = {
        ...loader,
        options: {
          ...loader.options,
          ...options
        }
      };
    }
    if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
      loader.text = true;
    }
    if (!loader.text) {
      loader.binary = true;
    }
    return loader;
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js
  var getGlobalLoaderRegistry = () => {
    const state = getGlobalLoaderState();
    state.loaderRegistry = state.loaderRegistry || [];
    return state.loaderRegistry;
  };
  function registerLoaders(loaders) {
    const loaderRegistry = getGlobalLoaderRegistry();
    loaders = Array.isArray(loaders) ? loaders : [loaders];
    for (const loader of loaders) {
      const normalizedLoader = normalizeLoader(loader);
      if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) {
        loaderRegistry.unshift(normalizedLoader);
      }
    }
  }
  function getRegisteredLoaders() {
    return getGlobalLoaderRegistry();
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js
  var log = new Log({
    id: "loaders.gl"
  });

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js
  var EXT_PATTERN = /\.([^.]+)$/;
  async function selectLoader(data) {
    let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let options = arguments.length > 2 ? arguments[2] : void 0;
    let context = arguments.length > 3 ? arguments[3] : void 0;
    if (!validHTTPResponse(data)) {
      return null;
    }
    let loader = selectLoaderSync(data, loaders, {
      ...options,
      nothrow: true
    }, context);
    if (loader) {
      return loader;
    }
    if (isBlob(data)) {
      data = await data.slice(0, 10).arrayBuffer();
      loader = selectLoaderSync(data, loaders, options, context);
    }
    if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
      throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
  }
  function selectLoaderSync(data) {
    let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let options = arguments.length > 2 ? arguments[2] : void 0;
    let context = arguments.length > 3 ? arguments[3] : void 0;
    if (!validHTTPResponse(data)) {
      return null;
    }
    if (loaders && !Array.isArray(loaders)) {
      return normalizeLoader(loaders);
    }
    let candidateLoaders = [];
    if (loaders) {
      candidateLoaders = candidateLoaders.concat(loaders);
    }
    if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
      candidateLoaders.push(...getRegisteredLoaders());
    }
    normalizeLoaders(candidateLoaders);
    const loader = selectLoaderInternal(data, candidateLoaders, options, context);
    if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
      throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
  }
  function selectLoaderInternal(data, loaders, options, context) {
    const url = getResourceUrl(data);
    const type = getResourceMIMEType(data);
    const testUrl = stripQueryString(url) || (context === null || context === void 0 ? void 0 : context.url);
    let loader = null;
    let reason = "";
    if (options !== null && options !== void 0 && options.mimeType) {
      loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
      reason = "match forced by supplied MIME type ".concat(options === null || options === void 0 ? void 0 : options.mimeType);
    }
    loader = loader || findLoaderByUrl(loaders, testUrl);
    reason = reason || (loader ? "matched url ".concat(testUrl) : "");
    loader = loader || findLoaderByMIMEType(loaders, type);
    reason = reason || (loader ? "matched MIME type ".concat(type) : "");
    loader = loader || findLoaderByInitialBytes(loaders, data);
    reason = reason || (loader ? "matched initial data ".concat(getFirstCharacters2(data)) : "");
    loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
    reason = reason || (loader ? "matched fallback MIME type ".concat(type) : "");
    if (reason) {
      var _loader;
      log.log(1, "selectLoader selected ".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, ": ").concat(reason, "."));
    }
    return loader;
  }
  function validHTTPResponse(data) {
    if (data instanceof Response) {
      if (data.status === 204) {
        return false;
      }
    }
    return true;
  }
  function getNoValidLoaderMessage(data) {
    const url = getResourceUrl(data);
    const type = getResourceMIMEType(data);
    let message = "No valid loader found (";
    message += url ? "".concat(path_exports.filename(url), ", ") : "no url provided, ";
    message += "MIME type: ".concat(type ? '"'.concat(type, '"') : "not provided", ", ");
    const firstCharacters = data ? getFirstCharacters2(data) : "";
    message += firstCharacters ? ' first bytes: "'.concat(firstCharacters, '"') : "first bytes: not available";
    message += ")";
    return message;
  }
  function normalizeLoaders(loaders) {
    for (const loader of loaders) {
      normalizeLoader(loader);
    }
  }
  function findLoaderByUrl(loaders, url) {
    const match = url && EXT_PATTERN.exec(url);
    const extension = match && match[1];
    return extension ? findLoaderByExtension(loaders, extension) : null;
  }
  function findLoaderByExtension(loaders, extension) {
    extension = extension.toLowerCase();
    for (const loader of loaders) {
      for (const loaderExtension of loader.extensions) {
        if (loaderExtension.toLowerCase() === extension) {
          return loader;
        }
      }
    }
    return null;
  }
  function findLoaderByMIMEType(loaders, mimeType) {
    for (const loader of loaders) {
      if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
        return loader;
      }
      if (mimeType === "application/x.".concat(loader.id)) {
        return loader;
      }
    }
    return null;
  }
  function findLoaderByInitialBytes(loaders, data) {
    if (!data) {
      return null;
    }
    for (const loader of loaders) {
      if (typeof data === "string") {
        if (testDataAgainstText(data, loader)) {
          return loader;
        }
      } else if (ArrayBuffer.isView(data)) {
        if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
          return loader;
        }
      } else if (data instanceof ArrayBuffer) {
        const byteOffset = 0;
        if (testDataAgainstBinary(data, byteOffset, loader)) {
          return loader;
        }
      }
    }
    return null;
  }
  function testDataAgainstText(data, loader) {
    if (loader.testText) {
      return loader.testText(data);
    }
    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
    return tests.some((test) => data.startsWith(test));
  }
  function testDataAgainstBinary(data, byteOffset, loader) {
    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
    return tests.some((test) => testBinary(data, byteOffset, loader, test));
  }
  function testBinary(data, byteOffset, loader, test) {
    if (test instanceof ArrayBuffer) {
      return compareArrayBuffers(test, data, test.byteLength);
    }
    switch (typeof test) {
      case "function":
        return test(data, loader);
      case "string":
        const magic = getMagicString2(data, byteOffset, test.length);
        return test === magic;
      default:
        return false;
    }
  }
  function getFirstCharacters2(data) {
    let length7 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
    if (typeof data === "string") {
      return data.slice(0, length7);
    } else if (ArrayBuffer.isView(data)) {
      return getMagicString2(data.buffer, data.byteOffset, length7);
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      return getMagicString2(data, byteOffset, length7);
    }
    return "";
  }
  function getMagicString2(arrayBuffer2, byteOffset, length7) {
    if (arrayBuffer2.byteLength < byteOffset + length7) {
      return "";
    }
    const dataView = new DataView(arrayBuffer2);
    let magic = "";
    for (let i3 = 0; i3 < length7; i3++) {
      magic += String.fromCharCode(dataView.getUint8(byteOffset + i3));
    }
    return magic;
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js
  var DEFAULT_CHUNK_SIZE = 256 * 1024;
  function* makeStringIterator(string, options) {
    const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
    let offset = 0;
    const textEncoder = new TextEncoder();
    while (offset < string.length) {
      const chunkLength = Math.min(string.length - offset, chunkSize);
      const chunk = string.slice(offset, offset + chunkLength);
      offset += chunkLength;
      yield textEncoder.encode(chunk);
    }
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js
  var DEFAULT_CHUNK_SIZE2 = 256 * 1024;
  function makeArrayBufferIterator(arrayBuffer2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      const {
        chunkSize = DEFAULT_CHUNK_SIZE2
      } = options;
      let byteOffset = 0;
      while (byteOffset < arrayBuffer2.byteLength) {
        const chunkByteLength = Math.min(arrayBuffer2.byteLength - byteOffset, chunkSize);
        const chunk = new ArrayBuffer(chunkByteLength);
        const sourceArray = new Uint8Array(arrayBuffer2, byteOffset, chunkByteLength);
        const chunkArray = new Uint8Array(chunk);
        chunkArray.set(sourceArray);
        byteOffset += chunkByteLength;
        yield chunk;
      }
    }();
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js
  var DEFAULT_CHUNK_SIZE3 = 1024 * 1024;
  async function* makeBlobIterator(blob, options) {
    const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE3;
    let offset = 0;
    while (offset < blob.size) {
      const end = offset + chunkSize;
      const chunk = await blob.slice(offset, end).arrayBuffer();
      offset = end;
      yield chunk;
    }
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js
  function makeStreamIterator(stream, options) {
    return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
  }
  async function* makeBrowserStreamIterator(stream, options) {
    const reader = stream.getReader();
    let nextBatchPromise;
    try {
      while (true) {
        const currentBatchPromise = nextBatchPromise || reader.read();
        if (options !== null && options !== void 0 && options._streamReadAhead) {
          nextBatchPromise = reader.read();
        }
        const {
          done,
          value
        } = await currentBatchPromise;
        if (done) {
          return;
        }
        yield toArrayBuffer2(value);
      }
    } catch (error2) {
      reader.releaseLock();
    }
  }
  async function* makeNodeStreamIterator(stream, options) {
    for await (const chunk of stream) {
      yield toArrayBuffer2(chunk);
    }
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js
  function makeIterator(data, options) {
    if (typeof data === "string") {
      return makeStringIterator(data, options);
    }
    if (data instanceof ArrayBuffer) {
      return makeArrayBufferIterator(data, options);
    }
    if (isBlob(data)) {
      return makeBlobIterator(data, options);
    }
    if (isReadableStream(data)) {
      return makeStreamIterator(data, options);
    }
    if (isResponse(data)) {
      const response = data;
      return makeStreamIterator(response.body, options);
    }
    throw new Error("makeIterator");
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js
  var ERR_DATA = "Cannot convert supplied data type";
  function getArrayBufferOrStringFromDataSync(data, loader, options) {
    if (loader.text && typeof data === "string") {
      return data;
    }
    if (isBuffer2(data)) {
      data = data.buffer;
    }
    if (data instanceof ArrayBuffer) {
      const arrayBuffer2 = data;
      if (loader.text && !loader.binary) {
        const textDecoder = new TextDecoder("utf8");
        return textDecoder.decode(arrayBuffer2);
      }
      return arrayBuffer2;
    }
    if (ArrayBuffer.isView(data)) {
      if (loader.text && !loader.binary) {
        const textDecoder = new TextDecoder("utf8");
        return textDecoder.decode(data);
      }
      let arrayBuffer2 = data.buffer;
      const byteLength = data.byteLength || data.length;
      if (data.byteOffset !== 0 || byteLength !== arrayBuffer2.byteLength) {
        arrayBuffer2 = arrayBuffer2.slice(data.byteOffset, data.byteOffset + byteLength);
      }
      return arrayBuffer2;
    }
    throw new Error(ERR_DATA);
  }
  async function getArrayBufferOrStringFromData(data, loader, options) {
    const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
    if (typeof data === "string" || isArrayBuffer) {
      return getArrayBufferOrStringFromDataSync(data, loader, options);
    }
    if (isBlob(data)) {
      data = await makeResponse(data);
    }
    if (isResponse(data)) {
      const response = data;
      await checkResponse(response);
      return loader.binary ? await response.arrayBuffer() : await response.text();
    }
    if (isReadableStream(data)) {
      data = makeIterator(data, options);
    }
    if (isIterable(data) || isAsyncIterable(data)) {
      return concatenateArrayBuffersAsync(data);
    }
    throw new Error(ERR_DATA);
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-fetch-function.js
  function getFetchFunction(options, context) {
    const globalOptions = getGlobalLoaderOptions();
    const fetchOptions = options || globalOptions;
    if (typeof fetchOptions.fetch === "function") {
      return fetchOptions.fetch;
    }
    if (isObject(fetchOptions.fetch)) {
      return (url) => fetchFile(url, fetchOptions);
    }
    if (context !== null && context !== void 0 && context.fetch) {
      return context === null || context === void 0 ? void 0 : context.fetch;
    }
    return fetchFile;
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js
  function getLoaderContext(context, options, parentContext) {
    if (parentContext) {
      return parentContext;
    }
    const newContext = {
      fetch: getFetchFunction(options, context),
      ...context
    };
    if (newContext.url) {
      const baseUrl = stripQueryString(newContext.url);
      newContext.baseUrl = baseUrl;
      newContext.queryString = extractQueryString(newContext.url);
      newContext.filename = path_exports.filename(baseUrl);
      newContext.baseUrl = path_exports.dirname(baseUrl);
    }
    if (!Array.isArray(newContext.loaders)) {
      newContext.loaders = null;
    }
    return newContext;
  }
  function getLoadersFromContext(loaders, context) {
    if (!context && loaders && !Array.isArray(loaders)) {
      return loaders;
    }
    let candidateLoaders;
    if (loaders) {
      candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
    }
    if (context && context.loaders) {
      const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
      candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
    }
    return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js
  async function parse(data, loaders, options, context) {
    assert3(!context || typeof context === "object");
    if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
      context = void 0;
      options = loaders;
      loaders = void 0;
    }
    data = await data;
    options = options || {};
    const url = getResourceUrl(data);
    const typedLoaders = loaders;
    const candidateLoaders = getLoadersFromContext(typedLoaders, context);
    const loader = await selectLoader(data, candidateLoaders, options);
    if (!loader) {
      return null;
    }
    options = normalizeOptions(options, loader, candidateLoaders, url);
    context = getLoaderContext({
      url,
      parse,
      loaders: candidateLoaders
    }, options, context || null);
    return await parseWithLoader(loader, data, options, context);
  }
  async function parseWithLoader(loader, data, options, context) {
    validateWorkerVersion(loader);
    if (isResponse(data)) {
      const response = data;
      const {
        ok,
        redirected,
        status,
        statusText,
        type,
        url
      } = response;
      const headers = Object.fromEntries(response.headers.entries());
      context.response = {
        headers,
        ok,
        redirected,
        status,
        statusText,
        type,
        url
      };
    }
    data = await getArrayBufferOrStringFromData(data, loader, options);
    if (loader.parseTextSync && typeof data === "string") {
      options.dataType = "text";
      return loader.parseTextSync(data, options, context, loader);
    }
    if (canParseWithWorker(loader, options)) {
      return await parseWithWorker(loader, data, options, context, parse);
    }
    if (loader.parseText && typeof data === "string") {
      return await loader.parseText(data, options, context, loader);
    }
    if (loader.parse) {
      return await loader.parse(data, options, context, loader);
    }
    assert3(!loader.parseSync);
    throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));
  }

  // ../../node_modules/@loaders.gl/core/dist/esm/lib/api/load.js
  async function load(url, loaders, options, context) {
    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
      context = void 0;
      options = loaders;
      loaders = void 0;
    }
    const fetch2 = getFetchFunction(options);
    let data = url;
    if (typeof url === "string") {
      data = await fetch2(url);
    }
    if (isBlob(url)) {
      data = await fetch2(url);
    }
    return await parse(data, loaders, options);
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js
  var VERSION4 = true ? "3.4.2" : "latest";

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js
  var {
    _parseImageNode
  } = globalThis;
  var IMAGE_SUPPORTED = typeof Image !== "undefined";
  var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
  var NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
  var DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
  function isImageTypeSupported(type) {
    switch (type) {
      case "auto":
        return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
      case "imagebitmap":
        return IMAGE_BITMAP_SUPPORTED;
      case "image":
        return IMAGE_SUPPORTED;
      case "data":
        return DATA_SUPPORTED;
      default:
        throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
    }
  }
  function getDefaultImageType() {
    if (IMAGE_BITMAP_SUPPORTED) {
      return "imagebitmap";
    }
    if (IMAGE_SUPPORTED) {
      return "image";
    }
    if (DATA_SUPPORTED) {
      return "data";
    }
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js
  function getImageType(image) {
    const format = getImageTypeOrNull(image);
    if (!format) {
      throw new Error("Not an image");
    }
    return format;
  }
  function getImageData(image) {
    switch (getImageType(image)) {
      case "data":
        return image;
      case "image":
      case "imagebitmap":
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        if (!context) {
          throw new Error("getImageData");
        }
        canvas.width = image.width;
        canvas.height = image.height;
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, image.width, image.height);
      default:
        throw new Error("getImageData");
    }
  }
  function getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return "imagebitmap";
    }
    if (typeof Image !== "undefined" && image instanceof Image) {
      return "image";
    }
    if (image && typeof image === "object" && image.data && image.width && image.height) {
      return "data";
    }
    return null;
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js
  var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
  var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
  function isSVG(url) {
    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
  }
  function getBlobOrSVGDataUrl(arrayBuffer2, url) {
    if (isSVG(url)) {
      const textDecoder = new TextDecoder();
      let xmlText = textDecoder.decode(arrayBuffer2);
      try {
        if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
          xmlText = unescape(encodeURIComponent(xmlText));
        }
      } catch (error2) {
        throw new Error(error2.message);
      }
      const src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
      return src;
    }
    return getBlob(arrayBuffer2, url);
  }
  function getBlob(arrayBuffer2, url) {
    if (isSVG(url)) {
      throw new Error("SVG cannot be parsed directly to imagebitmap");
    }
    return new Blob([new Uint8Array(arrayBuffer2)]);
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js
  async function parseToImage(arrayBuffer2, options, url) {
    const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer2, url);
    const URL2 = self.URL || self.webkitURL;
    const objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
    try {
      return await loadToImage(objectUrl || blobOrDataUrl, options);
    } finally {
      if (objectUrl) {
        URL2.revokeObjectURL(objectUrl);
      }
    }
  }
  async function loadToImage(url, options) {
    const image = new Image();
    image.src = url;
    if (options.image && options.image.decode && image.decode) {
      await image.decode();
      return image;
    }
    return await new Promise((resolve2, reject) => {
      try {
        image.onload = () => resolve2(image);
        image.onerror = (err) => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
      } catch (error2) {
        reject(error2);
      }
    });
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js
  var EMPTY_OBJECT = {};
  var imagebitmapOptionsSupported = true;
  async function parseToImageBitmap(arrayBuffer2, options, url) {
    let blob;
    if (isSVG(url)) {
      const image = await parseToImage(arrayBuffer2, options, url);
      blob = image;
    } else {
      blob = getBlob(arrayBuffer2, url);
    }
    const imagebitmapOptions = options && options.imagebitmap;
    return await safeCreateImageBitmap(blob, imagebitmapOptions);
  }
  async function safeCreateImageBitmap(blob) {
    let imagebitmapOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
      imagebitmapOptions = null;
    }
    if (imagebitmapOptions) {
      try {
        return await createImageBitmap(blob, imagebitmapOptions);
      } catch (error2) {
        console.warn(error2);
        imagebitmapOptionsSupported = false;
      }
    }
    return await createImageBitmap(blob);
  }
  function isEmptyObject(object) {
    for (const key in object || EMPTY_OBJECT) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/parse-isobmff-binary.js
  function getISOBMFFMediaType(buffer) {
    if (!checkString(buffer, "ftyp", 4)) {
      return null;
    }
    if ((buffer[8] & 96) === 0) {
      return null;
    }
    return decodeMajorBrand(buffer);
  }
  function decodeMajorBrand(buffer) {
    const brandMajor = getUTF8String(buffer, 8, 12).replace("\0", " ").trim();
    switch (brandMajor) {
      case "avif":
      case "avis":
        return {
          extension: "avif",
          mimeType: "image/avif"
        };
      default:
        return null;
    }
  }
  function getUTF8String(array, start, end) {
    return String.fromCharCode(...array.slice(start, end));
  }
  function stringToBytes(string) {
    return [...string].map((character) => character.charCodeAt(0));
  }
  function checkString(buffer, header) {
    let offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const headerBytes = stringToBytes(header);
    for (let i3 = 0; i3 < headerBytes.length; ++i3) {
      if (headerBytes[i3] !== buffer[i3 + offset]) {
        return false;
      }
    }
    return true;
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js
  var BIG_ENDIAN = false;
  var LITTLE_ENDIAN = true;
  function getBinaryImageMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
  }
  function getISOBMFFMetadata(binaryData) {
    const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
    const mediaType = getISOBMFFMediaType(buffer);
    if (!mediaType) {
      return null;
    }
    return {
      mimeType: mediaType.mimeType,
      width: 0,
      height: 0
    };
  }
  function getPngMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
    if (!isPng) {
      return null;
    }
    return {
      mimeType: "image/png",
      width: dataView.getUint32(16, BIG_ENDIAN),
      height: dataView.getUint32(20, BIG_ENDIAN)
    };
  }
  function getGifMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
    if (!isGif) {
      return null;
    }
    return {
      mimeType: "image/gif",
      width: dataView.getUint16(6, LITTLE_ENDIAN),
      height: dataView.getUint16(8, LITTLE_ENDIAN)
    };
  }
  function getBmpMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) {
      return null;
    }
    return {
      mimeType: "image/bmp",
      width: dataView.getUint32(18, LITTLE_ENDIAN),
      height: dataView.getUint32(22, LITTLE_ENDIAN)
    };
  }
  function getJpegMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
    if (!isJpeg) {
      return null;
    }
    const {
      tableMarkers,
      sofMarkers
    } = getJpegMarkers();
    let i3 = 2;
    while (i3 + 9 < dataView.byteLength) {
      const marker2 = dataView.getUint16(i3, BIG_ENDIAN);
      if (sofMarkers.has(marker2)) {
        return {
          mimeType: "image/jpeg",
          height: dataView.getUint16(i3 + 5, BIG_ENDIAN),
          width: dataView.getUint16(i3 + 7, BIG_ENDIAN)
        };
      }
      if (!tableMarkers.has(marker2)) {
        return null;
      }
      i3 += 2;
      i3 += dataView.getUint16(i3, BIG_ENDIAN);
    }
    return null;
  }
  function getJpegMarkers() {
    const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
    for (let i3 = 65504; i3 < 65520; ++i3) {
      tableMarkers.add(i3);
    }
    const sofMarkers = /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502]);
    return {
      tableMarkers,
      sofMarkers
    };
  }
  function toDataView(data) {
    if (data instanceof DataView) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      return new DataView(data.buffer);
    }
    if (data instanceof ArrayBuffer) {
      return new DataView(data);
    }
    throw new Error("toDataView");
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js
  async function parseToNodeImage(arrayBuffer2, options) {
    const {
      mimeType
    } = getBinaryImageMetadata(arrayBuffer2) || {};
    const _parseImageNode2 = globalThis._parseImageNode;
    assert2(_parseImageNode2);
    return await _parseImageNode2(arrayBuffer2, mimeType);
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js
  async function parseImage(arrayBuffer2, options, context) {
    options = options || {};
    const imageOptions = options.image || {};
    const imageType = imageOptions.type || "auto";
    const {
      url
    } = context || {};
    const loadType = getLoadableImageType(imageType);
    let image;
    switch (loadType) {
      case "imagebitmap":
        image = await parseToImageBitmap(arrayBuffer2, options, url);
        break;
      case "image":
        image = await parseToImage(arrayBuffer2, options, url);
        break;
      case "data":
        image = await parseToNodeImage(arrayBuffer2, options);
        break;
      default:
        assert2(false);
    }
    if (imageType === "data") {
      image = getImageData(image);
    }
    return image;
  }
  function getLoadableImageType(type) {
    switch (type) {
      case "auto":
      case "data":
        return getDefaultImageType();
      default:
        isImageTypeSupported(type);
        return type;
    }
  }

  // ../../node_modules/@loaders.gl/images/dist/esm/image-loader.js
  var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"];
  var MIME_TYPES = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"];
  var DEFAULT_IMAGE_LOADER_OPTIONS = {
    image: {
      type: "auto",
      decode: true
    }
  };
  var ImageLoader = {
    id: "image",
    module: "images",
    name: "Images",
    version: VERSION4,
    mimeTypes: MIME_TYPES,
    extensions: EXTENSIONS,
    parse: parseImage,
    tests: [(arrayBuffer2) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer2)))],
    options: DEFAULT_IMAGE_LOADER_OPTIONS
  };

  // ../../node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-format.js
  var mimeTypeSupportedSync = {};
  function isImageFormatSupported(mimeType) {
    if (mimeTypeSupportedSync[mimeType] === void 0) {
      const supported = isBrowser ? checkBrowserImageFormatSupport(mimeType) : checkNodeImageFormatSupport(mimeType);
      mimeTypeSupportedSync[mimeType] = supported;
    }
    return mimeTypeSupportedSync[mimeType];
  }
  function checkNodeImageFormatSupport(mimeType) {
    const NODE_FORMAT_SUPPORT = ["image/png", "image/jpeg", "image/gif"];
    const {
      _parseImageNode: _parseImageNode2,
      _imageFormatsNode = NODE_FORMAT_SUPPORT
    } = globalThis;
    return Boolean(_parseImageNode2) && _imageFormatsNode.includes(mimeType);
  }
  function checkBrowserImageFormatSupport(mimeType) {
    switch (mimeType) {
      case "image/avif":
      case "image/webp":
        return testBrowserImageFormatSupport(mimeType);
      default:
        return true;
    }
  }
  function testBrowserImageFormatSupport(mimeType) {
    try {
      const element = document.createElement("canvas");
      const dataURL = element.toDataURL(mimeType);
      return dataURL.indexOf("data:".concat(mimeType)) === 0;
    } catch {
      return false;
    }
  }

  // ../../node_modules/@probe.gl/env/dist/esm/lib/is-electron.js
  function isElectron2(mockUserAgent) {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions.electron)) {
      return true;
    }
    const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    const userAgent2 = mockUserAgent || realUserAgent;
    if (userAgent2 && userAgent2.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }

  // ../../node_modules/@probe.gl/env/dist/esm/lib/is-browser.js
  function isBrowser5() {
    const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
    return !isNode || isElectron2();
  }

  // ../../node_modules/@probe.gl/env/dist/esm/lib/globals.js
  var globals3 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document,
    process: typeof process === "object" && process
  };
  var self_4 = globals3.self || globals3.window || globals3.global;
  var window_4 = globals3.window || globals3.self || globals3.global;
  var document_4 = globals3.document || {};
  var process_2 = globals3.process || {};

  // ../../node_modules/@probe.gl/env/dist/esm/utils/globals.js
  var VERSION5 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
  var isBrowser6 = isBrowser5();

  // ../../node_modules/@probe.gl/env/dist/esm/lib/get-browser.js
  var window2 = globalThis;
  function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !isBrowser5()) {
      return "Node";
    }
    if (isElectron2(mockUserAgent)) {
      return "Electron";
    }
    const navigator_2 = typeof navigator !== "undefined" ? navigator : {};
    const userAgent2 = mockUserAgent || navigator_2.userAgent || "";
    if (userAgent2.indexOf("Edge") > -1) {
      return "Edge";
    }
    const isMSIE = userAgent2.indexOf("MSIE ") !== -1;
    const isTrident = userAgent2.indexOf("Trident/") !== -1;
    if (isMSIE || isTrident) {
      return "IE";
    }
    if (window2.chrome) {
      return "Chrome";
    }
    if (window2.safari) {
      return "Safari";
    }
    if (window2.mozInnerScreenX) {
      return "Firefox";
    }
    return "Unknown";
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/local-storage.js
  function getStorage2(type) {
    try {
      const storage = window[type];
      const x2 = "__storage_test__";
      storage.setItem(x2, x2);
      storage.removeItem(x2);
      return storage;
    } catch (e2) {
      return null;
    }
  }
  var LocalStorage2 = class {
    constructor(id) {
      let defaultSettings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
      _defineProperty(this, "storage", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "config", {});
      this.storage = getStorage2(type);
      this.id = id;
      this.config = {};
      Object.assign(this.config, defaultSettings);
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      this.config = {};
      return this.updateConfiguration(configuration);
    }
    updateConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
      return this;
    }
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // ../../node_modules/@probe.gl/log/dist/esm/utils/formatters.js
  function formatTime2(ms) {
    let formatted;
    if (ms < 10) {
      formatted = "".concat(ms.toFixed(2), "ms");
    } else if (ms < 100) {
      formatted = "".concat(ms.toFixed(1), "ms");
    } else if (ms < 1e3) {
      formatted = "".concat(ms.toFixed(0), "ms");
    } else {
      formatted = "".concat((ms / 1e3).toFixed(2), "s");
    }
    return formatted;
  }
  function leftPad2(string) {
    let length7 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
    const padLength = Math.max(length7 - string.length, 0);
    return "".concat(" ".repeat(padLength)).concat(string);
  }
  function formatImage2(image, message, scale8) {
    let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
    const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) {
      scale8 = Math.min(scale8, maxWidth / image.width);
    }
    const width = image.width * scale8;
    const height = image.height * scale8;
    const style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
    return ["".concat(message, " %c+"), style];
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/color.js
  var COLOR2;
  (function(COLOR3) {
    COLOR3[COLOR3["BLACK"] = 30] = "BLACK";
    COLOR3[COLOR3["RED"] = 31] = "RED";
    COLOR3[COLOR3["GREEN"] = 32] = "GREEN";
    COLOR3[COLOR3["YELLOW"] = 33] = "YELLOW";
    COLOR3[COLOR3["BLUE"] = 34] = "BLUE";
    COLOR3[COLOR3["MAGENTA"] = 35] = "MAGENTA";
    COLOR3[COLOR3["CYAN"] = 36] = "CYAN";
    COLOR3[COLOR3["WHITE"] = 37] = "WHITE";
    COLOR3[COLOR3["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR3[COLOR3["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR3[COLOR3["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR3[COLOR3["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR3[COLOR3["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR3[COLOR3["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR3[COLOR3["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR3[COLOR3["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR2 || (COLOR2 = {}));
  function getColor2(color) {
    return typeof color === "string" ? COLOR2[color.toUpperCase()] || COLOR2.WHITE : color;
  }
  function addColor2(string, color, background) {
    if (!isBrowser5 && typeof string === "string") {
      if (color) {
        color = getColor2(color);
        string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
      }
      if (background) {
        color = getColor2(background);
        string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
      }
    }
    return string;
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/autobind.js
  function autobind2(obj) {
    let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    for (const key of propNames) {
      if (typeof obj[key] === "function") {
        if (!predefined.find((name10) => key === name10)) {
          obj[key] = obj[key].bind(obj);
        }
      }
    }
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/assert.js
  function assert5(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }

  // ../../node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js
  function getHiResTimestamp3() {
    let timestamp;
    if (isBrowser5 && "performance" in window_4) {
      var _window$performance, _window$performance$n;
      timestamp = window_4 === null || window_4 === void 0 ? void 0 : (_window$performance = window_4.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
    } else if ("hrtime" in process_2) {
      var _process$hrtime;
      const timeParts = process_2 === null || process_2 === void 0 ? void 0 : (_process$hrtime = process_2.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_2);
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/log/dist/esm/log.js
  var originalConsole2 = {
    debug: isBrowser5 ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_SETTINGS = {
    enabled: true,
    level: 0
  };
  function noop2() {
  }
  var cache2 = {};
  var ONCE2 = {
    once: true
  };
  var Log2 = class {
    constructor() {
      let {
        id
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        id: ""
      };
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "VERSION", VERSION5);
      _defineProperty(this, "_startTs", getHiResTimestamp3());
      _defineProperty(this, "_deltaTs", getHiResTimestamp3());
      _defineProperty(this, "_storage", void 0);
      _defineProperty(this, "userData", {});
      _defineProperty(this, "LOG_THROTTLE_TIMEOUT", 0);
      this.id = id;
      this._storage = new LocalStorage2("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
      this.userData = {};
      this.timeStamp("".concat(this.id, " started"));
      autobind2(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((getHiResTimestamp3() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((getHiResTimestamp3() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
      this.level = newPriority;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this._storage.updateConfiguration({
        enabled
      });
      return this;
    }
    setLevel(level) {
      this._storage.updateConfiguration({
        level
      });
      return this;
    }
    get(setting) {
      return this._storage.config[setting];
    }
    set(setting, value) {
      this._storage.updateConfiguration({
        [setting]: value
      });
    }
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    assert(condition, message) {
      assert5(condition, message);
    }
    warn(message) {
      return this._getLogFunction(0, message, originalConsole2.warn, arguments, ONCE2);
    }
    error(message) {
      return this._getLogFunction(0, message, originalConsole2.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
    removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
    probe(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole2.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole2.debug, arguments);
    }
    info(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return this._getLogFunction(logLevel, message, originalConsole2.debug || originalConsole2.info, arguments, ONCE2);
    }
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop2, columns && [columns], {
          tag: getTableHeader2(table)
        });
      }
      return noop2;
    }
    image(_ref) {
      let {
        logLevel,
        priority,
        image,
        message = "",
        scale: scale8 = 1
      } = _ref;
      if (!this._shouldLog(logLevel || priority)) {
        return noop2;
      }
      return isBrowser5 ? logImageInBrowser2({
        image,
        message,
        scale: scale8
      }) : logImageInNode2({
        image,
        message,
        scale: scale8
      });
    }
    time(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeStamp || noop2);
    }
    group(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        collapsed: false
      };
      const options = normalizeArguments2({
        logLevel,
        message,
        opts
      });
      const {
        collapsed
      } = opts;
      options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.group(logLevel, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop2);
    }
    withGroup(logLevel, message, func) {
      this.group(logLevel, message)();
      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel2(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments2({
          logLevel,
          message,
          args,
          opts
        });
        method = method || opts.method;
        assert5(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp3();
        const tag = opts.tag || opts.message;
        if (opts.once) {
          if (!cache2[tag]) {
            cache2[tag] = getHiResTimestamp3();
          } else {
            return noop2;
          }
        }
        message = decorateMessage2(this.id, opts.message, opts);
        return method.bind(console, message, ...opts.args);
      }
      return noop2;
    }
  };
  _defineProperty(Log2, "VERSION", VERSION5);
  function normalizeLogLevel2(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert5(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments2(opts) {
    const {
      logLevel,
      message
    } = opts;
    opts.logLevel = normalizeLogLevel2(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message !== void 0) {
          args.unshift(message);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert5(messageType === "string" || messageType === "object");
    return Object.assign(opts, {
      args
    }, opts.opts);
  }
  function decorateMessage2(id, message, opts) {
    if (typeof message === "string") {
      const time = opts.time ? leftPad2(formatTime2(opts.total)) : "";
      message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
      message = addColor2(message, opts.color, opts.background);
    }
    return message;
  }
  function logImageInNode2(_ref2) {
    let {
      image,
      message = "",
      scale: scale8 = 1
    } = _ref2;
    let asciify = null;
    try {
      asciify = module.require("asciify-image");
    } catch (error2) {
    }
    if (asciify) {
      return () => asciify(image, {
        fit: "box",
        width: "".concat(Math.round(80 * scale8), "%")
      }).then((data) => console.log(data));
    }
    return noop2;
  }
  function logImageInBrowser2(_ref3) {
    let {
      image,
      message = "",
      scale: scale8 = 1
    } = _ref3;
    if (typeof image === "string") {
      const img = new Image();
      img.onload = () => {
        const args = formatImage2(img, message, scale8);
        console.log(...args);
      };
      img.src = image;
      return noop2;
    }
    const element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
      console.log(...formatImage2(image, message, scale8));
      return noop2;
    }
    if (element.toLowerCase() === "canvas") {
      const img = new Image();
      img.onload = () => console.log(...formatImage2(img, message, scale8));
      img.src = image.toDataURL();
      return noop2;
    }
    return noop2;
  }
  function getTableHeader2(table) {
    for (const key in table) {
      for (const title in table[key]) {
        return title || "untitled";
      }
    }
    return "empty";
  }

  // ../../node_modules/@probe.gl/log/dist/esm/index.js
  var esm_default = new Log2({
    id: "@probe.gl/log"
  });

  // ../core/src/utils/log.ts
  var log_default = new Log2({
    id: "deck"
  });

  // ../core/src/debug/loggers.ts
  var logState = {
    attributeUpdateStart: -1,
    attributeManagerUpdateStart: -1,
    attributeUpdateMessages: []
  };
  var LOG_LEVEL_MAJOR_UPDATE = 1;
  var LOG_LEVEL_MINOR_UPDATE = 2;
  var LOG_LEVEL_UPDATE_DETAIL = 3;
  var LOG_LEVEL_INFO = 4;
  var LOG_LEVEL_DRAW = 2;
  var getLoggers = (log4) => ({
    "layer.changeFlag": (layer, key, flags) => {
      log4.log(LOG_LEVEL_UPDATE_DETAIL, `${layer.id} ${key}: `, flags[key])();
    },
    "layer.initialize": (layer) => {
      log4.log(LOG_LEVEL_MAJOR_UPDATE, `Initializing ${layer}`)();
    },
    "layer.update": (layer, needsUpdate) => {
      if (needsUpdate) {
        const flags = layer.getChangeFlags();
        log4.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layer} because: ${Object.keys(flags).filter((key) => flags[key]).join(", ")}`)();
      } else {
        log4.log(LOG_LEVEL_INFO, `${layer} does not need update`)();
      }
    },
    "layer.matched": (layer, changed) => {
      if (changed) {
        log4.log(LOG_LEVEL_INFO, `Matched ${layer}, state transfered`)();
      }
    },
    "layer.finalize": (layer) => {
      log4.log(LOG_LEVEL_MAJOR_UPDATE, `Finalizing ${layer}`)();
    },
    "compositeLayer.renderLayers": (layer, updated, subLayers) => {
      if (updated) {
        log4.log(LOG_LEVEL_MINOR_UPDATE, `Composite layer rendered new subLayers ${layer}`, subLayers)();
      } else {
        log4.log(LOG_LEVEL_INFO, `Composite layer reused subLayers ${layer}`, subLayers)();
      }
    },
    "layerManager.setLayers": (layerManager, updated, layers) => {
      if (updated) {
        log4.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layers.length} deck layers`)();
      }
    },
    "layerManager.activateViewport": (layerManager, viewport) => {
      log4.log(LOG_LEVEL_UPDATE_DETAIL, "Viewport changed", viewport)();
    },
    "attributeManager.invalidate": (attributeManager, trigger, attributeNames) => {
      log4.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? `invalidated attributes ${attributeNames} (${trigger}) for ${attributeManager.id}` : `invalidated all attributes for ${attributeManager.id}`)();
    },
    "attributeManager.updateStart": (attributeManager) => {
      logState.attributeUpdateMessages.length = 0;
      logState.attributeManagerUpdateStart = Date.now();
    },
    "attributeManager.updateEnd": (attributeManager, numInstances) => {
      const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
      log4.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, `Updated attributes for ${numInstances} instances in ${attributeManager.id} in ${timeMs}ms`)();
      for (const updateMessage of logState.attributeUpdateMessages) {
        log4.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
      }
      log4.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
    },
    "attribute.updateStart": (attribute) => {
      logState.attributeUpdateStart = Date.now();
    },
    "attribute.allocate": (attribute, numInstances) => {
      const message = `${attribute.id} allocated ${numInstances}`;
      logState.attributeUpdateMessages.push(message);
    },
    "attribute.updateEnd": (attribute, numInstances) => {
      const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
      const message = `${attribute.id} updated ${numInstances} in ${timeMs}ms`;
      logState.attributeUpdateMessages.push(message);
    },
    "deckRenderer.renderLayers": (deckRenderer, renderStats, opts) => {
      const {
        pass,
        redrawReason,
        stats
      } = opts;
      for (const status of renderStats) {
        const {
          totalCount,
          visibleCount,
          compositeCount,
          pickableCount
        } = status;
        const primitiveCount = totalCount - compositeCount;
        const hiddenCount = primitiveCount - visibleCount;
        log4.log(LOG_LEVEL_DRAW, `RENDER #${deckRenderer.renderCount}   ${visibleCount} (of ${totalCount} layers) to ${pass} because ${redrawReason}   (${hiddenCount} hidden, ${compositeCount} composite ${pickableCount} pickable)`)();
        if (stats) {
          stats.get("Redraw Layers").add(visibleCount);
        }
      }
    }
  });

  // ../core/src/debug/index.ts
  var loggers = {};
  if (true) {
    loggers = getLoggers(log_default);
  }
  function register(handlers) {
    loggers = handlers;
  }
  function debug(eventType, arg1, arg2, arg3) {
    if (log_default.level > 0 && loggers[eventType]) {
      loggers[eventType].call(null, arg1, arg2, arg3);
    }
  }

  // ../core/src/utils/json-loader.ts
  function isJSON(text) {
    const firstChar = text[0];
    const lastChar = text[text.length - 1];
    return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
  }
  var json_loader_default = {
    id: "JSON",
    name: "JSON",
    module: "",
    version: "",
    options: {},
    extensions: ["json", "geojson"],
    mimeTypes: ["application/json", "application/geo+json"],
    testText: isJSON,
    parseTextSync: JSON.parse
  };

  // ../core/src/lib/init.ts
  function checkVersion() {
    const version = typeof __VERSION__ !== "undefined" ? __VERSION__ : globalThis.DECK_VERSION || "untranspiled source";
    const existingVersion = globalThis.deck && globalThis.deck.VERSION;
    if (existingVersion && existingVersion !== version) {
      throw new Error(`deck.gl - multiple versions detected: ${existingVersion} vs ${version}`);
    }
    if (!existingVersion) {
      log_default.log(1, `deck.gl ${version}`)();
      globalThis.deck = {
        ...globalThis.deck,
        VERSION: version,
        version,
        log: log_default,
        _registerLoggers: register
      };
      registerLoaders([
        json_loader_default,
        [ImageLoader, {
          imagebitmap: {
            premultiplyAlpha: "none"
          }
        }]
      ]);
    }
    return version;
  }
  var VERSION6 = checkVersion();

  // ../core/src/lib/constants.ts
  var COORDINATE_SYSTEM = {
    DEFAULT: -1,
    LNGLAT: 1,
    METER_OFFSETS: 2,
    LNGLAT_OFFSETS: 3,
    CARTESIAN: 0
  };
  Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", {
    get: () => {
      log_default.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
      return 0;
    }
  });
  var PROJECTION_MODE = {
    WEB_MERCATOR: 1,
    GLOBE: 2,
    WEB_MERCATOR_AUTO_OFFSET: 4,
    IDENTITY: 0
  };
  var UNIT = {
    common: 0,
    meters: 1,
    pixels: 2
  };
  var EVENTS = {
    click: {
      handler: "onClick"
    },
    panstart: {
      handler: "onDragStart"
    },
    panmove: {
      handler: "onDrag"
    },
    panend: {
      handler: "onDragEnd"
    }
  };
  var OPERATION = {
    DRAW: "draw",
    MASK: "mask",
    TERRAIN: "terrain"
  };

  // ../../node_modules/@luma.gl/gltools/dist/esm/utils/log.js
  var log2 = new Log2({
    id: "luma.gl"
  });

  // ../../node_modules/@luma.gl/gltools/dist/esm/utils/assert.js
  function assert6(condition, message) {
    if (!condition) {
      throw new Error(message || "luma.gl: assertion failed.");
    }
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js
  var ERR_CONTEXT = "Invalid WebGLRenderingContext";
  var ERR_WEBGL2 = "Requires WebGL2";
  function isWebGL(gl) {
    if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
      return true;
    }
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && Number.isFinite(gl._version));
  }
  function isWebGL2(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function getWebGL2Context(gl) {
    return isWebGL2(gl) ? gl : null;
  }
  function assertWebGLContext(gl) {
    assert6(isWebGL(gl), ERR_CONTEXT);
    return gl;
  }
  function assertWebGL2Context(gl) {
    assert6(isWebGL2(gl), ERR_WEBGL2);
    return gl;
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js
  var glErrorShadow = {};
  function error(msg) {
    if (globalThis.console && globalThis.console.error) {
      globalThis.console.error(msg);
    }
  }
  function log3(msg) {
    if (globalThis.console && globalThis.console.log) {
      globalThis.console.log(msg);
    }
  }
  function synthesizeGLError(err, opt_msg) {
    glErrorShadow[err] = true;
    if (opt_msg !== void 0) {
      error(opt_msg);
    }
  }
  function wrapGLError(gl) {
    const f2 = gl.getError;
    gl.getError = function getError() {
      let err;
      do {
        err = f2.apply(gl);
        if (err !== 0) {
          glErrorShadow[err] = true;
        }
      } while (err !== 0);
      for (err in glErrorShadow) {
        if (glErrorShadow[err]) {
          delete glErrorShadow[err];
          return parseInt(err, 10);
        }
      }
      return 0;
    };
  }
  var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES2(ext) {
    const gl = ext.gl;
    this.ext = ext;
    this.isAlive = true;
    this.hasBeenBound = false;
    this.elementArrayBuffer = null;
    this.attribs = new Array(ext.maxVertexAttribs);
    for (let n2 = 0; n2 < this.attribs.length; n2++) {
      const attrib = new WebGLVertexArrayObjectOES2.VertexAttrib(gl);
      this.attribs[n2] = attrib;
    }
    this.maxAttrib = 0;
  };
  WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
    this.enabled = false;
    this.buffer = null;
    this.size = 4;
    this.type = 5126;
    this.normalized = false;
    this.stride = 16;
    this.offset = 0;
    this.cached = "";
    this.recache();
  };
  WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
    this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
  };
  var OESVertexArrayObject = function OESVertexArrayObject2(gl) {
    const self2 = this;
    this.gl = gl;
    wrapGLError(gl);
    const original = this.original = {
      getParameter: gl.getParameter,
      enableVertexAttribArray: gl.enableVertexAttribArray,
      disableVertexAttribArray: gl.disableVertexAttribArray,
      bindBuffer: gl.bindBuffer,
      getVertexAttrib: gl.getVertexAttrib,
      vertexAttribPointer: gl.vertexAttribPointer
    };
    gl.getParameter = function getParameter(pname) {
      if (pname === self2.VERTEX_ARRAY_BINDING_OES) {
        if (self2.currentVertexArrayObject === self2.defaultVertexArrayObject) {
          return null;
        }
        return self2.currentVertexArrayObject;
      }
      return original.getParameter.apply(this, arguments);
    };
    gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index);
      const attrib = vao.attribs[index];
      attrib.enabled = true;
      return original.enableVertexAttribArray.apply(this, arguments);
    };
    gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index);
      const attrib = vao.attribs[index];
      attrib.enabled = false;
      return original.disableVertexAttribArray.apply(this, arguments);
    };
    gl.bindBuffer = function bindBuffer(target, buffer) {
      switch (target) {
        case 34962:
          self2.currentArrayBuffer = buffer;
          break;
        case 34963:
          self2.currentVertexArrayObject.elementArrayBuffer = buffer;
          break;
        default:
      }
      return original.bindBuffer.apply(this, arguments);
    };
    gl.getVertexAttrib = function getVertexAttrib(index, pname) {
      const vao = self2.currentVertexArrayObject;
      const attrib = vao.attribs[index];
      switch (pname) {
        case 34975:
          return attrib.buffer;
        case 34338:
          return attrib.enabled;
        case 34339:
          return attrib.size;
        case 34340:
          return attrib.stride;
        case 34341:
          return attrib.type;
        case 34922:
          return attrib.normalized;
        default:
          return original.getVertexAttrib.apply(this, arguments);
      }
    };
    gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, indx);
      const attrib = vao.attribs[indx];
      attrib.buffer = self2.currentArrayBuffer;
      attrib.size = size;
      attrib.type = type;
      attrib.normalized = normalized;
      attrib.stride = stride;
      attrib.offset = offset;
      attrib.recache();
      return original.vertexAttribPointer.apply(this, arguments);
    };
    if (gl.instrumentExtension) {
      gl.instrumentExtension(this, "OES_vertex_array_object");
    }
    if (gl.canvas) {
      gl.canvas.addEventListener("webglcontextrestored", () => {
        log3("OESVertexArrayObject emulation library context restored");
        self2.reset_();
      }, true);
    }
    this.reset_();
  };
  OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
  OESVertexArrayObject.prototype.reset_ = function reset_() {
    const contextWasLost = this.vertexArrayObjects !== void 0;
    if (contextWasLost) {
      for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
        this.vertexArrayObjects.isAlive = false;
      }
    }
    const gl = this.gl;
    this.maxVertexAttribs = gl.getParameter(34921);
    this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
    this.currentVertexArrayObject = null;
    this.currentArrayBuffer = null;
    this.vertexArrayObjects = [this.defaultVertexArrayObject];
    this.bindVertexArrayOES(null);
  };
  OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
    const arrayObject = new WebGLVertexArrayObjectOES(this);
    this.vertexArrayObjects.push(arrayObject);
    return arrayObject;
  };
  OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
    arrayObject.isAlive = false;
    this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
    if (this.currentVertexArrayObject === arrayObject) {
      this.bindVertexArrayOES(null);
    }
  };
  OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
    if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
      if (arrayObject.hasBeenBound && arrayObject.ext === this) {
        return true;
      }
    }
    return false;
  };
  OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
    const gl = this.gl;
    if (arrayObject && !arrayObject.isAlive) {
      synthesizeGLError(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
      return;
    }
    const original = this.original;
    const oldVAO = this.currentVertexArrayObject;
    this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
    this.currentVertexArrayObject.hasBeenBound = true;
    const newVAO = this.currentVertexArrayObject;
    if (oldVAO === newVAO) {
      return;
    }
    if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
      original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
    }
    let currentBinding = this.currentArrayBuffer;
    const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
    for (let n2 = 0; n2 <= maxAttrib; n2++) {
      const attrib = newVAO.attribs[n2];
      const oldAttrib = oldVAO ? oldVAO.attribs[n2] : null;
      if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
        if (attrib.enabled) {
          original.enableVertexAttribArray.call(gl, n2);
        } else {
          original.disableVertexAttribArray.call(gl, n2);
        }
      }
      if (attrib.enabled) {
        let bufferChanged = false;
        if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
          if (currentBinding !== attrib.buffer) {
            original.bindBuffer.call(gl, 34962, attrib.buffer);
            currentBinding = attrib.buffer;
          }
          bufferChanged = true;
        }
        if (bufferChanged || attrib.cached !== oldAttrib.cached) {
          original.vertexAttribPointer.call(gl, n2, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
        }
      }
    }
    if (this.currentArrayBuffer !== currentBinding) {
      original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
    }
  };
  function polyfillVertexArrayObject(gl) {
    if (typeof gl.createVertexArray === "function") {
      return;
    }
    const original_getSupportedExtensions = gl.getSupportedExtensions;
    gl.getSupportedExtensions = function getSupportedExtensions() {
      const list = original_getSupportedExtensions.call(this) || [];
      if (list.indexOf("OES_vertex_array_object") < 0) {
        list.push("OES_vertex_array_object");
      }
      return list;
    };
    const original_getExtension = gl.getExtension;
    gl.getExtension = function getExtension(name10) {
      const ext = original_getExtension.call(this, name10);
      if (ext) {
        return ext;
      }
      if (name10 !== "OES_vertex_array_object") {
        return null;
      }
      if (!gl.__OESVertexArrayObject) {
        this.__OESVertexArrayObject = new OESVertexArrayObject(this);
      }
      return this.__OESVertexArrayObject;
    };
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js
  var OES_element_index = "OES_element_index";
  var WEBGL_draw_buffers = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
  var EXT_disjoint_timer_query_webgl2 = "EXT_disjoint_timer_query_webgl2";
  var EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
  var WEBGL_debug_renderer_info = "WEBGL_debug_renderer_info";
  var GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723;
  var GL_DONT_CARE = 4352;
  var GL_GPU_DISJOINT_EXT = 36795;
  var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
  var GL_UNMASKED_VENDOR_WEBGL = 37445;
  var GL_UNMASKED_RENDERER_WEBGL = 37446;
  var getWebGL2ValueOrZero = (gl) => !isWebGL2(gl) ? 0 : void 0;
  var WEBGL_PARAMETERS = {
    [3074]: (gl) => !isWebGL2(gl) ? 36064 : void 0,
    [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: (gl) => !isWebGL2(gl) ? GL_DONT_CARE : void 0,
    [35977]: getWebGL2ValueOrZero,
    [32937]: getWebGL2ValueOrZero,
    [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
      const ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
      return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
    },
    [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
      const ext = gl.getExtension(WEBGL_debug_renderer_info);
      return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
    },
    [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
      const ext = gl.getExtension(WEBGL_debug_renderer_info);
      return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
    },
    [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
      const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
      return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
    },
    [32883]: getWebGL2ValueOrZero,
    [35071]: getWebGL2ValueOrZero,
    [37447]: getWebGL2ValueOrZero,
    [36063]: (gl, getParameter) => {
      if (!isWebGL2(gl)) {
        const ext = gl.getExtension(WEBGL_draw_buffers);
        return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
      }
      return void 0;
    },
    [35379]: getWebGL2ValueOrZero,
    [35374]: getWebGL2ValueOrZero,
    [35377]: getWebGL2ValueOrZero,
    [34852]: (gl) => {
      if (!isWebGL2(gl)) {
        const ext = gl.getExtension(WEBGL_draw_buffers);
        return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
      }
      return void 0;
    },
    [36203]: (gl) => gl.getExtension(OES_element_index) ? 2147483647 : 65535,
    [33001]: (gl) => gl.getExtension(OES_element_index) ? 16777216 : 65535,
    [33e3]: (gl) => 16777216,
    [37157]: getWebGL2ValueOrZero,
    [35373]: getWebGL2ValueOrZero,
    [35657]: getWebGL2ValueOrZero,
    [36183]: getWebGL2ValueOrZero,
    [37137]: getWebGL2ValueOrZero,
    [34045]: getWebGL2ValueOrZero,
    [35978]: getWebGL2ValueOrZero,
    [35979]: getWebGL2ValueOrZero,
    [35968]: getWebGL2ValueOrZero,
    [35376]: getWebGL2ValueOrZero,
    [35375]: getWebGL2ValueOrZero,
    [35659]: getWebGL2ValueOrZero,
    [37154]: getWebGL2ValueOrZero,
    [35371]: getWebGL2ValueOrZero,
    [35658]: getWebGL2ValueOrZero,
    [35076]: getWebGL2ValueOrZero,
    [35077]: getWebGL2ValueOrZero,
    [35380]: getWebGL2ValueOrZero
  };
  function getParameterPolyfill(gl, originalGetParameter, pname) {
    const limit = WEBGL_PARAMETERS[pname];
    const value = typeof limit === "function" ? limit(gl, originalGetParameter, pname) : limit;
    const result = value !== void 0 ? value : originalGetParameter(pname);
    return result;
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js
  var OES_vertex_array_object = "OES_vertex_array_object";
  var ANGLE_instanced_arrays = "ANGLE_instanced_arrays";
  var WEBGL_draw_buffers2 = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query2 = "EXT_disjoint_timer_query";
  var EXT_texture_filter_anisotropic2 = "EXT_texture_filter_anisotropic";
  var ERR_VAO_NOT_SUPPORTED = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
  function getExtensionData(gl, extension) {
    return {
      webgl2: isWebGL2(gl),
      ext: gl.getExtension(extension)
    };
  }
  var WEBGL2_CONTEXT_POLYFILLS = {
    [OES_vertex_array_object]: {
      meta: {
        suffix: "OES"
      },
      createVertexArray: () => {
        assert6(false, ERR_VAO_NOT_SUPPORTED);
      },
      deleteVertexArray: () => {
      },
      bindVertexArray: () => {
      },
      isVertexArray: () => false
    },
    [ANGLE_instanced_arrays]: {
      meta: {
        suffix: "ANGLE"
      },
      vertexAttribDivisor(location, divisor) {
        assert6(divisor === 0, "WebGL instanced rendering not supported");
      },
      drawElementsInstanced: () => {
      },
      drawArraysInstanced: () => {
      }
    },
    [WEBGL_draw_buffers2]: {
      meta: {
        suffix: "WEBGL"
      },
      drawBuffers: () => {
        assert6(false);
      }
    },
    [EXT_disjoint_timer_query2]: {
      meta: {
        suffix: "EXT"
      },
      createQuery: () => {
        assert6(false);
      },
      deleteQuery: () => {
        assert6(false);
      },
      beginQuery: () => {
        assert6(false);
      },
      endQuery: () => {
      },
      getQuery(handle, pname) {
        return this.getQueryObject(handle, pname);
      },
      getQueryParameter(handle, pname) {
        return this.getQueryObject(handle, pname);
      },
      getQueryObject: () => {
      }
    }
  };
  var WEBGL2_CONTEXT_OVERRIDES = {
    readBuffer: (gl, originalFunc, attachment) => {
      if (isWebGL2(gl)) {
        originalFunc(attachment);
      } else {
      }
    },
    getVertexAttrib: (gl, originalFunc, location, pname) => {
      const {
        webgl2,
        ext
      } = getExtensionData(gl, ANGLE_instanced_arrays);
      let result;
      switch (pname) {
        case 35069:
          result = !webgl2 ? false : void 0;
          break;
        case 35070:
          result = !webgl2 && !ext ? 0 : void 0;
          break;
        default:
      }
      return result !== void 0 ? result : originalFunc(location, pname);
    },
    getProgramParameter: (gl, originalFunc, program, pname) => {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 35967:
            return 35981;
          case 35971:
            return 0;
          case 35382:
            return 0;
          default:
        }
      }
      return originalFunc(program, pname);
    },
    getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 32937:
            return new Int32Array([0]);
          default:
        }
      }
      return gl.getInternalformatParameter(target, format, pname);
    },
    getTexParameter(gl, originalFunc, target, pname) {
      switch (pname) {
        case 34046:
          const {
            extensions
          } = gl.luma;
          const ext = extensions[EXT_texture_filter_anisotropic2];
          pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
          break;
        default:
      }
      return originalFunc(target, pname);
    },
    getParameter: getParameterPolyfill,
    hint(gl, originalFunc, pname, value) {
      return originalFunc(pname, value);
    }
  };

  // ../../node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js
  function polyfillContext(gl) {
    gl.luma = gl.luma || {};
    const {
      luma
    } = gl;
    if (!luma.polyfilled) {
      polyfillVertexArrayObject(gl);
      initializeExtensions(gl);
      installPolyfills(gl, WEBGL2_CONTEXT_POLYFILLS);
      installOverrides(gl, {
        target: luma,
        target2: gl
      });
      luma.polyfilled = true;
    }
    return gl;
  }
  globalThis.polyfillContext = polyfillContext;
  function initializeExtensions(gl) {
    gl.luma.extensions = {};
    const EXTENSIONS3 = gl.getSupportedExtensions() || [];
    for (const extension of EXTENSIONS3) {
      gl.luma[extension] = gl.getExtension(extension);
    }
  }
  function installOverrides(gl, _ref) {
    let {
      target,
      target2
    } = _ref;
    Object.keys(WEBGL2_CONTEXT_OVERRIDES).forEach((key) => {
      if (typeof WEBGL2_CONTEXT_OVERRIDES[key] === "function") {
        const originalFunc = gl[key] ? gl[key].bind(gl) : () => {
        };
        const polyfill2 = WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);
        target[key] = polyfill2;
        target2[key] = polyfill2;
      }
    });
  }
  function installPolyfills(gl, polyfills) {
    for (const extension of Object.getOwnPropertyNames(polyfills)) {
      if (extension !== "overrides") {
        polyfillExtension(gl, {
          extension,
          target: gl.luma,
          target2: gl
        });
      }
    }
  }
  function polyfillExtension(gl, _ref2) {
    let {
      extension,
      target,
      target2
    } = _ref2;
    const defaults = WEBGL2_CONTEXT_POLYFILLS[extension];
    assert6(defaults);
    const {
      meta = {}
    } = defaults;
    const {
      suffix = ""
    } = meta;
    const ext = gl.getExtension(extension);
    for (const key of Object.keys(defaults)) {
      const extKey = "".concat(key).concat(suffix);
      let polyfill2 = null;
      if (key === "meta") {
      } else if (typeof gl[key] === "function") {
      } else if (ext && typeof ext[extKey] === "function") {
        polyfill2 = function() {
          return ext[extKey](...arguments);
        };
      } else if (typeof defaults[key] === "function") {
        polyfill2 = defaults[key].bind(target);
      }
      if (polyfill2) {
        target[key] = polyfill2;
        target2[key] = polyfill2;
      }
    }
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js
  var GL_PARAMETER_DEFAULTS = {
    [3042]: false,
    [32773]: new Float32Array([0, 0, 0, 0]),
    [32777]: 32774,
    [34877]: 32774,
    [32969]: 1,
    [32968]: 0,
    [32971]: 1,
    [32970]: 0,
    [3106]: new Float32Array([0, 0, 0, 0]),
    [3107]: [true, true, true, true],
    [2884]: false,
    [2885]: 1029,
    [2929]: false,
    [2931]: 1,
    [2932]: 513,
    [2928]: new Float32Array([0, 1]),
    [2930]: true,
    [3024]: true,
    [36006]: null,
    [2886]: 2305,
    [33170]: 4352,
    [2849]: 1,
    [32823]: false,
    [32824]: 0,
    [10752]: 0,
    [32938]: 1,
    [32939]: false,
    [3089]: false,
    [3088]: new Int32Array([0, 0, 1024, 1024]),
    [2960]: false,
    [2961]: 0,
    [2968]: 4294967295,
    [36005]: 4294967295,
    [2962]: 519,
    [2967]: 0,
    [2963]: 4294967295,
    [34816]: 519,
    [36003]: 0,
    [36004]: 4294967295,
    [2964]: 7680,
    [2965]: 7680,
    [2966]: 7680,
    [34817]: 7680,
    [34818]: 7680,
    [34819]: 7680,
    [2978]: [0, 0, 1024, 1024],
    [3333]: 4,
    [3317]: 4,
    [37440]: false,
    [37441]: false,
    [37443]: 37444,
    [35723]: 4352,
    [36010]: null,
    [35977]: false,
    [3330]: 0,
    [3332]: 0,
    [3331]: 0,
    [3314]: 0,
    [32878]: 0,
    [3316]: 0,
    [3315]: 0,
    [32877]: 0
  };
  var enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
  var hint = (gl, value, key) => gl.hint(key, value);
  var pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
  var drawFramebuffer = (gl, value) => {
    const target = isWebGL2(gl) ? 36009 : 36160;
    return gl.bindFramebuffer(target, value);
  };
  var readFramebuffer = (gl, value) => {
    return gl.bindFramebuffer(36008, value);
  };
  function isArray(array) {
    return Array.isArray(array) || ArrayBuffer.isView(array);
  }
  var GL_PARAMETER_SETTERS = {
    [3042]: enable,
    [32773]: (gl, value) => gl.blendColor(...value),
    [32777]: "blendEquation",
    [34877]: "blendEquation",
    [32969]: "blendFunc",
    [32968]: "blendFunc",
    [32971]: "blendFunc",
    [32970]: "blendFunc",
    [3106]: (gl, value) => gl.clearColor(...value),
    [3107]: (gl, value) => gl.colorMask(...value),
    [2884]: enable,
    [2885]: (gl, value) => gl.cullFace(value),
    [2929]: enable,
    [2931]: (gl, value) => gl.clearDepth(value),
    [2932]: (gl, value) => gl.depthFunc(value),
    [2928]: (gl, value) => gl.depthRange(...value),
    [2930]: (gl, value) => gl.depthMask(value),
    [3024]: enable,
    [35723]: hint,
    [36006]: drawFramebuffer,
    [2886]: (gl, value) => gl.frontFace(value),
    [33170]: hint,
    [2849]: (gl, value) => gl.lineWidth(value),
    [32823]: enable,
    [32824]: "polygonOffset",
    [10752]: "polygonOffset",
    [35977]: enable,
    [32938]: "sampleCoverage",
    [32939]: "sampleCoverage",
    [3089]: enable,
    [3088]: (gl, value) => gl.scissor(...value),
    [2960]: enable,
    [2961]: (gl, value) => gl.clearStencil(value),
    [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
    [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
    [2962]: "stencilFuncFront",
    [2967]: "stencilFuncFront",
    [2963]: "stencilFuncFront",
    [34816]: "stencilFuncBack",
    [36003]: "stencilFuncBack",
    [36004]: "stencilFuncBack",
    [2964]: "stencilOpFront",
    [2965]: "stencilOpFront",
    [2966]: "stencilOpFront",
    [34817]: "stencilOpBack",
    [34818]: "stencilOpBack",
    [34819]: "stencilOpBack",
    [2978]: (gl, value) => gl.viewport(...value),
    [3333]: pixelStorei,
    [3317]: pixelStorei,
    [37440]: pixelStorei,
    [37441]: pixelStorei,
    [37443]: pixelStorei,
    [3330]: pixelStorei,
    [3332]: pixelStorei,
    [3331]: pixelStorei,
    [36010]: readFramebuffer,
    [3314]: pixelStorei,
    [32878]: pixelStorei,
    [3316]: pixelStorei,
    [3315]: pixelStorei,
    [32877]: pixelStorei,
    framebuffer: (gl, framebuffer) => {
      const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
      return gl.bindFramebuffer(36160, handle);
    },
    blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
    blendColor: (gl, value) => gl.blendColor(...value),
    blendEquation: (gl, args) => {
      args = isArray(args) ? args : [args, args];
      gl.blendEquationSeparate(...args);
    },
    blendFunc: (gl, args) => {
      args = isArray(args) && args.length === 2 ? [...args, ...args] : args;
      gl.blendFuncSeparate(...args);
    },
    clearColor: (gl, value) => gl.clearColor(...value),
    clearDepth: (gl, value) => gl.clearDepth(value),
    clearStencil: (gl, value) => gl.clearStencil(value),
    colorMask: (gl, value) => gl.colorMask(...value),
    cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
    cullFace: (gl, value) => gl.cullFace(value),
    depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
    depthFunc: (gl, value) => gl.depthFunc(value),
    depthMask: (gl, value) => gl.depthMask(value),
    depthRange: (gl, value) => gl.depthRange(...value),
    dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
    derivativeHint: (gl, value) => {
      gl.hint(35723, value);
    },
    frontFace: (gl, value) => gl.frontFace(value),
    mipmapHint: (gl, value) => gl.hint(33170, value),
    lineWidth: (gl, value) => gl.lineWidth(value),
    polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
    polygonOffset: (gl, value) => gl.polygonOffset(...value),
    sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
    scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
    scissor: (gl, value) => gl.scissor(...value),
    stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
    stencilMask: (gl, value) => {
      value = isArray(value) ? value : [value, value];
      const [mask, backMask] = value;
      gl.stencilMaskSeparate(1028, mask);
      gl.stencilMaskSeparate(1029, backMask);
    },
    stencilFunc: (gl, args) => {
      args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
      const [func, ref, mask, backFunc, backRef, backMask] = args;
      gl.stencilFuncSeparate(1028, func, ref, mask);
      gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
    },
    stencilOp: (gl, args) => {
      args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
      const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
      gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
    },
    viewport: (gl, value) => gl.viewport(...value)
  };
  function getValue(glEnum, values, cache4) {
    return values[glEnum] !== void 0 ? values[glEnum] : cache4[glEnum];
  }
  var GL_COMPOSITE_PARAMETER_SETTERS = {
    blendEquation: (gl, values, cache4) => gl.blendEquationSeparate(getValue(32777, values, cache4), getValue(34877, values, cache4)),
    blendFunc: (gl, values, cache4) => gl.blendFuncSeparate(getValue(32969, values, cache4), getValue(32968, values, cache4), getValue(32971, values, cache4), getValue(32970, values, cache4)),
    polygonOffset: (gl, values, cache4) => gl.polygonOffset(getValue(32824, values, cache4), getValue(10752, values, cache4)),
    sampleCoverage: (gl, values, cache4) => gl.sampleCoverage(getValue(32938, values, cache4), getValue(32939, values, cache4)),
    stencilFuncFront: (gl, values, cache4) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache4), getValue(2967, values, cache4), getValue(2963, values, cache4)),
    stencilFuncBack: (gl, values, cache4) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache4), getValue(36003, values, cache4), getValue(36004, values, cache4)),
    stencilOpFront: (gl, values, cache4) => gl.stencilOpSeparate(1028, getValue(2964, values, cache4), getValue(2965, values, cache4), getValue(2966, values, cache4)),
    stencilOpBack: (gl, values, cache4) => gl.stencilOpSeparate(1029, getValue(34817, values, cache4), getValue(34818, values, cache4), getValue(34819, values, cache4))
  };
  var GL_HOOKED_SETTERS = {
    enable: (update, capability) => update({
      [capability]: true
    }),
    disable: (update, capability) => update({
      [capability]: false
    }),
    pixelStorei: (update, pname, value) => update({
      [pname]: value
    }),
    hint: (update, pname, hint2) => update({
      [pname]: hint2
    }),
    bindFramebuffer: (update, target, framebuffer) => {
      switch (target) {
        case 36160:
          return update({
            [36006]: framebuffer,
            [36010]: framebuffer
          });
        case 36009:
          return update({
            [36006]: framebuffer
          });
        case 36008:
          return update({
            [36010]: framebuffer
          });
        default:
          return null;
      }
    },
    blendColor: (update, r2, g, b, a2) => update({
      [32773]: new Float32Array([r2, g, b, a2])
    }),
    blendEquation: (update, mode) => update({
      [32777]: mode,
      [34877]: mode
    }),
    blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
      [32777]: modeRGB,
      [34877]: modeAlpha
    }),
    blendFunc: (update, src, dst) => update({
      [32969]: src,
      [32968]: dst,
      [32971]: src,
      [32970]: dst
    }),
    blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
      [32969]: srcRGB,
      [32968]: dstRGB,
      [32971]: srcAlpha,
      [32970]: dstAlpha
    }),
    clearColor: (update, r2, g, b, a2) => update({
      [3106]: new Float32Array([r2, g, b, a2])
    }),
    clearDepth: (update, depth) => update({
      [2931]: depth
    }),
    clearStencil: (update, s2) => update({
      [2961]: s2
    }),
    colorMask: (update, r2, g, b, a2) => update({
      [3107]: [r2, g, b, a2]
    }),
    cullFace: (update, mode) => update({
      [2885]: mode
    }),
    depthFunc: (update, func) => update({
      [2932]: func
    }),
    depthRange: (update, zNear, zFar) => update({
      [2928]: new Float32Array([zNear, zFar])
    }),
    depthMask: (update, mask) => update({
      [2930]: mask
    }),
    frontFace: (update, face) => update({
      [2886]: face
    }),
    lineWidth: (update, width) => update({
      [2849]: width
    }),
    polygonOffset: (update, factor, units) => update({
      [32824]: factor,
      [10752]: units
    }),
    sampleCoverage: (update, value, invert5) => update({
      [32938]: value,
      [32939]: invert5
    }),
    scissor: (update, x2, y2, width, height) => update({
      [3088]: new Int32Array([x2, y2, width, height])
    }),
    stencilMask: (update, mask) => update({
      [2968]: mask,
      [36005]: mask
    }),
    stencilMaskSeparate: (update, face, mask) => update({
      [face === 1028 ? 2968 : 36005]: mask
    }),
    stencilFunc: (update, func, ref, mask) => update({
      [2962]: func,
      [2967]: ref,
      [2963]: mask,
      [34816]: func,
      [36003]: ref,
      [36004]: mask
    }),
    stencilFuncSeparate: (update, face, func, ref, mask) => update({
      [face === 1028 ? 2962 : 34816]: func,
      [face === 1028 ? 2967 : 36003]: ref,
      [face === 1028 ? 2963 : 36004]: mask
    }),
    stencilOp: (update, fail, zfail, zpass) => update({
      [2964]: fail,
      [2965]: zfail,
      [2966]: zpass,
      [34817]: fail,
      [34818]: zfail,
      [34819]: zpass
    }),
    stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
      [face === 1028 ? 2964 : 34817]: fail,
      [face === 1028 ? 2965 : 34818]: zfail,
      [face === 1028 ? 2966 : 34819]: zpass
    }),
    viewport: (update, x2, y2, width, height) => update({
      [2978]: [x2, y2, width, height]
    })
  };
  var isEnabled = (gl, key) => gl.isEnabled(key);
  var GL_PARAMETER_GETTERS = {
    [3042]: isEnabled,
    [2884]: isEnabled,
    [2929]: isEnabled,
    [3024]: isEnabled,
    [32823]: isEnabled,
    [32926]: isEnabled,
    [32928]: isEnabled,
    [3089]: isEnabled,
    [2960]: isEnabled,
    [35977]: isEnabled
  };

  // ../../node_modules/@luma.gl/gltools/dist/esm/utils/utils.js
  function isObjectEmpty(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }
  function deepArrayEqual(x2, y2) {
    if (x2 === y2) {
      return true;
    }
    const isArrayX = Array.isArray(x2) || ArrayBuffer.isView(x2);
    const isArrayY = Array.isArray(y2) || ArrayBuffer.isView(y2);
    if (isArrayX && isArrayY && x2.length === y2.length) {
      for (let i3 = 0; i3 < x2.length; ++i3) {
        if (x2[i3] !== y2[i3]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js
  function installGetterOverride(gl, functionName) {
    const originalGetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function get() {
      const pname = arguments.length <= 0 ? void 0 : arguments[0];
      if (!(pname in gl.state.cache)) {
        return originalGetterFunc(...arguments);
      }
      return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);
    };
    Object.defineProperty(gl[functionName], "name", {
      value: "".concat(functionName, "-from-cache"),
      configurable: false
    });
  }
  function installSetterSpy(gl, functionName, setter) {
    const originalSetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function set2() {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }
      const {
        valueChanged,
        oldValue
      } = setter(gl.state._updateCache, ...params);
      if (valueChanged) {
        originalSetterFunc(...params);
      }
      return oldValue;
    };
    Object.defineProperty(gl[functionName], "name", {
      value: "".concat(functionName, "-to-cache"),
      configurable: false
    });
  }
  function installProgramSpy(gl) {
    const originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
      if (gl.state.program !== handle) {
        originalUseProgram(handle);
        gl.state.program = handle;
      }
    };
  }
  var GLState = class {
    constructor(gl) {
      let {
        copyState = false,
        log: log4 = () => {
        }
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.program = null;
      this.stateStack = [];
      this.enable = true;
      this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
      this.log = log4;
      this._updateCache = this._updateCache.bind(this);
      Object.seal(this);
    }
    push() {
      let values = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.stateStack.push({});
    }
    pop() {
      assert6(this.stateStack.length > 0);
      const oldValues = this.stateStack[this.stateStack.length - 1];
      setParameters(this.gl, oldValues);
      this.stateStack.pop();
    }
    _updateCache(values) {
      let valueChanged = false;
      let oldValue;
      const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
      for (const key in values) {
        assert6(key !== void 0);
        const value = values[key];
        const cached = this.cache[key];
        if (!deepArrayEqual(value, cached)) {
          valueChanged = true;
          oldValue = cached;
          if (oldValues && !(key in oldValues)) {
            oldValues[key] = cached;
          }
          this.cache[key] = value;
        }
      }
      return {
        valueChanged,
        oldValue
      };
    }
  };
  function trackContextState(gl) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      enable: enable2 = true,
      copyState
    } = options;
    assert6(copyState !== void 0);
    if (!gl.state) {
      const {
        polyfillContext: polyfillContext2
      } = globalThis;
      if (polyfillContext2) {
        polyfillContext2(gl);
      }
      gl.state = new GLState(gl, {
        copyState
      });
      installProgramSpy(gl);
      for (const key in GL_HOOKED_SETTERS) {
        const setter = GL_HOOKED_SETTERS[key];
        installSetterSpy(gl, key, setter);
      }
      installGetterOverride(gl, "getParameter");
      installGetterOverride(gl, "isEnabled");
    }
    gl.state.enable = enable2;
    return gl;
  }
  function pushContextState(gl) {
    if (!gl.state) {
      trackContextState(gl, {
        copyState: false
      });
    }
    gl.state.push();
  }
  function popContextState(gl) {
    assert6(gl.state);
    gl.state.pop();
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js
  function setParameters(gl, values) {
    assert6(isWebGL(gl), "setParameters requires a WebGL context");
    if (isObjectEmpty(values)) {
      return;
    }
    const compositeSetters = {};
    for (const key in values) {
      const glConstant = Number(key);
      const setter = GL_PARAMETER_SETTERS[key];
      if (setter) {
        if (typeof setter === "string") {
          compositeSetters[setter] = true;
        } else {
          setter(gl, values[key], glConstant);
        }
      }
    }
    const cache4 = gl.state && gl.state.cache;
    if (cache4) {
      for (const key in compositeSetters) {
        const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
        compositeSetter(gl, values, cache4);
      }
    }
  }
  function getParameters(gl, parameters2) {
    parameters2 = parameters2 || GL_PARAMETER_DEFAULTS;
    if (typeof parameters2 === "number") {
      const key = parameters2;
      const getter = GL_PARAMETER_GETTERS[key];
      return getter ? getter(gl, key) : gl.getParameter(key);
    }
    const parameterKeys = Array.isArray(parameters2) ? parameters2 : Object.keys(parameters2);
    const state = {};
    for (const key of parameterKeys) {
      const getter = GL_PARAMETER_GETTERS[key];
      state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
    }
    return state;
  }
  function resetParameters(gl) {
    setParameters(gl, GL_PARAMETER_DEFAULTS);
  }
  function withParameters(gl, parameters2, func) {
    if (isObjectEmpty(parameters2)) {
      return func(gl);
    }
    const {
      nocatch = true
    } = parameters2;
    pushContextState(gl);
    setParameters(gl, parameters2);
    let value;
    if (nocatch) {
      value = func(gl);
      popContextState(gl);
    } else {
      try {
        value = func(gl);
      } finally {
        popContextState(gl);
      }
    }
    return value;
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js
  function cssToDeviceRatio(gl) {
    const {
      luma
    } = gl;
    if (gl.canvas && luma) {
      const cachedSize = luma.canvasSizeInfo;
      const clientWidth = "clientWidth" in cachedSize ? cachedSize.clientWidth : gl.canvas.clientWidth;
      return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
    }
    return 1;
  }
  function cssToDevicePixels(gl, cssPixel) {
    let yInvert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const ratio = cssToDeviceRatio(gl);
    const width = gl.drawingBufferWidth;
    const height = gl.drawingBufferHeight;
    return scalePixels(cssPixel, ratio, width, height, yInvert);
  }
  function getDevicePixelRatio(useDevicePixels) {
    const windowRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio || 1;
    if (Number.isFinite(useDevicePixels)) {
      return useDevicePixels <= 0 ? 1 : useDevicePixels;
    }
    return useDevicePixels ? windowRatio : 1;
  }
  function scalePixels(pixel, ratio, width, height, yInvert) {
    const x2 = scaleX(pixel[0], ratio, width);
    let y2 = scaleY(pixel[1], ratio, height, yInvert);
    let t2 = scaleX(pixel[0] + 1, ratio, width);
    const xHigh = t2 === width - 1 ? t2 : t2 - 1;
    t2 = scaleY(pixel[1] + 1, ratio, height, yInvert);
    let yHigh;
    if (yInvert) {
      t2 = t2 === 0 ? t2 : t2 + 1;
      yHigh = y2;
      y2 = t2;
    } else {
      yHigh = t2 === height - 1 ? t2 : t2 - 1;
    }
    return {
      x: x2,
      y: y2,
      width: Math.max(xHigh - x2 + 1, 1),
      height: Math.max(yHigh - y2 + 1, 1)
    };
  }
  function scaleX(x2, ratio, width) {
    const r2 = Math.min(Math.round(x2 * ratio), width - 1);
    return r2;
  }
  function scaleY(y2, ratio, height, yInvert) {
    return yInvert ? Math.max(0, height - 1 - Math.round(y2 * ratio)) : Math.min(Math.round(y2 * ratio), height - 1);
  }

  // ../../node_modules/@luma.gl/gltools/dist/esm/context/context.js
  var isBrowser7 = isBrowser5();
  var isPage = isBrowser7 && typeof document !== "undefined";
  var CONTEXT_DEFAULTS = {
    webgl2: true,
    webgl1: true,
    throwOnError: true,
    manageState: true,
    canvas: null,
    debug: false,
    width: 800,
    height: 600
  };
  function createGLContext() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    assert6(isBrowser7, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils");
    options = Object.assign({}, CONTEXT_DEFAULTS, options);
    const {
      width,
      height
    } = options;
    function onError(message) {
      if (options.throwOnError) {
        throw new Error(message);
      }
      console.error(message);
      return null;
    }
    options.onError = onError;
    let gl;
    const {
      canvas
    } = options;
    const targetCanvas = getCanvas({
      canvas,
      width,
      height,
      onError
    });
    gl = createBrowserContext(targetCanvas, options);
    if (!gl) {
      return null;
    }
    gl = instrumentGLContext(gl, options);
    logInfo(gl);
    return gl;
  }
  function instrumentGLContext(gl) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!gl || gl._instrumented) {
      return gl;
    }
    gl._version = gl._version || getVersion(gl);
    gl.luma = gl.luma || {};
    gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
    options = Object.assign({}, CONTEXT_DEFAULTS, options);
    const {
      manageState,
      debug: debug2
    } = options;
    if (manageState) {
      trackContextState(gl, {
        copyState: false,
        log: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return log2.log(1, ...args)();
        }
      });
    }
    if (isBrowser7 && debug2) {
      if (!globalThis.makeDebugContext) {
        log2.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
      } else {
        gl = globalThis.makeDebugContext(gl, options);
        log2.level = Math.max(log2.level, 1);
      }
    }
    gl._instrumented = true;
    return gl;
  }
  function getContextDebugInfo(gl) {
    const vendorMasked = gl.getParameter(7936);
    const rendererMasked = gl.getParameter(7937);
    const ext = gl.getExtension("WEBGL_debug_renderer_info");
    const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
    const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
    return {
      vendor: vendorUnmasked || vendorMasked,
      renderer: rendererUnmasked || rendererMasked,
      vendorMasked,
      rendererMasked,
      version: gl.getParameter(7938),
      shadingLanguageVersion: gl.getParameter(35724)
    };
  }
  function resizeGLContext(gl) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (gl.canvas) {
      const devicePixelRatio = getDevicePixelRatio(options.useDevicePixels);
      setDevicePixelRatio(gl, devicePixelRatio, options);
      return;
    }
    const ext = gl.getExtension("STACKGL_resize_drawingbuffer");
    if (ext && "width" in options && "height" in options) {
      ext.resize(options.width, options.height);
    }
  }
  function createBrowserContext(canvas, options) {
    const {
      onError
    } = options;
    let errorMessage = null;
    const onCreateError = (error2) => errorMessage = error2.statusMessage || errorMessage;
    canvas.addEventListener("webglcontextcreationerror", onCreateError, false);
    const {
      webgl1 = true,
      webgl2 = true
    } = options;
    let gl = null;
    if (webgl2) {
      gl = gl || canvas.getContext("webgl2", options);
      gl = gl || canvas.getContext("experimental-webgl2", options);
    }
    if (webgl1) {
      gl = gl || canvas.getContext("webgl", options);
      gl = gl || canvas.getContext("experimental-webgl", options);
    }
    canvas.removeEventListener("webglcontextcreationerror", onCreateError, false);
    if (!gl) {
      return onError("Failed to create ".concat(webgl2 && !webgl1 ? "WebGL2" : "WebGL", " context: ").concat(errorMessage || "Unknown error"));
    }
    if (options.onContextLost) {
      canvas.addEventListener("webglcontextlost", options.onContextLost, false);
    }
    if (options.onContextRestored) {
      canvas.addEventListener("webglcontextrestored", options.onContextRestored, false);
    }
    return gl;
  }
  function getCanvas(_ref) {
    let {
      canvas,
      width = 800,
      height = 600,
      onError
    } = _ref;
    let targetCanvas;
    if (typeof canvas === "string") {
      const isPageLoaded = isPage && document.readyState === "complete";
      if (!isPageLoaded) {
        onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
      }
      targetCanvas = document.getElementById(canvas);
    } else if (canvas) {
      targetCanvas = canvas;
    } else {
      targetCanvas = document.createElement("canvas");
      targetCanvas.id = "lumagl-canvas";
      targetCanvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : "100%";
      targetCanvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : "100%";
      document.body.insertBefore(targetCanvas, document.body.firstChild);
    }
    return targetCanvas;
  }
  function logInfo(gl) {
    const webGL = isWebGL2(gl) ? "WebGL2" : "WebGL1";
    const info = getContextDebugInfo(gl);
    const driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : "";
    const debug2 = gl.debug ? " debug" : "";
    log2.info(1, "".concat(webGL).concat(debug2, " context ").concat(driver))();
  }
  function getVersion(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return 2;
    }
    return 1;
  }
  function setDevicePixelRatio(gl, devicePixelRatio, options) {
    let clientWidth = "width" in options ? options.width : gl.canvas.clientWidth;
    let clientHeight = "height" in options ? options.height : gl.canvas.clientHeight;
    if (!clientWidth || !clientHeight) {
      log2.log(1, "Canvas clientWidth/clientHeight is 0")();
      devicePixelRatio = 1;
      clientWidth = gl.canvas.width || 1;
      clientHeight = gl.canvas.height || 1;
    }
    gl.luma = gl.luma || {};
    gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
    const cachedSize = gl.luma.canvasSizeInfo;
    if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
      let clampedPixelRatio = devicePixelRatio;
      const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
      const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
      gl.canvas.width = canvasWidth;
      gl.canvas.height = canvasHeight;
      if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
        log2.warn("Device pixel ratio clamped")();
        clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
        gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
        gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
      }
      Object.assign(gl.luma.canvasSizeInfo, {
        clientWidth,
        clientHeight,
        devicePixelRatio
      });
    }
  }

  // ../../node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js
  function getHiResTimestamp4() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) {
      timestamp = window.performance.now();
    } else if (typeof process !== "undefined" && process.hrtime) {
      const timeParts = process.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/stats/dist/esm/lib/stat.js
  var Stat2 = class {
    constructor(name10, type) {
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "sampleSize", 1);
      _defineProperty(this, "time", void 0);
      _defineProperty(this, "count", void 0);
      _defineProperty(this, "samples", void 0);
      _defineProperty(this, "lastTiming", void 0);
      _defineProperty(this, "lastSampleTime", void 0);
      _defineProperty(this, "lastSampleCount", void 0);
      _defineProperty(this, "_count", 0);
      _defineProperty(this, "_time", 0);
      _defineProperty(this, "_samples", 0);
      _defineProperty(this, "_startTime", 0);
      _defineProperty(this, "_timerPending", false);
      this.name = name10;
      this.type = type;
      this.reset();
    }
    setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
    incrementCount() {
      this.addCount(1);
      return this;
    }
    decrementCount() {
      this.subtractCount(1);
      return this;
    }
    addCount(value) {
      this._count += value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    subtractCount(value) {
      this._count -= value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;
      this._checkSampling();
      return this;
    }
    timeStart() {
      this._startTime = getHiResTimestamp4();
      this._timerPending = true;
      return this;
    }
    timeEnd() {
      if (!this._timerPending) {
        return this;
      }
      this.addTime(getHiResTimestamp4() - this._startTime);
      this._timerPending = false;
      this._checkSampling();
      return this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
    _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  };

  // ../../node_modules/@probe.gl/stats/dist/esm/lib/stats.js
  var Stats2 = class {
    constructor(options) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "stats", {});
      this.id = options.id;
      this.stats = {};
      this._initializeStats(options.stats);
      Object.seal(this);
    }
    get(name10) {
      let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
      return this._getOrCreate({
        name: name10,
        type
      });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    reset() {
      for (const key in this.stats) {
        this.stats[key].reset();
      }
      return this;
    }
    forEach(fn) {
      for (const key in this.stats) {
        fn(this.stats[key]);
      }
    }
    getTable() {
      const table = {};
      this.forEach((stat) => {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
    _initializeStats() {
      let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      stats.forEach((stat) => this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
      if (!stat || !stat.name) {
        return null;
      }
      const {
        name: name10,
        type
      } = stat;
      if (!this.stats[name10]) {
        if (stat instanceof Stat2) {
          this.stats[name10] = stat;
        } else {
          this.stats[name10] = new Stat2(name10, type);
        }
      }
      return this.stats[name10];
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/init.js
  var VERSION7 = true ? "8.5.20" : "untranspiled source";
  var STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
  var StatsManager = class {
    constructor() {
      this.stats = /* @__PURE__ */ new Map();
    }
    get(name10) {
      if (!this.stats.has(name10)) {
        this.stats.set(name10, new Stats2({
          id: name10
        }));
      }
      return this.stats.get(name10);
    }
  };
  var lumaStats = new StatsManager();
  if (globalThis.luma && globalThis.luma.VERSION !== VERSION7) {
    throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(VERSION7));
  }
  if (!globalThis.luma) {
    if (isBrowser5()) {
      log2.log(1, "luma.gl ".concat(VERSION7, " - ").concat(STARTUP_MESSAGE))();
    }
    globalThis.luma = globalThis.luma || {
      VERSION: VERSION7,
      version: VERSION7,
      log: log2,
      stats: lumaStats,
      globals: {
        modules: {},
        nodeIO: {}
      }
    };
  }
  var init_default = globalThis.luma;

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js
  function requestAnimationFrame2(callback) {
    return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
  }
  function cancelAnimationFrame(timerId) {
    return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/assert.js
  function assert7(condition, message) {
    if (!condition) {
      throw new Error(message || "luma.gl: assertion failed.");
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js
  function getKeyValue(gl, name10) {
    if (typeof name10 !== "string") {
      return name10;
    }
    const number = Number(name10);
    if (!isNaN(number)) {
      return number;
    }
    name10 = name10.replace(/^.*\./, "");
    const value = gl[name10];
    assert7(value !== void 0, "Accessing undefined constant GL.".concat(name10));
    return value;
  }
  function getKey(gl, value) {
    value = Number(value);
    for (const key in gl) {
      if (gl[key] === value) {
        return "GL.".concat(key);
      }
    }
    return String(value);
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/utils.js
  var uidCounters = {};
  function uid() {
    let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
    uidCounters[id] = uidCounters[id] || 1;
    const count2 = uidCounters[id]++;
    return "".concat(id, "-").concat(count2);
  }
  function isPowerOfTwo(n2) {
    assert7(typeof n2 === "number", "Input must be a number");
    return n2 && (n2 & n2 - 1) === 0;
  }
  function isObjectEmpty2(obj) {
    let isEmpty = true;
    for (const key in obj) {
      isEmpty = false;
      break;
    }
    return isEmpty;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js
  function stubRemovedMethods(instance, className, version, methodNames) {
    const upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
    const prototype = Object.getPrototypeOf(instance);
    methodNames.forEach((methodName) => {
      if (prototype.methodName) {
        return;
      }
      prototype[methodName] = () => {
        log2.removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
        throw new Error(methodName);
      };
    });
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js
  var ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
  var Resource = class {
    get [Symbol.toStringTag]() {
      return "Resource";
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGLContext(gl);
      const {
        id,
        userData = {}
      } = opts;
      this.gl = gl;
      this.gl2 = gl;
      this.id = id || uid(this[Symbol.toStringTag]);
      this.userData = userData;
      this._bound = false;
      this._handle = opts.handle;
      if (this._handle === void 0) {
        this._handle = this._createHandle();
      }
      this.byteLength = 0;
      this._addStats();
    }
    toString() {
      return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
    }
    get handle() {
      return this._handle;
    }
    delete() {
      let {
        deleteChildren = false
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const children = this._handle && this._deleteHandle(this._handle);
      if (this._handle) {
        this._removeStats();
      }
      this._handle = null;
      if (children && deleteChildren) {
        children.filter(Boolean).forEach((child) => child.delete());
      }
      return this;
    }
    bind() {
      let funcOrHandle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
      if (typeof funcOrHandle !== "function") {
        this._bindHandle(funcOrHandle);
        return this;
      }
      let value;
      if (!this._bound) {
        this._bindHandle(this.handle);
        this._bound = true;
        value = funcOrHandle();
        this._bound = false;
        this._bindHandle(null);
      } else {
        value = funcOrHandle();
      }
      return value;
    }
    unbind() {
      this.bind(null);
    }
    getParameter(pname) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      pname = getKeyValue(this.gl, pname);
      assert7(pname);
      const parameters2 = this.constructor.PARAMETERS || {};
      const parameter = parameters2[pname];
      if (parameter) {
        const isWebgl2 = isWebGL2(this.gl);
        const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (!parameterAvailable) {
          const webgl1Default = parameter.webgl1;
          const webgl2Default = "webgl2" in parameter ? parameter.webgl2 : parameter.webgl1;
          const defaultValue2 = isWebgl2 ? webgl2Default : webgl1Default;
          return defaultValue2;
        }
      }
      return this._getParameter(pname, opts);
    }
    getParameters() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        parameters: parameters2,
        keys
      } = options;
      const PARAMETERS = this.constructor.PARAMETERS || {};
      const isWebgl2 = isWebGL2(this.gl);
      const values = {};
      const parameterKeys = parameters2 || Object.keys(PARAMETERS);
      for (const pname of parameterKeys) {
        const parameter = PARAMETERS[pname];
        const parameterAvailable = parameter && (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (parameterAvailable) {
          const key = keys ? getKey(this.gl, pname) : pname;
          values[key] = this.getParameter(pname, options);
          if (keys && parameter.type === "GLenum") {
            values[key] = getKey(this.gl, values[key]);
          }
        }
      }
      return values;
    }
    setParameter(pname, value) {
      pname = getKeyValue(this.gl, pname);
      assert7(pname);
      const parameters2 = this.constructor.PARAMETERS || {};
      const parameter = parameters2[pname];
      if (parameter) {
        const isWebgl2 = isWebGL2(this.gl);
        const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (!parameterAvailable) {
          throw new Error("Parameter not available on this platform");
        }
        if (parameter.type === "GLenum") {
          value = getKeyValue(value);
        }
      }
      this._setParameter(pname, value);
      return this;
    }
    setParameters(parameters2) {
      for (const pname in parameters2) {
        this.setParameter(pname, parameters2[pname]);
      }
      return this;
    }
    stubRemovedMethods(className, version, methodNames) {
      return stubRemovedMethods(this, className, version, methodNames);
    }
    initialize(opts) {
    }
    _createHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _deleteHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _bindHandle(handle) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getOptsFromHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getParameter(pname, opts) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _setParameter(pname, value) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _context() {
      this.gl.luma = this.gl.luma || {};
      return this.gl.luma;
    }
    _addStats() {
      const name10 = this[Symbol.toStringTag];
      const stats = lumaStats.get("Resource Counts");
      stats.get("Resources Created").incrementCount();
      stats.get("".concat(name10, "s Created")).incrementCount();
      stats.get("".concat(name10, "s Active")).incrementCount();
    }
    _removeStats() {
      const name10 = this[Symbol.toStringTag];
      const stats = lumaStats.get("Resource Counts");
      stats.get("".concat(name10, "s Active")).decrementCount();
    }
    _trackAllocatedMemory(bytes) {
      let name10 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
      this._trackAllocatedMemoryForContext(bytes, name10);
      this._trackAllocatedMemoryForContext(bytes, name10, this.gl.canvas && this.gl.canvas.id);
      this.byteLength = bytes;
    }
    _trackAllocatedMemoryForContext(bytes) {
      let name10 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
      let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      const stats = lumaStats.get("Memory Usage".concat(id));
      stats.get("GPU Memory").addCount(bytes);
      stats.get("".concat(name10, " Memory")).addCount(bytes);
    }
    _trackDeallocatedMemory() {
      let name10 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
      this._trackDeallocatedMemoryForContext(name10);
      this._trackDeallocatedMemoryForContext(name10, this.gl.canvas && this.gl.canvas.id);
      this.byteLength = 0;
    }
    _trackDeallocatedMemoryForContext() {
      let name10 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
      let id = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      const stats = lumaStats.get("Memory Usage".concat(id));
      stats.get("GPU Memory").subtractCount(this.byteLength);
      stats.get("".concat(name10, " Memory")).subtractCount(this.byteLength);
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js
  var ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
  function getGLTypeFromTypedArray(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return 5126;
      case Uint16Array:
        return 5123;
      case Uint32Array:
        return 5125;
      case Uint8Array:
        return 5121;
      case Uint8ClampedArray:
        return 5121;
      case Int8Array:
        return 5120;
      case Int16Array:
        return 5122;
      case Int32Array:
        return 5124;
      default:
        throw new Error(ERR_TYPE_DEDUCTION);
    }
  }
  function getTypedArrayFromGLType(glType) {
    let {
      clamped = true
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    switch (glType) {
      case 5126:
        return Float32Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return clamped ? Uint8ClampedArray : Uint8Array;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Failed to deduce typed array type from GL constant");
    }
  }
  function flipRows(_ref) {
    let {
      data,
      width,
      height,
      bytesPerPixel = 4,
      temp
    } = _ref;
    const bytesPerRow = width * bytesPerPixel;
    temp = temp || new Uint8Array(bytesPerRow);
    for (let y2 = 0; y2 < height / 2; ++y2) {
      const topOffset = y2 * bytesPerRow;
      const bottomOffset = (height - y2 - 1) * bytesPerRow;
      temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
      data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
      data.set(temp, bottomOffset);
    }
  }
  function scalePixels2(_ref2) {
    let {
      data,
      width,
      height
    } = _ref2;
    const newWidth = Math.round(width / 2);
    const newHeight = Math.round(height / 2);
    const newData = new Uint8Array(newWidth * newHeight * 4);
    for (let y2 = 0; y2 < newHeight; y2++) {
      for (let x2 = 0; x2 < newWidth; x2++) {
        for (let c = 0; c < 4; c++) {
          newData[(y2 * newWidth + x2) * 4 + c] = data[(y2 * 2 * width + x2 * 2) * 4 + c];
        }
      }
    }
    return {
      data: newData,
      width: newWidth,
      height: newHeight
    };
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js
  function checkProps(className, props, propChecks) {
    const {
      removedProps = {},
      deprecatedProps = {},
      replacedProps = {}
    } = propChecks;
    for (const propName in removedProps) {
      if (propName in props) {
        const replacementProp = removedProps[propName];
        const replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : "N/A";
        log2.removed("".concat(className, ".").concat(propName), replacement)();
      }
    }
    for (const propName in deprecatedProps) {
      if (propName in props) {
        const replacementProp = deprecatedProps[propName];
        log2.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
      }
    }
    let newProps = null;
    for (const propName in replacedProps) {
      if (propName in props) {
        const replacementProp = replacedProps[propName];
        log2.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
        newProps = newProps || Object.assign({}, props);
        newProps[replacementProp] = props[propName];
        delete newProps[propName];
      }
    }
    return newProps || props;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js
  var DEFAULT_ACCESSOR_VALUES = {
    offset: 0,
    stride: 0,
    type: 5126,
    size: 1,
    divisor: 0,
    normalized: false,
    integer: false
  };
  var PROP_CHECKS = {
    deprecatedProps: {
      instanced: "divisor",
      isInstanced: "divisor"
    }
  };
  var Accessor = class {
    static getBytesPerElement(accessor) {
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT;
    }
    static getBytesPerVertex(accessor) {
      assert7(accessor.size);
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT * accessor.size;
    }
    static resolve() {
      for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
        accessors[_key] = arguments[_key];
      }
      return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
    }
    constructor() {
      for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        accessors[_key2] = arguments[_key2];
      }
      accessors.forEach((accessor) => this._assign(accessor));
      Object.freeze(this);
    }
    toString() {
      return JSON.stringify(this);
    }
    get BYTES_PER_ELEMENT() {
      return Accessor.getBytesPerElement(this);
    }
    get BYTES_PER_VERTEX() {
      return Accessor.getBytesPerVertex(this);
    }
    _assign() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      props = checkProps("Accessor", props, PROP_CHECKS);
      if (props.type !== void 0) {
        this.type = props.type;
        if (props.type === 5124 || props.type === 5125) {
          this.integer = true;
        }
      }
      if (props.size !== void 0) {
        this.size = props.size;
      }
      if (props.offset !== void 0) {
        this.offset = props.offset;
      }
      if (props.stride !== void 0) {
        this.stride = props.stride;
      }
      if (props.normalized !== void 0) {
        this.normalized = props.normalized;
      }
      if (props.integer !== void 0) {
        this.integer = props.integer;
      }
      if (props.divisor !== void 0) {
        this.divisor = props.divisor;
      }
      if (props.buffer !== void 0) {
        this.buffer = props.buffer;
      }
      if (props.index !== void 0) {
        if (typeof props.index === "boolean") {
          this.index = props.index ? 1 : 0;
        } else {
          this.index = props.index;
        }
      }
      if (props.instanced !== void 0) {
        this.divisor = props.instanced ? 1 : 0;
      }
      if (props.isInstanced !== void 0) {
        this.divisor = props.isInstanced ? 1 : 0;
      }
      return this;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js
  var DEBUG_DATA_LENGTH = 10;
  var DEPRECATED_PROPS = {
    offset: "accessor.offset",
    stride: "accessor.stride",
    type: "accessor.type",
    size: "accessor.size",
    divisor: "accessor.divisor",
    normalized: "accessor.normalized",
    integer: "accessor.integer",
    instanced: "accessor.divisor",
    isInstanced: "accessor.divisor"
  };
  var PROP_CHECKS_INITIALIZE = {
    removedProps: {},
    replacedProps: {
      bytes: "byteLength"
    },
    deprecatedProps: DEPRECATED_PROPS
  };
  var PROP_CHECKS_SET_PROPS = {
    removedProps: DEPRECATED_PROPS
  };
  var Buffer2 = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Buffer";
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, props);
      this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]);
      this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
      this.initialize(props);
      Object.seal(this);
    }
    getElementCount() {
      let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));
    }
    getVertexCount() {
      let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }
      if (Number.isFinite(props)) {
        props = {
          byteLength: props
        };
      }
      props = checkProps("Buffer", props, PROP_CHECKS_INITIALIZE);
      this.usage = props.usage || 35044;
      this.debugData = null;
      this.setAccessor(Object.assign({}, props, props.accessor));
      if (props.data) {
        this._setData(props.data, props.offset, props.byteLength);
      } else {
        this._setByteLength(props.byteLength || 0);
      }
      return this;
    }
    setProps(props) {
      props = checkProps("Buffer", props, PROP_CHECKS_SET_PROPS);
      if ("accessor" in props) {
        this.setAccessor(props.accessor);
      }
      return this;
    }
    setAccessor(accessor) {
      accessor = Object.assign({}, accessor);
      delete accessor.buffer;
      this.accessor = new Accessor(accessor);
      return this;
    }
    reallocate(byteLength) {
      if (byteLength > this.byteLength) {
        this._setByteLength(byteLength);
        return true;
      }
      this.bytesUsed = byteLength;
      return false;
    }
    setData(props) {
      return this.initialize(props);
    }
    subData(props) {
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }
      const {
        data,
        offset = 0,
        srcOffset = 0
      } = props;
      const byteLength = props.byteLength || props.length;
      assert7(data);
      const target = this.gl.webgl2 ? 36663 : this.target;
      this.gl.bindBuffer(target, this.handle);
      if (srcOffset !== 0 || byteLength !== void 0) {
        assertWebGL2Context(this.gl);
        this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
      } else {
        this.gl.bufferSubData(target, offset, data);
      }
      this.gl.bindBuffer(target, null);
      this.debugData = null;
      this._inferType(data);
      return this;
    }
    copyData(_ref) {
      let {
        sourceBuffer,
        readOffset = 0,
        writeOffset = 0,
        size
      } = _ref;
      const {
        gl
      } = this;
      assertWebGL2Context(gl);
      gl.bindBuffer(36662, sourceBuffer.handle);
      gl.bindBuffer(36663, this.handle);
      gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
      gl.bindBuffer(36662, null);
      gl.bindBuffer(36663, null);
      this.debugData = null;
      return this;
    }
    getData() {
      let {
        dstData = null,
        srcByteOffset = 0,
        dstOffset = 0,
        length: length7 = 0
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      assertWebGL2Context(this.gl);
      const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
        clamped: false
      });
      const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);
      const dstElementOffset = dstOffset;
      let dstAvailableElementCount;
      let dstElementCount;
      if (dstData) {
        dstElementCount = dstData.length;
        dstAvailableElementCount = dstElementCount - dstElementOffset;
      } else {
        dstAvailableElementCount = Math.min(sourceAvailableElementCount, length7 || sourceAvailableElementCount);
        dstElementCount = dstElementOffset + dstAvailableElementCount;
      }
      const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
      length7 = length7 || copyElementCount;
      assert7(length7 <= copyElementCount);
      dstData = dstData || new ArrayType(dstElementCount);
      this.gl.bindBuffer(36662, this.handle);
      this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length7);
      this.gl.bindBuffer(36662, null);
      return dstData;
    }
    bind() {
      let {
        target = this.target,
        index = this.accessor && this.accessor.index,
        offset = 0,
        size
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (target === 35345 || target === 35982) {
        if (size !== void 0) {
          this.gl.bindBufferRange(target, index, this.handle, offset, size);
        } else {
          assert7(offset === 0);
          this.gl.bindBufferBase(target, index, this.handle);
        }
      } else {
        this.gl.bindBuffer(target, this.handle);
      }
      return this;
    }
    unbind() {
      let {
        target = this.target,
        index = this.accessor && this.accessor.index
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const isIndexedBuffer = target === 35345 || target === 35982;
      if (isIndexedBuffer) {
        this.gl.bindBufferBase(target, index, null);
      } else {
        this.gl.bindBuffer(target, null);
      }
      return this;
    }
    getDebugData() {
      if (!this.debugData) {
        this.debugData = this.getData({
          length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)
        });
        return {
          data: this.debugData,
          changed: true
        };
      }
      return {
        data: this.debugData,
        changed: false
      };
    }
    invalidateDebugData() {
      this.debugData = null;
    }
    _setData(data) {
      let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      let byteLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : data.byteLength + offset;
      assert7(ArrayBuffer.isView(data));
      this._trackDeallocatedMemory();
      const target = this._getTarget();
      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, byteLength, this.usage);
      this.gl.bufferSubData(target, offset, data);
      this.gl.bindBuffer(target, null);
      this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
      this.bytesUsed = byteLength;
      this._trackAllocatedMemory(byteLength);
      const type = getGLTypeFromTypedArray(data);
      assert7(type);
      this.setAccessor(new Accessor(this.accessor, {
        type
      }));
      return this;
    }
    _setByteLength(byteLength) {
      let usage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.usage;
      assert7(byteLength >= 0);
      this._trackDeallocatedMemory();
      let data = byteLength;
      if (byteLength === 0) {
        data = new Float32Array(0);
      }
      const target = this._getTarget();
      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, data, usage);
      this.gl.bindBuffer(target, null);
      this.usage = usage;
      this.debugData = null;
      this.bytesUsed = byteLength;
      this._trackAllocatedMemory(byteLength);
      return this;
    }
    _getTarget() {
      return this.gl.webgl2 ? 36663 : this.target;
    }
    _getAvailableElementCount(srcByteOffset) {
      const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
        clamped: false
      });
      const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
      return this.getElementCount() - sourceElementOffset;
    }
    _inferType(data) {
      if (!this.accessor.type) {
        this.setAccessor(new Accessor(this.accessor, {
          type: getGLTypeFromTypedArray(data)
        }));
      }
    }
    _createHandle() {
      return this.gl.createBuffer();
    }
    _deleteHandle() {
      this.gl.deleteBuffer(this.handle);
      this._trackDeallocatedMemory();
    }
    _getParameter(pname) {
      this.gl.bindBuffer(this.target, this.handle);
      const value = this.gl.getBufferParameter(this.target, pname);
      this.gl.bindBuffer(this.target, null);
      return value;
    }
    get type() {
      log2.deprecated("Buffer.type", "Buffer.accessor.type")();
      return this.accessor.type;
    }
    get bytes() {
      log2.deprecated("Buffer.bytes", "Buffer.byteLength")();
      return this.byteLength;
    }
    setByteLength(byteLength) {
      log2.deprecated("setByteLength", "reallocate")();
      return this.reallocate(byteLength);
    }
    updateAccessor(opts) {
      log2.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")();
      this.accessor = new Accessor(this.accessor, opts);
      return this;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js
  var TEXTURE_FORMATS = {
    [6407]: {
      dataFormat: 6407,
      types: [5121, 33635]
    },
    [6408]: {
      dataFormat: 6408,
      types: [5121, 32819, 32820]
    },
    [6406]: {
      dataFormat: 6406,
      types: [5121]
    },
    [6409]: {
      dataFormat: 6409,
      types: [5121]
    },
    [6410]: {
      dataFormat: 6410,
      types: [5121]
    },
    [33326]: {
      dataFormat: 6403,
      types: [5126],
      gl2: true
    },
    [33328]: {
      dataFormat: 33319,
      types: [5126],
      gl2: true
    },
    [34837]: {
      dataFormat: 6407,
      types: [5126],
      gl2: true
    },
    [34836]: {
      dataFormat: 6408,
      types: [5126],
      gl2: true
    }
  };
  var DATA_FORMAT_CHANNELS = {
    [6403]: 1,
    [36244]: 1,
    [33319]: 2,
    [33320]: 2,
    [6407]: 3,
    [36248]: 3,
    [6408]: 4,
    [36249]: 4,
    [6402]: 1,
    [34041]: 1,
    [6406]: 1,
    [6409]: 1,
    [6410]: 2
  };
  var TYPE_SIZES = {
    [5126]: 4,
    [5125]: 4,
    [5124]: 4,
    [5123]: 2,
    [5122]: 2,
    [5131]: 2,
    [5120]: 1,
    [5121]: 1
  };
  function isFormatSupported(gl, format) {
    const info = TEXTURE_FORMATS[format];
    if (!info) {
      return false;
    }
    if (info.gl1 === void 0 && info.gl2 === void 0) {
      return true;
    }
    const value = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
    return typeof value === "string" ? gl.getExtension(value) : value;
  }
  function isLinearFilteringSupported(gl, format) {
    const info = TEXTURE_FORMATS[format];
    switch (info && info.types[0]) {
      case 5126:
        return gl.getExtension("OES_texture_float_linear");
      case 5131:
        return gl.getExtension("OES_texture_half_float_linear");
      default:
        return true;
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js
  var NPOT_MIN_FILTERS = [9729, 9728];
  var WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer2() {
  };
  var Texture = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Texture";
    }
    static isSupported(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        format,
        linearFiltering
      } = opts;
      let supported = true;
      if (format) {
        supported = supported && isFormatSupported(gl, format);
        supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));
      }
      return supported;
    }
    constructor(gl, props) {
      const {
        id = uid("texture"),
        handle,
        target
      } = props;
      super(gl, {
        id,
        handle
      });
      this.target = target;
      this.textureUnit = void 0;
      this.loaded = false;
      this.width = void 0;
      this.height = void 0;
      this.depth = void 0;
      this.format = void 0;
      this.type = void 0;
      this.dataFormat = void 0;
      this.border = void 0;
      this.textureUnit = void 0;
      this.mipmaps = void 0;
    }
    toString() {
      return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let data = props.data;
      if (data instanceof Promise) {
        data.then((resolvedImageData) => this.initialize(Object.assign({}, props, {
          pixels: resolvedImageData,
          data: resolvedImageData
        })));
        return this;
      }
      const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
      if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
        this._video = null;
        data.addEventListener("loadeddata", () => this.initialize(props));
        return this;
      }
      const {
        pixels = null,
        format = 6408,
        border = 0,
        recreate = false,
        parameters: parameters2 = {},
        pixelStore = {},
        textureUnit = void 0
      } = props;
      if (!data) {
        data = pixels;
      }
      let {
        width,
        height,
        dataFormat,
        type,
        compressed = false,
        mipmaps = true
      } = props;
      const {
        depth = 0
      } = props;
      ({
        width,
        height,
        compressed,
        dataFormat,
        type
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.format = format;
      this.type = type;
      this.dataFormat = dataFormat;
      this.border = border;
      this.textureUnit = textureUnit;
      if (Number.isFinite(this.textureUnit)) {
        this.gl.activeTexture(33984 + this.textureUnit);
        this.gl.bindTexture(this.target, this.handle);
      }
      if (mipmaps && this._isNPOT()) {
        log2.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
        mipmaps = false;
        this._updateForNPOT(parameters2);
      }
      this.mipmaps = mipmaps;
      this.setImageData({
        data,
        width,
        height,
        depth,
        format,
        type,
        dataFormat,
        border,
        mipmaps,
        parameters: pixelStore,
        compressed
      });
      if (mipmaps) {
        this.generateMipmap();
      }
      this.setParameters(parameters2);
      if (recreate) {
        this.data = data;
      }
      if (isVideo) {
        this._video = {
          video: data,
          parameters: parameters2,
          lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
        };
      }
      return this;
    }
    update() {
      if (this._video) {
        const {
          video,
          parameters: parameters2,
          lastTime
        } = this._video;
        if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
          return;
        }
        this.setSubImageData({
          data: video,
          parameters: parameters2
        });
        if (this.mipmaps) {
          this.generateMipmap();
        }
        this._video.lastTime = video.currentTime;
      }
    }
    resize(_ref) {
      let {
        height,
        width,
        mipmaps = false
      } = _ref;
      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width,
          height,
          format: this.format,
          type: this.type,
          dataFormat: this.dataFormat,
          border: this.border,
          mipmaps
        });
      }
      return this;
    }
    generateMipmap() {
      let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this._isNPOT()) {
        log2.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
        return this;
      }
      this.mipmaps = true;
      this.gl.bindTexture(this.target, this.handle);
      withParameters(this.gl, params, () => {
        this.gl.generateMipmap(this.target);
      });
      this.gl.bindTexture(this.target, null);
      return this;
    }
    setImageData(options) {
      this._trackDeallocatedMemory("Texture");
      const {
        target = this.target,
        pixels = null,
        level = 0,
        format = this.format,
        border = this.border,
        offset = 0,
        parameters: parameters2 = {}
      } = options;
      let {
        data = null,
        type = this.type,
        width = this.width,
        height = this.height,
        dataFormat = this.dataFormat,
        compressed = false
      } = options;
      if (!data) {
        data = pixels;
      }
      ({
        type,
        dataFormat,
        compressed,
        width,
        height
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      const {
        gl
      } = this;
      gl.bindTexture(this.target, this.handle);
      let dataType = null;
      ({
        data,
        dataType
      } = this._getDataType({
        data,
        compressed
      }));
      let gl2;
      let compressedTextureSize = 0;
      withParameters(this.gl, parameters2, () => {
        switch (dataType) {
          case "null":
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
            break;
          case "typed-array":
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
            break;
          case "buffer":
            gl2 = assertWebGL2Context(gl);
            gl2.bindBuffer(35052, data.handle || data);
            gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
            gl2.bindBuffer(35052, null);
            break;
          case "browser-object":
            if (isWebGL2(gl)) {
              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
            } else {
              gl.texImage2D(target, level, format, dataFormat, type, data);
            }
            break;
          case "compressed":
            for (const [levelIndex, levelData] of data.entries()) {
              gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
              compressedTextureSize += levelData.levelSize;
            }
            break;
          default:
            assert7(false, "Unknown image data type");
        }
      });
      if (dataType === "compressed") {
        this._trackAllocatedMemory(compressedTextureSize, "Texture");
      } else if (data && data.byteLength) {
        this._trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
        const channelSize = TYPE_SIZES[this.type] || 1;
        this._trackAllocatedMemory(this.width * this.height * channels * channelSize, "Texture");
      }
      this.loaded = true;
      return this;
    }
    setSubImageData(_ref2) {
      let {
        target = this.target,
        pixels = null,
        data = null,
        x: x2 = 0,
        y: y2 = 0,
        width = this.width,
        height = this.height,
        level = 0,
        format = this.format,
        type = this.type,
        dataFormat = this.dataFormat,
        compressed = false,
        offset = 0,
        border = this.border,
        parameters: parameters2 = {}
      } = _ref2;
      ({
        type,
        dataFormat,
        compressed,
        width,
        height
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      assert7(this.depth === 0, "texSubImage not supported for 3D textures");
      if (!data) {
        data = pixels;
      }
      if (data && data.data) {
        const ndarray = data;
        data = ndarray.data;
        width = ndarray.shape[0];
        height = ndarray.shape[1];
      }
      if (data instanceof Buffer2) {
        data = data.handle;
      }
      this.gl.bindTexture(this.target, this.handle);
      withParameters(this.gl, parameters2, () => {
        if (compressed) {
          this.gl.compressedTexSubImage2D(target, level, x2, y2, width, height, format, data);
        } else if (data === null) {
          this.gl.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, null);
        } else if (ArrayBuffer.isView(data)) {
          this.gl.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, data, offset);
        } else if (data instanceof WebGLBuffer) {
          const gl2 = assertWebGL2Context(this.gl);
          gl2.bindBuffer(35052, data);
          gl2.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, offset);
          gl2.bindBuffer(35052, null);
        } else if (isWebGL2(this.gl)) {
          const gl2 = assertWebGL2Context(this.gl);
          gl2.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, data);
        } else {
          this.gl.texSubImage2D(target, level, x2, y2, dataFormat, type, data);
        }
      });
      this.gl.bindTexture(this.target, null);
    }
    copyFramebuffer() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
      return null;
    }
    getActiveUnit() {
      return this.gl.getParameter(34016) - 33984;
    }
    bind() {
      let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
      const {
        gl
      } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, this.handle);
      return textureUnit;
    }
    unbind() {
      let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
      const {
        gl
      } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, null);
      return textureUnit;
    }
    _getDataType(_ref3) {
      let {
        data,
        compressed = false
      } = _ref3;
      if (compressed) {
        return {
          data,
          dataType: "compressed"
        };
      }
      if (data === null) {
        return {
          data,
          dataType: "null"
        };
      }
      if (ArrayBuffer.isView(data)) {
        return {
          data,
          dataType: "typed-array"
        };
      }
      if (data instanceof Buffer2) {
        return {
          data: data.handle,
          dataType: "buffer"
        };
      }
      if (data instanceof WebGLBuffer) {
        return {
          data,
          dataType: "buffer"
        };
      }
      return {
        data,
        dataType: "browser-object"
      };
    }
    _deduceParameters(opts) {
      const {
        format,
        data
      } = opts;
      let {
        width,
        height,
        dataFormat,
        type,
        compressed
      } = opts;
      const textureFormat = TEXTURE_FORMATS[format];
      dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
      type = type || textureFormat && textureFormat.types[0];
      compressed = compressed || textureFormat && textureFormat.compressed;
      ({
        width,
        height
      } = this._deduceImageSize(data, width, height));
      return {
        dataFormat,
        type,
        compressed,
        width,
        height,
        format,
        data
      };
    }
    _deduceImageSize(data, width, height) {
      let size;
      if (typeof ImageData !== "undefined" && data instanceof ImageData) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
        size = {
          width: data.naturalWidth,
          height: data.naturalHeight
        };
      } else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
        size = {
          width: data.videoWidth,
          height: data.videoHeight
        };
      } else if (!data) {
        size = {
          width: width >= 0 ? width : 1,
          height: height >= 0 ? height : 1
        };
      } else {
        size = {
          width,
          height
        };
      }
      assert7(size, "Could not deduced texture size");
      assert7(width === void 0 || size.width === width, "Deduced texture width does not match supplied width");
      assert7(height === void 0 || size.height === height, "Deduced texture height does not match supplied height");
      return size;
    }
    _createHandle() {
      return this.gl.createTexture();
    }
    _deleteHandle() {
      this.gl.deleteTexture(this.handle);
      this._trackDeallocatedMemory("Texture");
    }
    _getParameter(pname) {
      switch (pname) {
        case 4096:
          return this.width;
        case 4097:
          return this.height;
        default:
          this.gl.bindTexture(this.target, this.handle);
          const value = this.gl.getTexParameter(this.target, pname);
          this.gl.bindTexture(this.target, null);
          return value;
      }
    }
    _setParameter(pname, param) {
      this.gl.bindTexture(this.target, this.handle);
      param = this._getNPOTParam(pname, param);
      switch (pname) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.handle, pname, param);
          break;
        case 4096:
        case 4097:
          assert7(false);
          break;
        default:
          this.gl.texParameteri(this.target, pname, param);
          break;
      }
      this.gl.bindTexture(this.target, null);
      return this;
    }
    _isNPOT() {
      if (isWebGL2(this.gl)) {
        return false;
      }
      if (!this.width || !this.height) {
        return false;
      }
      return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);
    }
    _updateForNPOT(parameters2) {
      if (parameters2[this.gl.TEXTURE_MIN_FILTER] === void 0) {
        parameters2[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
      }
      if (parameters2[this.gl.TEXTURE_WRAP_S] === void 0) {
        parameters2[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
      }
      if (parameters2[this.gl.TEXTURE_WRAP_T] === void 0) {
        parameters2[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
      }
    }
    _getNPOTParam(pname, param) {
      if (this._isNPOT()) {
        switch (pname) {
          case 10241:
            if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
              param = 9729;
            }
            break;
          case 10242:
          case 10243:
            if (param !== 33071) {
              param = 33071;
            }
            break;
          default:
            break;
        }
      }
      return param;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js
  var pathPrefix2 = "";
  function loadImage(url, opts) {
    assert7(typeof url === "string");
    url = pathPrefix2 + url;
    return new Promise((resolve2, reject) => {
      try {
        const image = new Image();
        image.onload = () => resolve2(image);
        image.onerror = () => reject(new Error("Could not load image ".concat(url, ".")));
        image.crossOrigin = opts && opts.crossOrigin || "anonymous";
        image.src = url;
      } catch (error2) {
        reject(error2);
      }
    });
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js
  var Texture2D = class extends Texture {
    get [Symbol.toStringTag]() {
      return "Texture2D";
    }
    static isSupported(gl, opts) {
      return Texture.isSupported(gl, opts);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGLContext(gl);
      if (props instanceof Promise || typeof props === "string") {
        props = {
          data: props
        };
      }
      if (typeof props.data === "string") {
        props = Object.assign({}, props, {
          data: loadImage(props.data)
        });
      }
      super(gl, Object.assign({}, props, {
        target: 3553
      }));
      this.initialize(props);
      Object.seal(this);
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js
  var FACES = [34069, 34070, 34071, 34072, 34073, 34074];
  var TextureCube = class extends Texture {
    get [Symbol.toStringTag]() {
      return "TextureCube";
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGLContext(gl);
      super(gl, Object.assign({}, props, {
        target: 34067
      }));
      this.initialize(props);
      Object.seal(this);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        mipmaps = true,
        parameters: parameters2 = {}
      } = props;
      this.opts = props;
      this.setCubeMapImageData(props).then(() => {
        this.loaded = true;
        if (mipmaps) {
          this.generateMipmap(props);
        }
        this.setParameters(parameters2);
      });
      return this;
    }
    subImage(_ref) {
      let {
        face,
        data,
        x: x2 = 0,
        y: y2 = 0,
        mipmapLevel = 0
      } = _ref;
      return this._subImage({
        target: face,
        data,
        x: x2,
        y: y2,
        mipmapLevel
      });
    }
    async setCubeMapImageData(_ref2) {
      let {
        width,
        height,
        pixels,
        data,
        border = 0,
        format = 6408,
        type = 5121
      } = _ref2;
      const {
        gl
      } = this;
      const imageDataMap = pixels || data;
      const resolvedFaces = await Promise.all(FACES.map((face) => {
        const facePixels = imageDataMap[face];
        return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
      }));
      this.bind();
      FACES.forEach((face, index) => {
        if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {
          log2.warn("".concat(this.id, " has mipmap and multiple LODs."))();
        }
        resolvedFaces[index].forEach((image, lodLevel) => {
          if (width && height) {
            gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
          } else {
            gl.texImage2D(face, lodLevel, format, format, type, image);
          }
        });
      });
      this.unbind();
    }
    setImageDataForFace(options) {
      const {
        face,
        width,
        height,
        pixels,
        data,
        border = 0,
        format = 6408,
        type = 5121
      } = options;
      const {
        gl
      } = this;
      const imageData = pixels || data;
      this.bind();
      if (imageData instanceof Promise) {
        imageData.then((resolvedImageData) => this.setImageDataForFace(Object.assign({}, options, {
          face,
          data: resolvedImageData,
          pixels: resolvedImageData
        })));
      } else if (this.width || this.height) {
        gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
      } else {
        gl.texImage2D(face, 0, format, format, type, imageData);
      }
      return this;
    }
  };
  TextureCube.FACES = FACES;

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js
  var Texture3D = class extends Texture {
    get [Symbol.toStringTag]() {
      return "Texture3D";
    }
    static isSupported(gl) {
      return isWebGL2(gl);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGL2Context(gl);
      props = Object.assign({
        depth: 1
      }, props, {
        target: 32879,
        unpackFlipY: false
      });
      super(gl, props);
      this.initialize(props);
      Object.seal(this);
    }
    setImageData(_ref) {
      let {
        level = 0,
        dataFormat = 6408,
        width,
        height,
        depth = 1,
        border = 0,
        format,
        type = 5121,
        offset = 0,
        data,
        parameters: parameters2 = {}
      } = _ref;
      this._trackDeallocatedMemory("Texture");
      this.gl.bindTexture(this.target, this.handle);
      withParameters(this.gl, parameters2, () => {
        if (ArrayBuffer.isView(data)) {
          this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, data);
        }
        if (data instanceof Buffer2) {
          this.gl.bindBuffer(35052, data.handle);
          this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, offset);
        }
      });
      if (data && data.byteLength) {
        this._trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
        const channelSize = TYPE_SIZES[this.type] || 1;
        this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, "Texture");
      }
      this.loaded = true;
      return this;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js
  var EXT_FLOAT_WEBGL2 = "EXT_color_buffer_float";
  var renderbuffer_formats_default = {
    [33189]: {
      bpp: 2
    },
    [33190]: {
      gl2: true,
      bpp: 3
    },
    [36012]: {
      gl2: true,
      bpp: 4
    },
    [36168]: {
      bpp: 1
    },
    [34041]: {
      bpp: 4
    },
    [35056]: {
      gl2: true,
      bpp: 4
    },
    [36013]: {
      gl2: true,
      bpp: 5
    },
    [32854]: {
      bpp: 2
    },
    [36194]: {
      bpp: 2
    },
    [32855]: {
      bpp: 2
    },
    [33321]: {
      gl2: true,
      bpp: 1
    },
    [33330]: {
      gl2: true,
      bpp: 1
    },
    [33329]: {
      gl2: true,
      bpp: 1
    },
    [33332]: {
      gl2: true,
      bpp: 2
    },
    [33331]: {
      gl2: true,
      bpp: 2
    },
    [33334]: {
      gl2: true,
      bpp: 4
    },
    [33333]: {
      gl2: true,
      bpp: 4
    },
    [33323]: {
      gl2: true,
      bpp: 2
    },
    [33336]: {
      gl2: true,
      bpp: 2
    },
    [33335]: {
      gl2: true,
      bpp: 2
    },
    [33338]: {
      gl2: true,
      bpp: 4
    },
    [33337]: {
      gl2: true,
      bpp: 4
    },
    [33340]: {
      gl2: true,
      bpp: 8
    },
    [33339]: {
      gl2: true,
      bpp: 8
    },
    [32849]: {
      gl2: true,
      bpp: 3
    },
    [32856]: {
      gl2: true,
      bpp: 4
    },
    [32857]: {
      gl2: true,
      bpp: 4
    },
    [36220]: {
      gl2: true,
      bpp: 4
    },
    [36238]: {
      gl2: true,
      bpp: 4
    },
    [36975]: {
      gl2: true,
      bpp: 4
    },
    [36214]: {
      gl2: true,
      bpp: 8
    },
    [36232]: {
      gl2: true,
      bpp: 8
    },
    [36226]: {
      gl2: true,
      bpp: 16
    },
    [36208]: {
      gl2: true,
      bpp: 16
    },
    [33325]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 2
    },
    [33327]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    },
    [34842]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 8
    },
    [33326]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    },
    [33328]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 8
    },
    [34836]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 16
    },
    [35898]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js
  function isFormatSupported2(gl, format, formats2) {
    const info = formats2[format];
    if (!info) {
      return false;
    }
    const value = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
    if (typeof value === "string") {
      return gl.getExtension(value);
    }
    return value;
  }
  var Renderbuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Renderbuffer";
    }
    static isSupported(gl) {
      let {
        format
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        format: null
      };
      return !format || isFormatSupported2(gl, format, renderbuffer_formats_default);
    }
    static getSamplesForFormat(gl, _ref) {
      let {
        format
      } = _ref;
      return gl.getInternalformatParameter(36161, format, 32937);
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, opts);
      this.initialize(opts);
      Object.seal(this);
    }
    initialize(_ref2) {
      let {
        format,
        width = 1,
        height = 1,
        samples = 0
      } = _ref2;
      assert7(format, "Needs format");
      this._trackDeallocatedMemory();
      this.gl.bindRenderbuffer(36161, this.handle);
      if (samples !== 0 && isWebGL2(this.gl)) {
        this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
      } else {
        this.gl.renderbufferStorage(36161, format, width, height);
      }
      this.format = format;
      this.width = width;
      this.height = height;
      this.samples = samples;
      this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * renderbuffer_formats_default[this.format].bpp);
      return this;
    }
    resize(_ref3) {
      let {
        width,
        height
      } = _ref3;
      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width,
          height,
          format: this.format,
          samples: this.samples
        });
      }
      return this;
    }
    _createHandle() {
      return this.gl.createRenderbuffer();
    }
    _deleteHandle() {
      this.gl.deleteRenderbuffer(this.handle);
      this._trackDeallocatedMemory();
    }
    _bindHandle(handle) {
      this.gl.bindRenderbuffer(36161, handle);
    }
    _syncHandle(handle) {
      this.format = this.getParameter(36164);
      this.width = this.getParameter(36162);
      this.height = this.getParameter(36163);
      this.samples = this.getParameter(36011);
    }
    _getParameter(pname) {
      this.gl.bindRenderbuffer(36161, this.handle);
      const value = this.gl.getRenderbufferParameter(36161, pname);
      return value;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/clear.js
  var GL_DEPTH_BUFFER_BIT = 256;
  var GL_STENCIL_BUFFER_BIT = 1024;
  var GL_COLOR_BUFFER_BIT = 16384;
  var GL_COLOR = 6144;
  var GL_DEPTH = 6145;
  var GL_STENCIL = 6146;
  var GL_DEPTH_STENCIL = 34041;
  var ERR_ARGUMENTS = "clear: bad arguments";
  function clear(gl) {
    let {
      framebuffer = null,
      color = null,
      depth = null,
      stencil = null
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const parameters2 = {};
    if (framebuffer) {
      parameters2.framebuffer = framebuffer;
    }
    let clearFlags = 0;
    if (color) {
      clearFlags |= GL_COLOR_BUFFER_BIT;
      if (color !== true) {
        parameters2.clearColor = color;
      }
    }
    if (depth) {
      clearFlags |= GL_DEPTH_BUFFER_BIT;
      if (depth !== true) {
        parameters2.clearDepth = depth;
      }
    }
    if (stencil) {
      clearFlags |= GL_STENCIL_BUFFER_BIT;
      if (depth !== true) {
        parameters2.clearStencil = depth;
      }
    }
    assert7(clearFlags !== 0, ERR_ARGUMENTS);
    withParameters(gl, parameters2, () => {
      gl.clear(clearFlags);
    });
  }
  function clearBuffer(gl) {
    let {
      framebuffer = null,
      buffer = GL_COLOR,
      drawBuffer = 0,
      value = [0, 0, 0, 0]
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    assertWebGL2Context(gl);
    withParameters(gl, {
      framebuffer
    }, () => {
      switch (buffer) {
        case GL_COLOR:
          switch (value.constructor) {
            case Int32Array:
              gl.clearBufferiv(buffer, drawBuffer, value);
              break;
            case Uint32Array:
              gl.clearBufferuiv(buffer, drawBuffer, value);
              break;
            case Float32Array:
            default:
              gl.clearBufferfv(buffer, drawBuffer, value);
          }
          break;
        case GL_DEPTH:
          gl.clearBufferfv(GL_DEPTH, 0, [value]);
          break;
        case GL_STENCIL:
          gl.clearBufferiv(GL_STENCIL, 0, [value]);
          break;
        case GL_DEPTH_STENCIL:
          const [depth, stencil] = value;
          gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
          break;
        default:
          assert7(false, ERR_ARGUMENTS);
      }
    });
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js
  function glFormatToComponents(format) {
    switch (format) {
      case 6406:
      case 33326:
      case 6403:
        return 1;
      case 33328:
      case 33319:
        return 2;
      case 6407:
      case 34837:
        return 3;
      case 6408:
      case 34836:
        return 4;
      default:
        assert7(false);
        return 0;
    }
  }
  function glTypeToBytes(type) {
    switch (type) {
      case 5121:
        return 1;
      case 33635:
      case 32819:
      case 32820:
        return 2;
      case 5126:
        return 4;
      default:
        assert7(false);
        return 0;
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js
  function readPixelsToArray(source) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      sourceX = 0,
      sourceY = 0,
      sourceFormat = 6408
    } = options;
    let {
      sourceAttachment = 36064,
      target = null,
      sourceWidth,
      sourceHeight,
      sourceType
    } = options;
    const {
      framebuffer,
      deleteFramebuffer
    } = getFramebuffer(source);
    assert7(framebuffer);
    const {
      gl,
      handle,
      attachments
    } = framebuffer;
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    if (sourceAttachment === 36064 && handle === null) {
      sourceAttachment = 1028;
    }
    assert7(attachments[sourceAttachment]);
    sourceType = sourceType || attachments[sourceAttachment].type;
    target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
    sourceType = sourceType || getGLTypeFromTypedArray(target);
    const prevHandle = gl.bindFramebuffer(36160, handle);
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
      framebuffer.delete();
    }
    return target;
  }
  function readPixelsToBuffer(source, _ref) {
    let {
      sourceX = 0,
      sourceY = 0,
      sourceFormat = 6408,
      target = null,
      targetByteOffset = 0,
      sourceWidth,
      sourceHeight,
      sourceType
    } = _ref;
    const {
      framebuffer,
      deleteFramebuffer
    } = getFramebuffer(source);
    assert7(framebuffer);
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    const gl2 = assertWebGL2Context(framebuffer.gl);
    sourceType = sourceType || (target ? target.type : 5121);
    if (!target) {
      const components = glFormatToComponents(sourceFormat);
      const byteCount = glTypeToBytes(sourceType);
      const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
      target = new Buffer2(gl2, {
        byteLength,
        accessor: {
          type: sourceType,
          size: components
        }
      });
    }
    target.bind({
      target: 35051
    });
    withParameters(gl2, {
      framebuffer
    }, () => {
      gl2.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);
    });
    target.unbind({
      target: 35051
    });
    if (deleteFramebuffer) {
      framebuffer.delete();
    }
    return target;
  }
  function copyToDataUrl(source) {
    let {
      sourceAttachment = 36064,
      targetMaxHeight = Number.MAX_SAFE_INTEGER
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let data = readPixelsToArray(source, {
      sourceAttachment
    });
    let {
      width,
      height
    } = source;
    while (height > targetMaxHeight) {
      ({
        data,
        width,
        height
      } = scalePixels2({
        data,
        width,
        height
      }));
    }
    flipRows({
      data,
      width,
      height
    });
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext("2d");
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
    return canvas.toDataURL();
  }
  function copyToTexture(source, target) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const {
      sourceX = 0,
      sourceY = 0,
      targetMipmaplevel = 0,
      targetInternalFormat = 6408
    } = options;
    let {
      targetX,
      targetY,
      targetZ,
      width,
      height
    } = options;
    const {
      framebuffer,
      deleteFramebuffer
    } = getFramebuffer(source);
    assert7(framebuffer);
    const {
      gl,
      handle
    } = framebuffer;
    const isSubCopy = typeof targetX !== "undefined" || typeof targetY !== "undefined" || typeof targetZ !== "undefined";
    targetX = targetX || 0;
    targetY = targetY || 0;
    targetZ = targetZ || 0;
    const prevHandle = gl.bindFramebuffer(36160, handle);
    assert7(target);
    let texture = null;
    if (target instanceof Texture) {
      texture = target;
      width = Number.isFinite(width) ? width : texture.width;
      height = Number.isFinite(height) ? height : texture.height;
      texture.bind(0);
      target = texture.target;
    }
    if (!isSubCopy) {
      gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
    } else {
      switch (target) {
        case 3553:
        case 34067:
          gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
          break;
        case 35866:
        case 32879:
          const gl2 = assertWebGL2Context(gl);
          gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
          break;
        default:
      }
    }
    if (texture) {
      texture.unbind();
    }
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
      framebuffer.delete();
    }
    return texture;
  }
  function getFramebuffer(source) {
    if (!(source instanceof Framebuffer)) {
      return {
        framebuffer: toFramebuffer(source),
        deleteFramebuffer: true
      };
    }
    return {
      framebuffer: source,
      deleteFramebuffer: false
    };
  }
  function getPixelArray(pixelArray, type, format, width, height) {
    if (pixelArray) {
      return pixelArray;
    }
    type = type || 5121;
    const ArrayType = getTypedArrayFromGLType(type, {
      clamped: false
    });
    const components = glFormatToComponents(format);
    return new ArrayType(width * height * components);
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js
  var FEATURES = {
    WEBGL2: "WEBGL2",
    VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
    TIMER_QUERY: "TIMER_QUERY",
    INSTANCED_RENDERING: "INSTANCED_RENDERING",
    MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
    ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
    BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
    FLOAT_BLEND: "FLOAT_BLEND",
    COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
    TEXTURE_DEPTH: "TEXTURE_DEPTH",
    TEXTURE_FLOAT: "TEXTURE_FLOAT",
    TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
    TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
    TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
    TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
    COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
    COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
    COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
    GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
    GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
    GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
    GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
  };
  function checkFloat32ColorAttachment(gl) {
    const testTexture = new Texture2D(gl, {
      format: 6408,
      type: 5126,
      dataFormat: 6408
    });
    const testFb = new Framebuffer(gl, {
      id: "test-framebuffer",
      check: false,
      attachments: {
        [36064]: testTexture
      }
    });
    const status = testFb.getStatus();
    testTexture.delete();
    testFb.delete();
    return status === 36053;
  }
  var webgl_features_table_default = {
    [FEATURES.WEBGL2]: [false, true],
    [FEATURES.VERTEX_ARRAY_OBJECT]: ["OES_vertex_array_object", true],
    [FEATURES.TIMER_QUERY]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
    [FEATURES.INSTANCED_RENDERING]: ["ANGLE_instanced_arrays", true],
    [FEATURES.MULTIPLE_RENDER_TARGETS]: ["WEBGL_draw_buffers", true],
    [FEATURES.ELEMENT_INDEX_UINT32]: ["OES_element_index_uint", true],
    [FEATURES.BLEND_EQUATION_MINMAX]: ["EXT_blend_minmax", true],
    [FEATURES.FLOAT_BLEND]: ["EXT_float_blend"],
    [FEATURES.COLOR_ENCODING_SRGB]: ["EXT_sRGB", true],
    [FEATURES.TEXTURE_DEPTH]: ["WEBGL_depth_texture", true],
    [FEATURES.TEXTURE_FLOAT]: ["OES_texture_float", true],
    [FEATURES.TEXTURE_HALF_FLOAT]: ["OES_texture_half_float", true],
    [FEATURES.TEXTURE_FILTER_LINEAR_FLOAT]: ["OES_texture_float_linear"],
    [FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ["OES_texture_half_float_linear"],
    [FEATURES.TEXTURE_FILTER_ANISOTROPIC]: ["EXT_texture_filter_anisotropic"],
    [FEATURES.COLOR_ATTACHMENT_RGBA32F]: [checkFloat32ColorAttachment, "EXT_color_buffer_float"],
    [FEATURES.COLOR_ATTACHMENT_FLOAT]: [false, "EXT_color_buffer_float"],
    [FEATURES.COLOR_ATTACHMENT_HALF_FLOAT]: ["EXT_color_buffer_half_float"],
    [FEATURES.GLSL_FRAG_DATA]: ["WEBGL_draw_buffers", true],
    [FEATURES.GLSL_FRAG_DEPTH]: ["EXT_frag_depth", true],
    [FEATURES.GLSL_DERIVATIVES]: ["OES_standard_derivatives", true],
    [FEATURES.GLSL_TEXTURE_LOD]: ["EXT_shader_texture_lod", true]
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/features/features.js
  var LOG_UNSUPPORTED_FEATURE = 2;
  function hasFeature(gl, feature) {
    return hasFeatures(gl, feature);
  }
  function hasFeatures(gl, features) {
    features = Array.isArray(features) ? features : [features];
    return features.every((feature) => {
      return isFeatureSupported(gl, feature);
    });
  }
  function getFeatures(gl) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    for (const cap in webgl_features_table_default) {
      if (gl.luma.caps[cap] === void 0) {
        gl.luma.caps[cap] = isFeatureSupported(gl, cap);
      }
    }
    return gl.luma.caps;
  }
  function isFeatureSupported(gl, cap) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    if (gl.luma.caps[cap] === void 0) {
      gl.luma.caps[cap] = queryFeature(gl, cap);
    }
    if (!gl.luma.caps[cap]) {
      log2.log(LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
    }
    return gl.luma.caps[cap];
  }
  function queryFeature(gl, cap) {
    const feature = webgl_features_table_default[cap];
    assert7(feature, cap);
    let isSupported;
    const featureDefinition = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
    if (typeof featureDefinition === "function") {
      isSupported = featureDefinition(gl);
    } else if (Array.isArray(featureDefinition)) {
      isSupported = true;
      for (const extension of featureDefinition) {
        isSupported = isSupported && Boolean(gl.getExtension(extension));
      }
    } else if (typeof featureDefinition === "string") {
      isSupported = Boolean(gl.getExtension(featureDefinition));
    } else if (typeof featureDefinition === "boolean") {
      isSupported = featureDefinition;
    } else {
      assert7(false);
    }
    return isSupported;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js
  var ERR_MULTIPLE_RENDERTARGETS = "Multiple render targets not supported";
  var Framebuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Framebuffer";
    }
    static isSupported(gl) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        colorBufferFloat,
        colorBufferHalfFloat
      } = options;
      let supported = true;
      if (colorBufferFloat) {
        supported = Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float") || gl.getExtension("OES_texture_float"));
      }
      if (colorBufferHalfFloat) {
        supported = supported && Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float"));
      }
      return supported;
    }
    static getDefaultFramebuffer(gl) {
      gl.luma = gl.luma || {};
      gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {
        id: "default-framebuffer",
        handle: null,
        attachments: {}
      });
      return gl.luma.defaultFramebuffer;
    }
    get MAX_COLOR_ATTACHMENTS() {
      const gl2 = assertWebGL2Context(this.gl);
      return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
    }
    get MAX_DRAW_BUFFERS() {
      const gl2 = assertWebGL2Context(this.gl);
      return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, opts);
      this.width = null;
      this.height = null;
      this.attachments = {};
      this.readBuffer = 36064;
      this.drawBuffers = [36064];
      this.ownResources = [];
      this.initialize(opts);
      Object.seal(this);
    }
    get color() {
      return this.attachments[36064] || null;
    }
    get texture() {
      return this.attachments[36064] || null;
    }
    get depth() {
      return this.attachments[36096] || this.attachments[33306] || null;
    }
    get stencil() {
      return this.attachments[36128] || this.attachments[33306] || null;
    }
    initialize(_ref) {
      let {
        width = 1,
        height = 1,
        attachments = null,
        color = true,
        depth = true,
        stencil = false,
        check = true,
        readBuffer = void 0,
        drawBuffers = void 0
      } = _ref;
      assert7(width >= 0 && height >= 0, "Width and height need to be integers");
      this.width = width;
      this.height = height;
      if (attachments) {
        for (const attachment in attachments) {
          const target = attachments[attachment];
          const object = Array.isArray(target) ? target[0] : target;
          object.resize({
            width,
            height
          });
        }
      } else {
        attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
      }
      this.update({
        clearAttachments: true,
        attachments,
        readBuffer,
        drawBuffers
      });
      if (attachments && check) {
        this.checkStatus();
      }
    }
    delete() {
      for (const resource of this.ownResources) {
        resource.delete();
      }
      super.delete();
      return this;
    }
    update(_ref2) {
      let {
        attachments = {},
        readBuffer,
        drawBuffers,
        clearAttachments = false,
        resizeAttachments = true
      } = _ref2;
      this.attach(attachments, {
        clearAttachments,
        resizeAttachments
      });
      const {
        gl
      } = this;
      const prevHandle = gl.bindFramebuffer(36160, this.handle);
      if (readBuffer) {
        this._setReadBuffer(readBuffer);
      }
      if (drawBuffers) {
        this._setDrawBuffers(drawBuffers);
      }
      gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
    resize() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let {
        width,
        height
      } = options;
      if (this.handle === null) {
        assert7(width === void 0 && height === void 0);
        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        return this;
      }
      if (width === void 0) {
        width = this.gl.drawingBufferWidth;
      }
      if (height === void 0) {
        height = this.gl.drawingBufferHeight;
      }
      if (width !== this.width && height !== this.height) {
        log2.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
      }
      for (const attachmentPoint in this.attachments) {
        this.attachments[attachmentPoint].resize({
          width,
          height
        });
      }
      this.width = width;
      this.height = height;
      return this;
    }
    attach(attachments) {
      let {
        clearAttachments = false,
        resizeAttachments = true
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const newAttachments = {};
      if (clearAttachments) {
        Object.keys(this.attachments).forEach((key) => {
          newAttachments[key] = null;
        });
      }
      Object.assign(newAttachments, attachments);
      const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
      for (const key in newAttachments) {
        assert7(key !== void 0, "Misspelled framebuffer binding point?");
        const attachment = Number(key);
        const descriptor = newAttachments[attachment];
        let object = descriptor;
        if (!object) {
          this._unattach(attachment);
        } else if (object instanceof Renderbuffer) {
          this._attachRenderbuffer({
            attachment,
            renderbuffer: object
          });
        } else if (Array.isArray(descriptor)) {
          const [texture, layer = 0, level = 0] = descriptor;
          object = texture;
          this._attachTexture({
            attachment,
            texture,
            layer,
            level
          });
        } else {
          this._attachTexture({
            attachment,
            texture: object,
            layer: 0,
            level: 0
          });
        }
        if (resizeAttachments && object) {
          object.resize({
            width: this.width,
            height: this.height
          });
        }
      }
      this.gl.bindFramebuffer(36160, prevHandle || null);
      Object.assign(this.attachments, attachments);
      Object.keys(this.attachments).filter((key) => !this.attachments[key]).forEach((key) => {
        delete this.attachments[key];
      });
    }
    checkStatus() {
      const {
        gl
      } = this;
      const status = this.getStatus();
      if (status !== 36053) {
        throw new Error(_getFrameBufferStatus(status));
      }
      return this;
    }
    getStatus() {
      const {
        gl
      } = this;
      const prevHandle = gl.bindFramebuffer(36160, this.handle);
      const status = gl.checkFramebufferStatus(36160);
      gl.bindFramebuffer(36160, prevHandle || null);
      return status;
    }
    clear() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        color,
        depth,
        stencil,
        drawBuffers = []
      } = options;
      const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
      if (color || depth || stencil) {
        clear(this.gl, {
          color,
          depth,
          stencil
        });
      }
      drawBuffers.forEach((value, drawBuffer) => {
        clearBuffer(this.gl, {
          drawBuffer,
          value
        });
      });
      this.gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
    readPixels() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")();
      return null;
    }
    readPixelsToBuffer() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")();
      return null;
    }
    copyToDataUrl() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")();
      return null;
    }
    copyToImage() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")();
      return null;
    }
    copyToTexture() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")();
      return null;
    }
    blit() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")();
      return null;
    }
    invalidate(_ref3) {
      let {
        attachments = [],
        x: x2 = 0,
        y: y2 = 0,
        width,
        height
      } = _ref3;
      const gl2 = assertWebGL2Context(this.gl);
      const prevHandle = gl2.bindFramebuffer(36008, this.handle);
      const invalidateAll = x2 === 0 && y2 === 0 && width === void 0 && height === void 0;
      if (invalidateAll) {
        gl2.invalidateFramebuffer(36008, attachments);
      } else {
        gl2.invalidateFramebuffer(36008, attachments, x2, y2, width, height);
      }
      gl2.bindFramebuffer(36008, prevHandle);
      return this;
    }
    getAttachmentParameter(attachment, pname, keys) {
      let value = this._getAttachmentParameterFallback(pname);
      if (value === null) {
        this.gl.bindFramebuffer(36160, this.handle);
        value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
        this.gl.bindFramebuffer(36160, null);
      }
      if (keys && value > 1e3) {
        value = getKey(this.gl, value);
      }
      return value;
    }
    getAttachmentParameters() {
      let attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 36064;
      let keys = arguments.length > 1 ? arguments[1] : void 0;
      let parameters2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
      const values = {};
      for (const pname of parameters2) {
        const key = keys ? getKey(this.gl, pname) : pname;
        values[key] = this.getAttachmentParameter(attachment, pname, keys);
      }
      return values;
    }
    getParameters() {
      let keys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      const attachments = Object.keys(this.attachments);
      const parameters2 = {};
      for (const attachmentName of attachments) {
        const attachment = Number(attachmentName);
        const key = keys ? getKey(this.gl, attachment) : attachment;
        parameters2[key] = this.getAttachmentParameters(attachment, keys);
      }
      return parameters2;
    }
    show() {
      if (typeof window !== "undefined") {
        window.open(copyToDataUrl(this), "luma-debug-texture");
      }
      return this;
    }
    log() {
      let logLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      if (logLevel > log2.level || typeof window === "undefined") {
        return this;
      }
      message = message || "Framebuffer ".concat(this.id);
      const image = copyToDataUrl(this, {
        targetMaxHeight: 100
      });
      log2.image({
        logLevel,
        message,
        image
      }, message)();
      return this;
    }
    bind() {
      let {
        target = 36160
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.gl.bindFramebuffer(target, this.handle);
      return this;
    }
    unbind() {
      let {
        target = 36160
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.gl.bindFramebuffer(target, null);
      return this;
    }
    _createDefaultAttachments(color, depth, stencil, width, height) {
      let defaultAttachments = null;
      if (color) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36064] = new Texture2D(this.gl, {
          id: "".concat(this.id, "-color0"),
          pixels: null,
          format: 6408,
          type: 5121,
          width,
          height,
          mipmaps: false,
          parameters: {
            [10241]: 9729,
            [10240]: 9729,
            [10242]: 33071,
            [10243]: 33071
          }
        });
        this.ownResources.push(defaultAttachments[36064]);
      }
      if (depth && stencil) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[33306] = new Renderbuffer(this.gl, {
          id: "".concat(this.id, "-depth-stencil"),
          format: 35056,
          width,
          height: 111
        });
        this.ownResources.push(defaultAttachments[33306]);
      } else if (depth) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36096] = new Renderbuffer(this.gl, {
          id: "".concat(this.id, "-depth"),
          format: 33189,
          width,
          height
        });
        this.ownResources.push(defaultAttachments[36096]);
      } else if (stencil) {
        assert7(false);
      }
      return defaultAttachments;
    }
    _unattach(attachment) {
      const oldAttachment = this.attachments[attachment];
      if (!oldAttachment) {
        return;
      }
      if (oldAttachment instanceof Renderbuffer) {
        this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
      } else {
        this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
      }
      delete this.attachments[attachment];
    }
    _attachRenderbuffer(_ref4) {
      let {
        attachment = 36064,
        renderbuffer
      } = _ref4;
      const {
        gl
      } = this;
      gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
      this.attachments[attachment] = renderbuffer;
    }
    _attachTexture(_ref5) {
      let {
        attachment = 36064,
        texture,
        layer,
        level
      } = _ref5;
      const {
        gl
      } = this;
      gl.bindTexture(texture.target, texture.handle);
      switch (texture.target) {
        case 35866:
        case 32879:
          const gl2 = assertWebGL2Context(gl);
          gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
          break;
        case 34067:
          const face = mapIndexToCubeMapFace(layer);
          gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
          break;
        case 3553:
          gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
          break;
        default:
          assert7(false, "Illegal texture type");
      }
      gl.bindTexture(texture.target, null);
      this.attachments[attachment] = texture;
    }
    _setReadBuffer(readBuffer) {
      const gl2 = getWebGL2Context(this.gl);
      if (gl2) {
        gl2.readBuffer(readBuffer);
      } else {
        assert7(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
      }
      this.readBuffer = readBuffer;
    }
    _setDrawBuffers(drawBuffers) {
      const {
        gl
      } = this;
      const gl2 = assertWebGL2Context(gl);
      if (gl2) {
        gl2.drawBuffers(drawBuffers);
      } else {
        const ext = gl.getExtension("WEBGL_draw_buffers");
        if (ext) {
          ext.drawBuffersWEBGL(drawBuffers);
        } else {
          assert7(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
        }
      }
      this.drawBuffers = drawBuffers;
    }
    _getAttachmentParameterFallback(pname) {
      const caps = getFeatures(this.gl);
      switch (pname) {
        case 36052:
          return !caps.WEBGL2 ? 0 : null;
        case 33298:
        case 33299:
        case 33300:
        case 33301:
        case 33302:
        case 33303:
          return !caps.WEBGL2 ? 8 : null;
        case 33297:
          return !caps.WEBGL2 ? 5125 : null;
        case 33296:
          return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;
        default:
          return null;
      }
    }
    _createHandle() {
      return this.gl.createFramebuffer();
    }
    _deleteHandle() {
      this.gl.deleteFramebuffer(this.handle);
    }
    _bindHandle(handle) {
      return this.gl.bindFramebuffer(36160, handle);
    }
  };
  function mapIndexToCubeMapFace(layer) {
    return layer < 34069 ? layer + 34069 : layer;
  }
  function _getFrameBufferStatus(status) {
    const STATUS2 = Framebuffer.STATUS || {};
    return STATUS2[status] || "Framebuffer error ".concat(status);
  }
  var FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
  Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js
  function cloneTextureFrom(refTexture, overrides) {
    assert7(refTexture instanceof Texture2D || refTexture instanceof TextureCube || refTexture instanceof Texture3D);
    const TextureType = refTexture.constructor;
    const {
      gl,
      width,
      height,
      format,
      type,
      dataFormat,
      border,
      mipmaps
    } = refTexture;
    const textureOptions = Object.assign({
      width,
      height,
      format,
      type,
      dataFormat,
      border,
      mipmaps
    }, overrides);
    return new TextureType(gl, textureOptions);
  }
  function toFramebuffer(texture, opts) {
    const {
      gl,
      width,
      height,
      id
    } = texture;
    const framebuffer = new Framebuffer(gl, Object.assign({}, opts, {
      id: "framebuffer-for-".concat(id),
      width,
      height,
      attachments: {
        [36064]: texture
      }
    }));
    return framebuffer;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js
  function getShaderName(shader) {
    let defaultName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
    const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
    const match = shader.match(SHADER_NAME_REGEXP);
    return match ? match[1] : defaultName;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js
  var GL_FRAGMENT_SHADER = 35632;
  var GL_VERTEX_SHADER = 35633;
  function getShaderTypeName(type) {
    switch (type) {
      case GL_FRAGMENT_SHADER:
        return "fragment";
      case GL_VERTEX_SHADER:
        return "vertex";
      default:
        return "unknown type";
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js
  function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
    const errorStrings = errLog.split(/\r?\n/);
    const errors = {};
    const warnings = {};
    const name10 = shaderName || getShaderName(src) || "(unnamed)";
    const shaderDescription = "".concat(getShaderTypeName(shaderType), " shader ").concat(name10);
    for (let i3 = 0; i3 < errorStrings.length; i3++) {
      const errorString = errorStrings[i3];
      if (errorString.length <= 1) {
        continue;
      }
      const segments = errorString.split(":");
      const type = segments[0];
      const line = parseInt(segments[2], 10);
      if (isNaN(line)) {
        throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
      }
      if (type !== "WARNING") {
        errors[line] = errorString;
      } else {
        warnings[line] = errorString;
      }
    }
    const lines = addLineNumbers(src);
    return {
      shaderName: shaderDescription,
      errors: formatErrors(errors, lines),
      warnings: formatErrors(warnings, lines)
    };
  }
  function formatErrors(errors, lines) {
    let message = "";
    for (let i3 = 0; i3 < lines.length; i3++) {
      const line = lines[i3];
      if (!errors[i3 + 3] && !errors[i3 + 2] && !errors[i3 + 1]) {
        continue;
      }
      message += "".concat(line, "\n");
      if (errors[i3 + 1]) {
        const error2 = errors[i3 + 1];
        const segments = error2.split(":", 3);
        const type = segments[0];
        const column = parseInt(segments[1], 10) || 0;
        const err = error2.substring(segments.join(":").length + 1).trim();
        message += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
      }
    }
    return message;
  }
  function addLineNumbers(string) {
    let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    let delim = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ": ";
    const lines = string.split(/\r?\n/);
    const maxDigits = String(lines.length + start - 1).length;
    return lines.map((line, i3) => {
      const lineNumber = String(i3 + start);
      const digits = lineNumber.length;
      const prefix = padLeft(lineNumber, maxDigits - digits);
      return prefix + delim + line;
    });
  }
  function padLeft(string, digits) {
    let result = "";
    for (let i3 = 0; i3 < digits; ++i3) {
      result += " ";
    }
    return "".concat(result).concat(string);
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js
  function getShaderVersion(source) {
    let version = 100;
    const words = source.match(/[^\s]+/g);
    if (words.length >= 2 && words[0] === "#version") {
      const v = parseInt(words[1], 10);
      if (Number.isFinite(v)) {
        version = v;
      }
    }
    return version;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/shader.js
  var ERR_SOURCE = "Shader: GLSL source code must be a JavaScript string";
  var Shader = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Shader";
    }
    static getTypeName(shaderType) {
      switch (shaderType) {
        case 35633:
          return "vertex-shader";
        case 35632:
          return "fragment-shader";
        default:
          assert7(false);
          return "unknown";
      }
    }
    constructor(gl, props) {
      assertWebGLContext(gl);
      assert7(typeof props.source === "string", ERR_SOURCE);
      const id = getShaderName(props.source, null) || props.id || uid("unnamed ".concat(Shader.getTypeName(props.shaderType)));
      super(gl, {
        id
      });
      this.shaderType = props.shaderType;
      this.source = props.source;
      this.initialize(props);
    }
    initialize(_ref) {
      let {
        source
      } = _ref;
      const shaderName = getShaderName(source, null);
      if (shaderName) {
        this.id = uid(shaderName);
      }
      this._compile(source);
    }
    getParameter(pname) {
      return this.gl.getShaderParameter(this.handle, pname);
    }
    toString() {
      return "".concat(Shader.getTypeName(this.shaderType), ":").concat(this.id);
    }
    getName() {
      return getShaderName(this.source) || "unnamed-shader";
    }
    getSource() {
      return this.gl.getShaderSource(this.handle);
    }
    getTranslatedSource() {
      const extension = this.gl.getExtension("WEBGL_debug_shaders");
      return extension ? extension.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
    }
    _compile() {
      let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.source;
      if (!source.startsWith("#version ")) {
        source = "#version 100\n".concat(source);
      }
      this.source = source;
      this.gl.shaderSource(this.handle, this.source);
      this.gl.compileShader(this.handle);
      const compileStatus = this.getParameter(35713);
      if (!compileStatus) {
        const infoLog = this.gl.getShaderInfoLog(this.handle);
        const {
          shaderName,
          errors,
          warnings
        } = parseGLSLCompilerError(infoLog, this.source, this.shaderType, this.id);
        log2.error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();
        log2.warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();
        throw new Error("GLSL compilation errors in ".concat(shaderName));
      }
    }
    _deleteHandle() {
      this.gl.deleteShader(this.handle);
    }
    _getOptsFromHandle() {
      return {
        type: this.getParameter(35663),
        source: this.getSource()
      };
    }
  };
  var VertexShader = class extends Shader {
    get [Symbol.toStringTag]() {
      return "VertexShader";
    }
    constructor(gl, props) {
      if (typeof props === "string") {
        props = {
          source: props
        };
      }
      super(gl, Object.assign({}, props, {
        shaderType: 35633
      }));
    }
    _createHandle() {
      return this.gl.createShader(35633);
    }
  };
  var FragmentShader = class extends Shader {
    get [Symbol.toStringTag]() {
      return "FragmentShader";
    }
    constructor(gl, props) {
      if (typeof props === "string") {
        props = {
          source: props
        };
      }
      super(gl, Object.assign({}, props, {
        shaderType: 35632
      }));
    }
    _createHandle() {
      return this.gl.createShader(35632);
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js
  var UNIFORM_SETTERS = {
    [5126]: getArraySetter.bind(null, "uniform1fv", toFloatArray, 1, setVectorUniform),
    [35664]: getArraySetter.bind(null, "uniform2fv", toFloatArray, 2, setVectorUniform),
    [35665]: getArraySetter.bind(null, "uniform3fv", toFloatArray, 3, setVectorUniform),
    [35666]: getArraySetter.bind(null, "uniform4fv", toFloatArray, 4, setVectorUniform),
    [5124]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
    [35667]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
    [35668]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
    [35669]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
    [35670]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
    [35671]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
    [35672]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
    [35673]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
    [35674]: getArraySetter.bind(null, "uniformMatrix2fv", toFloatArray, 4, setMatrixUniform),
    [35675]: getArraySetter.bind(null, "uniformMatrix3fv", toFloatArray, 9, setMatrixUniform),
    [35676]: getArraySetter.bind(null, "uniformMatrix4fv", toFloatArray, 16, setMatrixUniform),
    [35678]: getSamplerSetter,
    [35680]: getSamplerSetter,
    [5125]: getArraySetter.bind(null, "uniform1uiv", toUIntArray, 1, setVectorUniform),
    [36294]: getArraySetter.bind(null, "uniform2uiv", toUIntArray, 2, setVectorUniform),
    [36295]: getArraySetter.bind(null, "uniform3uiv", toUIntArray, 3, setVectorUniform),
    [36296]: getArraySetter.bind(null, "uniform4uiv", toUIntArray, 4, setVectorUniform),
    [35685]: getArraySetter.bind(null, "uniformMatrix2x3fv", toFloatArray, 6, setMatrixUniform),
    [35686]: getArraySetter.bind(null, "uniformMatrix2x4fv", toFloatArray, 8, setMatrixUniform),
    [35687]: getArraySetter.bind(null, "uniformMatrix3x2fv", toFloatArray, 6, setMatrixUniform),
    [35688]: getArraySetter.bind(null, "uniformMatrix3x4fv", toFloatArray, 12, setMatrixUniform),
    [35689]: getArraySetter.bind(null, "uniformMatrix4x2fv", toFloatArray, 8, setMatrixUniform),
    [35690]: getArraySetter.bind(null, "uniformMatrix4x3fv", toFloatArray, 12, setMatrixUniform),
    [35678]: getSamplerSetter,
    [35680]: getSamplerSetter,
    [35679]: getSamplerSetter,
    [35682]: getSamplerSetter,
    [36289]: getSamplerSetter,
    [36292]: getSamplerSetter,
    [36293]: getSamplerSetter,
    [36298]: getSamplerSetter,
    [36299]: getSamplerSetter,
    [36300]: getSamplerSetter,
    [36303]: getSamplerSetter,
    [36306]: getSamplerSetter,
    [36307]: getSamplerSetter,
    [36308]: getSamplerSetter,
    [36311]: getSamplerSetter
  };
  var FLOAT_ARRAY = {};
  var INT_ARRAY = {};
  var UINT_ARRAY = {};
  var array1 = [0];
  function toTypedArray(value, uniformLength, Type2, cache4) {
    if (uniformLength === 1 && typeof value === "boolean") {
      value = value ? 1 : 0;
    }
    if (Number.isFinite(value)) {
      array1[0] = value;
      value = array1;
    }
    const length7 = value.length;
    if (length7 % uniformLength) {
      log2.warn("Uniform size should be multiples of ".concat(uniformLength), value)();
    }
    if (value instanceof Type2) {
      return value;
    }
    let result = cache4[length7];
    if (!result) {
      result = new Type2(length7);
      cache4[length7] = result;
    }
    for (let i3 = 0; i3 < length7; i3++) {
      result[i3] = value[i3];
    }
    return result;
  }
  function toFloatArray(value, uniformLength) {
    return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
  }
  function toIntArray(value, uniformLength) {
    return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
  }
  function toUIntArray(value, uniformLength) {
    return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
  }
  function getUniformSetter(gl, location, info) {
    const setter = UNIFORM_SETTERS[info.type];
    if (!setter) {
      throw new Error("Unknown GLSL uniform type ".concat(info.type));
    }
    return setter().bind(null, gl, location);
  }
  function parseUniformName(name10) {
    if (name10[name10.length - 1] !== "]") {
      return {
        name: name10,
        length: 1,
        isArray: false
      };
    }
    const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
    const matches3 = name10.match(UNIFORM_NAME_REGEXP);
    if (!matches3 || matches3.length < 2) {
      throw new Error("Failed to parse GLSL uniform name ".concat(name10));
    }
    return {
      name: matches3[1],
      length: matches3[2] || 1,
      isArray: Boolean(matches3[2])
    };
  }
  function checkUniformValues(uniforms, source, uniformMap) {
    for (const uniformName in uniforms) {
      const value = uniforms[uniformName];
      const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);
      if (shouldCheck && !checkUniformValue(value)) {
        source = source ? "".concat(source, " ") : "";
        console.error("".concat(source, " Bad uniform ").concat(uniformName), value);
        throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
      }
    }
    return true;
  }
  function checkUniformValue(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return checkUniformArray(value);
    }
    if (isFinite(value)) {
      return true;
    } else if (value === true || value === false) {
      return true;
    } else if (value instanceof Texture) {
      return true;
    } else if (value instanceof Renderbuffer) {
      return true;
    } else if (value instanceof Framebuffer) {
      return Boolean(value.texture);
    }
    return false;
  }
  function copyUniform(uniforms, key, value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      if (uniforms[key]) {
        const dest = uniforms[key];
        for (let i3 = 0, len3 = value.length; i3 < len3; ++i3) {
          dest[i3] = value[i3];
        }
      } else {
        uniforms[key] = value.slice();
      }
    } else {
      uniforms[key] = value;
    }
  }
  function checkUniformArray(value) {
    if (value.length === 0) {
      return false;
    }
    const checkLength = Math.min(value.length, 16);
    for (let i3 = 0; i3 < checkLength; ++i3) {
      if (!Number.isFinite(value[i3])) {
        return false;
      }
    }
    return true;
  }
  function getSamplerSetter() {
    let cache4 = null;
    return (gl, location, value) => {
      const update = cache4 !== value;
      if (update) {
        gl.uniform1i(location, value);
        cache4 = value;
      }
      return update;
    };
  }
  function getArraySetter(functionName, toArray, size, uniformSetter) {
    let cache4 = null;
    let cacheLength = null;
    return (gl, location, value) => {
      const arrayValue = toArray(value, size);
      const length7 = arrayValue.length;
      let update = false;
      if (cache4 === null) {
        cache4 = new Float32Array(length7);
        cacheLength = length7;
        update = true;
      } else {
        assert7(cacheLength === length7, "Uniform length cannot change.");
        for (let i3 = 0; i3 < length7; ++i3) {
          if (arrayValue[i3] !== cache4[i3]) {
            update = true;
            break;
          }
        }
      }
      if (update) {
        uniformSetter(gl, functionName, location, arrayValue);
        cache4.set(arrayValue);
      }
      return update;
    };
  }
  function setVectorUniform(gl, functionName, location, value) {
    gl[functionName](location, value);
  }
  function setMatrixUniform(gl, functionName, location, value) {
    gl[functionName](location, false, value);
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js
  var GL_BYTE = 5120;
  var GL_UNSIGNED_BYTE = 5121;
  var GL_SHORT = 5122;
  var GL_UNSIGNED_SHORT = 5123;
  var GL_POINTS = 0;
  var GL_LINES = 1;
  var GL_LINE_LOOP = 2;
  var GL_LINE_STRIP = 3;
  var GL_TRIANGLES = 4;
  var GL_TRIANGLE_STRIP = 5;
  var GL_TRIANGLE_FAN = 6;
  var GL_FLOAT = 5126;
  var GL_FLOAT_VEC2 = 35664;
  var GL_FLOAT_VEC3 = 35665;
  var GL_FLOAT_VEC4 = 35666;
  var GL_INT = 5124;
  var GL_INT_VEC2 = 35667;
  var GL_INT_VEC3 = 35668;
  var GL_INT_VEC4 = 35669;
  var GL_UNSIGNED_INT = 5125;
  var GL_UNSIGNED_INT_VEC2 = 36294;
  var GL_UNSIGNED_INT_VEC3 = 36295;
  var GL_UNSIGNED_INT_VEC4 = 36296;
  var GL_BOOL = 35670;
  var GL_BOOL_VEC2 = 35671;
  var GL_BOOL_VEC3 = 35672;
  var GL_BOOL_VEC4 = 35673;
  var GL_FLOAT_MAT2 = 35674;
  var GL_FLOAT_MAT3 = 35675;
  var GL_FLOAT_MAT4 = 35676;
  var GL_FLOAT_MAT2x3 = 35685;
  var GL_FLOAT_MAT2x4 = 35686;
  var GL_FLOAT_MAT3x2 = 35687;
  var GL_FLOAT_MAT3x4 = 35688;
  var GL_FLOAT_MAT4x2 = 35689;
  var GL_FLOAT_MAT4x3 = 35690;
  var COMPOSITE_GL_TYPES = {
    [GL_FLOAT]: [GL_FLOAT, 1, "float"],
    [GL_FLOAT_VEC2]: [GL_FLOAT, 2, "vec2"],
    [GL_FLOAT_VEC3]: [GL_FLOAT, 3, "vec3"],
    [GL_FLOAT_VEC4]: [GL_FLOAT, 4, "vec4"],
    [GL_INT]: [GL_INT, 1, "int"],
    [GL_INT_VEC2]: [GL_INT, 2, "ivec2"],
    [GL_INT_VEC3]: [GL_INT, 3, "ivec3"],
    [GL_INT_VEC4]: [GL_INT, 4, "ivec4"],
    [GL_UNSIGNED_INT]: [GL_UNSIGNED_INT, 1, "uint"],
    [GL_UNSIGNED_INT_VEC2]: [GL_UNSIGNED_INT, 2, "uvec2"],
    [GL_UNSIGNED_INT_VEC3]: [GL_UNSIGNED_INT, 3, "uvec3"],
    [GL_UNSIGNED_INT_VEC4]: [GL_UNSIGNED_INT, 4, "uvec4"],
    [GL_BOOL]: [GL_FLOAT, 1, "bool"],
    [GL_BOOL_VEC2]: [GL_FLOAT, 2, "bvec2"],
    [GL_BOOL_VEC3]: [GL_FLOAT, 3, "bvec3"],
    [GL_BOOL_VEC4]: [GL_FLOAT, 4, "bvec4"],
    [GL_FLOAT_MAT2]: [GL_FLOAT, 8, "mat2"],
    [GL_FLOAT_MAT2x3]: [GL_FLOAT, 8, "mat2x3"],
    [GL_FLOAT_MAT2x4]: [GL_FLOAT, 8, "mat2x4"],
    [GL_FLOAT_MAT3]: [GL_FLOAT, 12, "mat3"],
    [GL_FLOAT_MAT3x2]: [GL_FLOAT, 12, "mat3x2"],
    [GL_FLOAT_MAT3x4]: [GL_FLOAT, 12, "mat3x4"],
    [GL_FLOAT_MAT4]: [GL_FLOAT, 16, "mat4"],
    [GL_FLOAT_MAT4x2]: [GL_FLOAT, 16, "mat4x2"],
    [GL_FLOAT_MAT4x3]: [GL_FLOAT, 16, "mat4x3"]
  };
  function getPrimitiveDrawMode(drawMode) {
    switch (drawMode) {
      case GL_POINTS:
        return GL_POINTS;
      case GL_LINES:
        return GL_LINES;
      case GL_LINE_STRIP:
        return GL_LINES;
      case GL_LINE_LOOP:
        return GL_LINES;
      case GL_TRIANGLES:
        return GL_TRIANGLES;
      case GL_TRIANGLE_STRIP:
        return GL_TRIANGLES;
      case GL_TRIANGLE_FAN:
        return GL_TRIANGLES;
      default:
        assert7(false);
        return 0;
    }
  }
  function decomposeCompositeGLType(compositeGLType) {
    const typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];
    if (!typeAndSize) {
      return null;
    }
    const [type, components] = typeAndSize;
    return {
      type,
      components
    };
  }
  function getCompositeGLType(type, components) {
    switch (type) {
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
        type = GL_FLOAT;
        break;
      default:
    }
    for (const glType in COMPOSITE_GL_TYPES) {
      const [compType, compComponents, name10] = COMPOSITE_GL_TYPES[glType];
      if (compType === type && compComponents === components) {
        return {
          glType,
          name: name10
        };
      }
    }
    return null;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js
  var ProgramConfiguration = class {
    constructor(program) {
      this.id = program.id;
      this.attributeInfos = [];
      this.attributeInfosByName = {};
      this.attributeInfosByLocation = [];
      this.varyingInfos = [];
      this.varyingInfosByName = {};
      Object.seal(this);
      this._readAttributesFromProgram(program);
      this._readVaryingsFromProgram(program);
    }
    getAttributeInfo(locationOrName) {
      const location = Number(locationOrName);
      if (Number.isFinite(location)) {
        return this.attributeInfosByLocation[location];
      }
      return this.attributeInfosByName[locationOrName] || null;
    }
    getAttributeLocation(locationOrName) {
      const attributeInfo = this.getAttributeInfo(locationOrName);
      return attributeInfo ? attributeInfo.location : -1;
    }
    getAttributeAccessor(locationOrName) {
      const attributeInfo = this.getAttributeInfo(locationOrName);
      return attributeInfo ? attributeInfo.accessor : null;
    }
    getVaryingInfo(locationOrName) {
      const location = Number(locationOrName);
      if (Number.isFinite(location)) {
        return this.varyingInfos[location];
      }
      return this.varyingInfosByName[locationOrName] || null;
    }
    getVaryingIndex(locationOrName) {
      const varying = this.getVaryingInfo();
      return varying ? varying.location : -1;
    }
    getVaryingAccessor(locationOrName) {
      const varying = this.getVaryingInfo();
      return varying ? varying.accessor : null;
    }
    _readAttributesFromProgram(program) {
      const {
        gl
      } = program;
      const count2 = gl.getProgramParameter(program.handle, 35721);
      for (let index = 0; index < count2; index++) {
        const {
          name: name10,
          type,
          size
        } = gl.getActiveAttrib(program.handle, index);
        const location = gl.getAttribLocation(program.handle, name10);
        if (location >= 0) {
          this._addAttribute(location, name10, type, size);
        }
      }
      this.attributeInfos.sort((a2, b) => a2.location - b.location);
    }
    _readVaryingsFromProgram(program) {
      const {
        gl
      } = program;
      if (!isWebGL2(gl)) {
        return;
      }
      const count2 = gl.getProgramParameter(program.handle, 35971);
      for (let location = 0; location < count2; location++) {
        const {
          name: name10,
          type,
          size
        } = gl.getTransformFeedbackVarying(program.handle, location);
        this._addVarying(location, name10, type, size);
      }
      this.varyingInfos.sort((a2, b) => a2.location - b.location);
    }
    _addAttribute(location, name10, compositeType, size) {
      const {
        type,
        components
      } = decomposeCompositeGLType(compositeType);
      const accessor = {
        type,
        size: size * components
      };
      this._inferProperties(location, name10, accessor);
      const attributeInfo = {
        location,
        name: name10,
        accessor: new Accessor(accessor)
      };
      this.attributeInfos.push(attributeInfo);
      this.attributeInfosByLocation[location] = attributeInfo;
      this.attributeInfosByName[attributeInfo.name] = attributeInfo;
    }
    _inferProperties(location, name10, accessor) {
      if (/instance/i.test(name10)) {
        accessor.divisor = 1;
      }
    }
    _addVarying(location, name10, compositeType, size) {
      const {
        type,
        components
      } = decomposeCompositeGLType(compositeType);
      const accessor = new Accessor({
        type,
        size: size * components
      });
      const varying = {
        location,
        name: name10,
        accessor
      };
      this.varyingInfos.push(varying);
      this.varyingInfosByName[varying.name] = varying;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/program.js
  var LOG_PROGRAM_PERF_PRIORITY = 4;
  var GL_SEPARATE_ATTRIBS = 35981;
  var V6_DEPRECATED_METHODS = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
  var Program = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Program";
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, props);
      this.stubRemovedMethods("Program", "v6.0", V6_DEPRECATED_METHODS);
      this._isCached = false;
      this.initialize(props);
      Object.seal(this);
      this._setId(props.id);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        hash,
        vs: vs12,
        fs: fs8,
        varyings,
        bufferMode = GL_SEPARATE_ATTRIBS
      } = props;
      this.hash = hash || "";
      this.vs = typeof vs12 === "string" ? new VertexShader(this.gl, {
        id: "".concat(props.id, "-vs"),
        source: vs12
      }) : vs12;
      this.fs = typeof fs8 === "string" ? new FragmentShader(this.gl, {
        id: "".concat(props.id, "-fs"),
        source: fs8
      }) : fs8;
      assert7(this.vs instanceof VertexShader);
      assert7(this.fs instanceof FragmentShader);
      this.uniforms = {};
      this._textureUniforms = {};
      if (varyings && varyings.length > 0) {
        assertWebGL2Context(this.gl);
        this.varyings = varyings;
        this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
      }
      this._compileAndLink();
      this._readUniformLocationsFromLinkedProgram();
      this.configuration = new ProgramConfiguration(this);
      return this.setProps(props);
    }
    delete() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this._isCached) {
        return this;
      }
      return super.delete(options);
    }
    setProps(props) {
      if ("uniforms" in props) {
        this.setUniforms(props.uniforms);
      }
      return this;
    }
    draw(_ref) {
      let {
        logPriority,
        drawMode = 4,
        vertexCount,
        offset = 0,
        start,
        end,
        isIndexed = false,
        indexType = 5123,
        instanceCount = 0,
        isInstanced = instanceCount > 0,
        vertexArray = null,
        transformFeedback,
        framebuffer,
        parameters: parameters2 = {},
        uniforms,
        samplers
      } = _ref;
      if (uniforms || samplers) {
        log2.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")();
        this.setUniforms(uniforms || {});
      }
      if (log2.priority >= logPriority) {
        const fb = framebuffer ? framebuffer.id : "default";
        const message = "mode=".concat(getKey(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat(getKey(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);
        log2.log(logPriority, message)();
      }
      assert7(vertexArray);
      this.gl.useProgram(this.handle);
      if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {
        return false;
      }
      vertexArray.bindForDraw(vertexCount, instanceCount, () => {
        if (framebuffer !== void 0) {
          parameters2 = Object.assign({}, parameters2, {
            framebuffer
          });
        }
        if (transformFeedback) {
          const primitiveMode = getPrimitiveDrawMode(drawMode);
          transformFeedback.begin(primitiveMode);
        }
        this._bindTextures();
        withParameters(this.gl, parameters2, () => {
          if (isIndexed && isInstanced) {
            this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
          } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start) && !isNaN(end)) {
            this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
          } else if (isIndexed) {
            this.gl.drawElements(drawMode, vertexCount, indexType, offset);
          } else if (isInstanced) {
            this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
          } else {
            this.gl.drawArrays(drawMode, offset, vertexCount);
          }
        });
        if (transformFeedback) {
          transformFeedback.end();
        }
      });
      return true;
    }
    setUniforms() {
      let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (log2.priority >= 2) {
        checkUniformValues(uniforms, this.id, this._uniformSetters);
      }
      this.gl.useProgram(this.handle);
      for (const uniformName in uniforms) {
        const uniform = uniforms[uniformName];
        const uniformSetter = this._uniformSetters[uniformName];
        if (uniformSetter) {
          let value = uniform;
          let textureUpdate = false;
          if (value instanceof Framebuffer) {
            value = value.texture;
          }
          if (value instanceof Texture) {
            textureUpdate = this.uniforms[uniformName] !== uniform;
            if (textureUpdate) {
              if (uniformSetter.textureIndex === void 0) {
                uniformSetter.textureIndex = this._textureIndexCounter++;
              }
              const texture = value;
              const {
                textureIndex
              } = uniformSetter;
              texture.bind(textureIndex);
              value = textureIndex;
              this._textureUniforms[uniformName] = texture;
            } else {
              value = uniformSetter.textureIndex;
            }
          } else if (this._textureUniforms[uniformName]) {
            delete this._textureUniforms[uniformName];
          }
          if (uniformSetter(value) || textureUpdate) {
            copyUniform(this.uniforms, uniformName, uniform);
          }
        }
      }
      return this;
    }
    _areTexturesRenderable() {
      let texturesRenderable = true;
      for (const uniformName in this._textureUniforms) {
        const texture = this._textureUniforms[uniformName];
        texture.update();
        texturesRenderable = texturesRenderable && texture.loaded;
      }
      return texturesRenderable;
    }
    _bindTextures() {
      for (const uniformName in this._textureUniforms) {
        const textureIndex = this._uniformSetters[uniformName].textureIndex;
        this._textureUniforms[uniformName].bind(textureIndex);
      }
    }
    _createHandle() {
      return this.gl.createProgram();
    }
    _deleteHandle() {
      this.gl.deleteProgram(this.handle);
    }
    _getOptionsFromHandle(handle) {
      const shaderHandles = this.gl.getAttachedShaders(handle);
      const opts = {};
      for (const shaderHandle of shaderHandles) {
        const type = this.gl.getShaderParameter(this.handle, 35663);
        switch (type) {
          case 35633:
            opts.vs = new VertexShader({
              handle: shaderHandle
            });
            break;
          case 35632:
            opts.fs = new FragmentShader({
              handle: shaderHandle
            });
            break;
          default:
        }
      }
      return opts;
    }
    _getParameter(pname) {
      return this.gl.getProgramParameter(this.handle, pname);
    }
    _setId(id) {
      if (!id) {
        const programName = this._getName();
        this.id = uid(programName);
      }
    }
    _getName() {
      let programName = this.vs.getName() || this.fs.getName();
      programName = programName.replace(/shader/i, "");
      programName = programName ? "".concat(programName, "-program") : "program";
      return programName;
    }
    _compileAndLink() {
      const {
        gl
      } = this;
      gl.attachShader(this.handle, this.vs.handle);
      gl.attachShader(this.handle, this.fs.handle);
      log2.time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
      gl.linkProgram(this.handle);
      log2.timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
      if (gl.debug || log2.level > 0) {
        const linked = gl.getProgramParameter(this.handle, 35714);
        if (!linked) {
          throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
        }
        gl.validateProgram(this.handle);
        const validated = gl.getProgramParameter(this.handle, 35715);
        if (!validated) {
          throw new Error("Error validating: ".concat(gl.getProgramInfoLog(this.handle)));
        }
      }
    }
    _readUniformLocationsFromLinkedProgram() {
      const {
        gl
      } = this;
      this._uniformSetters = {};
      this._uniformCount = this._getParameter(35718);
      for (let i3 = 0; i3 < this._uniformCount; i3++) {
        const info = this.gl.getActiveUniform(this.handle, i3);
        const {
          name: name10
        } = parseUniformName(info.name);
        let location = gl.getUniformLocation(this.handle, name10);
        this._uniformSetters[name10] = getUniformSetter(gl, location, info);
        if (info.size > 1) {
          for (let l2 = 0; l2 < info.size; l2++) {
            location = gl.getUniformLocation(this.handle, "".concat(name10, "[").concat(l2, "]"));
            this._uniformSetters["".concat(name10, "[").concat(l2, "]")] = getUniformSetter(gl, location, info);
          }
        }
      }
      this._textureIndexCounter = 0;
    }
    getActiveUniforms(uniformIndices, pname) {
      return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
    }
    getUniformBlockIndex(blockName) {
      return this.gl2.getUniformBlockIndex(this.handle, blockName);
    }
    getActiveUniformBlockParameter(blockIndex, pname) {
      return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
    }
    uniformBlockBinding(blockIndex, blockBinding) {
      this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/query.js
  var GL_QUERY_RESULT = 34918;
  var GL_QUERY_RESULT_AVAILABLE = 34919;
  var GL_TIME_ELAPSED_EXT = 35007;
  var GL_GPU_DISJOINT_EXT2 = 36795;
  var GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976;
  var GL_ANY_SAMPLES_PASSED = 35887;
  var GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 36202;
  var Query = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Query";
    }
    static isSupported(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      const webgl2 = isWebGL2(gl);
      const hasTimerQuery = hasFeatures(gl, FEATURES.TIMER_QUERY);
      let supported = webgl2 || hasTimerQuery;
      for (const key of opts) {
        switch (key) {
          case "queries":
            supported = supported && webgl2;
            break;
          case "timers":
            supported = supported && hasTimerQuery;
            break;
          default:
            assert7(false);
        }
      }
      return supported;
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, opts);
      this.target = null;
      this._queryPending = false;
      this._pollingPromise = null;
      Object.seal(this);
    }
    beginTimeElapsedQuery() {
      return this.begin(GL_TIME_ELAPSED_EXT);
    }
    beginOcclusionQuery() {
      let {
        conservative = false
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
    }
    beginTransformFeedbackQuery() {
      return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
    }
    begin(target) {
      if (this._queryPending) {
        return this;
      }
      this.target = target;
      this.gl2.beginQuery(this.target, this.handle);
      return this;
    }
    end() {
      if (this._queryPending) {
        return this;
      }
      if (this.target) {
        this.gl2.endQuery(this.target);
        this.target = null;
        this._queryPending = true;
      }
      return this;
    }
    isResultAvailable() {
      if (!this._queryPending) {
        return false;
      }
      const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);
      if (resultAvailable) {
        this._queryPending = false;
      }
      return resultAvailable;
    }
    isTimerDisjoint() {
      return this.gl2.getParameter(GL_GPU_DISJOINT_EXT2);
    }
    getResult() {
      return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);
    }
    getTimerMilliseconds() {
      return this.getResult() / 1e6;
    }
    createPoll() {
      let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.POSITIVE_INFINITY;
      if (this._pollingPromise) {
        return this._pollingPromise;
      }
      let counter2 = 0;
      this._pollingPromise = new Promise((resolve2, reject) => {
        const poll = () => {
          if (this.isResultAvailable()) {
            resolve2(this.getResult());
            this._pollingPromise = null;
          } else if (counter2++ > limit) {
            reject("Timed out");
            this._pollingPromise = null;
          } else {
            requestAnimationFrame(poll);
          }
        };
        requestAnimationFrame(poll);
      });
      return this._pollingPromise;
    }
    _createHandle() {
      return Query.isSupported(this.gl) ? this.gl2.createQuery() : null;
    }
    _deleteHandle() {
      this.gl2.deleteQuery(this.handle);
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js
  var TransformFeedback = class extends Resource {
    get [Symbol.toStringTag]() {
      return "TransformFeedback";
    }
    static isSupported(gl) {
      return isWebGL2(gl);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGL2Context(gl);
      super(gl, props);
      this.initialize(props);
      this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]);
      Object.seal(this);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.buffers = {};
      this.unused = {};
      this.configuration = null;
      this.bindOnUse = true;
      if (!isObjectEmpty2(this.buffers)) {
        this.bind(() => this._unbindBuffers());
      }
      this.setProps(props);
      return this;
    }
    setProps(props) {
      if ("program" in props) {
        this.configuration = props.program && props.program.configuration;
      }
      if ("configuration" in props) {
        this.configuration = props.configuration;
      }
      if ("bindOnUse" in props) {
        props = props.bindOnUse;
      }
      if ("buffers" in props) {
        this.setBuffers(props.buffers);
      }
    }
    setBuffers() {
      let buffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.bind(() => {
        for (const bufferName in buffers) {
          this.setBuffer(bufferName, buffers[bufferName]);
        }
      });
      return this;
    }
    setBuffer(locationOrName, bufferOrParams) {
      const location = this._getVaryingIndex(locationOrName);
      const {
        buffer,
        byteSize,
        byteOffset
      } = this._getBufferParams(bufferOrParams);
      if (location < 0) {
        this.unused[locationOrName] = buffer;
        log2.warn("".concat(this.id, " unused varying buffer ").concat(locationOrName))();
        return this;
      }
      this.buffers[location] = bufferOrParams;
      if (!this.bindOnUse) {
        this._bindBuffer(location, buffer, byteOffset, byteSize);
      }
      return this;
    }
    begin() {
      let primitiveMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      this.gl.bindTransformFeedback(36386, this.handle);
      this._bindBuffers();
      this.gl.beginTransformFeedback(primitiveMode);
      return this;
    }
    end() {
      this.gl.endTransformFeedback();
      this._unbindBuffers();
      this.gl.bindTransformFeedback(36386, null);
      return this;
    }
    _getBufferParams(bufferOrParams) {
      let byteOffset;
      let byteSize;
      let buffer;
      if (bufferOrParams instanceof Buffer2 === false) {
        buffer = bufferOrParams.buffer;
        byteSize = bufferOrParams.byteSize;
        byteOffset = bufferOrParams.byteOffset;
      } else {
        buffer = bufferOrParams;
      }
      if (byteOffset !== void 0 || byteSize !== void 0) {
        byteOffset = byteOffset || 0;
        byteSize = byteSize || buffer.byteLength - byteOffset;
      }
      return {
        buffer,
        byteOffset,
        byteSize
      };
    }
    _getVaryingInfo(locationOrName) {
      return this.configuration && this.configuration.getVaryingInfo(locationOrName);
    }
    _getVaryingIndex(locationOrName) {
      if (this.configuration) {
        return this.configuration.getVaryingInfo(locationOrName).location;
      }
      const location = Number(locationOrName);
      return Number.isFinite(location) ? location : -1;
    }
    _bindBuffers() {
      if (this.bindOnUse) {
        for (const bufferIndex in this.buffers) {
          const {
            buffer,
            byteSize,
            byteOffset
          } = this._getBufferParams(this.buffers[bufferIndex]);
          this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
        }
      }
    }
    _unbindBuffers() {
      if (this.bindOnUse) {
        for (const bufferIndex in this.buffers) {
          this._bindBuffer(bufferIndex, null);
        }
      }
    }
    _bindBuffer(index, buffer) {
      let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      let byteSize = arguments.length > 3 ? arguments[3] : void 0;
      const handle = buffer && buffer.handle;
      if (!handle || byteSize === void 0) {
        this.gl.bindBufferBase(35982, index, handle);
      } else {
        this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
      }
      return this;
    }
    _createHandle() {
      return this.gl.createTransformFeedback();
    }
    _deleteHandle() {
      this.gl.deleteTransformFeedback(this.handle);
    }
    _bindHandle(handle) {
      this.gl.bindTransformFeedback(36386, this.handle);
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js
  var arrayBuffer = null;
  function getScratchArrayBuffer(byteLength) {
    if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
      arrayBuffer = new ArrayBuffer(byteLength);
    }
    return arrayBuffer;
  }
  function getScratchArray(Type2, length7) {
    const scratchArrayBuffer = getScratchArrayBuffer(Type2.BYTES_PER_ELEMENT * length7);
    return new Type2(scratchArrayBuffer, 0, length7);
  }
  function fillArray(_ref) {
    let {
      target,
      source,
      start = 0,
      count: count2 = 1
    } = _ref;
    const length7 = source.length;
    const total = count2 * length7;
    let copied = 0;
    for (let i3 = start; copied < length7; copied++) {
      target[i3++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target.copyWithin(start + copied, start, start + copied);
        copied *= 2;
      } else {
        target.copyWithin(start + copied, start, start + total - copied);
        copied = total;
      }
    }
    return target;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js
  var ERR_ELEMENTS = "elements must be GL.ELEMENT_ARRAY_BUFFER";
  var VertexArrayObject = class extends Resource {
    get [Symbol.toStringTag]() {
      return "VertexArrayObject";
    }
    static isSupported(gl) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (options.constantAttributeZero) {
        return isWebGL2(gl) || getBrowser() === "Chrome";
      }
      return true;
    }
    static getDefaultArray(gl) {
      gl.luma = gl.luma || {};
      if (!gl.luma.defaultVertexArray) {
        gl.luma.defaultVertexArray = new VertexArrayObject(gl, {
          handle: null,
          isDefaultArray: true
        });
      }
      return gl.luma.defaultVertexArray;
    }
    static getMaxAttributes(gl) {
      VertexArrayObject.MAX_ATTRIBUTES = VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);
      return VertexArrayObject.MAX_ATTRIBUTES;
    }
    static setConstant(gl, location, array) {
      switch (array.constructor) {
        case Float32Array:
          VertexArrayObject._setConstantFloatArray(gl, location, array);
          break;
        case Int32Array:
          VertexArrayObject._setConstantIntArray(gl, location, array);
          break;
        case Uint32Array:
          VertexArrayObject._setConstantUintArray(gl, location, array);
          break;
        default:
          assert7(false);
      }
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const id = opts.id || opts.program && opts.program.id;
      super(gl, Object.assign({}, opts, {
        id
      }));
      this.buffer = null;
      this.bufferValue = null;
      this.isDefaultArray = opts.isDefaultArray || false;
      this.gl2 = gl;
      this.initialize(opts);
      Object.seal(this);
    }
    delete() {
      super.delete();
      if (this.buffer) {
        this.buffer.delete();
      }
      return this;
    }
    get MAX_ATTRIBUTES() {
      return VertexArrayObject.getMaxAttributes(this.gl);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return this.setProps(props);
    }
    setProps(props) {
      return this;
    }
    setElementBuffer() {
      let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assert7(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
      this.bind(() => {
        this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
      });
      return this;
    }
    setBuffer(location, buffer, accessor) {
      if (buffer.target === 34963) {
        return this.setElementBuffer(buffer, accessor);
      }
      const {
        size,
        type,
        stride,
        offset,
        normalized,
        integer,
        divisor
      } = accessor;
      const {
        gl,
        gl2
      } = this;
      location = Number(location);
      this.bind(() => {
        gl.bindBuffer(34962, buffer.handle);
        if (integer) {
          assert7(isWebGL2(gl));
          gl2.vertexAttribIPointer(location, size, type, stride, offset);
        } else {
          gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
        }
        gl.enableVertexAttribArray(location);
        gl2.vertexAttribDivisor(location, divisor || 0);
      });
      return this;
    }
    enable(location) {
      let enable2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      const disablingAttributeZero = !enable2 && location === 0 && !VertexArrayObject.isSupported(this.gl, {
        constantAttributeZero: true
      });
      if (!disablingAttributeZero) {
        location = Number(location);
        this.bind(() => enable2 ? this.gl.enableVertexAttribArray(location) : this.gl.disableVertexAttribArray(location));
      }
      return this;
    }
    getConstantBuffer(elementCount, value) {
      const constantValue = this._normalizeConstantArrayValue(value);
      const byteLength = constantValue.byteLength * elementCount;
      const length7 = constantValue.length * elementCount;
      let updateNeeded = !this.buffer;
      this.buffer = this.buffer || new Buffer2(this.gl, byteLength);
      updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
      updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);
      if (updateNeeded) {
        const typedArray = getScratchArray(value.constructor, length7);
        fillArray({
          target: typedArray,
          source: constantValue,
          start: 0,
          count: length7
        });
        this.buffer.subData(typedArray);
        this.bufferValue = value;
      }
      return this.buffer;
    }
    _normalizeConstantArrayValue(arrayValue) {
      if (Array.isArray(arrayValue)) {
        return new Float32Array(arrayValue);
      }
      return arrayValue;
    }
    _compareConstantArrayValues(v1, v2) {
      if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
        return false;
      }
      for (let i3 = 0; i3 < v1.length; ++i3) {
        if (v1[i3] !== v2[i3]) {
          return false;
        }
      }
      return true;
    }
    static _setConstantFloatArray(gl, location, array) {
      switch (array.length) {
        case 1:
          gl.vertexAttrib1fv(location, array);
          break;
        case 2:
          gl.vertexAttrib2fv(location, array);
          break;
        case 3:
          gl.vertexAttrib3fv(location, array);
          break;
        case 4:
          gl.vertexAttrib4fv(location, array);
          break;
        default:
          assert7(false);
      }
    }
    static _setConstantIntArray(gl, location, array) {
      assert7(isWebGL2(gl));
      switch (array.length) {
        case 1:
          gl.vertexAttribI1iv(location, array);
          break;
        case 2:
          gl.vertexAttribI2iv(location, array);
          break;
        case 3:
          gl.vertexAttribI3iv(location, array);
          break;
        case 4:
          gl.vertexAttribI4iv(location, array);
          break;
        default:
          assert7(false);
      }
    }
    static _setConstantUintArray(gl, location, array) {
      assert7(isWebGL2(gl));
      switch (array.length) {
        case 1:
          gl.vertexAttribI1uiv(location, array);
          break;
        case 2:
          gl.vertexAttribI2uiv(location, array);
          break;
        case 3:
          gl.vertexAttribI3uiv(location, array);
          break;
        case 4:
          gl.vertexAttribI4uiv(location, array);
          break;
        default:
          assert7(false);
      }
    }
    _createHandle() {
      const gl2 = this.gl;
      return gl2.createVertexArray();
    }
    _deleteHandle(handle) {
      this.gl2.deleteVertexArray(handle);
      return [this.elements];
    }
    _bindHandle(handle) {
      this.gl2.bindVertexArray(handle);
    }
    _getParameter(pname, _ref) {
      let {
        location
      } = _ref;
      assert7(Number.isFinite(location));
      return this.bind(() => {
        switch (pname) {
          case 34373:
            return this.gl.getVertexAttribOffset(location, pname);
          default:
            return this.gl.getVertexAttrib(location, pname);
        }
      });
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js
  var ERR_ATTRIBUTE_TYPE = "VertexArray: attributes must be Buffers or constants (i.e. typed array)";
  var MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
  var DEPRECATIONS_V6 = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
  var VertexArray = class {
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const id = opts.id || opts.program && opts.program.id;
      this.id = id;
      this.gl = gl;
      this.configuration = null;
      this.elements = null;
      this.elementsAccessor = null;
      this.values = null;
      this.accessors = null;
      this.unused = null;
      this.drawParams = null;
      this.buffer = null;
      this.attributes = {};
      this.vertexArrayObject = new VertexArrayObject(gl);
      stubRemovedMethods(this, "VertexArray", "v6.0", DEPRECATIONS_V6);
      this.initialize(opts);
      Object.seal(this);
    }
    delete() {
      if (this.buffer) {
        this.buffer.delete();
      }
      this.vertexArrayObject.delete();
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.reset();
      this.configuration = null;
      this.bindOnUse = false;
      return this.setProps(props);
    }
    reset() {
      this.elements = null;
      this.elementsAccessor = null;
      const {
        MAX_ATTRIBUTES
      } = this.vertexArrayObject;
      this.values = new Array(MAX_ATTRIBUTES).fill(null);
      this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
      this.unused = {};
      this.drawParams = null;
      return this;
    }
    setProps(props) {
      if ("program" in props) {
        this.configuration = props.program && props.program.configuration;
      }
      if ("configuration" in props) {
        this.configuration = props.configuration;
      }
      if ("attributes" in props) {
        this.setAttributes(props.attributes);
      }
      if ("elements" in props) {
        this.setElementBuffer(props.elements);
      }
      if ("bindOnUse" in props) {
        props = props.bindOnUse;
      }
      return this;
    }
    clearDrawParams() {
      this.drawParams = null;
    }
    getDrawParams() {
      this.drawParams = this.drawParams || this._updateDrawParams();
      return this.drawParams;
    }
    setAttributes(attributes) {
      Object.assign(this.attributes, attributes);
      this.vertexArrayObject.bind(() => {
        for (const locationOrName in attributes) {
          const value = attributes[locationOrName];
          this._setAttribute(locationOrName, value);
        }
        this.gl.bindBuffer(34962, null);
      });
      return this;
    }
    setElementBuffer() {
      let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.elements = elementBuffer;
      this.elementsAccessor = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
      return this;
    }
    setBuffer(locationOrName, buffer) {
      let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (buffer.target === 34963) {
        return this.setElementBuffer(buffer, appAccessor);
      }
      const {
        location,
        accessor
      } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);
      if (location >= 0) {
        this.values[location] = buffer;
        this.accessors[location] = accessor;
        this.clearDrawParams();
        this.vertexArrayObject.setBuffer(location, buffer, accessor);
      }
      return this;
    }
    setConstant(locationOrName, arrayValue) {
      let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const {
        location,
        accessor
      } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
        size: arrayValue.length
      }, appAccessor));
      if (location >= 0) {
        arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
        this.values[location] = arrayValue;
        this.accessors[location] = accessor;
        this.clearDrawParams();
        this.vertexArrayObject.enable(location, false);
      }
      return this;
    }
    unbindBuffers() {
      this.vertexArrayObject.bind(() => {
        if (this.elements) {
          this.vertexArrayObject.setElementBuffer(null);
        }
        this.buffer = this.buffer || new Buffer2(this.gl, {
          accessor: {
            size: 4
          }
        });
        for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          if (this.values[location] instanceof Buffer2) {
            this.gl.disableVertexAttribArray(location);
            this.gl.bindBuffer(34962, this.buffer.handle);
            this.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
          }
        }
      });
      return this;
    }
    bindBuffers() {
      this.vertexArrayObject.bind(() => {
        if (this.elements) {
          this.setElementBuffer(this.elements);
        }
        for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          const buffer = this.values[location];
          if (buffer instanceof Buffer2) {
            this.setBuffer(location, buffer);
          }
        }
      });
      return this;
    }
    bindForDraw(vertexCount, instanceCount, func) {
      let value;
      this.vertexArrayObject.bind(() => {
        this._setConstantAttributes(vertexCount, instanceCount);
        value = func();
      });
      return value;
    }
    _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
      const INVALID_RESULT = {
        location: -1,
        accessor: null
      };
      const {
        location,
        name: name10
      } = this._getAttributeIndex(locationOrName);
      if (!Number.isFinite(location) || location < 0) {
        this.unused[locationOrName] = value;
        log2.once(3, () => "unused value ".concat(locationOrName, " in ").concat(this.id))();
        return INVALID_RESULT;
      }
      const accessInfo = this._getAttributeInfo(name10 || location);
      if (!accessInfo) {
        return INVALID_RESULT;
      }
      const currentAccessor = this.accessors[location] || {};
      const accessor = Accessor.resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);
      const {
        size,
        type
      } = accessor;
      assert7(Number.isFinite(size) && Number.isFinite(type));
      return {
        location,
        accessor
      };
    }
    _getAttributeInfo(attributeName) {
      return this.configuration && this.configuration.getAttributeInfo(attributeName);
    }
    _getAttributeIndex(locationOrName) {
      const location = Number(locationOrName);
      if (Number.isFinite(location)) {
        return {
          location
        };
      }
      const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
      const name10 = multiLocation ? multiLocation[1] : locationOrName;
      const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;
      if (this.configuration) {
        return {
          location: this.configuration.getAttributeLocation(name10) + locationOffset,
          name: name10
        };
      }
      return {
        location: -1
      };
    }
    _setAttribute(locationOrName, value) {
      if (value instanceof Buffer2) {
        this.setBuffer(locationOrName, value);
      } else if (Array.isArray(value) && value.length && value[0] instanceof Buffer2) {
        const buffer = value[0];
        const accessor = value[1];
        this.setBuffer(locationOrName, buffer, accessor);
      } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
        const constant = value;
        this.setConstant(locationOrName, constant);
      } else if (value.buffer instanceof Buffer2) {
        const accessor = value;
        this.setBuffer(locationOrName, accessor.buffer, accessor);
      } else {
        throw new Error(ERR_ATTRIBUTE_TYPE);
      }
    }
    _setConstantAttributes(vertexCount, instanceCount) {
      const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
      let constant = this.values[0];
      if (ArrayBuffer.isView(constant)) {
        this._setConstantAttributeZero(constant, elementCount);
      }
      for (let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        constant = this.values[location];
        if (ArrayBuffer.isView(constant)) {
          this._setConstantAttribute(location, constant);
        }
      }
    }
    _setConstantAttributeZero(constant, elementCount) {
      if (VertexArrayObject.isSupported(this.gl, {
        constantAttributeZero: true
      })) {
        this._setConstantAttribute(0, constant);
        return;
      }
      const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
      this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
    }
    _setConstantAttribute(location, constant) {
      VertexArrayObject.setConstant(this.gl, location, constant);
    }
    _updateDrawParams() {
      const drawParams = {
        isIndexed: false,
        isInstanced: false,
        indexCount: Infinity,
        vertexCount: Infinity,
        instanceCount: Infinity
      };
      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        this._updateDrawParamsForLocation(drawParams, location);
      }
      if (this.elements) {
        drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
        drawParams.isIndexed = true;
        drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
        drawParams.indexOffset = this.elementsAccessor.offset || 0;
      }
      if (drawParams.indexCount === Infinity) {
        drawParams.indexCount = 0;
      }
      if (drawParams.vertexCount === Infinity) {
        drawParams.vertexCount = 0;
      }
      if (drawParams.instanceCount === Infinity) {
        drawParams.instanceCount = 0;
      }
      return drawParams;
    }
    _updateDrawParamsForLocation(drawParams, location) {
      const value = this.values[location];
      const accessor = this.accessors[location];
      if (!value) {
        return;
      }
      const {
        divisor
      } = accessor;
      const isInstanced = divisor > 0;
      drawParams.isInstanced = drawParams.isInstanced || isInstanced;
      if (value instanceof Buffer2) {
        const buffer = value;
        if (isInstanced) {
          const instanceCount = buffer.getVertexCount(accessor);
          drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
        } else {
          const vertexCount = buffer.getVertexCount(accessor);
          drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
        }
      }
    }
    setElements() {
      let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      log2.deprecated("setElements", "setElementBuffer")();
      return this.setElementBuffer(elementBuffer, accessor);
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js
  function formatArrayValue(v, opts) {
    const {
      maxElts = 16,
      size = 1
    } = opts;
    let string = "[";
    for (let i3 = 0; i3 < v.length && i3 < maxElts; ++i3) {
      if (i3 > 0) {
        string += ",".concat(i3 % size === 0 ? " " : "");
      }
      string += formatValue(v[i3], opts);
    }
    const terminator = v.length > maxElts ? "..." : "]";
    return "".concat(string).concat(terminator);
  }
  function formatValue(v) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const EPSILON6 = 1e-16;
    const {
      isInteger = false
    } = opts;
    if (Array.isArray(v) || ArrayBuffer.isView(v)) {
      return formatArrayValue(v, opts);
    }
    if (!Number.isFinite(v)) {
      return String(v);
    }
    if (Math.abs(v) < EPSILON6) {
      return isInteger ? "0" : "0.";
    }
    if (isInteger) {
      return v.toFixed(0);
    }
    if (Math.abs(v) > 100 && Math.abs(v) < 1e4) {
      return v.toFixed(0);
    }
    const string = v.toPrecision(2);
    const decimal = string.indexOf(".0");
    return decimal === string.length - 2 ? string.slice(0, -1) : string;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js
  function getDebugTableForUniforms(_ref) {
    let {
      header = "Uniforms",
      program,
      uniforms,
      undefinedOnly = false
    } = _ref;
    assert7(program);
    const SHADER_MODULE_UNIFORM_REGEXP = ".*_.*";
    const PROJECT_MODULE_UNIFORM_REGEXP = ".*Matrix";
    const uniformLocations = program._uniformSetters;
    const table = {};
    const uniformNames = Object.keys(uniformLocations).sort();
    let count2 = 0;
    for (const uniformName of uniformNames) {
      if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
        if (addUniformToTable({
          table,
          header,
          uniforms,
          uniformName,
          undefinedOnly
        })) {
          count2++;
        }
      }
    }
    for (const uniformName of uniformNames) {
      if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
        if (addUniformToTable({
          table,
          header,
          uniforms,
          uniformName,
          undefinedOnly
        })) {
          count2++;
        }
      }
    }
    for (const uniformName of uniformNames) {
      if (!table[uniformName]) {
        if (addUniformToTable({
          table,
          header,
          uniforms,
          uniformName,
          undefinedOnly
        })) {
          count2++;
        }
      }
    }
    let unusedCount = 0;
    const unusedTable = {};
    if (!undefinedOnly) {
      for (const uniformName in uniforms) {
        const uniform = uniforms[uniformName];
        if (!table[uniformName]) {
          unusedCount++;
          unusedTable[uniformName] = {
            Type: "NOT USED: ".concat(uniform),
            [header]: formatValue(uniform)
          };
        }
      }
    }
    return {
      table,
      count: count2,
      unusedTable,
      unusedCount
    };
  }
  function addUniformToTable(_ref2) {
    let {
      table,
      header,
      uniforms,
      uniformName,
      undefinedOnly
    } = _ref2;
    const value = uniforms[uniformName];
    const isDefined = isUniformDefined(value);
    if (!undefinedOnly || !isDefined) {
      table[uniformName] = {
        [header]: isDefined ? formatValue(value) : "N/A",
        "Uniform Type": isDefined ? value : "NOT PROVIDED"
      };
      return true;
    }
    return false;
  }
  function isUniformDefined(value) {
    return value !== void 0 && value !== null;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js
  function getDebugTableForVertexArray(_ref) {
    let {
      vertexArray,
      header = "Attributes"
    } = _ref;
    if (!vertexArray.configuration) {
      return {};
    }
    const table = {};
    if (vertexArray.elements) {
      table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
    }
    const attributes = vertexArray.values;
    for (const attributeLocation in attributes) {
      const info = vertexArray._getAttributeInfo(attributeLocation);
      if (info) {
        let rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
        const accessor = vertexArray.accessors[info.location];
        if (accessor) {
          rowHeader = "".concat(attributeLocation, ": ").concat(getGLSLDeclaration(info.name, accessor));
        }
        table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
      }
    }
    return table;
  }
  function getDebugTableRow(vertexArray, attribute, accessor, header) {
    const {
      gl
    } = vertexArray;
    if (!attribute) {
      return {
        [header]: "null",
        "Format ": "N/A"
      };
    }
    let type = "NOT PROVIDED";
    let size = 1;
    let verts = 0;
    let bytes = 0;
    let isInteger;
    let marker2;
    let value;
    if (accessor) {
      type = accessor.type;
      size = accessor.size;
      type = String(type).replace("Array", "");
      isInteger = type.indexOf("nt") !== -1;
    }
    if (attribute instanceof Buffer2) {
      const buffer = attribute;
      const {
        data,
        changed
      } = buffer.getDebugData();
      marker2 = changed ? "*" : "";
      value = data;
      bytes = buffer.byteLength;
      verts = bytes / data.BYTES_PER_ELEMENT / size;
      let format;
      if (accessor) {
        const instanced = accessor.divisor > 0;
        format = "".concat(instanced ? "I " : "P ", " ").concat(verts, " (x").concat(size, "=").concat(bytes, " bytes ").concat(getKey(gl, type), ")");
      } else {
        isInteger = true;
        format = "".concat(bytes, " bytes");
      }
      return {
        [header]: "".concat(marker2).concat(formatValue(value, {
          size,
          isInteger
        })),
        "Format ": format
      };
    }
    value = attribute;
    size = attribute.length;
    type = String(attribute.constructor.name).replace("Array", "");
    isInteger = type.indexOf("nt") !== -1;
    return {
      [header]: "".concat(formatValue(value, {
        size,
        isInteger
      }), " (constant)"),
      "Format ": "".concat(size, "x").concat(type, " (constant)")
    };
  }
  function getGLSLDeclaration(name10, accessor) {
    const {
      type,
      size
    } = accessor;
    const typeAndName = getCompositeGLType(type, size);
    return typeAndName ? "".concat(name10, " (").concat(typeAndName.name, ")") : name10;
  }

  // ../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js
  function getDebugTableForProgramConfiguration(config2) {
    const table = {};
    const header = "Accessors for ".concat(config2.id);
    for (const attributeInfo of config2.attributeInfos) {
      if (attributeInfo) {
        const glslDeclaration = getGLSLDeclaration2(attributeInfo);
        table["in ".concat(glslDeclaration)] = {
          [header]: JSON.stringify(attributeInfo.accessor)
        };
      }
    }
    for (const varyingInfo of config2.varyingInfos) {
      if (varyingInfo) {
        const glslDeclaration = getGLSLDeclaration2(varyingInfo);
        table["out ".concat(glslDeclaration)] = {
          [header]: JSON.stringify(varyingInfo.accessor)
        };
      }
    }
    return table;
  }
  function getGLSLDeclaration2(attributeInfo) {
    const {
      type,
      size
    } = attributeInfo.accessor;
    const typeAndName = getCompositeGLType(type, size);
    if (typeAndName) {
      return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
    }
    return attributeInfo.name;
  }

  // ../../node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js
  var isPage2 = isBrowser5() && typeof document !== "undefined";
  var statIdCounter = 0;
  var AnimationLoop = class {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        onCreateContext = (opts) => createGLContext(opts),
        onAddHTML = null,
        onInitialize = () => {
        },
        onRender = () => {
        },
        onFinalize = () => {
        },
        onError,
        gl = null,
        glOptions = {},
        debug: debug2 = false,
        createFramebuffer = false,
        autoResizeViewport = true,
        autoResizeDrawingBuffer = true,
        stats = lumaStats.get("animation-loop-".concat(statIdCounter++))
      } = props;
      let {
        useDevicePixels = true
      } = props;
      if ("useDevicePixelRatio" in props) {
        log2.deprecated("useDevicePixelRatio", "useDevicePixels")();
        useDevicePixels = props.useDevicePixelRatio;
      }
      this.props = {
        onCreateContext,
        onAddHTML,
        onInitialize,
        onRender,
        onFinalize,
        onError,
        gl,
        glOptions,
        debug: debug2,
        createFramebuffer
      };
      this.gl = gl;
      this.needsRedraw = null;
      this.timeline = null;
      this.stats = stats;
      this.cpuTime = this.stats.get("CPU Time");
      this.gpuTime = this.stats.get("GPU Time");
      this.frameRate = this.stats.get("Frame Rate");
      this._initialized = false;
      this._running = false;
      this._animationFrameId = null;
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._cpuStartTime = 0;
      this.setProps({
        autoResizeViewport,
        autoResizeDrawingBuffer,
        useDevicePixels
      });
      this.start = this.start.bind(this);
      this.stop = this.stop.bind(this);
      this._pageLoadPromise = null;
      this._onMousemove = this._onMousemove.bind(this);
      this._onMouseleave = this._onMouseleave.bind(this);
    }
    delete() {
      this.stop();
      this._setDisplay(null);
    }
    setNeedsRedraw(reason) {
      assert7(typeof reason === "string");
      this.needsRedraw = this.needsRedraw || reason;
      return this;
    }
    setProps(props) {
      if ("autoResizeViewport" in props) {
        this.autoResizeViewport = props.autoResizeViewport;
      }
      if ("autoResizeDrawingBuffer" in props) {
        this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
      }
      if ("useDevicePixels" in props) {
        this.useDevicePixels = props.useDevicePixels;
      }
      return this;
    }
    start() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this._running) {
        return this;
      }
      this._running = true;
      const startPromise = this._getPageLoadPromise().then(() => {
        if (!this._running || this._initialized) {
          return null;
        }
        this._createWebGLContext(opts);
        this._createFramebuffer();
        this._startEventHandling();
        this._initializeCallbackData();
        this._updateCallbackData();
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
        this._gpuTimeQuery = Query.isSupported(this.gl, ["timers"]) ? new Query(this.gl) : null;
        this._initialized = true;
        return this.onInitialize(this.animationProps);
      }).then((appContext) => {
        if (this._running) {
          this._addCallbackData(appContext || {});
          if (appContext !== false) {
            this._startLoop();
          }
        }
      });
      if (this.props.onError) {
        startPromise.catch(this.props.onError);
      }
      return this;
    }
    redraw() {
      if (this.isContextLost()) {
        return this;
      }
      this._beginTimers();
      this._setupFrame();
      this._updateCallbackData();
      this._renderFrame(this.animationProps);
      this._clearNeedsRedraw();
      if (this.offScreen && this.gl.commit) {
        this.gl.commit();
      }
      if (this._resolveNextFrame) {
        this._resolveNextFrame(this);
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
      }
      this._endTimers();
      return this;
    }
    stop() {
      if (this._running) {
        this._finalizeCallbackData();
        this._cancelAnimationFrame(this._animationFrameId);
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
        this._animationFrameId = null;
        this._running = false;
      }
      return this;
    }
    attachTimeline(timeline) {
      this.timeline = timeline;
      return this.timeline;
    }
    detachTimeline() {
      this.timeline = null;
    }
    waitForRender() {
      this.setNeedsRedraw("waitForRender");
      if (!this._nextFramePromise) {
        this._nextFramePromise = new Promise((resolve2) => {
          this._resolveNextFrame = resolve2;
        });
      }
      return this._nextFramePromise;
    }
    async toDataURL() {
      this.setNeedsRedraw("toDataURL");
      await this.waitForRender();
      return this.gl.canvas.toDataURL();
    }
    isContextLost() {
      return this.gl.isContextLost();
    }
    onCreateContext() {
      return this.props.onCreateContext(...arguments);
    }
    onInitialize() {
      return this.props.onInitialize(...arguments);
    }
    onRender() {
      return this.props.onRender(...arguments);
    }
    onFinalize() {
      return this.props.onFinalize(...arguments);
    }
    getHTMLControlValue(id) {
      let defaultValue2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      const element = document.getElementById(id);
      return element ? Number(element.value) : defaultValue2;
    }
    setViewParameters() {
      log2.removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")();
      return this;
    }
    _startLoop() {
      const renderFrame = () => {
        if (!this._running) {
          return;
        }
        this.redraw();
        this._animationFrameId = this._requestAnimationFrame(renderFrame);
      };
      this._cancelAnimationFrame(this._animationFrameId);
      this._animationFrameId = this._requestAnimationFrame(renderFrame);
    }
    _getPageLoadPromise() {
      if (!this._pageLoadPromise) {
        this._pageLoadPromise = isPage2 ? new Promise((resolve2, reject) => {
          if (isPage2 && document.readyState === "complete") {
            resolve2(document);
            return;
          }
          window.addEventListener("load", () => {
            resolve2(document);
          });
        }) : Promise.resolve({});
      }
      return this._pageLoadPromise;
    }
    _setDisplay(display) {
      if (this.display) {
        this.display.delete();
        this.display.animationLoop = null;
      }
      if (display) {
        display.animationLoop = this;
      }
      this.display = display;
    }
    _cancelAnimationFrame(animationFrameId) {
      if (this.display && this.display.cancelAnimationFrame) {
        return this.display.cancelAnimationFrame(animationFrameId);
      }
      return cancelAnimationFrame(animationFrameId);
    }
    _requestAnimationFrame(renderFrameCallback) {
      if (this._running) {
        if (this.display && this.display.requestAnimationFrame) {
          return this.display.requestAnimationFrame(renderFrameCallback);
        }
        return requestAnimationFrame2(renderFrameCallback);
      }
      return void 0;
    }
    _renderFrame() {
      if (this.display) {
        this.display._renderFrame(...arguments);
        return;
      }
      this.onRender(...arguments);
    }
    _clearNeedsRedraw() {
      this.needsRedraw = null;
    }
    _setupFrame() {
      this._resizeCanvasDrawingBuffer();
      this._resizeViewport();
      this._resizeFramebuffer();
    }
    _initializeCallbackData() {
      this.animationProps = {
        gl: this.gl,
        stop: this.stop,
        canvas: this.gl.canvas,
        framebuffer: this.framebuffer,
        useDevicePixels: this.useDevicePixels,
        needsRedraw: null,
        startTime: Date.now(),
        engineTime: 0,
        tick: 0,
        tock: 0,
        time: 0,
        _timeline: this.timeline,
        _loop: this,
        _animationLoop: this,
        _mousePosition: null
      };
    }
    _updateCallbackData() {
      const {
        width,
        height,
        aspect
      } = this._getSizeAndAspect();
      if (width !== this.animationProps.width || height !== this.animationProps.height) {
        this.setNeedsRedraw("drawing buffer resized");
      }
      if (aspect !== this.animationProps.aspect) {
        this.setNeedsRedraw("drawing buffer aspect changed");
      }
      this.animationProps.width = width;
      this.animationProps.height = height;
      this.animationProps.aspect = aspect;
      this.animationProps.needsRedraw = this.needsRedraw;
      this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
      if (this.timeline) {
        this.timeline.update(this.animationProps.engineTime);
      }
      this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
      this.animationProps.tock++;
      this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
      this.animationProps._offScreen = this.offScreen;
    }
    _finalizeCallbackData() {
      this.onFinalize(this.animationProps);
    }
    _addCallbackData(appContext) {
      if (typeof appContext === "object" && appContext !== null) {
        this.animationProps = Object.assign({}, this.animationProps, appContext);
      }
    }
    _createWebGLContext(opts) {
      this.offScreen = opts.canvas && typeof OffscreenCanvas !== "undefined" && opts.canvas instanceof OffscreenCanvas;
      opts = Object.assign({}, opts, this.props.glOptions);
      this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);
      if (!isWebGL(this.gl)) {
        throw new Error("AnimationLoop.onCreateContext - illegal context returned");
      }
      resetParameters(this.gl);
      this._createInfoDiv();
    }
    _createInfoDiv() {
      if (this.gl.canvas && this.props.onAddHTML) {
        const wrapperDiv = document.createElement("div");
        document.body.appendChild(wrapperDiv);
        wrapperDiv.style.position = "relative";
        const div = document.createElement("div");
        div.style.position = "absolute";
        div.style.left = "10px";
        div.style.bottom = "10px";
        div.style.width = "300px";
        div.style.background = "white";
        wrapperDiv.appendChild(this.gl.canvas);
        wrapperDiv.appendChild(div);
        const html = this.props.onAddHTML(div);
        if (html) {
          div.innerHTML = html;
        }
      }
    }
    _getSizeAndAspect() {
      const width = this.gl.drawingBufferWidth;
      const height = this.gl.drawingBufferHeight;
      let aspect = 1;
      const {
        canvas
      } = this.gl;
      if (canvas && canvas.clientHeight) {
        aspect = canvas.clientWidth / canvas.clientHeight;
      } else if (width > 0 && height > 0) {
        aspect = width / height;
      }
      return {
        width,
        height,
        aspect
      };
    }
    _resizeViewport() {
      if (this.autoResizeViewport) {
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
      }
    }
    _resizeCanvasDrawingBuffer() {
      if (this.autoResizeDrawingBuffer) {
        resizeGLContext(this.gl, {
          useDevicePixels: this.useDevicePixels
        });
      }
    }
    _createFramebuffer() {
      if (this.props.createFramebuffer) {
        this.framebuffer = new Framebuffer(this.gl);
      }
    }
    _resizeFramebuffer() {
      if (this.framebuffer) {
        this.framebuffer.resize({
          width: this.gl.drawingBufferWidth,
          height: this.gl.drawingBufferHeight
        });
      }
    }
    _beginTimers() {
      this.frameRate.timeEnd();
      this.frameRate.timeStart();
      if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
        this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds());
      }
      if (this._gpuTimeQuery) {
        this._gpuTimeQuery.beginTimeElapsedQuery();
      }
      this.cpuTime.timeStart();
    }
    _endTimers() {
      this.cpuTime.timeEnd();
      if (this._gpuTimeQuery) {
        this._gpuTimeQuery.end();
      }
    }
    _startEventHandling() {
      const {
        canvas
      } = this.gl;
      if (canvas) {
        canvas.addEventListener("mousemove", this._onMousemove);
        canvas.addEventListener("mouseleave", this._onMouseleave);
      }
    }
    _onMousemove(e2) {
      this.animationProps._mousePosition = [e2.offsetX, e2.offsetY];
    }
    _onMouseleave(e2) {
      this.animationProps._mousePosition = null;
    }
  };

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js
  var VERTEX_SHADER = "vs";
  var FRAGMENT_SHADER = "fs";

  // ../../node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js
  function assert8(condition, message) {
    if (!condition) {
      throw new Error(message || "shadertools: assertion failed.");
    }
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js
  var TYPE_DEFINITIONS = {
    number: {
      validate(value, propType) {
        return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
      }
    },
    array: {
      validate(value, propType) {
        return Array.isArray(value) || ArrayBuffer.isView(value);
      }
    }
  };
  function parsePropTypes(propDefs) {
    const propTypes2 = {};
    for (const propName in propDefs) {
      const propDef = propDefs[propName];
      const propType = parsePropType(propDef);
      propTypes2[propName] = propType;
    }
    return propTypes2;
  }
  function parsePropType(propDef) {
    let type = getTypeOf(propDef);
    if (type === "object") {
      if (!propDef) {
        return {
          type: "object",
          value: null
        };
      }
      if ("type" in propDef) {
        return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
      }
      if (!("value" in propDef)) {
        return {
          type: "object",
          value: propDef
        };
      }
      type = getTypeOf(propDef.value);
      return Object.assign({
        type
      }, propDef, TYPE_DEFINITIONS[type]);
    }
    return Object.assign({
      type,
      value: propDef
    }, TYPE_DEFINITIONS[type]);
  }
  function getTypeOf(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return "array";
    }
    return typeof value;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js
  var VERTEX_SHADER2 = "vs";
  var FRAGMENT_SHADER2 = "fs";
  var ShaderModule = class {
    constructor(_ref) {
      let {
        name: name10,
        vs: vs12,
        fs: fs8,
        dependencies = [],
        uniforms,
        getUniforms: getUniforms8,
        deprecations = [],
        defines: defines2 = {},
        inject: inject6 = {},
        vertexShader,
        fragmentShader
      } = _ref;
      assert8(typeof name10 === "string");
      this.name = name10;
      this.vs = vs12 || vertexShader;
      this.fs = fs8 || fragmentShader;
      this.getModuleUniforms = getUniforms8;
      this.dependencies = dependencies;
      this.deprecations = this._parseDeprecationDefinitions(deprecations);
      this.defines = defines2;
      this.injections = normalizeInjections(inject6);
      if (uniforms) {
        this.uniforms = parsePropTypes(uniforms);
      }
    }
    getModuleSource(type) {
      let moduleSource;
      switch (type) {
        case VERTEX_SHADER2:
          moduleSource = this.vs || "";
          break;
        case FRAGMENT_SHADER2:
          moduleSource = this.fs || "";
          break;
        default:
          assert8(false);
      }
      return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
    }
    getUniforms(opts, uniforms) {
      if (this.getModuleUniforms) {
        return this.getModuleUniforms(opts, uniforms);
      }
      if (this.uniforms) {
        return this._defaultGetUniforms(opts);
      }
      return {};
    }
    getDefines() {
      return this.defines;
    }
    checkDeprecations(shaderSource, log4) {
      this.deprecations.forEach((def) => {
        if (def.regex.test(shaderSource)) {
          if (def.deprecated) {
            log4.deprecated(def.old, def.new)();
          } else {
            log4.removed(def.old, def.new)();
          }
        }
      });
    }
    _parseDeprecationDefinitions(deprecations) {
      deprecations.forEach((def) => {
        switch (def.type) {
          case "function":
            def.regex = new RegExp("\\b".concat(def.old, "\\("));
            break;
          default:
            def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
        }
      });
      return deprecations;
    }
    _defaultGetUniforms() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const uniforms = {};
      const propTypes2 = this.uniforms;
      for (const key in propTypes2) {
        const propDef = propTypes2[key];
        if (key in opts && !propDef.private) {
          if (propDef.validate) {
            assert8(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
          }
          uniforms[key] = opts[key];
        } else {
          uniforms[key] = propDef.value;
        }
      }
      return uniforms;
    }
  };
  function normalizeShaderModule(module2) {
    if (!module2.normalized) {
      module2.normalized = true;
      if (module2.uniforms && !module2.getUniforms) {
        const shaderModule2 = new ShaderModule(module2);
        module2.getUniforms = shaderModule2.getUniforms.bind(shaderModule2);
      }
    }
    return module2;
  }
  function normalizeInjections(injections) {
    const result = {
      vs: {},
      fs: {}
    };
    for (const hook in injections) {
      let injection = injections[hook];
      const stage = hook.slice(0, 2);
      if (typeof injection === "string") {
        injection = {
          order: 0,
          injection
        };
      }
      result[stage][hook] = injection;
    }
    return result;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js
  function resolveModules(modules) {
    return getShaderDependencies(instantiateModules(modules));
  }
  function getShaderDependencies(modules) {
    const moduleMap = {};
    const moduleDepth = {};
    getDependencyGraph({
      modules,
      level: 0,
      moduleMap,
      moduleDepth
    });
    return Object.keys(moduleDepth).sort((a2, b) => moduleDepth[b] - moduleDepth[a2]).map((name10) => moduleMap[name10]);
  }
  function getDependencyGraph(_ref) {
    let {
      modules,
      level,
      moduleMap,
      moduleDepth
    } = _ref;
    if (level >= 5) {
      throw new Error("Possible loop in shader dependency graph");
    }
    for (const module2 of modules) {
      moduleMap[module2.name] = module2;
      if (moduleDepth[module2.name] === void 0 || moduleDepth[module2.name] < level) {
        moduleDepth[module2.name] = level;
      }
    }
    for (const module2 of modules) {
      if (module2.dependencies) {
        getDependencyGraph({
          modules: module2.dependencies,
          level: level + 1,
          moduleMap,
          moduleDepth
        });
      }
    }
  }
  function instantiateModules(modules, seen) {
    return modules.map((module2) => {
      if (module2 instanceof ShaderModule) {
        return module2;
      }
      assert8(typeof module2 !== "string", "Shader module use by name is deprecated. Import shader module '".concat(module2, "' and use it directly."));
      assert8(module2.name, "shader module has no name");
      module2 = new ShaderModule(module2);
      module2.dependencies = instantiateModules(module2.dependencies);
      return module2;
    });
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js
  function isOldIE() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const navigator2 = typeof window !== "undefined" ? window.navigator || {} : {};
    const userAgent2 = opts.userAgent || navigator2.userAgent || "";
    const isMSIE = userAgent2.indexOf("MSIE ") !== -1;
    const isTrident = userAgent2.indexOf("Trident/") !== -1;
    return isMSIE || isTrident;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js
  var GL_VENDOR = 7936;
  var GL_RENDERER = 7937;
  var GL_VERSION = 7938;
  var GL_SHADING_LANGUAGE_VERSION = 35724;
  var WEBGL_FEATURES = {
    GLSL_FRAG_DATA: ["WEBGL_draw_buffers", true],
    GLSL_FRAG_DEPTH: ["EXT_frag_depth", true],
    GLSL_DERIVATIVES: ["OES_standard_derivatives", true],
    GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", true]
  };
  var FEATURES2 = {};
  Object.keys(WEBGL_FEATURES).forEach((key) => {
    FEATURES2[key] = key;
  });
  function isWebGL22(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function getContextInfo(gl) {
    const info = gl.getExtension("WEBGL_debug_renderer_info");
    const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
    const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
    const gpuVendor = identifyGPUVendor(vendor, renderer);
    const gpuInfo = {
      gpuVendor,
      vendor,
      renderer,
      version: gl.getParameter(GL_VERSION),
      shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
    };
    return gpuInfo;
  }
  function identifyGPUVendor(vendor, renderer) {
    if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
      return "NVIDIA";
    }
    if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
      return "INTEL";
    }
    if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
      return "AMD";
    }
    return "UNKNOWN GPU";
  }
  var compiledGlslExtensions = {};
  function canCompileGLGSExtension(gl, cap) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const feature = WEBGL_FEATURES[cap];
    assert8(feature, cap);
    if (!isOldIE(opts)) {
      return true;
    }
    if (cap in compiledGlslExtensions) {
      return compiledGlslExtensions[cap];
    }
    const extensionName = feature[0];
    const behavior = opts.behavior || "enable";
    const source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
    const shader = gl.createShader(35633);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const canCompile = gl.getShaderParameter(shader, 35713);
    gl.deleteShader(shader);
    compiledGlslExtensions[cap] = canCompile;
    return canCompile;
  }
  function getFeature(gl, cap) {
    const feature = WEBGL_FEATURES[cap];
    assert8(feature, cap);
    const extensionName = isWebGL22(gl) ? feature[1] || feature[0] : feature[0];
    const value = typeof extensionName === "string" ? Boolean(gl.getExtension(extensionName)) : extensionName;
    assert8(value === false || value === true);
    return value;
  }
  function hasFeatures2(gl, features) {
    features = Array.isArray(features) ? features : [features];
    return features.every((feature) => getFeature(gl, feature));
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js
  function getPlatformShaderDefines(gl) {
    const debugInfo = getContextInfo(gl);
    switch (debugInfo.gpuVendor.toLowerCase()) {
      case "nvidia":
        return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
      case "intel":
        return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
      case "amd":
        return "#define AMD_GPU\n";
      default:
        return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
    }
  }
  function getVersionDefines(gl, glslVersion, isFragment) {
    let versionDefines = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
    if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DEPTH)) {
      versionDefines += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_DERIVATIVES) && canCompileGLGSExtension(gl, FEATURES2.GLSL_DERIVATIVES)) {
      versionDefines += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DATA) && canCompileGLGSExtension(gl, FEATURES2.GLSL_FRAG_DATA, {
      behavior: "require"
    })) {
      versionDefines += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_TEXTURE_LOD)) {
      versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n";
    }
    return versionDefines;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js
  var MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
  var MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js
  var MODULE_INJECTORS = {
    [VERTEX_SHADER]: MODULE_INJECTORS_VS,
    [FRAGMENT_SHADER]: MODULE_INJECTORS_FS
  };
  var DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
  var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
  var fragments = [];
  function injectShader(source, type, inject6) {
    let injectStandardStubs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const isVertex = type === VERTEX_SHADER;
    for (const key in inject6) {
      const fragmentData = inject6[key];
      fragmentData.sort((a2, b) => a2.order - b.order);
      fragments.length = fragmentData.length;
      for (let i3 = 0, len3 = fragmentData.length; i3 < len3; ++i3) {
        fragments[i3] = fragmentData[i3].injection;
      }
      const fragmentString = "".concat(fragments.join("\n"), "\n");
      switch (key) {
        case "vs:#decl":
          if (isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "vs:#main-start":
          if (isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "vs:#main-end":
          if (isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        case "fs:#decl":
          if (!isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "fs:#main-start":
          if (!isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "fs:#main-end":
          if (!isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        default:
          source = source.replace(key, (match) => match + fragmentString);
      }
    }
    source = source.replace(DECLARATION_INJECT_MARKER, "");
    if (injectStandardStubs) {
      source = source.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[type]);
    }
    return source;
  }
  function combineInjects(injects) {
    const result = {};
    assert8(Array.isArray(injects) && injects.length > 1);
    injects.forEach((inject6) => {
      for (const key in inject6) {
        result[key] = result[key] ? "".concat(result[key], "\n").concat(inject6[key]) : inject6[key];
      }
    });
    return result;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js
  function testVariable(qualifier) {
    return new RegExp("\\b".concat(qualifier, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g");
  }
  var ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]];
  var ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("attribute"), "in $1"], [testVariable("varying"), "out $1"]];
  var ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("varying"), "in $1"]];
  var ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, "#version 100"], [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("], [/\btexture\(/g, "texture2D("], [/\btextureLod\(/g, "texture2DLodEXT("]];
  var ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "attribute $1"], [testVariable("out"), "varying $1"]];
  var ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "varying $1"]];
  var ES100_FRAGMENT_OUTPUT_NAME = "gl_FragColor";
  var ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
  var REGEX_START_OF_MAIN2 = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  function transpileShader(source, targetGLSLVersion, isVertex) {
    switch (targetGLSLVersion) {
      case 300:
        return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);
      case 100:
        return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);
      default:
        throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
    }
  }
  function convertShader(source, replacements) {
    for (const [pattern, replacement] of replacements) {
      source = source.replace(pattern, replacement);
    }
    return source;
  }
  function convertFragmentShaderTo300(source) {
    source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
    const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
    if (outputMatch) {
      const outputName = outputMatch[1];
      source = source.replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
    } else {
      const outputName = "fragmentColor";
      source = source.replace(REGEX_START_OF_MAIN2, (match) => "out vec4 ".concat(outputName, ";\n").concat(match)).replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
    }
    return source;
  }
  function convertFragmentShaderTo100(source) {
    source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
    const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
    if (outputMatch) {
      const outputName = outputMatch[1];
      source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, "").replace(new RegExp("\\b".concat(outputName, "\\b"), "g"), ES100_FRAGMENT_OUTPUT_NAME);
    }
    return source;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js
  var INJECT_SHADER_DECLARATIONS = "\n\n".concat(DECLARATION_INJECT_MARKER, "\n\n");
  var SHADER_TYPE = {
    [VERTEX_SHADER]: "vertex",
    [FRAGMENT_SHADER]: "fragment"
  };
  var FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
  function assembleShaders(gl, opts) {
    const {
      vs: vs12,
      fs: fs8
    } = opts;
    const modules = resolveModules(opts.modules || []);
    return {
      gl,
      vs: assembleShader(gl, Object.assign({}, opts, {
        source: vs12,
        type: VERTEX_SHADER,
        modules
      })),
      fs: assembleShader(gl, Object.assign({}, opts, {
        source: fs8,
        type: FRAGMENT_SHADER,
        modules
      })),
      getUniforms: assembleGetUniforms(modules)
    };
  }
  function assembleShader(gl, _ref) {
    let {
      id,
      source,
      type,
      modules,
      defines: defines2 = {},
      hookFunctions = [],
      inject: inject6 = {},
      transpileToGLSL100 = false,
      prologue = true,
      log: log4
    } = _ref;
    assert8(typeof source === "string", "shader source must be a string");
    const isVertex = type === VERTEX_SHADER;
    const sourceLines = source.split("\n");
    let glslVersion = 100;
    let versionLine = "";
    let coreSource = source;
    if (sourceLines[0].indexOf("#version ") === 0) {
      glslVersion = 300;
      versionLine = sourceLines[0];
      coreSource = sourceLines.slice(1).join("\n");
    } else {
      versionLine = "#version ".concat(glslVersion);
    }
    const allDefines = {};
    modules.forEach((module2) => {
      Object.assign(allDefines, module2.getDefines());
    });
    Object.assign(allDefines, defines2);
    let assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName2({
      id,
      source,
      type
    }), "\n").concat(getShaderType({
      type
    }), "\n").concat(getPlatformShaderDefines(gl), "\n").concat(getVersionDefines(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? "" : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
    const hookFunctionMap = normalizeHookFunctions(hookFunctions);
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for (const key in inject6) {
      const injection = typeof inject6[key] === "string" ? {
        injection: inject6[key],
        order: 0
      } : inject6[key];
      const match = key.match(/^(v|f)s:(#)?([\w-]+)$/);
      if (match) {
        const hash = match[2];
        const name10 = match[3];
        if (hash) {
          if (name10 === "decl") {
            declInjections[key] = [injection];
          } else {
            mainInjections[key] = [injection];
          }
        } else {
          hookInjections[key] = [injection];
        }
      } else {
        mainInjections[key] = [injection];
      }
    }
    for (const module2 of modules) {
      if (log4) {
        module2.checkDeprecations(coreSource, log4);
      }
      const moduleSource = module2.getModuleSource(type, glslVersion);
      assembledSource += moduleSource;
      const injections = module2.injections[type];
      for (const key in injections) {
        const match = key.match(/^(v|f)s:#([\w-]+)$/);
        if (match) {
          const name10 = match[2];
          const injectionType = name10 === "decl" ? declInjections : mainInjections;
          injectionType[key] = injectionType[key] || [];
          injectionType[key].push(injections[key]);
        } else {
          hookInjections[key] = hookInjections[key] || [];
          hookInjections[key].push(injections[key]);
        }
      }
    }
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = injectShader(assembledSource, type, declInjections);
    assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);
    assembledSource += coreSource;
    assembledSource = injectShader(assembledSource, type, mainInjections);
    assembledSource = transpileShader(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
    return assembledSource;
  }
  function assembleGetUniforms(modules) {
    return function getUniforms8(opts) {
      const uniforms = {};
      for (const module2 of modules) {
        const moduleUniforms = module2.getUniforms(opts, uniforms);
        Object.assign(uniforms, moduleUniforms);
      }
      return uniforms;
    };
  }
  function getShaderType(_ref2) {
    let {
      type
    } = _ref2;
    return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
  }
  function getShaderName2(_ref3) {
    let {
      id,
      source,
      type
    } = _ref3;
    const injectShaderName = id && typeof id === "string" && source.indexOf("SHADER_NAME") === -1;
    return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : "";
  }
  function getApplicationDefines() {
    let defines2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let count2 = 0;
    let sourceText = "";
    for (const define2 in defines2) {
      if (count2 === 0) {
        sourceText += "\n// APPLICATION DEFINES\n";
      }
      count2++;
      const value = defines2[define2];
      if (value || Number.isFinite(value)) {
        sourceText += "#define ".concat(define2.toUpperCase(), " ").concat(defines2[define2], "\n");
      }
    }
    if (count2 === 0) {
      sourceText += "\n";
    }
    return sourceText;
  }
  function getHookFunctions(hookFunctions, hookInjections) {
    let result = "";
    for (const hookName in hookFunctions) {
      const hookFunction = hookFunctions[hookName];
      result += "void ".concat(hookFunction.signature, " {\n");
      if (hookFunction.header) {
        result += "  ".concat(hookFunction.header);
      }
      if (hookInjections[hookName]) {
        const injections = hookInjections[hookName];
        injections.sort((a2, b) => a2.order - b.order);
        for (const injection of injections) {
          result += "  ".concat(injection.injection, "\n");
        }
      }
      if (hookFunction.footer) {
        result += "  ".concat(hookFunction.footer);
      }
      result += "}\n";
    }
    return result;
  }
  function normalizeHookFunctions(hookFunctions) {
    const result = {
      vs: {},
      fs: {}
    };
    hookFunctions.forEach((hook) => {
      let opts;
      if (typeof hook !== "string") {
        opts = hook;
        hook = opts.hook;
      } else {
        opts = {};
      }
      hook = hook.trim();
      const [stage, signature] = hook.split(":");
      const name10 = hook.replace(/\(.+/, "");
      result[stage][name10] = Object.assign(opts, {
        signature
      });
    });
    return result;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js
  var FS100 = "void main() {gl_FragColor = vec4(0);}";
  var FS_GLES = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";
  var FS300 = "#version 300 es\n".concat(FS_GLES);
  function getQualifierDetails(line, qualifiers) {
    qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
    const words = line.replace(/^\s+/, "").split(/\s+/);
    const [qualifier, type, definition] = words;
    if (!qualifiers.includes(qualifier) || !type || !definition) {
      return null;
    }
    const name10 = definition.split(";")[0];
    return {
      qualifier,
      type,
      name: name10
    };
  }
  function getPassthroughFS() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      version = 100,
      input,
      inputType,
      output
    } = options;
    if (!input) {
      if (version === 300) {
        return FS300;
      } else if (version > 300) {
        return "#version ".concat(version, "\n").concat(FS_GLES);
      }
      return FS100;
    }
    const outputValue = convertToVec4(input, inputType);
    if (version >= 300) {
      return "#version ".concat(version, " ").concat(version === 300 ? "es" : "", "\nin ").concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
    }
    return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
  }
  function typeToChannelSuffix(type) {
    switch (type) {
      case "float":
        return "x";
      case "vec2":
        return "xy";
      case "vec3":
        return "xyz";
      case "vec4":
        return "xyzw";
      default:
        assert8(false);
        return null;
    }
  }
  function typeToChannelCount(type) {
    switch (type) {
      case "float":
        return 1;
      case "vec2":
        return 2;
      case "vec3":
        return 3;
      case "vec4":
        return 4;
      default:
        assert8(false);
        return null;
    }
  }
  function convertToVec4(variable, type) {
    switch (type) {
      case "float":
        return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");
      case "vec2":
        return "vec4(".concat(variable, ", 0.0, 1.0)");
      case "vec3":
        return "vec4(".concat(variable, ", 1.0)");
      case "vec4":
        return variable;
      default:
        assert8(false);
        return null;
    }
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js
  var fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
  var fp32 = {
    name: "fp32",
    vs: fp32shader,
    fs: null
  };

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js
  function fp64ify(a2) {
    let out = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let startIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const hiPart = Math.fround(a2);
    const loPart = a2 - hiPart;
    out[startIndex] = hiPart;
    out[startIndex + 1] = loPart;
    return out;
  }
  function fp64LowPart(a2) {
    return a2 - Math.fround(a2);
  }
  function fp64ifyMatrix4(matrix) {
    const matrixFP64 = new Float32Array(32);
    for (let i3 = 0; i3 < 4; ++i3) {
      for (let j = 0; j < 4; ++j) {
        const index = i3 * 4 + j;
        fp64ify(matrix[j * 4 + i3], matrixFP64, index * 2);
      }
    }
    return matrixFP64;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js
  var fp64_arithmetic_glsl_default = "uniform float ONE;\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n";

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js
  var fp64_functions_glsl_default = "const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\nvec2 exp_fp64(vec2 a) {\n\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n\n\n\n\n\n  s = sum_fp64(s, t);\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n";

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js
  var CONST_UNIFORMS = {
    ONE: 1
  };
  function getUniforms() {
    return CONST_UNIFORMS;
  }
  var fp64arithmetic = {
    name: "fp64-arithmetic",
    vs: fp64_arithmetic_glsl_default,
    fs: null,
    getUniforms,
    fp64ify,
    fp64LowPart,
    fp64ifyMatrix4
  };
  var fp64 = {
    name: "fp64",
    vs: fp64_functions_glsl_default,
    fs: null,
    dependencies: [fp64arithmetic],
    fp64ify,
    fp64LowPart,
    fp64ifyMatrix4
  };

  // ../../node_modules/@math.gl/core/dist/esm/lib/assert.js
  function assert9(condition, message) {
    if (!condition) {
      throw new Error("math.gl assertion ".concat(message));
    }
  }

  // ../../node_modules/@math.gl/core/dist/esm/lib/common.js
  var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
  var config = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true
  };
  function formatValue2(value, {
    precision = config.precision
  } = {}) {
    value = round(value);
    return "".concat(parseFloat(value.toPrecision(precision)));
  }
  function isArray2(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function toRadians(degrees2) {
    return radians(degrees2);
  }
  function toDegrees(radians2) {
    return degrees(radians2);
  }
  function radians(degrees2, result) {
    return map(degrees2, (degrees3) => degrees3 * DEGREES_TO_RADIANS, result);
  }
  function degrees(radians2, result) {
    return map(radians2, (radians3) => radians3 * RADIANS_TO_DEGREES, result);
  }
  function clamp(value, min, max) {
    return map(value, (value2) => Math.max(min, Math.min(max, value2)));
  }
  function lerp(a2, b, t2) {
    if (isArray2(a2)) {
      return a2.map((ai, i3) => lerp(ai, b[i3], t2));
    }
    return t2 * b + (1 - t2) * a2;
  }
  function equals(a2, b, epsilon) {
    const oldEpsilon = config.EPSILON;
    if (epsilon) {
      config.EPSILON = epsilon;
    }
    try {
      if (a2 === b) {
        return true;
      }
      if (isArray2(a2) && isArray2(b)) {
        if (a2.length !== b.length) {
          return false;
        }
        for (let i3 = 0; i3 < a2.length; ++i3) {
          if (!equals(a2[i3], b[i3])) {
            return false;
          }
        }
        return true;
      }
      if (a2 && a2.equals) {
        return a2.equals(b);
      }
      if (b && b.equals) {
        return b.equals(a2);
      }
      if (typeof a2 === "number" && typeof b === "number") {
        return Math.abs(a2 - b) <= config.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b));
      }
      return false;
    } finally {
      config.EPSILON = oldEpsilon;
    }
  }
  function round(value) {
    return Math.round(value / config.EPSILON) * config.EPSILON;
  }
  function duplicateArray(array) {
    return array.clone ? array.clone() : new Array(array.length);
  }
  function map(value, func, result) {
    if (isArray2(value)) {
      const array = value;
      result = result || duplicateArray(array);
      for (let i3 = 0; i3 < result.length && i3 < array.length; ++i3) {
        result[i3] = func(value[i3], i3, result);
      }
      return result;
    }
    return func(value);
  }

  // ../../node_modules/@math.gl/core/dist/esm/classes/base/math-array.js
  function _extendableBuiltin(cls) {
    function ExtendableBuiltin() {
      var instance = Reflect.construct(cls, Array.from(arguments));
      Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
      return instance;
    }
    ExtendableBuiltin.prototype = Object.create(cls.prototype, {
      constructor: {
        value: cls,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(ExtendableBuiltin, cls);
    } else {
      ExtendableBuiltin.__proto__ = cls;
    }
    return ExtendableBuiltin;
  }
  var MathArray = class extends _extendableBuiltin(Array) {
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = array[i3 + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        targetArray[offset + i3] = this[i3];
      }
      return targetArray;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray2(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target) {
      return target ? this.to(target) : this;
    }
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config);
    }
    formatString(opts) {
      let string = "";
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        string += (i3 > 0 ? ", " : "") + formatValue2(this[i3], opts);
      }
      return "".concat(opts.printTypes ? this.constructor.name : "", "[").concat(string, "]");
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        if (!equals(this[i3], array[i3])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        if (this[i3] !== array[i3]) {
          return false;
        }
      }
      return true;
    }
    negate() {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = -this[i3];
      }
      return this.check();
    }
    lerp(a2, b, t2) {
      if (t2 === void 0) {
        return this.lerp(this, a2, b);
      }
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        const ai = a2[i3];
        this[i3] = ai + t2 * (b[i3] - ai);
      }
      return this.check();
    }
    min(vector) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = Math.min(vector[i3], this[i3]);
      }
      return this.check();
    }
    max(vector) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = Math.max(vector[i3], this[i3]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = Math.min(Math.max(this[i3], minVector[i3]), maxVector[i3]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          this[i3] += vector[i3];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          this[i3] -= vector[i3];
        }
      }
      return this.check();
    }
    scale(scale8) {
      if (typeof scale8 === "number") {
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          this[i3] *= scale8;
        }
      } else {
        for (let i3 = 0; i3 < this.ELEMENTS && i3 < scale8.length; ++i3) {
          this[i3] *= scale8[i3];
        }
      }
      return this.check();
    }
    multiplyByScalar(scalar) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] *= scalar;
      }
      return this.check();
    }
    check() {
      if (config.debug && !this.validate()) {
        throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
      }
      return this;
    }
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        valid = valid && Number.isFinite(this[i3]);
      }
      return valid;
    }
    sub(a2) {
      return this.subtract(a2);
    }
    setScalar(a2) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = a2;
      }
      return this.check();
    }
    addScalar(a2) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] += a2;
      }
      return this.check();
    }
    subScalar(a2) {
      return this.addScalar(-a2);
    }
    multiplyScalar(scalar) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] *= scalar;
      }
      return this.check();
    }
    divideScalar(a2) {
      return this.multiplyByScalar(1 / a2);
    }
    clampScalar(min, max) {
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        this[i3] = Math.min(Math.max(this[i3], min), max);
      }
      return this.check();
    }
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/esm/lib/validators.js
  function validateVector(v, length7) {
    if (v.length !== length7) {
      return false;
    }
    for (let i3 = 0; i3 < v.length; ++i3) {
      if (!Number.isFinite(v[i3])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber(value) {
    if (!Number.isFinite(value)) {
      throw new Error("Invalid number ".concat(value));
    }
    return value;
  }
  function checkVector(v, length7, callerName = "") {
    if (config.debug && !validateVector(v, length7)) {
      throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
    }
    return v;
  }

  // ../../node_modules/@math.gl/core/dist/esm/classes/base/vector.js
  var Vector = class extends MathArray {
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber(value);
    }
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    magnitude() {
      return this.len();
    }
    lengthSquared() {
      let length7 = 0;
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        length7 += this[i3] * this[i3];
      }
      return length7;
    }
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length7 = 0;
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        const dist2 = this[i3] - mathArray[i3];
        length7 += dist2 * dist2;
      }
      return checkNumber(length7);
    }
    dot(mathArray) {
      let product = 0;
      for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
        product += this[i3] * mathArray[i3];
      }
      return checkNumber(product);
    }
    normalize() {
      const length7 = this.magnitude();
      if (length7 !== 0) {
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          this[i3] /= length7;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          this[i3] *= vector[i3];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          this[i3] /= vector[i3];
        }
      }
      return this.check();
    }
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i3) {
      assert9(i3 >= 0 && i3 < this.ELEMENTS, "index is out of range");
      return checkNumber(this[i3]);
    }
    setComponent(i3, value) {
      assert9(i3 >= 0 && i3 < this.ELEMENTS, "index is out of range");
      this[i3] = value;
      return this.check();
    }
    addVectors(a2, b) {
      return this.copy(a2).add(b);
    }
    subVectors(a2, b) {
      return this.copy(a2).subtract(b);
    }
    multiplyVectors(a2, b) {
      return this.copy(a2).multiply(b);
    }
    addScaledVector(a2, b) {
      return this.add(new this.constructor(a2).multiplyScalar(b));
    }
  };

  // ../../node_modules/gl-matrix/esm/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree = Math.PI / 180;
  if (!Math.hypot)
    Math.hypot = function() {
      var y2 = 0, i3 = arguments.length;
      while (i3--) {
        y2 += arguments[i3] * arguments[i3];
      }
      return Math.sqrt(y2);
    };

  // ../../node_modules/gl-matrix/esm/vec2.js
  function create() {
    var out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function add(out, a2, b) {
    out[0] = a2[0] + b[0];
    out[1] = a2[1] + b[1];
    return out;
  }
  function subtract(out, a2, b) {
    out[0] = a2[0] - b[0];
    out[1] = a2[1] - b[1];
    return out;
  }
  function scale(out, a2, b) {
    out[0] = a2[0] * b;
    out[1] = a2[1] * b;
    return out;
  }
  function length(a2) {
    var x2 = a2[0], y2 = a2[1];
    return Math.hypot(x2, y2);
  }
  function lerp2(out, a2, b, t2) {
    var ax = a2[0], ay = a2[1];
    out[0] = ax + t2 * (b[0] - ax);
    out[1] = ay + t2 * (b[1] - ay);
    return out;
  }
  function transformMat2(out, a2, m) {
    var x2 = a2[0], y2 = a2[1];
    out[0] = m[0] * x2 + m[2] * y2;
    out[1] = m[1] * x2 + m[3] * y2;
    return out;
  }
  function transformMat2d(out, a2, m) {
    var x2 = a2[0], y2 = a2[1];
    out[0] = m[0] * x2 + m[2] * y2 + m[4];
    out[1] = m[1] * x2 + m[3] * y2 + m[5];
    return out;
  }
  function transformMat3(out, a2, m) {
    var x2 = a2[0], y2 = a2[1];
    out[0] = m[0] * x2 + m[3] * y2 + m[6];
    out[1] = m[1] * x2 + m[4] * y2 + m[7];
    return out;
  }
  function transformMat4(out, a2, m) {
    var x2 = a2[0];
    var y2 = a2[1];
    out[0] = m[0] * x2 + m[4] * y2 + m[12];
    out[1] = m[1] * x2 + m[5] * y2 + m[13];
    return out;
  }
  var sub = subtract;
  var forEach2 = function() {
    var vec = create();
    return function(a2, stride, offset, count2, fn, arg) {
      var i3, l2;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l2 = Math.min(count2 * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i3 = offset; i3 < l2; i3 += stride) {
        vec[0] = a2[i3];
        vec[1] = a2[i3 + 1];
        fn(vec, vec, arg);
        a2[i3] = vec[0];
        a2[i3 + 1] = vec[1];
      }
      return a2;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector(out, a2, m) {
    const x2 = a2[0];
    const y2 = a2[1];
    const w = m[3] * x2 + m[7] * y2 || 1;
    out[0] = (m[0] * x2 + m[4] * y2) / w;
    out[1] = (m[1] * x2 + m[5] * y2) / w;
    return out;
  }
  function vec3_transformMat4AsVector(out, a2, m) {
    const x2 = a2[0];
    const y2 = a2[1];
    const z = a2[2];
    const w = m[3] * x2 + m[7] * y2 + m[11] * z || 1;
    out[0] = (m[0] * x2 + m[4] * y2 + m[8] * z) / w;
    out[1] = (m[1] * x2 + m[5] * y2 + m[9] * z) / w;
    out[2] = (m[2] * x2 + m[6] * y2 + m[10] * z) / w;
    return out;
  }
  function vec3_transformMat2(out, a2, m) {
    const x2 = a2[0];
    const y2 = a2[1];
    out[0] = m[0] * x2 + m[2] * y2;
    out[1] = m[1] * x2 + m[3] * y2;
    out[2] = a2[2];
    return out;
  }
  function vec4_transformMat2(out, a2, m) {
    const x2 = a2[0];
    const y2 = a2[1];
    out[0] = m[0] * x2 + m[2] * y2;
    out[1] = m[1] * x2 + m[3] * y2;
    out[2] = a2[2];
    out[3] = a2[3];
    return out;
  }
  function vec4_transformMat3(out, a2, m) {
    const x2 = a2[0];
    const y2 = a2[1];
    const z = a2[2];
    out[0] = m[0] * x2 + m[3] * y2 + m[6] * z;
    out[1] = m[1] * x2 + m[4] * y2 + m[7] * z;
    out[2] = m[2] * x2 + m[5] * y2 + m[8] * z;
    out[3] = a2[3];
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/esm/classes/vector2.js
  var Vector2 = class extends Vector {
    constructor(x2 = 0, y2 = 0) {
      super(2);
      if (isArray2(x2) && arguments.length === 1) {
        this.copy(x2);
      } else {
        if (config.debug) {
          checkNumber(x2);
          checkNumber(y2);
        }
        this[0] = x2;
        this[1] = y2;
      }
    }
    set(x2, y2) {
      this[0] = x2;
      this[1] = y2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
      }
      this[0] = object.x;
      this[1] = object.y;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      return object;
    }
    get ELEMENTS() {
      return 2;
    }
    horizontalAngle() {
      return Math.atan2(this.y, this.x);
    }
    verticalAngle() {
      return Math.atan2(this.x, this.y);
    }
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    transformAsPoint(matrix4) {
      transformMat4(this, this, matrix4);
      return this.check();
    }
    transformAsVector(matrix4) {
      vec2_transformMat4AsVector(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat3(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2x3(matrix2x3) {
      transformMat2d(this, this, matrix2x3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      transformMat2(this, this, matrix2);
      return this.check();
    }
  };

  // ../../node_modules/gl-matrix/esm/vec3.js
  function create2() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function length2(a2) {
    var x2 = a2[0];
    var y2 = a2[1];
    var z = a2[2];
    return Math.hypot(x2, y2, z);
  }
  function fromValues(x2, y2, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x2;
    out[1] = y2;
    out[2] = z;
    return out;
  }
  function distance(a2, b) {
    var x2 = b[0] - a2[0];
    var y2 = b[1] - a2[1];
    var z = b[2] - a2[2];
    return Math.hypot(x2, y2, z);
  }
  function negate(out, a2) {
    out[0] = -a2[0];
    out[1] = -a2[1];
    out[2] = -a2[2];
    return out;
  }
  function normalize(out, a2) {
    var x2 = a2[0];
    var y2 = a2[1];
    var z = a2[2];
    var len3 = x2 * x2 + y2 * y2 + z * z;
    if (len3 > 0) {
      len3 = 1 / Math.sqrt(len3);
    }
    out[0] = a2[0] * len3;
    out[1] = a2[1] * len3;
    out[2] = a2[2] * len3;
    return out;
  }
  function dot(a2, b) {
    return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
  }
  function cross(out, a2, b) {
    var ax = a2[0], ay = a2[1], az = a2[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function transformMat42(out, a2, m) {
    var x2 = a2[0], y2 = a2[1], z = a2[2];
    var w = m[3] * x2 + m[7] * y2 + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x2 + m[4] * y2 + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x2 + m[5] * y2 + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x2 + m[6] * y2 + m[10] * z + m[14]) / w;
    return out;
  }
  function transformMat32(out, a2, m) {
    var x2 = a2[0], y2 = a2[1], z = a2[2];
    out[0] = x2 * m[0] + y2 * m[3] + z * m[6];
    out[1] = x2 * m[1] + y2 * m[4] + z * m[7];
    out[2] = x2 * m[2] + y2 * m[5] + z * m[8];
    return out;
  }
  function transformQuat(out, a2, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x2 = a2[0], y2 = a2[1], z = a2[2];
    var uvx = qy * z - qz * y2, uvy = qz * x2 - qx * z, uvz = qx * y2 - qy * x2;
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x2 + uvx + uuvx;
    out[1] = y2 + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX(out, a2, b, rad) {
    var p2 = [], r2 = [];
    p2[0] = a2[0] - b[0];
    p2[1] = a2[1] - b[1];
    p2[2] = a2[2] - b[2];
    r2[0] = p2[0];
    r2[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
    r2[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
    out[0] = r2[0] + b[0];
    out[1] = r2[1] + b[1];
    out[2] = r2[2] + b[2];
    return out;
  }
  function rotateY(out, a2, b, rad) {
    var p2 = [], r2 = [];
    p2[0] = a2[0] - b[0];
    p2[1] = a2[1] - b[1];
    p2[2] = a2[2] - b[2];
    r2[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
    r2[1] = p2[1];
    r2[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
    out[0] = r2[0] + b[0];
    out[1] = r2[1] + b[1];
    out[2] = r2[2] + b[2];
    return out;
  }
  function rotateZ(out, a2, b, rad) {
    var p2 = [], r2 = [];
    p2[0] = a2[0] - b[0];
    p2[1] = a2[1] - b[1];
    p2[2] = a2[2] - b[2];
    r2[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
    r2[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
    r2[2] = p2[2];
    out[0] = r2[0] + b[0];
    out[1] = r2[1] + b[1];
    out[2] = r2[2] + b[2];
    return out;
  }
  function angle(a2, b) {
    var ax = a2[0], ay = a2[1], az = a2[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a2, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  var dist = distance;
  var len = length2;
  var forEach3 = function() {
    var vec = create2();
    return function(a2, stride, offset, count2, fn, arg) {
      var i3, l2;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l2 = Math.min(count2 * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i3 = offset; i3 < l2; i3 += stride) {
        vec[0] = a2[i3];
        vec[1] = a2[i3 + 1];
        vec[2] = a2[i3 + 2];
        fn(vec, vec, arg);
        a2[i3] = vec[0];
        a2[i3 + 1] = vec[1];
        a2[i3 + 2] = vec[2];
      }
      return a2;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/esm/classes/vector3.js
  var ORIGIN = [0, 0, 0];
  var ZERO;
  var Vector3 = class extends Vector {
    static get ZERO() {
      if (!ZERO) {
        ZERO = new Vector3(0, 0, 0);
        Object.freeze(ZERO);
      }
      return ZERO;
    }
    constructor(x2 = 0, y2 = 0, z = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray2(x2)) {
        this.copy(x2);
      } else {
        if (config.debug) {
          checkNumber(x2);
          checkNumber(y2);
          checkNumber(z);
        }
        this[0] = x2;
        this[1] = y2;
        this[2] = z;
      }
    }
    set(x2, y2, z) {
      this[0] = x2;
      this[1] = y2;
      this[2] = z;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
        checkNumber(object.z);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    angle(vector) {
      return angle(this, vector);
    }
    cross(vector) {
      cross(this, this, vector);
      return this.check();
    }
    rotateX({
      radians: radians2,
      origin = ORIGIN
    }) {
      rotateX(this, this, origin, radians2);
      return this.check();
    }
    rotateY({
      radians: radians2,
      origin = ORIGIN
    }) {
      rotateY(this, this, origin, radians2);
      return this.check();
    }
    rotateZ({
      radians: radians2,
      origin = ORIGIN
    }) {
      rotateZ(this, this, origin, radians2);
      return this.check();
    }
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    transformAsPoint(matrix4) {
      transformMat42(this, this, matrix4);
      return this.check();
    }
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat32(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat2(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat(this, this, quaternion2);
      return this.check();
    }
  };

  // ../../node_modules/@math.gl/core/dist/esm/classes/vector4.js
  var ZERO2;
  var Vector4 = class extends Vector {
    static get ZERO() {
      if (!ZERO2) {
        ZERO2 = new Vector4(0, 0, 0, 0);
        Object.freeze(ZERO2);
      }
      return ZERO2;
    }
    constructor(x2 = 0, y2 = 0, z = 0, w = 0) {
      super(-0, -0, -0, -0);
      if (isArray2(x2) && arguments.length === 1) {
        this.copy(x2);
      } else {
        if (config.debug) {
          checkNumber(x2);
          checkNumber(y2);
          checkNumber(z);
          checkNumber(w);
        }
        this[0] = x2;
        this[1] = y2;
        this[2] = z;
        this[3] = w;
      }
    }
    set(x2, y2, z, w) {
      this[0] = x2;
      this[1] = y2;
      this[2] = z;
      this[3] = w;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
        checkNumber(object.z);
        checkNumber(object.w);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this;
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      object.w = this[3];
      return object;
    }
    get ELEMENTS() {
      return 4;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber(value);
    }
    transform(matrix4) {
      transformMat42(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      vec4_transformMat3(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec4_transformMat2(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat(this, this, quaternion2);
      return this.check();
    }
    applyMatrix4(m) {
      m.transform(this, this);
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/esm/classes/base/matrix.js
  var Matrix = class extends MathArray {
    toString() {
      let string = "[";
      if (config.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += " ".concat(this[col * this.RANK + row]);
          }
        }
      } else {
        string += "column-major:";
        for (let i3 = 0; i3 < this.ELEMENTS; ++i3) {
          string += " ".concat(this[i3]);
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i3 = 0; i3 < this.RANK; ++i3) {
        result[i3] = this[firstIndex + i3];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i3 = 0; i3 < this.RANK; ++i3) {
        this[firstIndex + i3] = columnVector[i3];
      }
      return this;
    }
  };

  // ../../node_modules/gl-matrix/esm/mat3.js
  function create3() {
    var out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function transpose(out, a2) {
    if (out === a2) {
      var a01 = a2[1], a02 = a2[2], a12 = a2[5];
      out[1] = a2[3];
      out[2] = a2[6];
      out[3] = a01;
      out[5] = a2[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a2[0];
      out[1] = a2[3];
      out[2] = a2[6];
      out[3] = a2[1];
      out[4] = a2[4];
      out[5] = a2[7];
      out[6] = a2[2];
      out[7] = a2[5];
      out[8] = a2[8];
    }
    return out;
  }
  function invert(out, a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2];
    var a10 = a2[3], a11 = a2[4], a12 = a2[5];
    var a20 = a2[6], a21 = a2[7], a22 = a2[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function determinant(a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2];
    var a10 = a2[3], a11 = a2[4], a12 = a2[5];
    var a20 = a2[6], a21 = a2[7], a22 = a2[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply(out, a2, b) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2];
    var a10 = a2[3], a11 = a2[4], a12 = a2[5];
    var a20 = a2[6], a21 = a2[7], a22 = a2[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate(out, a2, v) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], x2 = v[0], y2 = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x2 * a00 + y2 * a10 + a20;
    out[7] = x2 * a01 + y2 * a11 + a21;
    out[8] = x2 * a02 + y2 * a12 + a22;
    return out;
  }
  function rotate(out, a2, rad) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], s2 = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s2 * a10;
    out[1] = c * a01 + s2 * a11;
    out[2] = c * a02 + s2 * a12;
    out[3] = c * a10 - s2 * a00;
    out[4] = c * a11 - s2 * a01;
    out[5] = c * a12 - s2 * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale2(out, a2, v) {
    var x2 = v[0], y2 = v[1];
    out[0] = x2 * a2[0];
    out[1] = x2 * a2[1];
    out[2] = x2 * a2[2];
    out[3] = y2 * a2[3];
    out[4] = y2 * a2[4];
    out[5] = y2 * a2[5];
    out[6] = a2[6];
    out[7] = a2[7];
    out[8] = a2[8];
    return out;
  }
  function fromQuat(out, q) {
    var x2 = q[0], y2 = q[1], z = q[2], w = q[3];
    var x22 = x2 + x2;
    var y22 = y2 + y2;
    var z2 = z + z;
    var xx = x2 * x22;
    var yx = y2 * x22;
    var yy = y2 * y22;
    var zx = z * x22;
    var zy = z * y22;
    var zz = z * z2;
    var wx = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/esm/classes/matrix3.js
  var INDICES;
  (function(INDICES3) {
    INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES3[INDICES3["COL1ROW0"] = 3] = "COL1ROW0";
    INDICES3[INDICES3["COL1ROW1"] = 4] = "COL1ROW1";
    INDICES3[INDICES3["COL1ROW2"] = 5] = "COL1ROW2";
    INDICES3[INDICES3["COL2ROW0"] = 6] = "COL2ROW0";
    INDICES3[INDICES3["COL2ROW1"] = 7] = "COL2ROW1";
    INDICES3[INDICES3["COL2ROW2"] = 8] = "COL2ROW2";
  })(INDICES || (INDICES = {}));
  var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  var Matrix3 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix();
    }
    static get ZERO() {
      return getZeroMatrix();
    }
    get ELEMENTS() {
      return 9;
    }
    get RANK() {
      return 3;
    }
    get INDICES() {
      return INDICES;
    }
    constructor(array, ...args) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else if (args.length > 0) {
        this.copy([array, ...args]);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      return this.check();
    }
    identity() {
      return this.copy(IDENTITY_MATRIX);
    }
    fromObject(object) {
      return this.check();
    }
    fromQuaternion(q) {
      fromQuat(this, q);
      return this.check();
    }
    set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    determinant() {
      return determinant(this);
    }
    transpose() {
      transpose(this, this);
      return this.check();
    }
    invert() {
      invert(this, this);
      return this.check();
    }
    multiplyLeft(a2) {
      multiply(this, a2, this);
      return this.check();
    }
    multiplyRight(a2) {
      multiply(this, this, a2);
      return this.check();
    }
    rotate(radians2) {
      rotate(this, this, radians2);
      return this.check();
    }
    scale(factor) {
      if (Array.isArray(factor)) {
        scale2(this, this, factor);
      } else {
        scale2(this, this, [factor, factor]);
      }
      return this.check();
    }
    translate(vec) {
      translate(this, this, vec);
      return this.check();
    }
    transform(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = transformMat3(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat32(result || [-0, -0, -0], vector, this);
          break;
        case 4:
          out = vec4_transformMat3(result || [-0, -0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformVector(vector, result) {
      return this.transform(vector, result);
    }
    transformVector2(vector, result) {
      return this.transform(vector, result);
    }
    transformVector3(vector, result) {
      return this.transform(vector, result);
    }
  };
  var ZERO_MATRIX3;
  var IDENTITY_MATRIX3;
  function getZeroMatrix() {
    if (!ZERO_MATRIX3) {
      ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO_MATRIX3);
    }
    return ZERO_MATRIX3;
  }
  function getIdentityMatrix() {
    if (!IDENTITY_MATRIX3) {
      IDENTITY_MATRIX3 = new Matrix3();
      Object.freeze(IDENTITY_MATRIX3);
    }
    return IDENTITY_MATRIX3;
  }

  // ../../node_modules/gl-matrix/esm/mat4.js
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose2(out, a2) {
    if (out === a2) {
      var a01 = a2[1], a02 = a2[2], a03 = a2[3];
      var a12 = a2[6], a13 = a2[7];
      var a23 = a2[11];
      out[1] = a2[4];
      out[2] = a2[8];
      out[3] = a2[12];
      out[4] = a01;
      out[6] = a2[9];
      out[7] = a2[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a2[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a2[0];
      out[1] = a2[4];
      out[2] = a2[8];
      out[3] = a2[12];
      out[4] = a2[1];
      out[5] = a2[5];
      out[6] = a2[9];
      out[7] = a2[13];
      out[8] = a2[2];
      out[9] = a2[6];
      out[10] = a2[10];
      out[11] = a2[14];
      out[12] = a2[3];
      out[13] = a2[7];
      out[14] = a2[11];
      out[15] = a2[15];
    }
    return out;
  }
  function invert2(out, a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function determinant2(a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  function multiply2(out, a2, b) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate2(out, a2, v) {
    var x2 = v[0], y2 = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a2 === out) {
      out[12] = a2[0] * x2 + a2[4] * y2 + a2[8] * z + a2[12];
      out[13] = a2[1] * x2 + a2[5] * y2 + a2[9] * z + a2[13];
      out[14] = a2[2] * x2 + a2[6] * y2 + a2[10] * z + a2[14];
      out[15] = a2[3] * x2 + a2[7] * y2 + a2[11] * z + a2[15];
    } else {
      a00 = a2[0];
      a01 = a2[1];
      a02 = a2[2];
      a03 = a2[3];
      a10 = a2[4];
      a11 = a2[5];
      a12 = a2[6];
      a13 = a2[7];
      a20 = a2[8];
      a21 = a2[9];
      a22 = a2[10];
      a23 = a2[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x2 + a10 * y2 + a20 * z + a2[12];
      out[13] = a01 * x2 + a11 * y2 + a21 * z + a2[13];
      out[14] = a02 * x2 + a12 * y2 + a22 * z + a2[14];
      out[15] = a03 * x2 + a13 * y2 + a23 * z + a2[15];
    }
    return out;
  }
  function scale3(out, a2, v) {
    var x2 = v[0], y2 = v[1], z = v[2];
    out[0] = a2[0] * x2;
    out[1] = a2[1] * x2;
    out[2] = a2[2] * x2;
    out[3] = a2[3] * x2;
    out[4] = a2[4] * y2;
    out[5] = a2[5] * y2;
    out[6] = a2[6] * y2;
    out[7] = a2[7] * y2;
    out[8] = a2[8] * z;
    out[9] = a2[9] * z;
    out[10] = a2[10] * z;
    out[11] = a2[11] * z;
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
    return out;
  }
  function rotate2(out, a2, rad, axis) {
    var x2 = axis[0], y2 = axis[1], z = axis[2];
    var len3 = Math.hypot(x2, y2, z);
    var s2, c, t2;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len3 < EPSILON) {
      return null;
    }
    len3 = 1 / len3;
    x2 *= len3;
    y2 *= len3;
    z *= len3;
    s2 = Math.sin(rad);
    c = Math.cos(rad);
    t2 = 1 - c;
    a00 = a2[0];
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a10 = a2[4];
    a11 = a2[5];
    a12 = a2[6];
    a13 = a2[7];
    a20 = a2[8];
    a21 = a2[9];
    a22 = a2[10];
    a23 = a2[11];
    b00 = x2 * x2 * t2 + c;
    b01 = y2 * x2 * t2 + z * s2;
    b02 = z * x2 * t2 - y2 * s2;
    b10 = x2 * y2 * t2 - z * s2;
    b11 = y2 * y2 * t2 + c;
    b12 = z * y2 * t2 + x2 * s2;
    b20 = x2 * z * t2 + y2 * s2;
    b21 = y2 * z * t2 - x2 * s2;
    b22 = z * z * t2 + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a2 !== out) {
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    return out;
  }
  function rotateX2(out, a2, rad) {
    var s2 = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a2[4];
    var a11 = a2[5];
    var a12 = a2[6];
    var a13 = a2[7];
    var a20 = a2[8];
    var a21 = a2[9];
    var a22 = a2[10];
    var a23 = a2[11];
    if (a2 !== out) {
      out[0] = a2[0];
      out[1] = a2[1];
      out[2] = a2[2];
      out[3] = a2[3];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[4] = a10 * c + a20 * s2;
    out[5] = a11 * c + a21 * s2;
    out[6] = a12 * c + a22 * s2;
    out[7] = a13 * c + a23 * s2;
    out[8] = a20 * c - a10 * s2;
    out[9] = a21 * c - a11 * s2;
    out[10] = a22 * c - a12 * s2;
    out[11] = a23 * c - a13 * s2;
    return out;
  }
  function rotateY2(out, a2, rad) {
    var s2 = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a2[0];
    var a01 = a2[1];
    var a02 = a2[2];
    var a03 = a2[3];
    var a20 = a2[8];
    var a21 = a2[9];
    var a22 = a2[10];
    var a23 = a2[11];
    if (a2 !== out) {
      out[4] = a2[4];
      out[5] = a2[5];
      out[6] = a2[6];
      out[7] = a2[7];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[0] = a00 * c - a20 * s2;
    out[1] = a01 * c - a21 * s2;
    out[2] = a02 * c - a22 * s2;
    out[3] = a03 * c - a23 * s2;
    out[8] = a00 * s2 + a20 * c;
    out[9] = a01 * s2 + a21 * c;
    out[10] = a02 * s2 + a22 * c;
    out[11] = a03 * s2 + a23 * c;
    return out;
  }
  function rotateZ2(out, a2, rad) {
    var s2 = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a2[0];
    var a01 = a2[1];
    var a02 = a2[2];
    var a03 = a2[3];
    var a10 = a2[4];
    var a11 = a2[5];
    var a12 = a2[6];
    var a13 = a2[7];
    if (a2 !== out) {
      out[8] = a2[8];
      out[9] = a2[9];
      out[10] = a2[10];
      out[11] = a2[11];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[0] = a00 * c + a10 * s2;
    out[1] = a01 * c + a11 * s2;
    out[2] = a02 * c + a12 * s2;
    out[3] = a03 * c + a13 * s2;
    out[4] = a10 * c - a00 * s2;
    out[5] = a11 * c - a01 * s2;
    out[6] = a12 * c - a02 * s2;
    out[7] = a13 * c - a03 * s2;
    return out;
  }
  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  function fromQuat2(out, q) {
    var x2 = q[0], y2 = q[1], z = q[2], w = q[3];
    var x22 = x2 + x2;
    var y22 = y2 + y2;
    var z2 = z + z;
    var xx = x2 * x22;
    var yx = y2 * x22;
    var yy = y2 * y22;
    var zx = z * x22;
    var zy = z * y22;
    var zz = z * z2;
    var wx = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    var f2 = 1 / Math.tan(fovy / 2), nf;
    out[0] = f2 / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f2;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function orthoNO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho = orthoNO;
  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len3;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len3 = 1 / Math.hypot(z0, z1, z2);
    z0 *= len3;
    z1 *= len3;
    z2 *= len3;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len3 = Math.hypot(x0, x1, x2);
    if (!len3) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len3 = 1 / len3;
      x0 *= len3;
      x1 *= len3;
      x2 *= len3;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len3 = Math.hypot(y0, y1, y2);
    if (!len3) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len3 = 1 / len3;
      y0 *= len3;
      y1 *= len3;
      y2 *= len3;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }

  // ../../node_modules/gl-matrix/esm/vec4.js
  function create4() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function add2(out, a2, b) {
    out[0] = a2[0] + b[0];
    out[1] = a2[1] + b[1];
    out[2] = a2[2] + b[2];
    out[3] = a2[3] + b[3];
    return out;
  }
  function scale4(out, a2, b) {
    out[0] = a2[0] * b;
    out[1] = a2[1] * b;
    out[2] = a2[2] * b;
    out[3] = a2[3] * b;
    return out;
  }
  function length3(a2) {
    var x2 = a2[0];
    var y2 = a2[1];
    var z = a2[2];
    var w = a2[3];
    return Math.hypot(x2, y2, z, w);
  }
  function squaredLength(a2) {
    var x2 = a2[0];
    var y2 = a2[1];
    var z = a2[2];
    var w = a2[3];
    return x2 * x2 + y2 * y2 + z * z + w * w;
  }
  function normalize2(out, a2) {
    var x2 = a2[0];
    var y2 = a2[1];
    var z = a2[2];
    var w = a2[3];
    var len3 = x2 * x2 + y2 * y2 + z * z + w * w;
    if (len3 > 0) {
      len3 = 1 / Math.sqrt(len3);
    }
    out[0] = x2 * len3;
    out[1] = y2 * len3;
    out[2] = z * len3;
    out[3] = w * len3;
    return out;
  }
  function dot2(a2, b) {
    return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2] + a2[3] * b[3];
  }
  function lerp3(out, a2, b, t2) {
    var ax = a2[0];
    var ay = a2[1];
    var az = a2[2];
    var aw = a2[3];
    out[0] = ax + t2 * (b[0] - ax);
    out[1] = ay + t2 * (b[1] - ay);
    out[2] = az + t2 * (b[2] - az);
    out[3] = aw + t2 * (b[3] - aw);
    return out;
  }
  function transformMat43(out, a2, m) {
    var x2 = a2[0], y2 = a2[1], z = a2[2], w = a2[3];
    out[0] = m[0] * x2 + m[4] * y2 + m[8] * z + m[12] * w;
    out[1] = m[1] * x2 + m[5] * y2 + m[9] * z + m[13] * w;
    out[2] = m[2] * x2 + m[6] * y2 + m[10] * z + m[14] * w;
    out[3] = m[3] * x2 + m[7] * y2 + m[11] * z + m[15] * w;
    return out;
  }
  function transformQuat2(out, a2, q) {
    var x2 = a2[0], y2 = a2[1], z = a2[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var ix = qw * x2 + qy * z - qz * y2;
    var iy = qw * y2 + qz * x2 - qx * z;
    var iz = qw * z + qx * y2 - qy * x2;
    var iw = -qx * x2 - qy * y2 - qz * z;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a2[3];
    return out;
  }
  var forEach4 = function() {
    var vec = create4();
    return function(a2, stride, offset, count2, fn, arg) {
      var i3, l2;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l2 = Math.min(count2 * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i3 = offset; i3 < l2; i3 += stride) {
        vec[0] = a2[i3];
        vec[1] = a2[i3 + 1];
        vec[2] = a2[i3 + 2];
        vec[3] = a2[i3 + 3];
        fn(vec, vec, arg);
        a2[i3] = vec[0];
        a2[i3 + 1] = vec[1];
        a2[i3 + 2] = vec[2];
        a2[i3 + 3] = vec[3];
      }
      return a2;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/esm/classes/matrix4.js
  var INDICES2;
  (function(INDICES3) {
    INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES3[INDICES3["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES3[INDICES3["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES3[INDICES3["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES3[INDICES3["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES3[INDICES3["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES3[INDICES3["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES3[INDICES3["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES3[INDICES3["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES3[INDICES3["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES3[INDICES3["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES3[INDICES3["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES3[INDICES3["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES3[INDICES3["COL3ROW3"] = 15] = "COL3ROW3";
  })(INDICES2 || (INDICES2 = {}));
  var DEFAULT_FOVY = 45 * Math.PI / 180;
  var DEFAULT_ASPECT = 1;
  var DEFAULT_NEAR = 0.1;
  var DEFAULT_FAR = 500;
  var IDENTITY_MATRIX2 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var Matrix4 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix2();
    }
    static get ZERO() {
      return getZeroMatrix2();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return INDICES2;
    }
    constructor(array) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
    identity() {
      return this.copy(IDENTITY_MATRIX2);
    }
    fromObject(object) {
      return this.check();
    }
    fromQuaternion(quaternion2) {
      fromQuat2(this, quaternion2);
      return this.check();
    }
    frustum(view) {
      const {
        left,
        right,
        bottom,
        top,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      if (far === Infinity) {
        computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
      } else {
        frustum(this, left, right, bottom, top, near, far);
      }
      return this.check();
    }
    lookAt(view) {
      const {
        eye,
        center = [0, 0, 0],
        up = [0, 1, 0]
      } = view;
      lookAt(this, eye, center, up);
      return this.check();
    }
    ortho(view) {
      const {
        left,
        right,
        bottom,
        top,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      ortho(this, left, right, bottom, top, near, far);
      return this.check();
    }
    orthographic(view) {
      const {
        fovy = DEFAULT_FOVY,
        aspect = DEFAULT_ASPECT,
        focalDistance = 1,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      checkRadians(fovy);
      const halfY = fovy / 2;
      const top = focalDistance * Math.tan(halfY);
      const right = top * aspect;
      return this.ortho({
        left: -right,
        right,
        bottom: -top,
        top,
        near,
        far
      });
    }
    perspective(view) {
      const {
        fovy = 45 * Math.PI / 180,
        aspect = 1,
        near = 0.1,
        far = 500
      } = view;
      checkRadians(fovy);
      perspective(this, fovy, aspect, near, far);
      return this.check();
    }
    determinant() {
      return determinant2(this);
    }
    getScale(result = [-0, -0, -0]) {
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
    getTranslation(result = [-0, -0, -0]) {
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
    getRotation(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale8 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale8[0];
      const inverseScale1 = 1 / scale8[1];
      const inverseScale2 = 1 / scale8[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
    getRotationMatrix3(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale8 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale8[0];
      const inverseScale1 = 1 / scale8[1];
      const inverseScale2 = 1 / scale8[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
    transpose() {
      transpose2(this, this);
      return this.check();
    }
    invert() {
      invert2(this, this);
      return this.check();
    }
    multiplyLeft(a2) {
      multiply2(this, a2, this);
      return this.check();
    }
    multiplyRight(a2) {
      multiply2(this, this, a2);
      return this.check();
    }
    rotateX(radians2) {
      rotateX2(this, this, radians2);
      return this.check();
    }
    rotateY(radians2) {
      rotateY2(this, this, radians2);
      return this.check();
    }
    rotateZ(radians2) {
      rotateZ2(this, this, radians2);
      return this.check();
    }
    rotateXYZ(angleXYZ) {
      return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    rotateAxis(radians2, axis) {
      rotate2(this, this, radians2, axis);
      return this.check();
    }
    scale(factor) {
      scale3(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
      return this.check();
    }
    translate(vector) {
      translate2(this, this, vector);
      return this.check();
    }
    transform(vector, result) {
      if (vector.length === 4) {
        result = transformMat43(result || [-0, -0, -0, -0], vector, this);
        checkVector(result, 4);
        return result;
      }
      return this.transformAsPoint(vector, result);
    }
    transformAsPoint(vector, result) {
      const {
        length: length7
      } = vector;
      let out;
      switch (length7) {
        case 2:
          out = transformMat4(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat42(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformAsVector(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
          break;
        case 3:
          out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformPoint(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformVector(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformDirection(vector, result) {
      return this.transformAsVector(vector, result);
    }
    makeRotationX(radians2) {
      return this.identity().rotateX(radians2);
    }
    makeTranslation(x2, y2, z) {
      return this.identity().translate([x2, y2, z]);
    }
  };
  var ZERO3;
  var IDENTITY;
  function getZeroMatrix2() {
    if (!ZERO3) {
      ZERO3 = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO3);
    }
    return ZERO3;
  }
  function getIdentityMatrix2() {
    if (!IDENTITY) {
      IDENTITY = new Matrix4();
      Object.freeze(IDENTITY);
    }
    return IDENTITY;
  }
  function checkRadians(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) {
      throw Error("expected radians");
    }
  }
  function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
  }

  // ../../node_modules/gl-matrix/esm/quat.js
  function create5() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity2(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s2 = Math.sin(rad);
    out[0] = s2 * axis[0];
    out[1] = s2 * axis[1];
    out[2] = s2 * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function multiply3(out, a2, b) {
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX3(out, a2, rad) {
    rad *= 0.5;
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var bx = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY3(out, a2, rad) {
    rad *= 0.5;
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var by = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ3(out, a2, rad) {
    rad *= 0.5;
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var bz = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW(out, a2) {
    var x2 = a2[0], y2 = a2[1], z = a2[2];
    out[0] = x2;
    out[1] = y2;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1 - x2 * x2 - y2 * y2 - z * z));
    return out;
  }
  function slerp(out, a2, b, t2) {
    var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega, cosom, sinom, scale0, scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t2) * omega) / sinom;
      scale1 = Math.sin(t2 * omega) / sinom;
    } else {
      scale0 = 1 - t2;
      scale1 = t2;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function invert3(out, a2) {
    var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
    var dot4 = a0 * a0 + a1 * a1 + a22 * a22 + a3 * a3;
    var invDot = dot4 ? 1 / dot4 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a22 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  function conjugate(out, a2) {
    out[0] = -a2[0];
    out[1] = -a2[1];
    out[2] = -a2[2];
    out[3] = a2[3];
    return out;
  }
  function fromMat3(out, m) {
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      var i3 = 0;
      if (m[4] > m[0])
        i3 = 1;
      if (m[8] > m[i3 * 3 + i3])
        i3 = 2;
      var j = (i3 + 1) % 3;
      var k = (i3 + 2) % 3;
      fRoot = Math.sqrt(m[i3 * 3 + i3] - m[j * 3 + j] - m[k * 3 + k] + 1);
      out[i3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i3] + m[i3 * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i3] + m[i3 * 3 + k]) * fRoot;
    }
    return out;
  }
  var add3 = add2;
  var scale5 = scale4;
  var dot3 = dot2;
  var lerp4 = lerp3;
  var length4 = length3;
  var squaredLength2 = squaredLength;
  var normalize3 = normalize2;
  var rotationTo = function() {
    var tmpvec3 = create2();
    var xUnitVec3 = fromValues(1, 0, 0);
    var yUnitVec3 = fromValues(0, 1, 0);
    return function(out, a2, b) {
      var dot4 = dot(a2, b);
      if (dot4 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a2);
        if (len(tmpvec3) < 1e-6)
          cross(tmpvec3, yUnitVec3, a2);
        normalize(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot4 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a2, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot4;
        return normalize3(out, out);
      }
    };
  }();
  var sqlerp = function() {
    var temp1 = create5();
    var temp2 = create5();
    return function(out, a2, b, c, d, t2) {
      slerp(temp1, a2, d, t2);
      slerp(temp2, b, c, t2);
      slerp(out, temp1, temp2, 2 * t2 * (1 - t2));
      return out;
    };
  }();
  var setAxes = function() {
    var matr = create3();
    return function(out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize3(out, fromMat3(out, matr));
    };
  }();

  // ../../node_modules/@math.gl/core/dist/esm/classes/quaternion.js
  var IDENTITY_QUATERNION = [0, 0, 0, 1];
  var Quaternion = class extends MathArray {
    constructor(x2 = 0, y2 = 0, z = 0, w = 1) {
      super(-0, -0, -0, -0);
      if (Array.isArray(x2) && arguments.length === 1) {
        this.copy(x2);
      } else {
        this.set(x2, y2, z, w);
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    set(x2, y2, z, w) {
      this[0] = x2;
      this[1] = y2;
      this[2] = z;
      this[3] = w;
      return this.check();
    }
    fromObject(object) {
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this.check();
    }
    fromMatrix3(m) {
      fromMat3(this, m);
      return this.check();
    }
    fromAxisRotation(axis, rad) {
      setAxisAngle(this, axis, rad);
      return this.check();
    }
    identity() {
      identity2(this);
      return this.check();
    }
    setAxisAngle(axis, rad) {
      return this.fromAxisRotation(axis, rad);
    }
    get ELEMENTS() {
      return 4;
    }
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber(value);
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber(value);
    }
    len() {
      return length4(this);
    }
    lengthSquared() {
      return squaredLength2(this);
    }
    dot(a2) {
      return dot3(this, a2);
    }
    rotationTo(vectorA, vectorB) {
      rotationTo(this, vectorA, vectorB);
      return this.check();
    }
    add(a2) {
      add3(this, this, a2);
      return this.check();
    }
    calculateW() {
      calculateW(this, this);
      return this.check();
    }
    conjugate() {
      conjugate(this, this);
      return this.check();
    }
    invert() {
      invert3(this, this);
      return this.check();
    }
    lerp(a2, b, t2) {
      if (t2 === void 0) {
        return this.lerp(this, a2, b);
      }
      lerp4(this, a2, b, t2);
      return this.check();
    }
    multiplyRight(a2) {
      multiply3(this, this, a2);
      return this.check();
    }
    multiplyLeft(a2) {
      multiply3(this, a2, this);
      return this.check();
    }
    normalize() {
      const length7 = this.len();
      const l2 = length7 > 0 ? 1 / length7 : 0;
      this[0] = this[0] * l2;
      this[1] = this[1] * l2;
      this[2] = this[2] * l2;
      this[3] = this[3] * l2;
      if (length7 === 0) {
        this[3] = 1;
      }
      return this.check();
    }
    rotateX(rad) {
      rotateX3(this, this, rad);
      return this.check();
    }
    rotateY(rad) {
      rotateY3(this, this, rad);
      return this.check();
    }
    rotateZ(rad) {
      rotateZ3(this, this, rad);
      return this.check();
    }
    scale(b) {
      scale5(this, this, b);
      return this.check();
    }
    slerp(arg0, arg1, arg2) {
      let start;
      let target;
      let ratio;
      switch (arguments.length) {
        case 1:
          ({
            start = IDENTITY_QUATERNION,
            target,
            ratio
          } = arg0);
          break;
        case 2:
          start = this;
          target = arg0;
          ratio = arg1;
          break;
        default:
          start = arg0;
          target = arg1;
          ratio = arg2;
      }
      slerp(this, start, target, ratio);
      return this.check();
    }
    transformVector4(vector, result = new Vector4()) {
      transformQuat2(result, vector, this);
      return checkVector(result, 4);
    }
    lengthSq() {
      return this.lengthSquared();
    }
    setFromAxisAngle(axis, rad) {
      return this.setAxisAngle(axis, rad);
    }
    premultiply(a2) {
      return this.multiplyLeft(a2);
    }
    multiply(a2) {
      return this.multiplyRight(a2);
    }
  };

  // ../../node_modules/@math.gl/core/node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // ../../node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js
  var EPSILON2 = 1e-6;
  var EARTH_RADIUS_METERS = 6371e3;
  var SphericalCoordinates = class {
    constructor({
      phi = 0,
      theta = 0,
      radius = 1,
      bearing,
      pitch,
      altitude,
      radiusScale = EARTH_RADIUS_METERS
    } = {}) {
      _defineProperty2(this, "phi", void 0);
      _defineProperty2(this, "theta", void 0);
      _defineProperty2(this, "radius", void 0);
      _defineProperty2(this, "radiusScale", void 0);
      this.phi = phi;
      this.theta = theta;
      this.radius = radius || altitude || 1;
      this.radiusScale = radiusScale || 1;
      if (bearing !== void 0) {
        this.bearing = bearing;
      }
      if (pitch !== void 0) {
        this.pitch = pitch;
      }
      this.check();
    }
    toString() {
      return this.formatString(config);
    }
    formatString({
      printTypes = false
    }) {
      const f2 = formatValue2;
      return "".concat(printTypes ? "Spherical" : "", "[rho:").concat(f2(this.radius), ",theta:").concat(f2(this.theta), ",phi:").concat(f2(this.phi), "]");
    }
    equals(other) {
      return equals(this.radius, other.radius) && equals(this.theta, other.theta) && equals(this.phi, other.phi);
    }
    exactEquals(other) {
      return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
    }
    get bearing() {
      return 180 - degrees(this.phi);
    }
    set bearing(v) {
      this.phi = Math.PI - radians(v);
    }
    get pitch() {
      return degrees(this.theta);
    }
    set pitch(v) {
      this.theta = radians(v);
    }
    get longitude() {
      return degrees(this.phi);
    }
    get latitude() {
      return degrees(this.theta);
    }
    get lng() {
      return degrees(this.phi);
    }
    get lat() {
      return degrees(this.theta);
    }
    get z() {
      return (this.radius - 1) * this.radiusScale;
    }
    set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this.check();
    }
    clone() {
      return new SphericalCoordinates().copy(this);
    }
    copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this.check();
    }
    fromLngLatZ([lng, lat, z]) {
      this.radius = 1 + z / this.radiusScale;
      this.phi = radians(lat);
      this.theta = radians(lng);
      return this.check();
    }
    fromVector3(v) {
      this.radius = length2(v);
      if (this.radius > 0) {
        this.theta = Math.atan2(v[0], v[1]);
        this.phi = Math.acos(clamp(v[2] / this.radius, -1, 1));
      }
      return this.check();
    }
    toVector3() {
      return new Vector3(0, 0, this.radius).rotateX({
        radians: this.theta
      }).rotateZ({
        radians: this.phi
      });
    }
    makeSafe() {
      this.phi = Math.max(EPSILON2, Math.min(Math.PI - EPSILON2, this.phi));
      return this;
    }
    check() {
      if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
        throw new Error("SphericalCoordinates: some fields set to invalid numbers");
      }
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/esm/lib/math-utils.js
  var math_utils_default = {
    EPSILON1: 0.1,
    EPSILON2: 0.01,
    EPSILON3: 1e-3,
    EPSILON4: 1e-4,
    EPSILON5: 1e-5,
    EPSILON6: 1e-6,
    EPSILON7: 1e-7,
    EPSILON8: 1e-8,
    EPSILON9: 1e-9,
    EPSILON10: 1e-10,
    EPSILON11: 1e-11,
    EPSILON12: 1e-12,
    EPSILON13: 1e-13,
    EPSILON14: 1e-14,
    EPSILON15: 1e-15,
    EPSILON16: 1e-16,
    EPSILON17: 1e-17,
    EPSILON18: 1e-18,
    EPSILON19: 1e-19,
    EPSILON20: 1e-20,
    PI_OVER_TWO: Math.PI / 2,
    PI_OVER_FOUR: Math.PI / 4,
    PI_OVER_SIX: Math.PI / 6,
    TWO_PI: Math.PI * 2
  };

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js
  var lights_glsl_default = "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js
  var INITIAL_MODULE_OPTIONS = {
    lightSources: {}
  };
  function convertColor() {
    let {
      color = [0, 0, 0],
      intensity = 1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return color.map((component) => component * intensity / 255);
  }
  function getLightSourceUniforms(_ref) {
    let {
      ambientLight,
      pointLights = [],
      directionalLights = []
    } = _ref;
    const lightSourceUniforms = {};
    if (ambientLight) {
      lightSourceUniforms["lighting_uAmbientLight.color"] = convertColor(ambientLight);
    } else {
      lightSourceUniforms["lighting_uAmbientLight.color"] = [0, 0, 0];
    }
    pointLights.forEach((pointLight, index) => {
      lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);
      lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;
      lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation || [1, 0, 0];
    });
    lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
    directionalLights.forEach((directionalLight, index) => {
      lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);
      lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;
    });
    lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
    return lightSourceUniforms;
  }
  function getUniforms2() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS;
    if ("lightSources" in opts) {
      const {
        ambientLight,
        pointLights,
        directionalLights
      } = opts.lightSources || {};
      const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
      if (!hasLights) {
        return {
          lighting_uEnabled: false
        };
      }
      return Object.assign({}, getLightSourceUniforms({
        ambientLight,
        pointLights,
        directionalLights
      }), {
        lighting_uEnabled: true
      });
    }
    if ("lights" in opts) {
      const lightSources = {
        pointLights: [],
        directionalLights: []
      };
      for (const light of opts.lights || []) {
        switch (light.type) {
          case "ambient":
            lightSources.ambientLight = light;
            break;
          case "directional":
            lightSources.directionalLights.push(light);
            break;
          case "point":
            lightSources.pointLights.push(light);
            break;
          default:
        }
      }
      return getUniforms2({
        lightSources
      });
    }
    return {};
  }
  var lights = {
    name: "lights",
    vs: lights_glsl_default,
    fs: lights_glsl_default,
    getUniforms: getUniforms2,
    defines: {
      MAX_LIGHTS: 3
    }
  };

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js
  var DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
  var DEFAULT_MODULE_OPTIONS = {
    pickingSelectedColor: null,
    pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
    pickingActive: false,
    pickingAttribute: false
  };
  function getUniforms3() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_MODULE_OPTIONS;
    const uniforms = {};
    if (opts.pickingSelectedColor !== void 0) {
      if (!opts.pickingSelectedColor) {
        uniforms.picking_uSelectedColorValid = 0;
      } else {
        const selectedColor = opts.pickingSelectedColor.slice(0, 3);
        uniforms.picking_uSelectedColorValid = 1;
        uniforms.picking_uSelectedColor = selectedColor;
      }
    }
    if (opts.pickingHighlightColor) {
      const color = Array.from(opts.pickingHighlightColor, (x2) => x2 / 255);
      if (!Number.isFinite(color[3])) {
        color[3] = 1;
      }
      uniforms.picking_uHighlightColor = color;
    }
    if (opts.pickingActive !== void 0) {
      uniforms.picking_uActive = Boolean(opts.pickingActive);
      uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);
    }
    return uniforms;
  }
  var vs = "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n";
  var fs = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
  var picking = {
    name: "picking",
    vs,
    fs,
    getUniforms: getUniforms3
  };

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js
  var phong_lighting_glsl_default = "\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n";

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js
  var INITIAL_MODULE_OPTIONS2 = {};
  function getMaterialUniforms(material) {
    const {
      ambient = 0.35,
      diffuse = 0.6,
      shininess = 32,
      specularColor = [30, 30, 30]
    } = material;
    return {
      lighting_uAmbient: ambient,
      lighting_uDiffuse: diffuse,
      lighting_uShininess: shininess,
      lighting_uSpecularColor: specularColor.map((x2) => x2 / 255)
    };
  }
  function getUniforms4() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS2;
    if (!("material" in opts)) {
      return {};
    }
    const {
      material
    } = opts;
    if (!material) {
      return {
        lighting_uEnabled: false
      };
    }
    return getMaterialUniforms(material);
  }
  var gouraudLighting = {
    name: "gouraud-lighting",
    dependencies: [lights],
    vs: phong_lighting_glsl_default,
    defines: {
      LIGHTING_VERTEX: 1
    },
    getUniforms: getUniforms4
  };
  var phongLighting = {
    name: "phong-lighting",
    dependencies: [lights],
    fs: phong_lighting_glsl_default,
    defines: {
      LIGHTING_FRAGMENT: 1
    },
    getUniforms: getUniforms4
  };

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js
  var pbr_vertex_glsl_default = "uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\nvarying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n# else\nvarying vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n";

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js
  var pbr_fragment_glsl_default = "#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)\n# error PBR fragment shader: Texture LOD is not available\n#endif\n\n#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)\n# error PBR fragment shader: Derivatives are not available\n#endif\n\n\n#if (__VERSION__ < 300)\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\n#else\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\n#endif\n\nprecision highp float;\n\nuniform bool pbr_uUnlit;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nvarying vec3 pbr_vPosition;\n\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\n\n\nstruct PBRInfo\n{\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float LdotH;\n  float VdotH;\n  float perceptualRoughness;\n  float metalness;\n  vec3 reflectance0;\n  vec3 reflectance90;\n  float alphaRoughness;\n  vec3 diffuseColor;\n  vec3 specularColor;\n  vec3 n;\n  vec3 v;\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\n  return vec4(linOut,srgbIn.w);;\n#else\n  return srgbIn;\n#endif\n}\n\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0;\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n\n\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);\n  vec3 h = normalize(l+v);\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbr_uUnlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n\n\n    float perceptualRoughness = u_MetallicRoughnessValues.y;\n    float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n\n    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n\n\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();\n    vec3 v = normalize(u_Camera - pbr_vPosition);\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInputs = PBRInfo(\n      0.0,\n      NdotV,\n      0.0,\n      0.0,\n      0.0,\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n#ifdef USE_LIGHTS\n    PBRInfo_setAmbientLight(pbrInputs);\n    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {\n      if (i < lighting_uDirectionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n      }\n    }\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {\n      if (i < lighting_uPointLightCount) {\n        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n      }\n    }\n#endif\n#ifdef USE_IBL\n    color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\n    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifdef PBR_DEBUG\n\n\n\n\n\n    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n";

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js
  var pbr = {
    name: "pbr",
    vs: pbr_vertex_glsl_default,
    fs: pbr_fragment_glsl_default,
    defines: {
      LIGHTING_FRAGMENT: 1
    },
    dependencies: [lights]
  };

  // ../../node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js
  var vs2 = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
  var transform = {
    name: "transform",
    vs: vs2,
    fs: null
  };

  // ../../node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js
  var ProgramManager = class {
    static getDefaultProgramManager(gl) {
      gl.luma = gl.luma || {};
      gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);
      return gl.luma.defaultProgramManager;
    }
    constructor(gl) {
      this.gl = gl;
      this._programCache = {};
      this._getUniforms = {};
      this._registeredModules = {};
      this._hookFunctions = [];
      this._defaultModules = [];
      this._hashes = {};
      this._hashCounter = 0;
      this.stateHash = 0;
      this._useCounts = {};
    }
    addDefaultModule(module2) {
      if (!this._defaultModules.find((m) => m.name === module2.name)) {
        this._defaultModules.push(module2);
      }
      this.stateHash++;
    }
    removeDefaultModule(module2) {
      const moduleName = typeof module2 === "string" ? module2 : module2.name;
      this._defaultModules = this._defaultModules.filter((m) => m.name !== moduleName);
      this.stateHash++;
    }
    addShaderHook(hook, opts) {
      if (opts) {
        hook = Object.assign(opts, {
          hook
        });
      }
      this._hookFunctions.push(hook);
      this.stateHash++;
    }
    get() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        vs: vs12 = "",
        fs: fs8 = "",
        defines: defines2 = {},
        inject: inject6 = {},
        varyings = [],
        bufferMode = 35981,
        transpileToGLSL100 = false
      } = props;
      const modules = this._getModuleList(props.modules);
      const vsHash = this._getHash(vs12);
      const fsHash = this._getHash(fs8);
      const moduleHashes = modules.map((m) => this._getHash(m.name)).sort();
      const varyingHashes = varyings.map((v) => this._getHash(v));
      const defineKeys = Object.keys(defines2).sort();
      const injectKeys = Object.keys(inject6).sort();
      const defineHashes = [];
      const injectHashes = [];
      for (const key of defineKeys) {
        defineHashes.push(this._getHash(key));
        defineHashes.push(this._getHash(defines2[key]));
      }
      for (const key of injectKeys) {
        injectHashes.push(this._getHash(key));
        injectHashes.push(this._getHash(inject6[key]));
      }
      const hash = "".concat(vsHash, "/").concat(fsHash, "D").concat(defineHashes.join("/"), "M").concat(moduleHashes.join("/"), "I").concat(injectHashes.join("/"), "V").concat(varyingHashes.join("/"), "H").concat(this.stateHash, "B").concat(bufferMode).concat(transpileToGLSL100 ? "T" : "");
      if (!this._programCache[hash]) {
        const assembled = assembleShaders(this.gl, {
          vs: vs12,
          fs: fs8,
          modules,
          inject: inject6,
          defines: defines2,
          hookFunctions: this._hookFunctions,
          transpileToGLSL100
        });
        this._programCache[hash] = new Program(this.gl, {
          hash,
          vs: assembled.vs,
          fs: assembled.fs,
          varyings,
          bufferMode
        });
        this._getUniforms[hash] = assembled.getUniforms || ((x2) => {
        });
        this._useCounts[hash] = 0;
      }
      this._useCounts[hash]++;
      return this._programCache[hash];
    }
    getUniforms(program) {
      return this._getUniforms[program.hash] || null;
    }
    release(program) {
      const hash = program.hash;
      this._useCounts[hash]--;
      if (this._useCounts[hash] === 0) {
        this._programCache[hash].delete();
        delete this._programCache[hash];
        delete this._getUniforms[hash];
        delete this._useCounts[hash];
      }
    }
    _getHash(key) {
      if (this._hashes[key] === void 0) {
        this._hashes[key] = this._hashCounter++;
      }
      return this._hashes[key];
    }
    _getModuleList() {
      let appModules = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      const modules = new Array(this._defaultModules.length + appModules.length);
      const seen = {};
      let count2 = 0;
      for (let i3 = 0, len3 = this._defaultModules.length; i3 < len3; ++i3) {
        const module2 = this._defaultModules[i3];
        const name10 = module2.name;
        modules[count2++] = module2;
        seen[name10] = true;
      }
      for (let i3 = 0, len3 = appModules.length; i3 < len3; ++i3) {
        const module2 = appModules[i3];
        const name10 = module2.name;
        if (!seen[name10]) {
          modules[count2++] = module2;
          seen[name10] = true;
        }
      }
      modules.length = count2;
      return modules;
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js
  var GLTF_TO_LUMA_ATTRIBUTE_MAP = {
    POSITION: "positions",
    NORMAL: "normals",
    COLOR_0: "colors",
    TEXCOORD_0: "texCoords",
    TEXCOORD_1: "texCoords1",
    TEXCOORD_2: "texCoords2"
  };
  function getBuffersFromGeometry(gl, geometry, options) {
    const buffers = {};
    let indices = geometry.indices;
    for (const name10 in geometry.attributes) {
      const attribute = geometry.attributes[name10];
      const remappedName = mapAttributeName(name10, options);
      if (name10 === "indices") {
        indices = attribute;
      } else if (attribute.constant) {
        buffers[remappedName] = attribute.value;
      } else {
        const typedArray = attribute.value;
        const accessor = {
          ...attribute
        };
        delete accessor.value;
        buffers[remappedName] = [new Buffer2(gl, typedArray), accessor];
        inferAttributeAccessor(name10, accessor);
      }
    }
    if (indices) {
      const data = indices.value || indices;
      assert7(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
      const accessor = {
        size: 1,
        isIndexed: indices.isIndexed === void 0 ? true : indices.isIndexed
      };
      buffers.indices = [new Buffer2(gl, {
        data,
        target: 34963
      }), accessor];
    }
    return buffers;
  }
  function mapAttributeName(name10, options) {
    const {
      attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP
    } = options || {};
    return attributeMap && attributeMap[name10] || name10;
  }
  function inferAttributeAccessor(attributeName, attribute) {
    let category;
    switch (attributeName) {
      case "texCoords":
      case "texCoord1":
      case "texCoord2":
      case "texCoord3":
        category = "uvs";
        break;
      case "vertices":
      case "positions":
      case "normals":
      case "pickingColors":
        category = "vectors";
        break;
      default:
    }
    switch (category) {
      case "vectors":
        attribute.size = attribute.size || 3;
        break;
      case "uvs":
        attribute.size = attribute.size || 2;
        break;
      default:
    }
    assert7(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
  }

  // ../../node_modules/@luma.gl/engine/dist/esm/lib/model.js
  var LOG_DRAW_PRIORITY = 2;
  var LOG_DRAW_TIMEOUT = 1e4;
  var ERR_MODEL_PARAMS = "Model needs drawMode and vertexCount";
  var NOOP2 = () => {
  };
  var DRAW_PARAMS = {};
  var Model = class {
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        id = uid("model")
      } = props;
      assert7(isWebGL(gl));
      this.id = id;
      this.gl = gl;
      this.id = props.id || uid("Model");
      this.lastLogTime = 0;
      this.animated = false;
      this.initialize(props);
    }
    initialize(props) {
      this.props = {};
      this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);
      this._programManagerState = -1;
      this._managedProgram = false;
      const {
        program = null,
        vs: vs12,
        fs: fs8,
        modules,
        defines: defines2,
        inject: inject6,
        varyings,
        bufferMode,
        transpileToGLSL100
      } = props;
      this.programProps = {
        program,
        vs: vs12,
        fs: fs8,
        modules,
        defines: defines2,
        inject: inject6,
        varyings,
        bufferMode,
        transpileToGLSL100
      };
      this.program = null;
      this.vertexArray = null;
      this._programDirty = true;
      this.userData = {};
      this.needsRedraw = true;
      this._attributes = {};
      this.attributes = {};
      this.uniforms = {};
      this.pickable = true;
      this._checkProgram();
      this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
      this.drawMode = props.drawMode !== void 0 ? props.drawMode : 4;
      this.vertexCount = props.vertexCount || 0;
      this.geometryBuffers = {};
      this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;
      this._setModelProps(props);
      this.geometry = {};
      assert7(this.drawMode !== void 0 && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
    }
    setProps(props) {
      this._setModelProps(props);
    }
    delete() {
      for (const key in this._attributes) {
        if (this._attributes[key] !== this.attributes[key]) {
          this._attributes[key].delete();
        }
      }
      if (this._managedProgram) {
        this.programManager.release(this.program);
        this._managedProgram = false;
      }
      this.vertexArray.delete();
      this._deleteGeometryBuffers();
    }
    getDrawMode() {
      return this.drawMode;
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getInstanceCount() {
      return this.instanceCount;
    }
    getAttributes() {
      return this.attributes;
    }
    getProgram() {
      return this.program;
    }
    setProgram(props) {
      const {
        program,
        vs: vs12,
        fs: fs8,
        modules,
        defines: defines2,
        inject: inject6,
        varyings,
        bufferMode,
        transpileToGLSL100
      } = props;
      this.programProps = {
        program,
        vs: vs12,
        fs: fs8,
        modules,
        defines: defines2,
        inject: inject6,
        varyings,
        bufferMode,
        transpileToGLSL100
      };
      this._programDirty = true;
    }
    getUniforms() {
      return this.uniforms;
    }
    setDrawMode(drawMode) {
      this.drawMode = drawMode;
      return this;
    }
    setVertexCount(vertexCount) {
      assert7(Number.isFinite(vertexCount));
      this.vertexCount = vertexCount;
      return this;
    }
    setInstanceCount(instanceCount) {
      assert7(Number.isFinite(instanceCount));
      this.instanceCount = instanceCount;
      return this;
    }
    setGeometry(geometry) {
      this.drawMode = geometry.drawMode;
      this.vertexCount = geometry.getVertexCount();
      this._deleteGeometryBuffers();
      this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);
      this.vertexArray.setAttributes(this.geometryBuffers);
      return this;
    }
    setAttributes() {
      let attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (isObjectEmpty2(attributes)) {
        return this;
      }
      const normalizedAttributes = {};
      for (const name10 in attributes) {
        const attribute = attributes[name10];
        normalizedAttributes[name10] = attribute.getValue ? attribute.getValue() : attribute;
      }
      this.vertexArray.setAttributes(normalizedAttributes);
      return this;
    }
    setUniforms() {
      let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Object.assign(this.uniforms, uniforms);
      return this;
    }
    getModuleUniforms(opts) {
      this._checkProgram();
      const getUniforms8 = this.programManager.getUniforms(this.program);
      if (getUniforms8) {
        return getUniforms8(opts);
      }
      return {};
    }
    updateModuleSettings(opts) {
      const uniforms = this.getModuleUniforms(opts || {});
      return this.setUniforms(uniforms);
    }
    clear(opts) {
      clear(this.program.gl, opts);
      return this;
    }
    draw() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._checkProgram();
      const {
        moduleSettings = null,
        framebuffer,
        uniforms = {},
        attributes = {},
        transformFeedback = this.transformFeedback,
        parameters: parameters2 = {},
        vertexArray = this.vertexArray
      } = opts;
      this.setAttributes(attributes);
      this.updateModuleSettings(moduleSettings);
      this.setUniforms(uniforms);
      let logPriority;
      if (log2.priority >= LOG_DRAW_PRIORITY) {
        logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);
      }
      const drawParams = this.vertexArray.getDrawParams();
      const {
        isIndexed = drawParams.isIndexed,
        indexType = drawParams.indexType,
        indexOffset = drawParams.indexOffset,
        vertexArrayInstanced = drawParams.isInstanced
      } = this.props;
      if (vertexArrayInstanced && !this.isInstanced) {
        log2.warn("Found instanced attributes on non-instanced model", this.id)();
      }
      const {
        isInstanced,
        instanceCount
      } = this;
      const {
        onBeforeRender = NOOP2,
        onAfterRender = NOOP2
      } = this.props;
      onBeforeRender();
      this.program.setUniforms(this.uniforms);
      const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {
        logPriority,
        uniforms: null,
        framebuffer,
        parameters: parameters2,
        drawMode: this.getDrawMode(),
        vertexCount: this.getVertexCount(),
        vertexArray,
        transformFeedback,
        isIndexed,
        indexType,
        isInstanced,
        instanceCount,
        offset: isIndexed ? indexOffset : 0
      }));
      onAfterRender();
      if (log2.priority >= LOG_DRAW_PRIORITY) {
        this._logDrawCallEnd(logPriority, vertexArray, framebuffer);
      }
      return didDraw;
    }
    transform() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        discard = true,
        feedbackBuffers,
        unbindModels = []
      } = opts;
      let {
        parameters: parameters2
      } = opts;
      if (feedbackBuffers) {
        this._setFeedbackBuffers(feedbackBuffers);
      }
      if (discard) {
        parameters2 = Object.assign({}, parameters2, {
          [35977]: discard
        });
      }
      unbindModels.forEach((model) => model.vertexArray.unbindBuffers());
      try {
        this.draw(Object.assign({}, opts, {
          parameters: parameters2
        }));
      } finally {
        unbindModels.forEach((model) => model.vertexArray.bindBuffers());
      }
      return this;
    }
    render() {
      let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")();
      return this.setUniforms(uniforms).draw();
    }
    _setModelProps(props) {
      Object.assign(this.props, props);
      if ("uniforms" in props) {
        this.setUniforms(props.uniforms);
      }
      if ("pickable" in props) {
        this.pickable = props.pickable;
      }
      if ("instanceCount" in props) {
        this.instanceCount = props.instanceCount;
      }
      if ("geometry" in props) {
        this.setGeometry(props.geometry);
      }
      if ("attributes" in props) {
        this.setAttributes(props.attributes);
      }
      if ("_feedbackBuffers" in props) {
        this._setFeedbackBuffers(props._feedbackBuffers);
      }
    }
    _checkProgram() {
      const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;
      if (!needsUpdate) {
        return;
      }
      let {
        program
      } = this.programProps;
      if (program) {
        this._managedProgram = false;
      } else {
        const {
          vs: vs12,
          fs: fs8,
          modules,
          inject: inject6,
          defines: defines2,
          varyings,
          bufferMode,
          transpileToGLSL100
        } = this.programProps;
        program = this.programManager.get({
          vs: vs12,
          fs: fs8,
          modules,
          inject: inject6,
          defines: defines2,
          varyings,
          bufferMode,
          transpileToGLSL100
        });
        if (this.program && this._managedProgram) {
          this.programManager.release(this.program);
        }
        this._programManagerState = this.programManager.stateHash;
        this._managedProgram = true;
      }
      assert7(program instanceof Program, "Model needs a program");
      this._programDirty = false;
      if (program === this.program) {
        return;
      }
      this.program = program;
      if (this.vertexArray) {
        this.vertexArray.setProps({
          program: this.program,
          attributes: this.vertexArray.attributes
        });
      } else {
        this.vertexArray = new VertexArray(this.gl, {
          program: this.program
        });
      }
      this.setUniforms(Object.assign({}, this.getModuleUniforms()));
    }
    _deleteGeometryBuffers() {
      for (const name10 in this.geometryBuffers) {
        const buffer = this.geometryBuffers[name10][0] || this.geometryBuffers[name10];
        if (buffer instanceof Buffer2) {
          buffer.delete();
        }
      }
    }
    _setAnimationProps(animationProps) {
      if (this.animated) {
        assert7(animationProps, "Model.draw(): animated uniforms but no animationProps");
      }
    }
    _setFeedbackBuffers() {
      let feedbackBuffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (isObjectEmpty2(feedbackBuffers)) {
        return this;
      }
      const {
        gl
      } = this.program;
      this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {
        program: this.program
      });
      this.transformFeedback.setBuffers(feedbackBuffers);
      return this;
    }
    _logDrawCallStart(logLevel) {
      const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;
      if (Date.now() - this.lastLogTime < logDrawTimeout) {
        return void 0;
      }
      this.lastLogTime = Date.now();
      log2.group(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
        collapsed: log2.level <= 2
      })();
      return logLevel;
    }
    _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {
      if (logLevel === void 0) {
        return;
      }
      const attributeTable = getDebugTableForVertexArray({
        vertexArray,
        header: "".concat(this.id, " attributes"),
        attributes: this._attributes
      });
      const {
        table: uniformTable,
        unusedTable,
        unusedCount
      } = getDebugTableForUniforms({
        header: "".concat(this.id, " uniforms"),
        program: this.program,
        uniforms: Object.assign({}, this.program.uniforms, uniforms)
      });
      const {
        table: missingTable,
        count: missingCount
      } = getDebugTableForUniforms({
        header: "".concat(this.id, " uniforms"),
        program: this.program,
        uniforms: Object.assign({}, this.program.uniforms, uniforms),
        undefinedOnly: true
      });
      if (missingCount > 0) {
        log2.log("MISSING UNIFORMS", Object.keys(missingTable))();
      }
      if (unusedCount > 0) {
        log2.log("UNUSED UNIFORMS", Object.keys(unusedTable))();
      }
      const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);
      log2.table(logLevel, attributeTable)();
      log2.table(logLevel, uniformTable)();
      log2.table(logLevel + 1, configTable)();
      if (framebuffer) {
        framebuffer.log({
          logLevel: LOG_DRAW_PRIORITY,
          message: "Rendered to ".concat(framebuffer.id)
        });
      }
      log2.groupEnd(LOG_DRAW_PRIORITY)();
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js
  var BufferTransform = class {
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.currentIndex = 0;
      this.feedbackMap = {};
      this.varyings = null;
      this.bindings = [];
      this.resources = {};
      this._initialize(props);
      Object.seal(this);
    }
    setupResources(opts) {
      for (const binding of this.bindings) {
        this._setupTransformFeedback(binding, opts);
      }
    }
    updateModelProps() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        varyings
      } = this;
      if (varyings.length > 0) {
        props = Object.assign({}, props, {
          varyings
        });
      }
      return props;
    }
    getDrawOptions() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const binding = this.bindings[this.currentIndex];
      const {
        sourceBuffers,
        transformFeedback
      } = binding;
      const attributes = Object.assign({}, sourceBuffers, opts.attributes);
      return {
        attributes,
        transformFeedback
      };
    }
    swap() {
      if (this.feedbackMap) {
        this.currentIndex = this._getNextIndex();
        return true;
      }
      return false;
    }
    update() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._setupBuffers(opts);
    }
    getBuffer(varyingName) {
      const {
        feedbackBuffers
      } = this.bindings[this.currentIndex];
      const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;
      if (!bufferOrParams) {
        return null;
      }
      return bufferOrParams instanceof Buffer2 ? bufferOrParams : bufferOrParams.buffer;
    }
    getData() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        varyingName
      } = options;
      const buffer = this.getBuffer(varyingName);
      if (buffer) {
        return buffer.getData();
      }
      return null;
    }
    delete() {
      for (const name10 in this.resources) {
        this.resources[name10].delete();
      }
    }
    _initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._setupBuffers(props);
      this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);
      if (this.varyings.length > 0) {
        assert7(isWebGL2(this.gl));
      }
    }
    _getFeedbackBuffers(props) {
      const {
        sourceBuffers = {}
      } = props;
      const feedbackBuffers = {};
      if (this.bindings[this.currentIndex]) {
        Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
      }
      if (this.feedbackMap) {
        for (const sourceName in this.feedbackMap) {
          const feedbackName = this.feedbackMap[sourceName];
          if (sourceName in sourceBuffers) {
            feedbackBuffers[feedbackName] = sourceName;
          }
        }
      }
      Object.assign(feedbackBuffers, props.feedbackBuffers);
      for (const bufferName in feedbackBuffers) {
        const bufferOrRef = feedbackBuffers[bufferName];
        if (typeof bufferOrRef === "string") {
          const sourceBuffer = sourceBuffers[bufferOrRef];
          const {
            byteLength,
            usage,
            accessor
          } = sourceBuffer;
          feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
            byteLength,
            usage,
            accessor
          });
        }
      }
      return feedbackBuffers;
    }
    _setupBuffers() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        sourceBuffers = null
      } = props;
      Object.assign(this.feedbackMap, props.feedbackMap);
      const feedbackBuffers = this._getFeedbackBuffers(props);
      this._updateBindings({
        sourceBuffers,
        feedbackBuffers
      });
    }
    _setupTransformFeedback(binding, _ref) {
      let {
        model
      } = _ref;
      const {
        program
      } = model;
      binding.transformFeedback = new TransformFeedback(this.gl, {
        program,
        buffers: binding.feedbackBuffers
      });
    }
    _updateBindings(opts) {
      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
      if (this.feedbackMap) {
        const {
          sourceBuffers,
          feedbackBuffers
        } = this._swapBuffers(this.bindings[this.currentIndex]);
        const nextIndex = this._getNextIndex();
        this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
          sourceBuffers,
          feedbackBuffers
        });
      }
    }
    _updateBinding(binding, opts) {
      if (!binding) {
        return {
          sourceBuffers: Object.assign({}, opts.sourceBuffers),
          feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
        };
      }
      Object.assign(binding.sourceBuffers, opts.sourceBuffers);
      Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);
      if (binding.transformFeedback) {
        binding.transformFeedback.setBuffers(binding.feedbackBuffers);
      }
      return binding;
    }
    _swapBuffers(opts) {
      if (!this.feedbackMap) {
        return null;
      }
      const sourceBuffers = Object.assign({}, opts.sourceBuffers);
      const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);
      for (const srcName in this.feedbackMap) {
        const dstName = this.feedbackMap[srcName];
        sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
        feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
        assert7(feedbackBuffers[dstName] instanceof Buffer2);
      }
      return {
        sourceBuffers,
        feedbackBuffers
      };
    }
    _createNewBuffer(name10, opts) {
      const buffer = new Buffer2(this.gl, opts);
      if (this.resources[name10]) {
        this.resources[name10].delete();
      }
      this.resources[name10] = buffer;
      return buffer;
    }
    _getNextIndex() {
      return (this.currentIndex + 1) % 2;
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js
  var SAMPLER_UNIFORM_PREFIX = "transform_uSampler_";
  var SIZE_UNIFORM_PREFIX = "transform_uSize_";
  var VS_POS_VARIABLE = "transform_position";
  function updateForTextures(_ref) {
    let {
      vs: vs12,
      sourceTextureMap,
      targetTextureVarying,
      targetTexture
    } = _ref;
    const texAttributeNames = Object.keys(sourceTextureMap);
    let sourceCount = texAttributeNames.length;
    let targetTextureType = null;
    const samplerTextureMap = {};
    let updatedVs = vs12;
    let finalInject = {};
    if (sourceCount > 0 || targetTextureVarying) {
      const vsLines = updatedVs.split("\n");
      const updateVsLines = vsLines.slice();
      vsLines.forEach((line, index, lines) => {
        if (sourceCount > 0) {
          const updated = processAttributeDefinition(line, sourceTextureMap);
          if (updated) {
            const {
              updatedLine,
              inject: inject6
            } = updated;
            updateVsLines[index] = updatedLine;
            finalInject = combineInjects([finalInject, inject6]);
            Object.assign(samplerTextureMap, updated.samplerTextureMap);
            sourceCount--;
          }
        }
        if (targetTextureVarying && !targetTextureType) {
          targetTextureType = getVaryingType(line, targetTextureVarying);
        }
      });
      if (targetTextureVarying) {
        assert7(targetTexture);
        const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
        const uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
        const posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\n");
        const inject6 = {
          "vs:#decl": uniformDeclaration,
          "vs:#main-start": posInstructions
        };
        finalInject = combineInjects([finalInject, inject6]);
      }
      updatedVs = updateVsLines.join("\n");
    }
    return {
      vs: updatedVs,
      targetTextureType,
      inject: finalInject,
      samplerTextureMap
    };
  }
  function getSizeUniforms(_ref2) {
    let {
      sourceTextureMap,
      targetTextureVarying,
      targetTexture
    } = _ref2;
    const uniforms = {};
    let width;
    let height;
    if (targetTextureVarying) {
      ({
        width,
        height
      } = targetTexture);
      uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];
    }
    for (const textureName in sourceTextureMap) {
      ({
        width,
        height
      } = sourceTextureMap[textureName]);
      uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];
    }
    return uniforms;
  }
  function getAttributeDefinition(line) {
    return getQualifierDetails(line, ["attribute", "in"]);
  }
  function getSamplerDeclerations(textureName) {
    const samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);
    const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);
    const uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
    return {
      samplerName,
      sizeName,
      uniformDeclerations
    };
  }
  function getVaryingType(line, varying) {
    const qualaiferDetails = getQualifierDetails(line, ["varying", "out"]);
    if (!qualaiferDetails) {
      return null;
    }
    return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
  }
  function processAttributeDefinition(line, textureMap) {
    const samplerTextureMap = {};
    const attributeData = getAttributeDefinition(line);
    if (!attributeData) {
      return null;
    }
    const {
      type,
      name: name10
    } = attributeData;
    if (name10 && textureMap[name10]) {
      const updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");
      const {
        samplerName,
        sizeName,
        uniformDeclerations
      } = getSamplerDeclerations(name10);
      const channels = typeToChannelSuffix(type);
      const sampleInstruction = "  ".concat(type, " ").concat(name10, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
      samplerTextureMap[samplerName] = name10;
      const inject6 = {
        "vs:#decl": uniformDeclerations,
        "vs:#main-start": sampleInstruction
      };
      return {
        updatedLine,
        inject: inject6,
        samplerTextureMap
      };
    }
    return null;
  }

  // ../../node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js
  var SRC_TEX_PARAMETER_OVERRIDES = {
    [10241]: 9728,
    [10240]: 9728,
    [10242]: 33071,
    [10243]: 33071
  };
  var FS_OUTPUT_VARIABLE = "transform_output";
  var TextureTransform = class {
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.id = this.currentIndex = 0;
      this._swapTexture = null;
      this.targetTextureVarying = null;
      this.targetTextureType = null;
      this.samplerTextureMap = null;
      this.bindings = [];
      this.resources = {};
      this._initialize(props);
      Object.seal(this);
    }
    updateModelProps() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const updatedModelProps = this._processVertexShader(props);
      return Object.assign({}, props, updatedModelProps);
    }
    getDrawOptions() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        sourceBuffers,
        sourceTextures,
        framebuffer,
        targetTexture
      } = this.bindings[this.currentIndex];
      const attributes = Object.assign({}, sourceBuffers, opts.attributes);
      const uniforms = Object.assign({}, opts.uniforms);
      const parameters2 = Object.assign({}, opts.parameters);
      let discard = opts.discard;
      if (this.hasSourceTextures || this.hasTargetTexture) {
        attributes.transform_elementID = this.elementIDBuffer;
        for (const sampler in this.samplerTextureMap) {
          const textureName = this.samplerTextureMap[sampler];
          uniforms[sampler] = sourceTextures[textureName];
        }
        this._setSourceTextureParameters();
        const sizeUniforms = getSizeUniforms({
          sourceTextureMap: sourceTextures,
          targetTextureVarying: this.targetTextureVarying,
          targetTexture
        });
        Object.assign(uniforms, sizeUniforms);
      }
      if (this.hasTargetTexture) {
        discard = false;
        parameters2.viewport = [0, 0, framebuffer.width, framebuffer.height];
      }
      return {
        attributes,
        framebuffer,
        uniforms,
        discard,
        parameters: parameters2
      };
    }
    swap() {
      if (this._swapTexture) {
        this.currentIndex = this._getNextIndex();
        return true;
      }
      return false;
    }
    update() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._setupTextures(opts);
    }
    getTargetTexture() {
      const {
        targetTexture
      } = this.bindings[this.currentIndex];
      return targetTexture;
    }
    getData() {
      let {
        packed = false
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        framebuffer
      } = this.bindings[this.currentIndex];
      const pixels = readPixelsToArray(framebuffer);
      if (!packed) {
        return pixels;
      }
      const ArrayType = pixels.constructor;
      const channelCount = typeToChannelCount(this.targetTextureType);
      const packedPixels = new ArrayType(pixels.length * channelCount / 4);
      let packCount = 0;
      for (let i3 = 0; i3 < pixels.length; i3 += 4) {
        for (let j = 0; j < channelCount; j++) {
          packedPixels[packCount++] = pixels[i3 + j];
        }
      }
      return packedPixels;
    }
    getFramebuffer() {
      const currentResources = this.bindings[this.currentIndex];
      return currentResources.framebuffer;
    }
    delete() {
      if (this.ownTexture) {
        this.ownTexture.delete();
      }
      if (this.elementIDBuffer) {
        this.elementIDBuffer.delete();
      }
    }
    _initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        _targetTextureVarying,
        _swapTexture
      } = props;
      this._swapTexture = _swapTexture;
      this.targetTextureVarying = _targetTextureVarying;
      this.hasTargetTexture = _targetTextureVarying;
      this._setupTextures(props);
    }
    _createTargetTexture(props) {
      const {
        sourceTextures,
        textureOrReference
      } = props;
      if (textureOrReference instanceof Texture2D) {
        return textureOrReference;
      }
      const refTexture = sourceTextures[textureOrReference];
      if (!refTexture) {
        return null;
      }
      this._targetRefTexName = textureOrReference;
      return this._createNewTexture(refTexture);
    }
    _setupTextures() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        sourceBuffers,
        _sourceTextures = {},
        _targetTexture
      } = props;
      const targetTexture = this._createTargetTexture({
        sourceTextures: _sourceTextures,
        textureOrReference: _targetTexture
      });
      this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;
      this._updateBindings({
        sourceBuffers,
        sourceTextures: _sourceTextures,
        targetTexture
      });
      if ("elementCount" in props) {
        this._updateElementIDBuffer(props.elementCount);
      }
    }
    _updateElementIDBuffer(elementCount) {
      if (typeof elementCount !== "number" || this.elementCount >= elementCount) {
        return;
      }
      const elementIds = new Float32Array(elementCount);
      elementIds.forEach((_, index, array) => {
        array[index] = index;
      });
      if (!this.elementIDBuffer) {
        this.elementIDBuffer = new Buffer2(this.gl, {
          data: elementIds,
          accessor: {
            size: 1
          }
        });
      } else {
        this.elementIDBuffer.setData({
          data: elementIds
        });
      }
      this.elementCount = elementCount;
    }
    _updateBindings(opts) {
      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
      if (this._swapTexture) {
        const {
          sourceTextures,
          targetTexture
        } = this._swapTextures(this.bindings[this.currentIndex]);
        const nextIndex = this._getNextIndex();
        this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
          sourceTextures,
          targetTexture
        });
      }
    }
    _updateBinding(binding, opts) {
      const {
        sourceBuffers,
        sourceTextures,
        targetTexture
      } = opts;
      if (!binding) {
        binding = {
          sourceBuffers: {},
          sourceTextures: {},
          targetTexture: null
        };
      }
      Object.assign(binding.sourceTextures, sourceTextures);
      Object.assign(binding.sourceBuffers, sourceBuffers);
      if (targetTexture) {
        binding.targetTexture = targetTexture;
        const {
          width,
          height
        } = targetTexture;
        const {
          framebuffer
        } = binding;
        if (framebuffer) {
          framebuffer.update({
            attachments: {
              [36064]: targetTexture
            },
            resizeAttachments: false
          });
          framebuffer.resize({
            width,
            height
          });
        } else {
          binding.framebuffer = new Framebuffer(this.gl, {
            id: "transform-framebuffer",
            width,
            height,
            attachments: {
              [36064]: targetTexture
            }
          });
        }
      }
      return binding;
    }
    _setSourceTextureParameters() {
      const index = this.currentIndex;
      const {
        sourceTextures
      } = this.bindings[index];
      for (const name10 in sourceTextures) {
        sourceTextures[name10].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
      }
    }
    _swapTextures(opts) {
      if (!this._swapTexture) {
        return null;
      }
      const sourceTextures = Object.assign({}, opts.sourceTextures);
      sourceTextures[this._swapTexture] = opts.targetTexture;
      const targetTexture = opts.sourceTextures[this._swapTexture];
      return {
        sourceTextures,
        targetTexture
      };
    }
    _createNewTexture(refTexture) {
      const texture = cloneTextureFrom(refTexture, {
        parameters: {
          [10241]: 9728,
          [10240]: 9728,
          [10242]: 33071,
          [10243]: 33071
        },
        pixelStore: {
          [37440]: false
        }
      });
      if (this.ownTexture) {
        this.ownTexture.delete();
      }
      this.ownTexture = texture;
      return texture;
    }
    _getNextIndex() {
      return (this.currentIndex + 1) % 2;
    }
    _processVertexShader() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        sourceTextures,
        targetTexture
      } = this.bindings[this.currentIndex];
      const {
        vs: vs12,
        uniforms,
        targetTextureType,
        inject: inject6,
        samplerTextureMap
      } = updateForTextures({
        vs: props.vs,
        sourceTextureMap: sourceTextures,
        targetTextureVarying: this.targetTextureVarying,
        targetTexture
      });
      const combinedInject = combineInjects([props.inject || {}, inject6]);
      this.targetTextureType = targetTextureType;
      this.samplerTextureMap = samplerTextureMap;
      const fs8 = props._fs || getPassthroughFS({
        version: getShaderVersion(vs12),
        input: this.targetTextureVarying,
        inputType: targetTextureType,
        output: FS_OUTPUT_VARIABLE
      });
      const modules = this.hasSourceTextures || this.targetTextureVarying ? [transform].concat(props.modules || []) : props.modules;
      return {
        vs: vs12,
        fs: fs8,
        modules,
        uniforms,
        inject: combinedInject
      };
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/esm/transform/transform.js
  var Transform = class {
    static isSupported(gl) {
      return isWebGL2(gl);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.model = null;
      this.elementCount = 0;
      this.bufferTransform = null;
      this.textureTransform = null;
      this.elementIDBuffer = null;
      this._initialize(props);
      Object.seal(this);
    }
    delete() {
      const {
        model,
        bufferTransform,
        textureTransform
      } = this;
      if (model) {
        model.delete();
      }
      if (bufferTransform) {
        bufferTransform.delete();
      }
      if (textureTransform) {
        textureTransform.delete();
      }
    }
    run() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        clearRenderTarget = true
      } = opts;
      const updatedOpts = this._updateDrawOptions(opts);
      if (clearRenderTarget && updatedOpts.framebuffer) {
        updatedOpts.framebuffer.clear({
          color: true
        });
      }
      this.model.transform(updatedOpts);
    }
    swap() {
      let swapped = false;
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        swapped = swapped || resourceTransform.swap();
      }
      assert7(swapped, "Nothing to swap");
    }
    getBuffer() {
      let varyingName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
    }
    getData() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        const data = resourceTransform.getData(opts);
        if (data) {
          return data;
        }
      }
      return null;
    }
    getFramebuffer() {
      return this.textureTransform && this.textureTransform.getFramebuffer();
    }
    update() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if ("elementCount" in opts) {
        this.model.setVertexCount(opts.elementCount);
      }
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        resourceTransform.update(opts);
      }
    }
    _initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        gl
      } = this;
      this._buildResourceTransforms(gl, props);
      props = this._updateModelProps(props);
      this.model = new Model(gl, Object.assign({}, props, {
        fs: props.fs || getPassthroughFS({
          version: getShaderVersion(props.vs)
        }),
        id: props.id || "transform-model",
        drawMode: props.drawMode || 0,
        vertexCount: props.elementCount
      }));
      this.bufferTransform && this.bufferTransform.setupResources({
        model: this.model
      });
    }
    _updateModelProps(props) {
      let updatedProps = Object.assign({}, props);
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        updatedProps = resourceTransform.updateModelProps(updatedProps);
      }
      return updatedProps;
    }
    _buildResourceTransforms(gl, props) {
      if (canCreateBufferTransform(props)) {
        this.bufferTransform = new BufferTransform(gl, props);
      }
      if (canCreateTextureTransform(props)) {
        this.textureTransform = new TextureTransform(gl, props);
      }
      assert7(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures");
    }
    _updateDrawOptions(opts) {
      let updatedOpts = Object.assign({}, opts);
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
      }
      return updatedOpts;
    }
  };
  function canCreateBufferTransform(props) {
    if (!isObjectEmpty2(props.feedbackBuffers) || !isObjectEmpty2(props.feedbackMap) || props.varyings && props.varyings.length > 0) {
      return true;
    }
    return false;
  }
  function canCreateTextureTransform(props) {
    if (!isObjectEmpty2(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {
      return true;
    }
    return false;
  }

  // ../../node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js
  var DRAW_MODE = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  };
  var Geometry = class {
    static get DRAW_MODE() {
      return DRAW_MODE;
    }
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        id = uid("geometry"),
        drawMode = DRAW_MODE.TRIANGLES,
        attributes = {},
        indices = null,
        vertexCount = null
      } = props;
      this.id = id;
      this.drawMode = drawMode | 0;
      this.attributes = {};
      this.userData = {};
      this._setAttributes(attributes, indices);
      this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
    }
    get mode() {
      return this.drawMode;
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getAttributes() {
      return this.indices ? {
        indices: this.indices,
        ...this.attributes
      } : this.attributes;
    }
    _print(attributeName) {
      return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
    }
    _setAttributes(attributes, indices) {
      if (indices) {
        this.indices = ArrayBuffer.isView(indices) ? {
          value: indices,
          size: 1
        } : indices;
      }
      for (const attributeName in attributes) {
        let attribute = attributes[attributeName];
        attribute = ArrayBuffer.isView(attribute) ? {
          value: attribute
        } : attribute;
        assert7(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));
        if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) {
          attribute.size = 3;
        }
        if (attributeName === "indices") {
          assert7(!this.indices);
          this.indices = attribute;
        } else {
          this.attributes[attributeName] = attribute;
        }
      }
      if (this.indices && this.indices.isIndexed !== void 0) {
        this.indices = Object.assign({}, this.indices);
        delete this.indices.isIndexed;
      }
      return this;
    }
    _calculateVertexCount(attributes, indices) {
      if (indices) {
        return indices.value.length;
      }
      let vertexCount = Infinity;
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        const {
          value,
          size,
          constant
        } = attribute;
        if (!constant && value && size >= 1) {
          vertexCount = Math.min(vertexCount, value.length / size);
        }
      }
      assert7(Number.isFinite(vertexCount));
      return vertexCount;
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js
  var INDEX_OFFSETS = {
    x: [2, 0, 1],
    y: [0, 1, 2],
    z: [1, 2, 0]
  };
  var TruncatedConeGeometry = class extends Geometry {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        id = uid("truncated-code-geometry")
      } = props;
      const {
        indices,
        attributes
      } = tesselateTruncatedCone(props);
      super({
        ...props,
        id,
        indices,
        attributes: {
          ...attributes,
          ...props.attributes
        }
      });
    }
  };
  function tesselateTruncatedCone(props) {
    const {
      bottomRadius = 0,
      topRadius = 0,
      height = 1,
      nradial = 10,
      nvertical = 10,
      verticalAxis = "y",
      topCap = false,
      bottomCap = false
    } = props;
    const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
    const numVertices = (nradial + 1) * (nvertical + 1 + extra);
    const slant = Math.atan2(bottomRadius - topRadius, height);
    const msin = Math.sin;
    const mcos = Math.cos;
    const mpi = Math.PI;
    const cosSlant = mcos(slant);
    const sinSlant = msin(slant);
    const start = topCap ? -2 : 0;
    const end = nvertical + (bottomCap ? 2 : 0);
    const vertsAroundEdge = nradial + 1;
    const indices = new Uint16Array(nradial * (nvertical + extra) * 6);
    const indexOffset = INDEX_OFFSETS[verticalAxis];
    const positions = new Float32Array(numVertices * 3);
    const normals = new Float32Array(numVertices * 3);
    const texCoords = new Float32Array(numVertices * 2);
    let i3 = 0;
    let i22 = 0;
    for (let i4 = start; i4 <= end; i4++) {
      let v = i4 / nvertical;
      let y2 = height * v;
      let ringRadius;
      if (i4 < 0) {
        y2 = 0;
        v = 1;
        ringRadius = bottomRadius;
      } else if (i4 > nvertical) {
        y2 = height;
        v = 1;
        ringRadius = topRadius;
      } else {
        ringRadius = bottomRadius + (topRadius - bottomRadius) * (i4 / nvertical);
      }
      if (i4 === -2 || i4 === nvertical + 2) {
        ringRadius = 0;
        v = 0;
      }
      y2 -= height / 2;
      for (let j = 0; j < vertsAroundEdge; j++) {
        const sin2 = msin(j * mpi * 2 / nradial);
        const cos2 = mcos(j * mpi * 2 / nradial);
        positions[i3 + indexOffset[0]] = sin2 * ringRadius;
        positions[i3 + indexOffset[1]] = y2;
        positions[i3 + indexOffset[2]] = cos2 * ringRadius;
        normals[i3 + indexOffset[0]] = i4 < 0 || i4 > nvertical ? 0 : sin2 * cosSlant;
        normals[i3 + indexOffset[1]] = i4 < 0 ? -1 : i4 > nvertical ? 1 : sinSlant;
        normals[i3 + indexOffset[2]] = i4 < 0 || i4 > nvertical ? 0 : cos2 * cosSlant;
        texCoords[i22 + 0] = j / nradial;
        texCoords[i22 + 1] = v;
        i22 += 2;
        i3 += 3;
      }
    }
    for (let i4 = 0; i4 < nvertical + extra; i4++) {
      for (let j = 0; j < nradial; j++) {
        const index = (i4 * nradial + j) * 6;
        indices[index + 0] = vertsAroundEdge * (i4 + 0) + 0 + j;
        indices[index + 1] = vertsAroundEdge * (i4 + 0) + 1 + j;
        indices[index + 2] = vertsAroundEdge * (i4 + 1) + 1 + j;
        indices[index + 3] = vertsAroundEdge * (i4 + 0) + 0 + j;
        indices[index + 4] = vertsAroundEdge * (i4 + 1) + 1 + j;
        indices[index + 5] = vertsAroundEdge * (i4 + 1) + 0 + j;
      }
    }
    return {
      indices,
      attributes: {
        POSITION: {
          size: 3,
          value: positions
        },
        NORMAL: {
          size: 3,
          value: normals
        },
        TEXCOORD_0: {
          size: 2,
          value: texCoords
        }
      }
    };
  }

  // ../../node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js
  var ConeGeometry = class extends TruncatedConeGeometry {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        id = uid("cone-geometry"),
        radius = 1,
        cap = true
      } = props;
      super({
        ...props,
        id,
        topRadius: 0,
        topCap: Boolean(cap),
        bottomCap: Boolean(cap),
        bottomRadius: radius
      });
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js
  var CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
  var CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);
  var CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
  var CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);
  var ATTRIBUTES = {
    POSITION: {
      size: 3,
      value: new Float32Array(CUBE_POSITIONS)
    },
    NORMAL: {
      size: 3,
      value: new Float32Array(CUBE_NORMALS)
    },
    TEXCOORD_0: {
      size: 2,
      value: new Float32Array(CUBE_TEX_COORDS)
    }
  };
  var CubeGeometry = class extends Geometry {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        id = uid("cube-geometry")
      } = props;
      super({
        ...props,
        id,
        indices: {
          size: 1,
          value: new Uint16Array(CUBE_INDICES)
        },
        attributes: {
          ...ATTRIBUTES,
          ...props.attributes
        }
      });
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js
  var CylinderGeometry = class extends TruncatedConeGeometry {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        id = uid("cylinder-geometry"),
        radius = 1
      } = props;
      super({
        ...props,
        id,
        bottomRadius: radius,
        topRadius: radius
      });
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js
  var ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
  var ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];
  var IcoSphereGeometry = class extends Geometry {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        id = uid("ico-sphere-geometry")
      } = props;
      const {
        indices,
        attributes
      } = tesselateIcosaHedron(props);
      super({
        ...props,
        id,
        indices,
        attributes: {
          ...attributes,
          ...props.attributes
        }
      });
    }
  };
  function tesselateIcosaHedron(props) {
    const {
      iterations = 0
    } = props;
    const PI2 = Math.PI;
    const PI22 = PI2 * 2;
    const positions = [...ICO_POSITIONS];
    let indices = [...ICO_INDICES];
    positions.push();
    indices.push();
    const getMiddlePoint = (() => {
      const pointMemo = {};
      return (i1, i22) => {
        i1 *= 3;
        i22 *= 3;
        const mini = i1 < i22 ? i1 : i22;
        const maxi = i1 > i22 ? i1 : i22;
        const key = "".concat(mini, "|").concat(maxi);
        if (key in pointMemo) {
          return pointMemo[key];
        }
        const x1 = positions[i1];
        const y1 = positions[i1 + 1];
        const z1 = positions[i1 + 2];
        const x2 = positions[i22];
        const y2 = positions[i22 + 1];
        const z2 = positions[i22 + 2];
        let xm = (x1 + x2) / 2;
        let ym = (y1 + y2) / 2;
        let zm = (z1 + z2) / 2;
        const len3 = Math.sqrt(xm * xm + ym * ym + zm * zm);
        xm /= len3;
        ym /= len3;
        zm /= len3;
        positions.push(xm, ym, zm);
        return pointMemo[key] = positions.length / 3 - 1;
      };
    })();
    for (let i3 = 0; i3 < iterations; i3++) {
      const indices2 = [];
      for (let j = 0; j < indices.length; j += 3) {
        const a2 = getMiddlePoint(indices[j + 0], indices[j + 1]);
        const b = getMiddlePoint(indices[j + 1], indices[j + 2]);
        const c = getMiddlePoint(indices[j + 2], indices[j + 0]);
        indices2.push(c, indices[j + 0], a2, a2, indices[j + 1], b, b, indices[j + 2], c, a2, b, c);
      }
      indices = indices2;
    }
    const normals = new Array(positions.length);
    const texCoords = new Array(positions.length / 3 * 2);
    const l2 = indices.length;
    for (let i3 = l2 - 3; i3 >= 0; i3 -= 3) {
      const i1 = indices[i3 + 0];
      const i22 = indices[i3 + 1];
      const i32 = indices[i3 + 2];
      const in1 = i1 * 3;
      const in2 = i22 * 3;
      const in3 = i32 * 3;
      const iu1 = i1 * 2;
      const iu2 = i22 * 2;
      const iu3 = i32 * 2;
      const x1 = positions[in1 + 0];
      const y1 = positions[in1 + 1];
      const z1 = positions[in1 + 2];
      const theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
      const phi1 = Math.atan2(y1, x1) + PI2;
      const v1 = theta1 / PI2;
      const u1 = 1 - phi1 / PI22;
      const x2 = positions[in2 + 0];
      const y2 = positions[in2 + 1];
      const z2 = positions[in2 + 2];
      const theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
      const phi2 = Math.atan2(y2, x2) + PI2;
      const v2 = theta2 / PI2;
      const u2 = 1 - phi2 / PI22;
      const x3 = positions[in3 + 0];
      const y3 = positions[in3 + 1];
      const z3 = positions[in3 + 2];
      const theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
      const phi3 = Math.atan2(y3, x3) + PI2;
      const v3 = theta3 / PI2;
      const u3 = 1 - phi3 / PI22;
      const vec1 = [x3 - x2, y3 - y2, z3 - z2];
      const vec2 = [x1 - x2, y1 - y2, z1 - z2];
      const normal = new Vector3(vec1).cross(vec2).normalize();
      let newIndex;
      if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {
        positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
        newIndex = positions.length / 3 - 1;
        indices.push(newIndex);
        texCoords[newIndex * 2 + 0] = 1;
        texCoords[newIndex * 2 + 1] = v1;
        normals[newIndex * 3 + 0] = normal.x;
        normals[newIndex * 3 + 1] = normal.y;
        normals[newIndex * 3 + 2] = normal.z;
        positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
        newIndex = positions.length / 3 - 1;
        indices.push(newIndex);
        texCoords[newIndex * 2 + 0] = 1;
        texCoords[newIndex * 2 + 1] = v2;
        normals[newIndex * 3 + 0] = normal.x;
        normals[newIndex * 3 + 1] = normal.y;
        normals[newIndex * 3 + 2] = normal.z;
        positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
        newIndex = positions.length / 3 - 1;
        indices.push(newIndex);
        texCoords[newIndex * 2 + 0] = 1;
        texCoords[newIndex * 2 + 1] = v3;
        normals[newIndex * 3 + 0] = normal.x;
        normals[newIndex * 3 + 1] = normal.y;
        normals[newIndex * 3 + 2] = normal.z;
      }
      normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
      normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
      normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;
      texCoords[iu1 + 0] = u1;
      texCoords[iu1 + 1] = v1;
      texCoords[iu2 + 0] = u2;
      texCoords[iu2 + 1] = v2;
      texCoords[iu3 + 0] = u3;
      texCoords[iu3 + 1] = v3;
    }
    return {
      indices: {
        size: 1,
        value: new Uint16Array(indices)
      },
      attributes: {
        POSITION: {
          size: 3,
          value: new Float32Array(positions)
        },
        NORMAL: {
          size: 3,
          value: new Float32Array(normals)
        },
        TEXCOORD_0: {
          size: 2,
          value: new Float32Array(texCoords)
        }
      }
    };
  }

  // ../../node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js
  function unpackIndexedGeometry(geometry) {
    const {
      indices,
      attributes
    } = geometry;
    if (!indices) {
      return geometry;
    }
    const vertexCount = indices.value.length;
    const unpackedAttributes = {};
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const {
        constant,
        value,
        size
      } = attribute;
      if (constant || !size) {
        continue;
      }
      const unpackedValue = new value.constructor(vertexCount * size);
      for (let x2 = 0; x2 < vertexCount; ++x2) {
        const index = indices.value[x2];
        for (let i3 = 0; i3 < size; i3++) {
          unpackedValue[x2 * size + i3] = value[index * size + i3];
        }
      }
      unpackedAttributes[attributeName] = {
        size,
        value: unpackedValue
      };
    }
    return {
      attributes: Object.assign({}, attributes, unpackedAttributes)
    };
  }

  // ../../node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js
  var PlaneGeometry = class extends Geometry {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        id = uid("plane-geometry")
      } = props;
      const {
        indices,
        attributes
      } = tesselatePlane(props);
      super({
        ...props,
        id,
        indices,
        attributes: {
          ...attributes,
          ...props.attributes
        }
      });
    }
  };
  function tesselatePlane(props) {
    const {
      type = "x,y",
      offset = 0,
      flipCull = false,
      unpack: unpack2 = false
    } = props;
    const coords = type.split(",");
    let c1len = props["".concat(coords[0], "len")] || 1;
    const c2len = props["".concat(coords[1], "len")] || 1;
    const subdivisions1 = props["n".concat(coords[0])] || 1;
    const subdivisions2 = props["n".concat(coords[1])] || 1;
    const numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);
    const positions = new Float32Array(numVertices * 3);
    const normals = new Float32Array(numVertices * 3);
    const texCoords = new Float32Array(numVertices * 2);
    if (flipCull) {
      c1len = -c1len;
    }
    let i22 = 0;
    let i3 = 0;
    for (let z = 0; z <= subdivisions2; z++) {
      for (let x2 = 0; x2 <= subdivisions1; x2++) {
        const u = x2 / subdivisions1;
        const v = z / subdivisions2;
        texCoords[i22 + 0] = flipCull ? 1 - u : u;
        texCoords[i22 + 1] = v;
        switch (type) {
          case "x,y":
            positions[i3 + 0] = c1len * u - c1len * 0.5;
            positions[i3 + 1] = c2len * v - c2len * 0.5;
            positions[i3 + 2] = offset;
            normals[i3 + 0] = 0;
            normals[i3 + 1] = 0;
            normals[i3 + 2] = flipCull ? 1 : -1;
            break;
          case "x,z":
            positions[i3 + 0] = c1len * u - c1len * 0.5;
            positions[i3 + 1] = offset;
            positions[i3 + 2] = c2len * v - c2len * 0.5;
            normals[i3 + 0] = 0;
            normals[i3 + 1] = flipCull ? 1 : -1;
            normals[i3 + 2] = 0;
            break;
          case "y,z":
            positions[i3 + 0] = offset;
            positions[i3 + 1] = c1len * u - c1len * 0.5;
            positions[i3 + 2] = c2len * v - c2len * 0.5;
            normals[i3 + 0] = flipCull ? 1 : -1;
            normals[i3 + 1] = 0;
            normals[i3 + 2] = 0;
            break;
          default:
            throw new Error("PlaneGeometry: unknown type");
        }
        i22 += 2;
        i3 += 3;
      }
    }
    const numVertsAcross = subdivisions1 + 1;
    const indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);
    for (let z = 0; z < subdivisions2; z++) {
      for (let x2 = 0; x2 < subdivisions1; x2++) {
        const index = (z * subdivisions1 + x2) * 6;
        indices[index + 0] = (z + 0) * numVertsAcross + x2;
        indices[index + 1] = (z + 1) * numVertsAcross + x2;
        indices[index + 2] = (z + 0) * numVertsAcross + x2 + 1;
        indices[index + 3] = (z + 1) * numVertsAcross + x2;
        indices[index + 4] = (z + 1) * numVertsAcross + x2 + 1;
        indices[index + 5] = (z + 0) * numVertsAcross + x2 + 1;
      }
    }
    const geometry = {
      indices: {
        size: 1,
        value: indices
      },
      attributes: {
        POSITION: {
          size: 3,
          value: positions
        },
        NORMAL: {
          size: 3,
          value: normals
        },
        TEXCOORD_0: {
          size: 2,
          value: texCoords
        }
      }
    };
    return unpack2 ? unpackIndexedGeometry(geometry) : geometry;
  }

  // ../../node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js
  var SphereGeometry = class extends Geometry {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        id = uid("sphere-geometry")
      } = props;
      const {
        indices,
        attributes
      } = tesselateSphere(props);
      super({
        ...props,
        id,
        indices,
        attributes: {
          ...attributes,
          ...props.attributes
        }
      });
    }
  };
  function tesselateSphere(props) {
    const {
      nlat = 10,
      nlong = 10
    } = props;
    let {
      radius = 1
    } = props;
    const startLat = 0;
    const endLat = Math.PI;
    const latRange = endLat - startLat;
    const startLong = 0;
    const endLong = 2 * Math.PI;
    const longRange = endLong - startLong;
    const numVertices = (nlat + 1) * (nlong + 1);
    if (typeof radius === "number") {
      const value = radius;
      radius = (n1, n2, n3, u, v) => value;
    }
    const positions = new Float32Array(numVertices * 3);
    const normals = new Float32Array(numVertices * 3);
    const texCoords = new Float32Array(numVertices * 2);
    const IndexType = numVertices > 65535 ? Uint32Array : Uint16Array;
    const indices = new IndexType(nlat * nlong * 6);
    for (let y2 = 0; y2 <= nlat; y2++) {
      for (let x2 = 0; x2 <= nlong; x2++) {
        const u = x2 / nlong;
        const v = y2 / nlat;
        const index = x2 + y2 * (nlong + 1);
        const i22 = index * 2;
        const i3 = index * 3;
        const theta = longRange * u;
        const phi = latRange * v;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        const sinPhi = Math.sin(phi);
        const cosPhi = Math.cos(phi);
        const ux = cosTheta * sinPhi;
        const uy = cosPhi;
        const uz = sinTheta * sinPhi;
        const r2 = radius(ux, uy, uz, u, v);
        positions[i3 + 0] = r2 * ux;
        positions[i3 + 1] = r2 * uy;
        positions[i3 + 2] = r2 * uz;
        normals[i3 + 0] = ux;
        normals[i3 + 1] = uy;
        normals[i3 + 2] = uz;
        texCoords[i22 + 0] = u;
        texCoords[i22 + 1] = 1 - v;
      }
    }
    const numVertsAround = nlong + 1;
    for (let x2 = 0; x2 < nlong; x2++) {
      for (let y2 = 0; y2 < nlat; y2++) {
        const index = (x2 * nlat + y2) * 6;
        indices[index + 0] = y2 * numVertsAround + x2;
        indices[index + 1] = y2 * numVertsAround + x2 + 1;
        indices[index + 2] = (y2 + 1) * numVertsAround + x2;
        indices[index + 3] = (y2 + 1) * numVertsAround + x2;
        indices[index + 4] = y2 * numVertsAround + x2 + 1;
        indices[index + 5] = (y2 + 1) * numVertsAround + x2 + 1;
      }
    }
    return {
      indices: {
        size: 1,
        value: indices
      },
      attributes: {
        POSITION: {
          size: 3,
          value: positions
        },
        NORMAL: {
          size: 3,
          value: normals
        },
        TEXCOORD_0: {
          size: 2,
          value: texCoords
        }
      }
    };
  }

  // ../../node_modules/@luma.gl/engine/dist/esm/animation/timeline.js
  var channelHandles = 1;
  var animationHandles = 1;
  var Timeline = class {
    constructor() {
      this.time = 0;
      this.channels = /* @__PURE__ */ new Map();
      this.animations = /* @__PURE__ */ new Map();
      this.playing = false;
      this.lastEngineTime = -1;
    }
    addChannel(props) {
      const {
        delay = 0,
        duration = Number.POSITIVE_INFINITY,
        rate = 1,
        repeat = 1
      } = props;
      const handle = channelHandles++;
      const channel = {
        time: 0,
        delay,
        duration,
        rate,
        repeat
      };
      this._setChannelTime(channel, this.time);
      this.channels.set(handle, channel);
      return handle;
    }
    removeChannel(handle) {
      this.channels.delete(handle);
      for (const [animationHandle, animation] of this.animations) {
        if (animation.channel === handle) {
          this.detachAnimation(animationHandle);
        }
      }
    }
    isFinished(handle) {
      const channel = this.channels.get(handle);
      if (channel === void 0) {
        return false;
      }
      return this.time >= channel.delay + channel.duration * channel.repeat;
    }
    getTime(handle) {
      if (handle === void 0) {
        return this.time;
      }
      const channel = this.channels.get(handle);
      if (channel === void 0) {
        return -1;
      }
      return channel.time;
    }
    setTime(time) {
      this.time = Math.max(0, time);
      const channels = this.channels.values();
      for (const channel of channels) {
        this._setChannelTime(channel, this.time);
      }
      const animations = this.animations.values();
      for (const animationData of animations) {
        const {
          animation,
          channel
        } = animationData;
        animation.setTime(this.getTime(channel));
      }
    }
    play() {
      this.playing = true;
    }
    pause() {
      this.playing = false;
      this.lastEngineTime = -1;
    }
    reset() {
      this.setTime(0);
    }
    attachAnimation(animation, channelHandle) {
      const animationHandle = animationHandles++;
      this.animations.set(animationHandle, {
        animation,
        channel: channelHandle
      });
      animation.setTime(this.getTime(channelHandle));
      return animationHandle;
    }
    detachAnimation(handle) {
      this.animations.delete(handle);
    }
    update(engineTime) {
      if (this.playing) {
        if (this.lastEngineTime === -1) {
          this.lastEngineTime = engineTime;
        }
        this.setTime(this.time + (engineTime - this.lastEngineTime));
        this.lastEngineTime = engineTime;
      }
    }
    _setChannelTime(channel, time) {
      const offsetTime = time - channel.delay;
      const totalDuration = channel.duration * channel.repeat;
      if (offsetTime >= totalDuration) {
        channel.time = channel.duration * channel.rate;
      } else {
        channel.time = Math.max(0, offsetTime) % channel.duration;
        channel.time *= channel.rate;
      }
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js
  var CLIPSPACE_VERTEX_SHADER = "attribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n";
  var POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];
  var ClipSpace = class extends Model {
    constructor(gl, opts) {
      const TEX_COORDS = POSITIONS.map((coord) => coord === -1 ? 0 : coord);
      super(gl, Object.assign({}, opts, {
        vs: CLIPSPACE_VERTEX_SHADER,
        geometry: new Geometry({
          drawMode: 5,
          vertexCount: 4,
          attributes: {
            aClipSpacePosition: {
              size: 2,
              value: new Float32Array(POSITIONS)
            },
            aTexCoord: {
              size: 2,
              value: new Float32Array(TEX_COORDS)
            },
            aCoordinate: {
              size: 2,
              value: new Float32Array(TEX_COORDS)
            }
          }
        })
      }));
      this.setVertexCount(4);
    }
  };

  // ../core/src/effects/lighting/ambient-light.ts
  var DEFAULT_LIGHT_COLOR = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY = 1;
  var idCount = 0;
  var AmbientLight = class {
    type = "ambient";
    constructor(props = {}) {
      const {
        color = DEFAULT_LIGHT_COLOR
      } = props;
      const {
        intensity = DEFAULT_LIGHT_INTENSITY
      } = props;
      this.id = props.id || `ambient-${idCount++}`;
      this.color = color;
      this.intensity = intensity;
    }
  };

  // ../core/src/effects/lighting/directional-light.ts
  var DEFAULT_LIGHT_COLOR2 = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY2 = 1;
  var DEFAULT_LIGHT_DIRECTION = [0, 0, -1];
  var idCount2 = 0;
  var DirectionalLight = class {
    type = "directional";
    constructor(props = {}) {
      const {
        color = DEFAULT_LIGHT_COLOR2
      } = props;
      const {
        intensity = DEFAULT_LIGHT_INTENSITY2
      } = props;
      const {
        direction = DEFAULT_LIGHT_DIRECTION
      } = props;
      const {
        _shadow = false
      } = props;
      this.id = props.id || `directional-${idCount2++}`;
      this.color = color;
      this.intensity = intensity;
      this.type = "directional";
      this.direction = new Vector3(direction).normalize().toArray();
      this.shadow = _shadow;
    }
    getProjectedLight(opts) {
      return this;
    }
  };

  // ../../node_modules/@luma.gl/constants/dist/esm/index.js
  var esm_default2 = {
    DEPTH_BUFFER_BIT: 256,
    STENCIL_BUFFER_BIT: 1024,
    COLOR_BUFFER_BIT: 16384,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    ZERO: 0,
    ONE: 1,
    SRC_COLOR: 768,
    ONE_MINUS_SRC_COLOR: 769,
    SRC_ALPHA: 770,
    ONE_MINUS_SRC_ALPHA: 771,
    DST_ALPHA: 772,
    ONE_MINUS_DST_ALPHA: 773,
    DST_COLOR: 774,
    ONE_MINUS_DST_COLOR: 775,
    SRC_ALPHA_SATURATE: 776,
    CONSTANT_COLOR: 32769,
    ONE_MINUS_CONSTANT_COLOR: 32770,
    CONSTANT_ALPHA: 32771,
    ONE_MINUS_CONSTANT_ALPHA: 32772,
    FUNC_ADD: 32774,
    FUNC_SUBTRACT: 32778,
    FUNC_REVERSE_SUBTRACT: 32779,
    BLEND_EQUATION: 32777,
    BLEND_EQUATION_RGB: 32777,
    BLEND_EQUATION_ALPHA: 34877,
    BLEND_DST_RGB: 32968,
    BLEND_SRC_RGB: 32969,
    BLEND_DST_ALPHA: 32970,
    BLEND_SRC_ALPHA: 32971,
    BLEND_COLOR: 32773,
    ARRAY_BUFFER_BINDING: 34964,
    ELEMENT_ARRAY_BUFFER_BINDING: 34965,
    LINE_WIDTH: 2849,
    ALIASED_POINT_SIZE_RANGE: 33901,
    ALIASED_LINE_WIDTH_RANGE: 33902,
    CULL_FACE_MODE: 2885,
    FRONT_FACE: 2886,
    DEPTH_RANGE: 2928,
    DEPTH_WRITEMASK: 2930,
    DEPTH_CLEAR_VALUE: 2931,
    DEPTH_FUNC: 2932,
    STENCIL_CLEAR_VALUE: 2961,
    STENCIL_FUNC: 2962,
    STENCIL_FAIL: 2964,
    STENCIL_PASS_DEPTH_FAIL: 2965,
    STENCIL_PASS_DEPTH_PASS: 2966,
    STENCIL_REF: 2967,
    STENCIL_VALUE_MASK: 2963,
    STENCIL_WRITEMASK: 2968,
    STENCIL_BACK_FUNC: 34816,
    STENCIL_BACK_FAIL: 34817,
    STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
    STENCIL_BACK_PASS_DEPTH_PASS: 34819,
    STENCIL_BACK_REF: 36003,
    STENCIL_BACK_VALUE_MASK: 36004,
    STENCIL_BACK_WRITEMASK: 36005,
    VIEWPORT: 2978,
    SCISSOR_BOX: 3088,
    COLOR_CLEAR_VALUE: 3106,
    COLOR_WRITEMASK: 3107,
    UNPACK_ALIGNMENT: 3317,
    PACK_ALIGNMENT: 3333,
    MAX_TEXTURE_SIZE: 3379,
    MAX_VIEWPORT_DIMS: 3386,
    SUBPIXEL_BITS: 3408,
    RED_BITS: 3410,
    GREEN_BITS: 3411,
    BLUE_BITS: 3412,
    ALPHA_BITS: 3413,
    DEPTH_BITS: 3414,
    STENCIL_BITS: 3415,
    POLYGON_OFFSET_UNITS: 10752,
    POLYGON_OFFSET_FACTOR: 32824,
    TEXTURE_BINDING_2D: 32873,
    SAMPLE_BUFFERS: 32936,
    SAMPLES: 32937,
    SAMPLE_COVERAGE_VALUE: 32938,
    SAMPLE_COVERAGE_INVERT: 32939,
    COMPRESSED_TEXTURE_FORMATS: 34467,
    VENDOR: 7936,
    RENDERER: 7937,
    VERSION: 7938,
    IMPLEMENTATION_COLOR_READ_TYPE: 35738,
    IMPLEMENTATION_COLOR_READ_FORMAT: 35739,
    BROWSER_DEFAULT_WEBGL: 37444,
    STATIC_DRAW: 35044,
    STREAM_DRAW: 35040,
    DYNAMIC_DRAW: 35048,
    ARRAY_BUFFER: 34962,
    ELEMENT_ARRAY_BUFFER: 34963,
    BUFFER_SIZE: 34660,
    BUFFER_USAGE: 34661,
    CURRENT_VERTEX_ATTRIB: 34342,
    VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
    VERTEX_ATTRIB_ARRAY_SIZE: 34339,
    VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
    VERTEX_ATTRIB_ARRAY_TYPE: 34341,
    VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
    VERTEX_ATTRIB_ARRAY_POINTER: 34373,
    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
    CULL_FACE: 2884,
    FRONT: 1028,
    BACK: 1029,
    FRONT_AND_BACK: 1032,
    BLEND: 3042,
    DEPTH_TEST: 2929,
    DITHER: 3024,
    POLYGON_OFFSET_FILL: 32823,
    SAMPLE_ALPHA_TO_COVERAGE: 32926,
    SAMPLE_COVERAGE: 32928,
    SCISSOR_TEST: 3089,
    STENCIL_TEST: 2960,
    NO_ERROR: 0,
    INVALID_ENUM: 1280,
    INVALID_VALUE: 1281,
    INVALID_OPERATION: 1282,
    OUT_OF_MEMORY: 1285,
    CONTEXT_LOST_WEBGL: 37442,
    CW: 2304,
    CCW: 2305,
    DONT_CARE: 4352,
    FASTEST: 4353,
    NICEST: 4354,
    GENERATE_MIPMAP_HINT: 33170,
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    INT: 5124,
    UNSIGNED_INT: 5125,
    FLOAT: 5126,
    DOUBLE: 5130,
    DEPTH_COMPONENT: 6402,
    ALPHA: 6406,
    RGB: 6407,
    RGBA: 6408,
    LUMINANCE: 6409,
    LUMINANCE_ALPHA: 6410,
    UNSIGNED_SHORT_4_4_4_4: 32819,
    UNSIGNED_SHORT_5_5_5_1: 32820,
    UNSIGNED_SHORT_5_6_5: 33635,
    FRAGMENT_SHADER: 35632,
    VERTEX_SHADER: 35633,
    COMPILE_STATUS: 35713,
    DELETE_STATUS: 35712,
    LINK_STATUS: 35714,
    VALIDATE_STATUS: 35715,
    ATTACHED_SHADERS: 35717,
    ACTIVE_ATTRIBUTES: 35721,
    ACTIVE_UNIFORMS: 35718,
    MAX_VERTEX_ATTRIBS: 34921,
    MAX_VERTEX_UNIFORM_VECTORS: 36347,
    MAX_VARYING_VECTORS: 36348,
    MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
    MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
    MAX_TEXTURE_IMAGE_UNITS: 34930,
    MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
    SHADER_TYPE: 35663,
    SHADING_LANGUAGE_VERSION: 35724,
    CURRENT_PROGRAM: 35725,
    NEVER: 512,
    ALWAYS: 519,
    LESS: 513,
    EQUAL: 514,
    LEQUAL: 515,
    GREATER: 516,
    GEQUAL: 518,
    NOTEQUAL: 517,
    KEEP: 7680,
    REPLACE: 7681,
    INCR: 7682,
    DECR: 7683,
    INVERT: 5386,
    INCR_WRAP: 34055,
    DECR_WRAP: 34056,
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987,
    TEXTURE_MAG_FILTER: 10240,
    TEXTURE_MIN_FILTER: 10241,
    TEXTURE_WRAP_S: 10242,
    TEXTURE_WRAP_T: 10243,
    TEXTURE_2D: 3553,
    TEXTURE: 5890,
    TEXTURE_CUBE_MAP: 34067,
    TEXTURE_BINDING_CUBE_MAP: 34068,
    TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
    TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
    TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
    TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
    MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
    TEXTURE0: 33984,
    ACTIVE_TEXTURE: 34016,
    REPEAT: 10497,
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    TEXTURE_WIDTH: 4096,
    TEXTURE_HEIGHT: 4097,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    INT_VEC2: 35667,
    INT_VEC3: 35668,
    INT_VEC4: 35669,
    BOOL: 35670,
    BOOL_VEC2: 35671,
    BOOL_VEC3: 35672,
    BOOL_VEC4: 35673,
    FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    SAMPLER_2D: 35678,
    SAMPLER_CUBE: 35680,
    LOW_FLOAT: 36336,
    MEDIUM_FLOAT: 36337,
    HIGH_FLOAT: 36338,
    LOW_INT: 36339,
    MEDIUM_INT: 36340,
    HIGH_INT: 36341,
    FRAMEBUFFER: 36160,
    RENDERBUFFER: 36161,
    RGBA4: 32854,
    RGB5_A1: 32855,
    RGB565: 36194,
    DEPTH_COMPONENT16: 33189,
    STENCIL_INDEX: 6401,
    STENCIL_INDEX8: 36168,
    DEPTH_STENCIL: 34041,
    RENDERBUFFER_WIDTH: 36162,
    RENDERBUFFER_HEIGHT: 36163,
    RENDERBUFFER_INTERNAL_FORMAT: 36164,
    RENDERBUFFER_RED_SIZE: 36176,
    RENDERBUFFER_GREEN_SIZE: 36177,
    RENDERBUFFER_BLUE_SIZE: 36178,
    RENDERBUFFER_ALPHA_SIZE: 36179,
    RENDERBUFFER_DEPTH_SIZE: 36180,
    RENDERBUFFER_STENCIL_SIZE: 36181,
    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
    COLOR_ATTACHMENT0: 36064,
    DEPTH_ATTACHMENT: 36096,
    STENCIL_ATTACHMENT: 36128,
    DEPTH_STENCIL_ATTACHMENT: 33306,
    NONE: 0,
    FRAMEBUFFER_COMPLETE: 36053,
    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
    FRAMEBUFFER_UNSUPPORTED: 36061,
    FRAMEBUFFER_BINDING: 36006,
    RENDERBUFFER_BINDING: 36007,
    READ_FRAMEBUFFER: 36008,
    DRAW_FRAMEBUFFER: 36009,
    MAX_RENDERBUFFER_SIZE: 34024,
    INVALID_FRAMEBUFFER_OPERATION: 1286,
    UNPACK_FLIP_Y_WEBGL: 37440,
    UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
    UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
    READ_BUFFER: 3074,
    UNPACK_ROW_LENGTH: 3314,
    UNPACK_SKIP_ROWS: 3315,
    UNPACK_SKIP_PIXELS: 3316,
    PACK_ROW_LENGTH: 3330,
    PACK_SKIP_ROWS: 3331,
    PACK_SKIP_PIXELS: 3332,
    TEXTURE_BINDING_3D: 32874,
    UNPACK_SKIP_IMAGES: 32877,
    UNPACK_IMAGE_HEIGHT: 32878,
    MAX_3D_TEXTURE_SIZE: 32883,
    MAX_ELEMENTS_VERTICES: 33e3,
    MAX_ELEMENTS_INDICES: 33001,
    MAX_TEXTURE_LOD_BIAS: 34045,
    MAX_FRAGMENT_UNIFORM_COMPONENTS: 35657,
    MAX_VERTEX_UNIFORM_COMPONENTS: 35658,
    MAX_ARRAY_TEXTURE_LAYERS: 35071,
    MIN_PROGRAM_TEXEL_OFFSET: 35076,
    MAX_PROGRAM_TEXEL_OFFSET: 35077,
    MAX_VARYING_COMPONENTS: 35659,
    FRAGMENT_SHADER_DERIVATIVE_HINT: 35723,
    RASTERIZER_DISCARD: 35977,
    VERTEX_ARRAY_BINDING: 34229,
    MAX_VERTEX_OUTPUT_COMPONENTS: 37154,
    MAX_FRAGMENT_INPUT_COMPONENTS: 37157,
    MAX_SERVER_WAIT_TIMEOUT: 37137,
    MAX_ELEMENT_INDEX: 36203,
    RED: 6403,
    RGB8: 32849,
    RGBA8: 32856,
    RGB10_A2: 32857,
    TEXTURE_3D: 32879,
    TEXTURE_WRAP_R: 32882,
    TEXTURE_MIN_LOD: 33082,
    TEXTURE_MAX_LOD: 33083,
    TEXTURE_BASE_LEVEL: 33084,
    TEXTURE_MAX_LEVEL: 33085,
    TEXTURE_COMPARE_MODE: 34892,
    TEXTURE_COMPARE_FUNC: 34893,
    SRGB: 35904,
    SRGB8: 35905,
    SRGB8_ALPHA8: 35907,
    COMPARE_REF_TO_TEXTURE: 34894,
    RGBA32F: 34836,
    RGB32F: 34837,
    RGBA16F: 34842,
    RGB16F: 34843,
    TEXTURE_2D_ARRAY: 35866,
    TEXTURE_BINDING_2D_ARRAY: 35869,
    R11F_G11F_B10F: 35898,
    RGB9_E5: 35901,
    RGBA32UI: 36208,
    RGB32UI: 36209,
    RGBA16UI: 36214,
    RGB16UI: 36215,
    RGBA8UI: 36220,
    RGB8UI: 36221,
    RGBA32I: 36226,
    RGB32I: 36227,
    RGBA16I: 36232,
    RGB16I: 36233,
    RGBA8I: 36238,
    RGB8I: 36239,
    RED_INTEGER: 36244,
    RGB_INTEGER: 36248,
    RGBA_INTEGER: 36249,
    R8: 33321,
    RG8: 33323,
    R16F: 33325,
    R32F: 33326,
    RG16F: 33327,
    RG32F: 33328,
    R8I: 33329,
    R8UI: 33330,
    R16I: 33331,
    R16UI: 33332,
    R32I: 33333,
    R32UI: 33334,
    RG8I: 33335,
    RG8UI: 33336,
    RG16I: 33337,
    RG16UI: 33338,
    RG32I: 33339,
    RG32UI: 33340,
    R8_SNORM: 36756,
    RG8_SNORM: 36757,
    RGB8_SNORM: 36758,
    RGBA8_SNORM: 36759,
    RGB10_A2UI: 36975,
    TEXTURE_IMMUTABLE_FORMAT: 37167,
    TEXTURE_IMMUTABLE_LEVELS: 33503,
    UNSIGNED_INT_2_10_10_10_REV: 33640,
    UNSIGNED_INT_10F_11F_11F_REV: 35899,
    UNSIGNED_INT_5_9_9_9_REV: 35902,
    FLOAT_32_UNSIGNED_INT_24_8_REV: 36269,
    UNSIGNED_INT_24_8: 34042,
    HALF_FLOAT: 5131,
    RG: 33319,
    RG_INTEGER: 33320,
    INT_2_10_10_10_REV: 36255,
    CURRENT_QUERY: 34917,
    QUERY_RESULT: 34918,
    QUERY_RESULT_AVAILABLE: 34919,
    ANY_SAMPLES_PASSED: 35887,
    ANY_SAMPLES_PASSED_CONSERVATIVE: 36202,
    MAX_DRAW_BUFFERS: 34852,
    DRAW_BUFFER0: 34853,
    DRAW_BUFFER1: 34854,
    DRAW_BUFFER2: 34855,
    DRAW_BUFFER3: 34856,
    DRAW_BUFFER4: 34857,
    DRAW_BUFFER5: 34858,
    DRAW_BUFFER6: 34859,
    DRAW_BUFFER7: 34860,
    DRAW_BUFFER8: 34861,
    DRAW_BUFFER9: 34862,
    DRAW_BUFFER10: 34863,
    DRAW_BUFFER11: 34864,
    DRAW_BUFFER12: 34865,
    DRAW_BUFFER13: 34866,
    DRAW_BUFFER14: 34867,
    DRAW_BUFFER15: 34868,
    MAX_COLOR_ATTACHMENTS: 36063,
    COLOR_ATTACHMENT1: 36065,
    COLOR_ATTACHMENT2: 36066,
    COLOR_ATTACHMENT3: 36067,
    COLOR_ATTACHMENT4: 36068,
    COLOR_ATTACHMENT5: 36069,
    COLOR_ATTACHMENT6: 36070,
    COLOR_ATTACHMENT7: 36071,
    COLOR_ATTACHMENT8: 36072,
    COLOR_ATTACHMENT9: 36073,
    COLOR_ATTACHMENT10: 36074,
    COLOR_ATTACHMENT11: 36075,
    COLOR_ATTACHMENT12: 36076,
    COLOR_ATTACHMENT13: 36077,
    COLOR_ATTACHMENT14: 36078,
    COLOR_ATTACHMENT15: 36079,
    SAMPLER_3D: 35679,
    SAMPLER_2D_SHADOW: 35682,
    SAMPLER_2D_ARRAY: 36289,
    SAMPLER_2D_ARRAY_SHADOW: 36292,
    SAMPLER_CUBE_SHADOW: 36293,
    INT_SAMPLER_2D: 36298,
    INT_SAMPLER_3D: 36299,
    INT_SAMPLER_CUBE: 36300,
    INT_SAMPLER_2D_ARRAY: 36303,
    UNSIGNED_INT_SAMPLER_2D: 36306,
    UNSIGNED_INT_SAMPLER_3D: 36307,
    UNSIGNED_INT_SAMPLER_CUBE: 36308,
    UNSIGNED_INT_SAMPLER_2D_ARRAY: 36311,
    MAX_SAMPLES: 36183,
    SAMPLER_BINDING: 35097,
    PIXEL_PACK_BUFFER: 35051,
    PIXEL_UNPACK_BUFFER: 35052,
    PIXEL_PACK_BUFFER_BINDING: 35053,
    PIXEL_UNPACK_BUFFER_BINDING: 35055,
    COPY_READ_BUFFER: 36662,
    COPY_WRITE_BUFFER: 36663,
    COPY_READ_BUFFER_BINDING: 36662,
    COPY_WRITE_BUFFER_BINDING: 36663,
    FLOAT_MAT2x3: 35685,
    FLOAT_MAT2x4: 35686,
    FLOAT_MAT3x2: 35687,
    FLOAT_MAT3x4: 35688,
    FLOAT_MAT4x2: 35689,
    FLOAT_MAT4x3: 35690,
    UNSIGNED_INT_VEC2: 36294,
    UNSIGNED_INT_VEC3: 36295,
    UNSIGNED_INT_VEC4: 36296,
    UNSIGNED_NORMALIZED: 35863,
    SIGNED_NORMALIZED: 36764,
    VERTEX_ATTRIB_ARRAY_INTEGER: 35069,
    VERTEX_ATTRIB_ARRAY_DIVISOR: 35070,
    TRANSFORM_FEEDBACK_BUFFER_MODE: 35967,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 35968,
    TRANSFORM_FEEDBACK_VARYINGS: 35971,
    TRANSFORM_FEEDBACK_BUFFER_START: 35972,
    TRANSFORM_FEEDBACK_BUFFER_SIZE: 35973,
    TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 35976,
    MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 35978,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 35979,
    INTERLEAVED_ATTRIBS: 35980,
    SEPARATE_ATTRIBS: 35981,
    TRANSFORM_FEEDBACK_BUFFER: 35982,
    TRANSFORM_FEEDBACK_BUFFER_BINDING: 35983,
    TRANSFORM_FEEDBACK: 36386,
    TRANSFORM_FEEDBACK_PAUSED: 36387,
    TRANSFORM_FEEDBACK_ACTIVE: 36388,
    TRANSFORM_FEEDBACK_BINDING: 36389,
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 33296,
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 33297,
    FRAMEBUFFER_ATTACHMENT_RED_SIZE: 33298,
    FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 33299,
    FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 33300,
    FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 33301,
    FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 33302,
    FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 33303,
    FRAMEBUFFER_DEFAULT: 33304,
    DEPTH24_STENCIL8: 35056,
    DRAW_FRAMEBUFFER_BINDING: 36006,
    READ_FRAMEBUFFER_BINDING: 36010,
    RENDERBUFFER_SAMPLES: 36011,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 36052,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 36182,
    UNIFORM_BUFFER: 35345,
    UNIFORM_BUFFER_BINDING: 35368,
    UNIFORM_BUFFER_START: 35369,
    UNIFORM_BUFFER_SIZE: 35370,
    MAX_VERTEX_UNIFORM_BLOCKS: 35371,
    MAX_FRAGMENT_UNIFORM_BLOCKS: 35373,
    MAX_COMBINED_UNIFORM_BLOCKS: 35374,
    MAX_UNIFORM_BUFFER_BINDINGS: 35375,
    MAX_UNIFORM_BLOCK_SIZE: 35376,
    MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 35377,
    MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 35379,
    UNIFORM_BUFFER_OFFSET_ALIGNMENT: 35380,
    ACTIVE_UNIFORM_BLOCKS: 35382,
    UNIFORM_TYPE: 35383,
    UNIFORM_SIZE: 35384,
    UNIFORM_BLOCK_INDEX: 35386,
    UNIFORM_OFFSET: 35387,
    UNIFORM_ARRAY_STRIDE: 35388,
    UNIFORM_MATRIX_STRIDE: 35389,
    UNIFORM_IS_ROW_MAJOR: 35390,
    UNIFORM_BLOCK_BINDING: 35391,
    UNIFORM_BLOCK_DATA_SIZE: 35392,
    UNIFORM_BLOCK_ACTIVE_UNIFORMS: 35394,
    UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 35395,
    UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 35396,
    UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 35398,
    OBJECT_TYPE: 37138,
    SYNC_CONDITION: 37139,
    SYNC_STATUS: 37140,
    SYNC_FLAGS: 37141,
    SYNC_FENCE: 37142,
    SYNC_GPU_COMMANDS_COMPLETE: 37143,
    UNSIGNALED: 37144,
    SIGNALED: 37145,
    ALREADY_SIGNALED: 37146,
    TIMEOUT_EXPIRED: 37147,
    CONDITION_SATISFIED: 37148,
    WAIT_FAILED: 37149,
    SYNC_FLUSH_COMMANDS_BIT: 1,
    COLOR: 6144,
    DEPTH: 6145,
    STENCIL: 6146,
    MIN: 32775,
    MAX: 32776,
    DEPTH_COMPONENT24: 33190,
    STREAM_READ: 35041,
    STREAM_COPY: 35042,
    STATIC_READ: 35045,
    STATIC_COPY: 35046,
    DYNAMIC_READ: 35049,
    DYNAMIC_COPY: 35050,
    DEPTH_COMPONENT32F: 36012,
    DEPTH32F_STENCIL8: 36013,
    INVALID_INDEX: 4294967295,
    TIMEOUT_IGNORED: -1,
    MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 37447,
    VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
    UNMASKED_VENDOR_WEBGL: 37445,
    UNMASKED_RENDERER_WEBGL: 37446,
    MAX_TEXTURE_MAX_ANISOTROPY_EXT: 34047,
    TEXTURE_MAX_ANISOTROPY_EXT: 34046,
    COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
    COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
    COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
    COMPRESSED_R11_EAC: 37488,
    COMPRESSED_SIGNED_R11_EAC: 37489,
    COMPRESSED_RG11_EAC: 37490,
    COMPRESSED_SIGNED_RG11_EAC: 37491,
    COMPRESSED_RGB8_ETC2: 37492,
    COMPRESSED_RGBA8_ETC2_EAC: 37493,
    COMPRESSED_SRGB8_ETC2: 37494,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
    COMPRESSED_RGB_ETC1_WEBGL: 36196,
    COMPRESSED_RGB_ATC_WEBGL: 35986,
    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35986,
    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
    UNSIGNED_INT_24_8_WEBGL: 34042,
    HALF_FLOAT_OES: 36193,
    RGBA32F_EXT: 34836,
    RGB32F_EXT: 34837,
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 33297,
    UNSIGNED_NORMALIZED_EXT: 35863,
    MIN_EXT: 32775,
    MAX_EXT: 32776,
    SRGB_EXT: 35904,
    SRGB_ALPHA_EXT: 35906,
    SRGB8_ALPHA8_EXT: 35907,
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 33296,
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723,
    COLOR_ATTACHMENT0_WEBGL: 36064,
    COLOR_ATTACHMENT1_WEBGL: 36065,
    COLOR_ATTACHMENT2_WEBGL: 36066,
    COLOR_ATTACHMENT3_WEBGL: 36067,
    COLOR_ATTACHMENT4_WEBGL: 36068,
    COLOR_ATTACHMENT5_WEBGL: 36069,
    COLOR_ATTACHMENT6_WEBGL: 36070,
    COLOR_ATTACHMENT7_WEBGL: 36071,
    COLOR_ATTACHMENT8_WEBGL: 36072,
    COLOR_ATTACHMENT9_WEBGL: 36073,
    COLOR_ATTACHMENT10_WEBGL: 36074,
    COLOR_ATTACHMENT11_WEBGL: 36075,
    COLOR_ATTACHMENT12_WEBGL: 36076,
    COLOR_ATTACHMENT13_WEBGL: 36077,
    COLOR_ATTACHMENT14_WEBGL: 36078,
    COLOR_ATTACHMENT15_WEBGL: 36079,
    DRAW_BUFFER0_WEBGL: 34853,
    DRAW_BUFFER1_WEBGL: 34854,
    DRAW_BUFFER2_WEBGL: 34855,
    DRAW_BUFFER3_WEBGL: 34856,
    DRAW_BUFFER4_WEBGL: 34857,
    DRAW_BUFFER5_WEBGL: 34858,
    DRAW_BUFFER6_WEBGL: 34859,
    DRAW_BUFFER7_WEBGL: 34860,
    DRAW_BUFFER8_WEBGL: 34861,
    DRAW_BUFFER9_WEBGL: 34862,
    DRAW_BUFFER10_WEBGL: 34863,
    DRAW_BUFFER11_WEBGL: 34864,
    DRAW_BUFFER12_WEBGL: 34865,
    DRAW_BUFFER13_WEBGL: 34866,
    DRAW_BUFFER14_WEBGL: 34867,
    DRAW_BUFFER15_WEBGL: 34868,
    MAX_COLOR_ATTACHMENTS_WEBGL: 36063,
    MAX_DRAW_BUFFERS_WEBGL: 34852,
    VERTEX_ARRAY_BINDING_OES: 34229,
    QUERY_COUNTER_BITS_EXT: 34916,
    CURRENT_QUERY_EXT: 34917,
    QUERY_RESULT_EXT: 34918,
    QUERY_RESULT_AVAILABLE_EXT: 34919,
    TIME_ELAPSED_EXT: 35007,
    TIMESTAMP_EXT: 36392,
    GPU_DISJOINT_EXT: 36795
  };

  // ../core/src/passes/pass.ts
  var Pass = class {
    constructor(gl, props = {
      id: "pass"
    }) {
      const {
        id
      } = props;
      this.id = id;
      this.gl = gl;
      this.props = {
        ...props
      };
    }
    setProps(props) {
      Object.assign(this.props, props);
    }
    render(params) {
    }
    cleanup() {
    }
  };

  // ../core/src/passes/layers-pass.ts
  var LayersPass = class extends Pass {
    _lastRenderIndex = -1;
    render(options) {
      const gl = this.gl;
      setParameters(gl, {
        framebuffer: options.target
      });
      return this._drawLayers(options);
    }
    _drawLayers(options) {
      const {
        target,
        moduleParameters,
        viewports,
        views,
        onViewportActive,
        clearStack = true,
        clearCanvas = true
      } = options;
      options.pass = options.pass || "unknown";
      const gl = this.gl;
      if (clearCanvas) {
        clearGLCanvas(gl, target);
      }
      if (clearStack) {
        this._lastRenderIndex = -1;
      }
      const renderStats = [];
      for (const viewport of viewports) {
        const view = views && views[viewport.id];
        onViewportActive?.(viewport);
        const drawLayerParams = this._getDrawLayerParams(viewport, options);
        const subViewports = viewport.subViewports || [viewport];
        for (const subViewport of subViewports) {
          const stats = this._drawLayersInViewport(gl, {
            target,
            moduleParameters,
            viewport: subViewport,
            view,
            pass: options.pass,
            layers: options.layers
          }, drawLayerParams);
          renderStats.push(stats);
        }
      }
      return renderStats;
    }
    _getDrawLayerParams(viewport, {
      layers,
      pass,
      isPicking = false,
      layerFilter,
      cullRect,
      effects,
      moduleParameters
    }, evaluateShouldDrawOnly = false) {
      const drawLayerParams = [];
      const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
      const drawContext = {
        layer: layers[0],
        viewport,
        isPicking,
        renderPass: pass,
        cullRect
      };
      const layerFilterCache = {};
      for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
        const layer = layers[layerIndex];
        const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);
        const layerParam = {
          shouldDrawLayer
        };
        if (shouldDrawLayer && !evaluateShouldDrawOnly) {
          layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
          layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);
          layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);
        }
        drawLayerParams[layerIndex] = layerParam;
      }
      return drawLayerParams;
    }
    _drawLayersInViewport(gl, {
      layers,
      moduleParameters: globalModuleParameters,
      pass,
      target,
      viewport,
      view
    }, drawLayerParams) {
      const glViewport = getGLViewport(gl, {
        moduleParameters: globalModuleParameters,
        target,
        viewport
      });
      if (view && view.props.clear) {
        const clearOpts = view.props.clear === true ? {
          color: true,
          depth: true
        } : view.props.clear;
        withParameters(gl, {
          scissorTest: true,
          scissor: glViewport
        }, () => clear(gl, clearOpts));
      }
      const renderStatus = {
        totalCount: layers.length,
        visibleCount: 0,
        compositeCount: 0,
        pickableCount: 0
      };
      setParameters(gl, {
        viewport: glViewport
      });
      for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
        const layer = layers[layerIndex];
        const {
          shouldDrawLayer,
          layerRenderIndex,
          moduleParameters,
          layerParameters
        } = drawLayerParams[layerIndex];
        if (shouldDrawLayer && layer.props.pickable) {
          renderStatus.pickableCount++;
        }
        if (layer.isComposite) {
          renderStatus.compositeCount++;
        } else if (shouldDrawLayer) {
          renderStatus.visibleCount++;
          this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
          moduleParameters.viewport = viewport;
          try {
            layer._drawLayer({
              moduleParameters,
              uniforms: {
                layerIndex: layerRenderIndex
              },
              parameters: layerParameters
            });
          } catch (err) {
            layer.raiseError(err, `drawing ${layer} to ${pass}`);
          }
        }
      }
      return renderStatus;
    }
    shouldDrawLayer(layer) {
      return true;
    }
    getModuleParameters(layer, effects) {
      return null;
    }
    getLayerParameters(layer, layerIndex, viewport) {
      return layer.props.parameters;
    }
    _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
      const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
      if (!shouldDrawLayer) {
        return false;
      }
      drawContext.layer = layer;
      let parent = layer.parent;
      while (parent) {
        if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {
          return false;
        }
        drawContext.layer = parent;
        parent = parent.parent;
      }
      if (layerFilter) {
        const rootLayerId = drawContext.layer.id;
        if (!(rootLayerId in layerFilterCache)) {
          layerFilterCache[rootLayerId] = layerFilter(drawContext);
        }
        if (!layerFilterCache[rootLayerId]) {
          return false;
        }
      }
      layer.activateViewport(drawContext.viewport);
      return true;
    }
    _getModuleParameters(layer, effects, pass, overrides) {
      const moduleParameters = Object.assign(Object.create(layer.internalState?.propsInTransition || layer.props), {
        autoWrapLongitude: layer.wrapLongitude,
        viewport: layer.context.viewport,
        mousePosition: layer.context.mousePosition,
        pickingActive: 0,
        devicePixelRatio: cssToDeviceRatio(this.gl)
      });
      if (effects) {
        for (const effect of effects) {
          Object.assign(moduleParameters, effect.getModuleParameters?.(layer));
        }
      }
      return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
    }
  };
  function layerIndexResolver(startIndex = 0, layerIndices = {}) {
    const resolvers = {};
    const resolveLayerIndex = (layer, isDrawn) => {
      const indexOverride = layer.props._offset;
      const layerId = layer.id;
      const parentId = layer.parent && layer.parent.id;
      let index;
      if (parentId && !(parentId in layerIndices)) {
        resolveLayerIndex(layer.parent, false);
      }
      if (parentId in resolvers) {
        const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
        index = resolver(layer, isDrawn);
        resolvers[layerId] = resolver;
      } else if (Number.isFinite(indexOverride)) {
        index = indexOverride + (layerIndices[parentId] || 0);
        resolvers[layerId] = null;
      } else {
        index = startIndex;
      }
      if (isDrawn && index >= startIndex) {
        startIndex = index + 1;
      }
      layerIndices[layerId] = index;
      return index;
    };
    return resolveLayerIndex;
  }
  function getGLViewport(gl, {
    moduleParameters,
    target,
    viewport
  }) {
    const useTarget = target && target.id !== "default-framebuffer";
    const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || cssToDeviceRatio(gl);
    const height = useTarget ? target.height : gl.drawingBufferHeight;
    const dimensions = viewport;
    return [dimensions.x * pixelRatio, height - (dimensions.y + dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
  }
  function clearGLCanvas(gl, targetFramebuffer) {
    const width = targetFramebuffer ? targetFramebuffer.width : gl.drawingBufferWidth;
    const height = targetFramebuffer ? targetFramebuffer.height : gl.drawingBufferHeight;
    setParameters(gl, {
      viewport: [0, 0, width, height]
    });
    gl.clear(esm_default2.COLOR_BUFFER_BIT | esm_default2.DEPTH_BUFFER_BIT);
  }

  // ../core/src/passes/shadow-pass.ts
  var ShadowPass = class extends LayersPass {
    constructor(gl, props) {
      super(gl, props);
      this.shadowMap = new Texture2D(gl, {
        width: 1,
        height: 1,
        parameters: {
          [gl.TEXTURE_MIN_FILTER]: gl.LINEAR,
          [gl.TEXTURE_MAG_FILTER]: gl.LINEAR,
          [gl.TEXTURE_WRAP_S]: gl.CLAMP_TO_EDGE,
          [gl.TEXTURE_WRAP_T]: gl.CLAMP_TO_EDGE
        }
      });
      this.depthBuffer = new Renderbuffer(gl, {
        format: gl.DEPTH_COMPONENT16,
        width: 1,
        height: 1
      });
      this.fbo = new Framebuffer(gl, {
        id: "shadowmap",
        width: 1,
        height: 1,
        attachments: {
          [gl.COLOR_ATTACHMENT0]: this.shadowMap,
          [gl.DEPTH_ATTACHMENT]: this.depthBuffer
        }
      });
    }
    render(params) {
      const target = this.fbo;
      withParameters(this.gl, {
        depthRange: [0, 1],
        depthTest: true,
        blend: false,
        clearColor: [1, 1, 1, 1]
      }, () => {
        const viewport = params.viewports[0];
        const pixelRatio = cssToDeviceRatio(this.gl);
        const width = viewport.width * pixelRatio;
        const height = viewport.height * pixelRatio;
        if (width !== target.width || height !== target.height) {
          target.resize({
            width,
            height
          });
        }
        super.render({
          ...params,
          target,
          pass: "shadow"
        });
      });
    }
    shouldDrawLayer(layer) {
      return layer.props.shadowEnabled !== false;
    }
    getModuleParameters() {
      return {
        drawToShadowMap: true
      };
    }
    delete() {
      if (this.fbo) {
        this.fbo.delete();
        this.fbo = null;
      }
      if (this.shadowMap) {
        this.shadowMap.delete();
        this.shadowMap = null;
      }
      if (this.depthBuffer) {
        this.depthBuffer.delete();
        this.depthBuffer = null;
      }
    }
  };

  // ../core/src/shaderlib/misc/geometry.ts
  var defines = "#define SMOOTH_EDGE_RADIUS 0.5";
  var vs3 = `
${defines}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`;
  var fs2 = `
${defines}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`;
  var geometry_default = {
    name: "geometry",
    vs: vs3,
    fs: fs2
  };

  // ../core/src/shaderlib/project/project.glsl.ts
  var COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => `const int COORDINATE_SYSTEM_${key} = ${COORDINATE_SYSTEM[key]};`).join("");
  var PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => `const int PROJECTION_MODE_${key} = ${PROJECTION_MODE[key]};`).join("");
  var UNIT_GLSL_CONSTANTS = Object.keys(UNIT).map((key) => `const int UNIT_${key.toUpperCase()} = ${UNIT[key]};`).join("");
  var project_glsl_default = `${COORDINATE_SYSTEM_GLSL_CONSTANTS}
${PROJECTION_MODE_GLSL_CONSTANTS}
${UNIT_GLSL_CONSTANTS}

uniform int project_uCoordinateSystem;
uniform int project_uProjectionMode;
uniform float project_uScale;
uniform bool project_uWrapLongitude;
uniform vec3 project_uCommonUnitsPerMeter;
uniform vec3 project_uCommonUnitsPerWorldUnit;
uniform vec3 project_uCommonUnitsPerWorldUnit2;
uniform vec4 project_uCenter;
uniform mat4 project_uModelMatrix;
uniform mat4 project_uViewProjectionMatrix;
uniform vec2 project_uViewportSize;
uniform float project_uDevicePixelRatio;
uniform float project_uFocalDistance;
uniform vec3 project_uCameraPosition;
uniform vec3 project_uCoordinateOrigin;
uniform vec3 project_uCommonOrigin;
uniform bool project_uPseudoMeters;

const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0; // meters
const float GLOBE_RADIUS = 256.0;

// returns an adjustment factor for uCommonUnitsPerMeter
float project_size_at_latitude(float lat) {
  float y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

float project_size() {
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&
    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
    project_uPseudoMeters == false) {

    // uCommonUnitsPerMeter in low-zoom Web Mercator is non-linear
    // Adjust by 1 / cos(latitude)
    // If geometry.position (vertex in common space) is populated, use it
    // Otherwise use geometry.worldPosition (anchor in world space)
    
    if (geometry.position.w == 0.0) {
      return project_size_at_latitude(geometry.worldPosition.y);
    }

    // latitude from common y: 2.0 * (atan(exp(y / TILE_SIZE * 2.0 * PI - PI)) - PI / 4.0)
    // Taylor series of 1 / cos(latitude)
    // Max error < 0.003
  
    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    float y2 = y * y;
    float y4 = y2 * y2;
    float y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

float project_size_at_latitude(float meters, float lat) {
  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);
}

//
// Scaling offsets - scales meters to "world distance"
// Note the scalar version of project_size is for scaling the z component only
//
float project_size(float meters) {
  return meters * project_uCommonUnitsPerMeter.z * project_size();
}

vec2 project_size(vec2 meters) {
  return meters * project_uCommonUnitsPerMeter.xy * project_size();
}

vec3 project_size(vec3 meters) {
  return meters * project_uCommonUnitsPerMeter * project_size();
}

vec4 project_size(vec4 meters) {
  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);
}

// Get rotation matrix that aligns the z axis with the given up vector
// Find 3 unit vectors ux, uy, uz that are perpendicular to each other and uz == up
mat3 project_get_orientation_matrix(vec3 up) {
  vec3 uz = normalize(up);
  // Tangent on XY plane
  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
  vec3 uy = cross(uz, ux);
  return mat3(ux, uy, uz);
}

bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
    transform = project_get_orientation_matrix(commonPosition);
    return true;
  }
  return false;
}

//
// Projecting normal - transform deltas from current coordinate system to
// normals in the worldspace
//
vec3 project_normal(vec3 vector) {
  // Apply model matrix
  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);
  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);
  mat3 rotation;
  if (project_needs_rotation(geometry.position.xyz, rotation)) {
    n = rotation * n;
  }
  return n;
}

vec4 project_offset_(vec4 offset) {
  float dy = offset.y;
  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;
  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

//
// Projecting positions - non-linear projection: lnglats => unit tile [0-1, 0-1]
//
vec2 project_mercator_(vec2 lnglat) {
  float x = lnglat.x;
  if (project_uWrapLongitude) {
    x = mod(x + 180., 360.0) - 180.;
  }
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

vec3 project_globe_(vec3 lnglatz) {
  float lambda = radians(lnglatz.x);
  float phi = radians(lnglatz.y);
  float cosPhi = cos(phi);
  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;

  return vec3(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

//
// Projects positions (defined by project_uCoordinateSystem) to common space (defined by project_uProjectionMode)
//
vec4 project_position(vec4 position, vec3 position64Low) {
  vec4 position_world = project_uModelMatrix * position;

  // Work around for a Mac+NVIDIA bug https://github.com/visgl/deck.gl/issues/4145
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_mercator_(position_world.xy),
        project_size_at_latitude(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world.xyz += project_uCoordinateOrigin;
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {
        // Too far from the projection center for offset mode to be accurate
        // Only use high parts
        return vec4(
          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,
          project_size(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||
    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    // Subtract high part of 64 bit value. Convert remainder to float32, preserving precision.
    position_world.xyz -= project_uCoordinateOrigin;
  }

  // Translation is already added to the high parts
  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));
}

vec4 project_position(vec4 position) {
  return project_position(position, ZERO_64_LOW);
}

vec3 project_position(vec3 position, vec3 position64Low) {
  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
  return projected_position.xyz;
}

vec3 project_position(vec3 position) {
  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

vec2 project_position(vec2 position) {
  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
  return viewProjectionMatrix * position + center;
}

//
// Projects from common space coordinates to clip space.
// Uses project_uViewProjectionMatrix
//
vec4 project_common_position_to_clipspace(vec4 position) {
  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);
}

// Returns a clip space offset that corresponds to a given number of screen pixels
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;
  return offset * project_uFocalDistance;
}

float project_size_to_pixel(float meters) {
  return project_size(meters) * project_uScale;
}
float project_size_to_pixel(float size, int unit) {
  if (unit == UNIT_METERS) return project_size_to_pixel(size);
  if (unit == UNIT_COMMON) return size * project_uScale;
  // UNIT_PIXELS
  return size;
}
float project_pixel_size(float pixels) {
  return pixels / project_uScale;
}
vec2 project_pixel_size(vec2 pixels) {
  return pixels / project_uScale;
}
`;

  // ../core/node_modules/gl-matrix/esm/common.js
  var ARRAY_TYPE2 = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree2 = Math.PI / 180;
  if (!Math.hypot)
    Math.hypot = function() {
      var y2 = 0, i3 = arguments.length;
      while (i3--) {
        y2 += arguments[i3] * arguments[i3];
      }
      return Math.sqrt(y2);
    };

  // ../core/node_modules/gl-matrix/esm/mat4.js
  function invert4(out, a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function multiply4(out, a2, b) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate3(out, a2, v) {
    var x2 = v[0], y2 = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a2 === out) {
      out[12] = a2[0] * x2 + a2[4] * y2 + a2[8] * z + a2[12];
      out[13] = a2[1] * x2 + a2[5] * y2 + a2[9] * z + a2[13];
      out[14] = a2[2] * x2 + a2[6] * y2 + a2[10] * z + a2[14];
      out[15] = a2[3] * x2 + a2[7] * y2 + a2[11] * z + a2[15];
    } else {
      a00 = a2[0];
      a01 = a2[1];
      a02 = a2[2];
      a03 = a2[3];
      a10 = a2[4];
      a11 = a2[5];
      a12 = a2[6];
      a13 = a2[7];
      a20 = a2[8];
      a21 = a2[9];
      a22 = a2[10];
      a23 = a2[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x2 + a10 * y2 + a20 * z + a2[12];
      out[13] = a01 * x2 + a11 * y2 + a21 * z + a2[13];
      out[14] = a02 * x2 + a12 * y2 + a22 * z + a2[14];
      out[15] = a03 * x2 + a13 * y2 + a23 * z + a2[15];
    }
    return out;
  }
  function scale6(out, a2, v) {
    var x2 = v[0], y2 = v[1], z = v[2];
    out[0] = a2[0] * x2;
    out[1] = a2[1] * x2;
    out[2] = a2[2] * x2;
    out[3] = a2[3] * x2;
    out[4] = a2[4] * y2;
    out[5] = a2[5] * y2;
    out[6] = a2[6] * y2;
    out[7] = a2[7] * y2;
    out[8] = a2[8] * z;
    out[9] = a2[9] * z;
    out[10] = a2[10] * z;
    out[11] = a2[11] * z;
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
    return out;
  }

  // ../core/node_modules/gl-matrix/esm/vec4.js
  function create6() {
    var out = new ARRAY_TYPE2(4);
    if (ARRAY_TYPE2 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function scale7(out, a2, b) {
    out[0] = a2[0] * b;
    out[1] = a2[1] * b;
    out[2] = a2[2] * b;
    out[3] = a2[3] * b;
    return out;
  }
  function transformMat44(out, a2, m) {
    var x2 = a2[0], y2 = a2[1], z = a2[2], w = a2[3];
    out[0] = m[0] * x2 + m[4] * y2 + m[8] * z + m[12] * w;
    out[1] = m[1] * x2 + m[5] * y2 + m[9] * z + m[13] * w;
    out[2] = m[2] * x2 + m[6] * y2 + m[10] * z + m[14] * w;
    out[3] = m[3] * x2 + m[7] * y2 + m[11] * z + m[15] * w;
    return out;
  }
  var forEach5 = function() {
    var vec = create6();
    return function(a2, stride, offset, count2, fn, arg) {
      var i3, l2;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l2 = Math.min(count2 * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i3 = offset; i3 < l2; i3 += stride) {
        vec[0] = a2[i3];
        vec[1] = a2[i3 + 1];
        vec[2] = a2[i3 + 2];
        vec[3] = a2[i3 + 3];
        fn(vec, vec, arg);
        a2[i3] = vec[0];
        a2[i3 + 1] = vec[1];
        a2[i3 + 2] = vec[2];
        a2[i3 + 3] = vec[3];
      }
      return a2;
    };
  }();

  // ../core/src/utils/memoize.ts
  function isEqual(a2, b) {
    if (a2 === b) {
      return true;
    }
    if (Array.isArray(a2)) {
      const len3 = a2.length;
      if (!b || b.length !== len3) {
        return false;
      }
      for (let i3 = 0; i3 < len3; i3++) {
        if (a2[i3] !== b[i3]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function memoize(compute) {
    let cachedArgs = {};
    let cachedResult;
    return (args) => {
      for (const key in args) {
        if (!isEqual(args[key], cachedArgs[key])) {
          cachedResult = compute(args);
          cachedArgs = args;
          break;
        }
      }
      return cachedResult;
    };
  }

  // ../core/src/shaderlib/project/viewport-uniforms.ts
  var ZERO_VECTOR = [0, 0, 0, 0];
  var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  var IDENTITY_MATRIX4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
  var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
  var getMemoizedViewportUniforms = memoize(calculateViewportUniforms);
  function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
    if (coordinateOrigin.length < 3) {
      coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
    }
    let shaderCoordinateOrigin = coordinateOrigin;
    let geospatialOrigin;
    let offsetMode = true;
    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
      geospatialOrigin = coordinateOrigin;
    } else {
      geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;
    }
    switch (viewport.projectionMode) {
      case PROJECTION_MODE.WEB_MERCATOR:
        if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
          geospatialOrigin = [0, 0, 0];
          offsetMode = false;
        }
        break;
      case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
        if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
          shaderCoordinateOrigin = geospatialOrigin;
        } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
          shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];
          geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
          shaderCoordinateOrigin[0] -= coordinateOrigin[0];
          shaderCoordinateOrigin[1] -= coordinateOrigin[1];
          shaderCoordinateOrigin[2] -= coordinateOrigin[2];
        }
        break;
      case PROJECTION_MODE.IDENTITY:
        shaderCoordinateOrigin = viewport.position.map(Math.fround);
        shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
        break;
      case PROJECTION_MODE.GLOBE:
        offsetMode = false;
        geospatialOrigin = null;
        break;
      default:
        offsetMode = false;
    }
    return {
      geospatialOrigin,
      shaderCoordinateOrigin,
      offsetMode
    };
  }
  function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
    const {
      viewMatrixUncentered,
      projectionMatrix
    } = viewport;
    let {
      viewMatrix: viewMatrix2,
      viewProjectionMatrix
    } = viewport;
    let projectionCenter = ZERO_VECTOR;
    let originCommon = ZERO_VECTOR;
    let cameraPosCommon = viewport.cameraPosition;
    const {
      geospatialOrigin,
      shaderCoordinateOrigin,
      offsetMode
    } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);
    if (offsetMode) {
      originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
      cameraPosCommon = [cameraPosCommon[0] - originCommon[0], cameraPosCommon[1] - originCommon[1], cameraPosCommon[2] - originCommon[2]];
      originCommon[3] = 1;
      projectionCenter = transformMat44([], originCommon, viewProjectionMatrix);
      viewMatrix2 = viewMatrixUncentered || viewMatrix2;
      viewProjectionMatrix = multiply4([], projectionMatrix, viewMatrix2);
      viewProjectionMatrix = multiply4([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
    }
    return {
      viewMatrix: viewMatrix2,
      viewProjectionMatrix,
      projectionCenter,
      originCommon,
      cameraPosCommon,
      shaderCoordinateOrigin,
      geospatialOrigin
    };
  }
  function getUniformsFromViewport({
    viewport,
    devicePixelRatio = 1,
    modelMatrix: modelMatrix2 = null,
    coordinateSystem = COORDINATE_SYSTEM.DEFAULT,
    coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
    autoWrapLongitude = false
  }) {
    if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
    }
    const uniforms = getMemoizedViewportUniforms({
      viewport,
      devicePixelRatio,
      coordinateSystem,
      coordinateOrigin
    });
    uniforms.project_uWrapLongitude = autoWrapLongitude;
    uniforms.project_uModelMatrix = modelMatrix2 || IDENTITY_MATRIX4;
    return uniforms;
  }
  function calculateViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  }) {
    const {
      projectionCenter,
      viewProjectionMatrix,
      originCommon,
      cameraPosCommon,
      shaderCoordinateOrigin,
      geospatialOrigin
    } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
    const distanceScales = viewport.getDistanceScales();
    const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
    const focalDistance = transformMat44([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
    const uniforms = {
      project_uCoordinateSystem: coordinateSystem,
      project_uProjectionMode: viewport.projectionMode,
      project_uCoordinateOrigin: shaderCoordinateOrigin,
      project_uCommonOrigin: originCommon.slice(0, 3),
      project_uCenter: projectionCenter,
      project_uPseudoMeters: Boolean(viewport._pseudoMeters),
      project_uViewportSize: viewportSize,
      project_uDevicePixelRatio: devicePixelRatio,
      project_uFocalDistance: focalDistance,
      project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
      project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
      project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
      project_uScale: viewport.scale,
      project_uWrapLongitude: false,
      project_uViewProjectionMatrix: viewProjectionMatrix,
      project_uModelMatrix: IDENTITY_MATRIX4,
      project_uCameraPosition: cameraPosCommon
    };
    if (geospatialOrigin) {
      const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
      switch (coordinateSystem) {
        case COORDINATE_SYSTEM.METER_OFFSETS:
          uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
          uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
          break;
        case COORDINATE_SYSTEM.LNGLAT:
        case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
          if (!viewport._pseudoMeters) {
            uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
          }
          uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
          uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
          break;
        case COORDINATE_SYSTEM.CARTESIAN:
          uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
          uniforms.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
          break;
        default:
          break;
      }
    }
    return uniforms;
  }

  // ../core/src/shaderlib/project/project.ts
  var INITIAL_MODULE_OPTIONS3 = {};
  function getUniforms5(opts = INITIAL_MODULE_OPTIONS3) {
    if ("viewport" in opts) {
      return getUniformsFromViewport(opts);
    }
    return {};
  }
  var project_default = {
    name: "project",
    dependencies: [fp32, geometry_default],
    vs: project_glsl_default,
    getUniforms: getUniforms5
  };

  // ../../node_modules/@math.gl/web-mercator/dist/esm/math-utils.js
  function createMat4() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function transformVector(matrix, vector) {
    const result = transformMat43([], vector, matrix);
    scale4(result, result, 1 / result[3]);
    return result;
  }
  function mod(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
  }
  function lerp5(start, end, step) {
    return step * end + (1 - step) * start;
  }
  function clamp2(x2, min, max) {
    return x2 < min ? min : x2 > max ? max : x2;
  }
  function ieLog2(x2) {
    return Math.log(x2) * Math.LOG2E;
  }
  var log22 = Math.log2 || ieLog2;

  // ../../node_modules/@math.gl/web-mercator/dist/esm/assert.js
  function assert10(condition, message) {
    if (!condition) {
      throw new Error(message || "@math.gl/web-mercator: assertion failed.");
    }
  }

  // ../../node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js
  var PI = Math.PI;
  var PI_4 = PI / 4;
  var DEGREES_TO_RADIANS2 = PI / 180;
  var RADIANS_TO_DEGREES2 = 180 / PI;
  var TILE_SIZE = 512;
  var EARTH_CIRCUMFERENCE = 4003e4;
  var MAX_LATITUDE = 85.051129;
  var DEFAULT_ALTITUDE = 1.5;
  function zoomToScale(zoom) {
    return Math.pow(2, zoom);
  }
  function scaleToZoom(scale8) {
    return log22(scale8);
  }
  function lngLatToWorld(lngLat) {
    const [lng, lat] = lngLat;
    assert10(Number.isFinite(lng));
    assert10(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
    const lambda2 = lng * DEGREES_TO_RADIANS2;
    const phi2 = lat * DEGREES_TO_RADIANS2;
    const x2 = TILE_SIZE * (lambda2 + PI) / (2 * PI);
    const y2 = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
    return [x2, y2];
  }
  function worldToLngLat(xy) {
    const [x2, y2] = xy;
    const lambda2 = x2 / TILE_SIZE * (2 * PI) - PI;
    const phi2 = 2 * (Math.atan(Math.exp(y2 / TILE_SIZE * (2 * PI) - PI)) - PI_4);
    return [lambda2 * RADIANS_TO_DEGREES2, phi2 * RADIANS_TO_DEGREES2];
  }
  function getMeterZoom(options) {
    const {
      latitude
    } = options;
    assert10(Number.isFinite(latitude));
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
  }
  function unitsPerMeter(latitude) {
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
  }
  function getDistanceScales(options) {
    const {
      latitude,
      longitude,
      highPrecision = false
    } = options;
    assert10(Number.isFinite(latitude) && Number.isFinite(longitude));
    const worldSize = TILE_SIZE;
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    const unitsPerDegreeX = worldSize / 360;
    const unitsPerDegreeY = unitsPerDegreeX / latCosine;
    const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
    const result = {
      unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],
      metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],
      unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],
      degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]
    };
    if (highPrecision) {
      const latCosine2 = DEGREES_TO_RADIANS2 * Math.tan(latitude * DEGREES_TO_RADIANS2) / latCosine;
      const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
      const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
      const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
      result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
      result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
    }
    return result;
  }
  function addMetersToLngLat(lngLatZ, xyz) {
    const [longitude, latitude, z0] = lngLatZ;
    const [x2, y2, z] = xyz;
    const {
      unitsPerMeter: unitsPerMeter2,
      unitsPerMeter2: unitsPerMeter22
    } = getDistanceScales({
      longitude,
      latitude,
      highPrecision: true
    });
    const worldspace = lngLatToWorld(lngLatZ);
    worldspace[0] += x2 * (unitsPerMeter2[0] + unitsPerMeter22[0] * y2);
    worldspace[1] += y2 * (unitsPerMeter2[1] + unitsPerMeter22[1] * y2);
    const newLngLat = worldToLngLat(worldspace);
    const newZ = (z0 || 0) + (z || 0);
    return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
  }
  function getViewMatrix(options) {
    const {
      height,
      pitch,
      bearing,
      altitude,
      scale: scale8,
      center
    } = options;
    const vm = createMat4();
    translate2(vm, vm, [0, 0, -altitude]);
    rotateX2(vm, vm, -pitch * DEGREES_TO_RADIANS2);
    rotateZ2(vm, vm, bearing * DEGREES_TO_RADIANS2);
    const relativeScale = scale8 / height;
    scale3(vm, vm, [relativeScale, relativeScale, relativeScale]);
    if (center) {
      translate2(vm, vm, negate([], center));
    }
    return vm;
  }
  function getProjectionParameters(options) {
    const {
      width,
      height,
      altitude,
      pitch = 0,
      offset,
      center,
      scale: scale8,
      nearZMultiplier = 1,
      farZMultiplier = 1
    } = options;
    let {
      fovy = altitudeToFovy(DEFAULT_ALTITUDE)
    } = options;
    if (altitude !== void 0) {
      fovy = altitudeToFovy(altitude);
    }
    const fovRadians = fovy * DEGREES_TO_RADIANS2;
    const pitchRadians = pitch * DEGREES_TO_RADIANS2;
    const focalDistance = fovyToAltitude(fovy);
    let cameraToSeaLevelDistance = focalDistance;
    if (center) {
      cameraToSeaLevelDistance += center[2] * scale8 / Math.cos(pitchRadians) / height;
    }
    const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
    const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp2(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
    const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
    const horizonDistance = cameraToSeaLevelDistance * 10;
    const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
    return {
      fov: fovRadians,
      aspect: width / height,
      focalDistance,
      near: nearZMultiplier,
      far: farZ
    };
  }
  function altitudeToFovy(altitude) {
    return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES2;
  }
  function fovyToAltitude(fovy) {
    return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS2);
  }
  function worldToPixels(xyz, pixelProjectionMatrix) {
    const [x2, y2, z = 0] = xyz;
    assert10(Number.isFinite(x2) && Number.isFinite(y2) && Number.isFinite(z));
    return transformVector(pixelProjectionMatrix, [x2, y2, z, 1]);
  }
  function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
    const [x2, y2, z] = xyz;
    assert10(Number.isFinite(x2) && Number.isFinite(y2), "invalid pixel coordinate");
    if (Number.isFinite(z)) {
      const coord = transformVector(pixelUnprojectionMatrix, [x2, y2, z, 1]);
      return coord;
    }
    const coord0 = transformVector(pixelUnprojectionMatrix, [x2, y2, 0, 1]);
    const coord1 = transformVector(pixelUnprojectionMatrix, [x2, y2, 1, 1]);
    const z0 = coord0[2];
    const z1 = coord1[2];
    const t2 = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
    return lerp2([], coord0, coord1, t2);
  }

  // ../../node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js
  function fitBounds(options) {
    const {
      width,
      height,
      bounds,
      minExtent = 0,
      maxZoom = 24,
      offset = [0, 0]
    } = options;
    const [[west, south], [east, north]] = bounds;
    const padding = getPaddingObject(options.padding);
    const nw = lngLatToWorld([west, clamp2(north, -MAX_LATITUDE, MAX_LATITUDE)]);
    const se = lngLatToWorld([east, clamp2(south, -MAX_LATITUDE, MAX_LATITUDE)]);
    const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];
    const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
    assert10(targetSize[0] > 0 && targetSize[1] > 0);
    const scaleX2 = targetSize[0] / size[0];
    const scaleY2 = targetSize[1] / size[1];
    const offsetX = (padding.right - padding.left) / 2 / scaleX2;
    const offsetY = (padding.bottom - padding.top) / 2 / scaleY2;
    const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
    const centerLngLat = worldToLngLat(center);
    const zoom = Math.min(maxZoom, log22(Math.abs(Math.min(scaleX2, scaleY2))));
    assert10(Number.isFinite(zoom));
    return {
      longitude: centerLngLat[0],
      latitude: centerLngLat[1],
      zoom
    };
  }
  function getPaddingObject(padding = 0) {
    if (typeof padding === "number") {
      return {
        top: padding,
        bottom: padding,
        left: padding,
        right: padding
      };
    }
    assert10(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
    return padding;
  }

  // ../../node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js
  var DEGREES_TO_RADIANS3 = Math.PI / 180;
  function getBounds(viewport, z = 0) {
    const {
      width,
      height,
      unproject
    } = viewport;
    const unprojectOps = {
      targetZ: z
    };
    const bottomLeft = unproject([0, height], unprojectOps);
    const bottomRight = unproject([width, height], unprojectOps);
    let topLeft;
    let topRight;
    const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS3 : Math.atan(0.5 / viewport.altitude);
    const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS3;
    if (halfFov > angleToGround - 0.01) {
      topLeft = unprojectOnFarPlane(viewport, 0, z);
      topRight = unprojectOnFarPlane(viewport, width, z);
    } else {
      topLeft = unproject([0, 0], unprojectOps);
      topRight = unproject([width, 0], unprojectOps);
    }
    return [bottomLeft, bottomRight, topRight, topLeft];
  }
  function unprojectOnFarPlane(viewport, x2, targetZ) {
    const {
      pixelUnprojectionMatrix
    } = viewport;
    const coord0 = transformVector(pixelUnprojectionMatrix, [x2, 0, 1, 1]);
    const coord1 = transformVector(pixelUnprojectionMatrix, [x2, viewport.height, 1, 1]);
    const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
    const t2 = (z - coord0[2]) / (coord1[2] - coord0[2]);
    const coord = lerp2([], coord0, coord1, t2);
    const result = worldToLngLat(coord);
    result.push(targetZ);
    return result;
  }

  // ../../node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js
  var TILE_SIZE2 = 512;
  function normalizeViewportProps(props) {
    const {
      width,
      height,
      pitch = 0
    } = props;
    let {
      longitude,
      latitude,
      zoom,
      bearing = 0
    } = props;
    if (longitude < -180 || longitude > 180) {
      longitude = mod(longitude + 180, 360) - 180;
    }
    if (bearing < -180 || bearing > 180) {
      bearing = mod(bearing + 180, 360) - 180;
    }
    const minZoom = log22(height / TILE_SIZE2);
    if (zoom <= minZoom) {
      zoom = minZoom;
      latitude = 0;
    } else {
      const halfHeightPixels = height / 2 / Math.pow(2, zoom);
      const minLatitude = worldToLngLat([0, halfHeightPixels])[1];
      if (latitude < minLatitude) {
        latitude = minLatitude;
      } else {
        const maxLatitude = worldToLngLat([0, TILE_SIZE2 - halfHeightPixels])[1];
        if (latitude > maxLatitude) {
          latitude = maxLatitude;
        }
      }
    }
    return {
      width,
      height,
      longitude,
      latitude,
      zoom,
      pitch,
      bearing
    };
  }

  // ../../node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js
  var EPSILON4 = 0.01;
  var VIEWPORT_TRANSITION_PROPS = ["longitude", "latitude", "zoom"];
  var DEFAULT_OPTS = {
    curve: 1.414,
    speed: 1.2
  };
  function flyToViewport(startProps, endProps, t2, options) {
    const {
      startZoom,
      startCenterXY,
      uDelta,
      w0,
      u1,
      S,
      rho,
      rho2,
      r0
    } = getFlyToTransitionParams(startProps, endProps, options);
    if (u1 < EPSILON4) {
      const viewport = {};
      for (const key of VIEWPORT_TRANSITION_PROPS) {
        const startValue = startProps[key];
        const endValue = endProps[key];
        viewport[key] = lerp5(startValue, endValue, t2);
      }
      return viewport;
    }
    const s2 = t2 * S;
    const w = Math.cosh(r0) / Math.cosh(r0 + rho * s2);
    const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s2) - Math.sinh(r0)) / rho2) / u1;
    const scaleIncrement = 1 / w;
    const newZoom = startZoom + scaleToZoom(scaleIncrement);
    const newCenterWorld = scale([], uDelta, u);
    add(newCenterWorld, newCenterWorld, startCenterXY);
    const newCenter = worldToLngLat(newCenterWorld);
    return {
      longitude: newCenter[0],
      latitude: newCenter[1],
      zoom: newZoom
    };
  }
  function getFlyToDuration(startProps, endProps, options) {
    const opts = {
      ...DEFAULT_OPTS,
      ...options
    };
    const {
      screenSpeed,
      speed,
      maxDuration
    } = opts;
    const {
      S,
      rho
    } = getFlyToTransitionParams(startProps, endProps, opts);
    const length7 = 1e3 * S;
    let duration;
    if (Number.isFinite(screenSpeed)) {
      duration = length7 / (screenSpeed / rho);
    } else {
      duration = length7 / speed;
    }
    return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
  }
  function getFlyToTransitionParams(startProps, endProps, opts) {
    opts = Object.assign({}, DEFAULT_OPTS, opts);
    const rho = opts.curve;
    const startZoom = startProps.zoom;
    const startCenter = [startProps.longitude, startProps.latitude];
    const startScale = zoomToScale(startZoom);
    const endZoom = endProps.zoom;
    const endCenter = [endProps.longitude, endProps.latitude];
    const scale8 = zoomToScale(endZoom - startZoom);
    const startCenterXY = lngLatToWorld(startCenter);
    const endCenterXY = lngLatToWorld(endCenter);
    const uDelta = sub([], endCenterXY, startCenterXY);
    const w0 = Math.max(startProps.width, startProps.height);
    const w1 = w0 / scale8;
    const u1 = length(uDelta) * startScale;
    const _u1 = Math.max(u1, EPSILON4);
    const rho2 = rho * rho;
    const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
    const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
    const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
    const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    const S = (r1 - r0) / rho;
    return {
      startZoom,
      startCenterXY,
      uDelta,
      w0,
      u1,
      S,
      rho,
      rho2,
      r0,
      r1
    };
  }

  // ../core/src/shaderlib/shadow/shadow.ts
  var vs4 = `
const int max_lights = 2;
uniform mat4 shadow_uViewProjectionMatrices[max_lights];
uniform vec4 shadow_uProjectCenters[max_lights];
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform int shadow_uLightId;
uniform float shadow_uLightCount;

varying vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  if (shadow_uDrawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);
  }
  if (shadow_uUseShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow_uLightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`;
  var fs3 = `
const int max_lights = 2;
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;
uniform vec4 shadow_uColor;
uniform float shadow_uLightCount;

varying vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture2D(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow_uDrawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow_uUseShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow_uLightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`;
  var getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);
  var getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);
  var DEFAULT_SHADOW_COLOR = [0, 0, 0, 1];
  var VECTOR_TO_POINT_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
    const [x2, y2, z] = xyz;
    const coord = pixelsToWorld([x2, y2, z], pixelUnprojectionMatrix);
    if (Number.isFinite(z)) {
      return coord;
    }
    return [coord[0], coord[1], 0];
  }
  function getViewportCenterPosition({
    viewport,
    center
  }) {
    return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
  }
  function getViewProjectionMatrices({
    viewport,
    shadowMatrices
  }) {
    const projectionMatrices = [];
    const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
    const farZ = viewport.isGeospatial ? void 0 : 1;
    const corners = [
      [0, 0, farZ],
      [viewport.width, 0, farZ],
      [0, viewport.height, farZ],
      [viewport.width, viewport.height, farZ],
      [0, 0, -1],
      [viewport.width, 0, -1],
      [0, viewport.height, -1],
      [viewport.width, viewport.height, -1]
    ].map((pixel) => screenToCommonSpace(pixel, pixelUnprojectionMatrix));
    for (const shadowMatrix of shadowMatrices) {
      const viewMatrix2 = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());
      const positions = corners.map((corner) => viewMatrix2.transform(corner));
      const projectionMatrix = new Matrix4().ortho({
        left: Math.min(...positions.map((position) => position[0])),
        right: Math.max(...positions.map((position) => position[0])),
        bottom: Math.min(...positions.map((position) => position[1])),
        top: Math.max(...positions.map((position) => position[1])),
        near: Math.min(...positions.map((position) => -position[2])),
        far: Math.max(...positions.map((position) => -position[2]))
      });
      projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
    }
    return projectionMatrices;
  }
  function createShadowUniforms(opts, context) {
    const {
      shadowEnabled = true
    } = opts;
    if (!shadowEnabled || !opts.shadowMatrices || !opts.shadowMatrices.length) {
      return {
        shadow_uDrawShadowMap: false,
        shadow_uUseShadowMap: false
      };
    }
    const uniforms = {
      shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
      shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
      shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,
      shadow_uLightId: opts.shadowLightId || 0,
      shadow_uLightCount: opts.shadowMatrices.length
    };
    const center = getMemoizedViewportCenterPosition({
      viewport: opts.viewport,
      center: context.project_uCenter
    });
    const projectCenters = [];
    const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
      shadowMatrices: opts.shadowMatrices,
      viewport: opts.viewport
    }).slice();
    for (let i3 = 0; i3 < opts.shadowMatrices.length; i3++) {
      const viewProjectionMatrix = viewProjectionMatrices[i3];
      const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(opts.viewport.center).negate());
      if (context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR) {
        viewProjectionMatrices[i3] = viewProjectionMatrixCentered;
        projectCenters[i3] = center;
      } else {
        viewProjectionMatrices[i3] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX2);
        projectCenters[i3] = viewProjectionMatrixCentered.transform(center);
      }
    }
    for (let i3 = 0; i3 < viewProjectionMatrices.length; i3++) {
      uniforms[`shadow_uViewProjectionMatrices[${i3}]`] = viewProjectionMatrices[i3];
      uniforms[`shadow_uProjectCenters[${i3}]`] = projectCenters[i3];
      if (opts.shadowMaps && opts.shadowMaps.length > 0) {
        uniforms[`shadow_uShadowMap${i3}`] = opts.shadowMaps[i3];
      } else {
        uniforms[`shadow_uShadowMap${i3}`] = opts.dummyShadowMap;
      }
    }
    return uniforms;
  }
  var shadow_default = {
    name: "shadow",
    dependencies: [project_default],
    vs: vs4,
    fs: fs3,
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
      "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
    },
    getUniforms: (opts = {}, context = {}) => {
      if ("viewport" in opts && (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0)) {
        return createShadowUniforms(opts, context);
      }
      return {};
    }
  };

  // ../core/src/effects/lighting/lighting-effect.ts
  var DEFAULT_AMBIENT_LIGHT_PROPS = {
    color: [255, 255, 255],
    intensity: 1
  };
  var DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{
    color: [255, 255, 255],
    intensity: 1,
    direction: [-1, 3, -1]
  }, {
    color: [255, 255, 255],
    intensity: 0.9,
    direction: [1, -8, -2.5]
  }];
  var DEFAULT_SHADOW_COLOR2 = [0, 0, 0, 200 / 255];
  var LightingEffect = class {
    id = "lighting-effect";
    shadowColor = DEFAULT_SHADOW_COLOR2;
    shadowPasses = [];
    shadowMaps = [];
    dummyShadowMap = null;
    constructor(props = {}) {
      this.setProps(props);
    }
    setProps(props) {
      this.ambientLight = null;
      this.directionalLights = [];
      this.pointLights = [];
      for (const key in props) {
        const lightSource = props[key];
        switch (lightSource.type) {
          case "ambient":
            this.ambientLight = lightSource;
            break;
          case "directional":
            this.directionalLights.push(lightSource);
            break;
          case "point":
            this.pointLights.push(lightSource);
            break;
          default:
        }
      }
      this._applyDefaultLights();
      this.shadow = this.directionalLights.some((light) => light.shadow);
      this.props = props;
    }
    preRender(gl, {
      layers,
      layerFilter,
      viewports,
      onViewportActive,
      views
    }) {
      if (!this.shadow)
        return;
      this.shadowMatrices = this._calculateMatrices();
      if (this.shadowPasses.length === 0) {
        this._createShadowPasses(gl);
      }
      if (!this.programManager) {
        this.programManager = ProgramManager.getDefaultProgramManager(gl);
        if (shadow_default) {
          this.programManager.addDefaultModule(shadow_default);
        }
      }
      if (!this.dummyShadowMap) {
        this.dummyShadowMap = new Texture2D(gl, {
          width: 1,
          height: 1
        });
      }
      for (let i3 = 0; i3 < this.shadowPasses.length; i3++) {
        const shadowPass = this.shadowPasses[i3];
        shadowPass.render({
          layers,
          layerFilter,
          viewports,
          onViewportActive,
          views,
          moduleParameters: {
            shadowLightId: i3,
            dummyShadowMap: this.dummyShadowMap,
            shadowMatrices: this.shadowMatrices
          }
        });
      }
    }
    getModuleParameters(layer) {
      const parameters2 = this.shadow ? {
        shadowMaps: this.shadowMaps,
        dummyShadowMap: this.dummyShadowMap,
        shadowColor: this.shadowColor,
        shadowMatrices: this.shadowMatrices
      } : {};
      parameters2.lightSources = {
        ambientLight: this.ambientLight,
        directionalLights: this.directionalLights.map((directionalLight) => directionalLight.getProjectedLight({
          layer
        })),
        pointLights: this.pointLights.map((pointLight) => pointLight.getProjectedLight({
          layer
        }))
      };
      return parameters2;
    }
    cleanup() {
      for (const shadowPass of this.shadowPasses) {
        shadowPass.delete();
      }
      this.shadowPasses.length = 0;
      this.shadowMaps.length = 0;
      if (this.dummyShadowMap) {
        this.dummyShadowMap.delete();
        this.dummyShadowMap = null;
      }
      if (this.shadow && this.programManager) {
        this.programManager.removeDefaultModule(shadow_default);
        this.programManager = null;
      }
    }
    _calculateMatrices() {
      const lightMatrices = [];
      for (const light of this.directionalLights) {
        const viewMatrix2 = new Matrix4().lookAt({
          eye: new Vector3(light.direction).negate()
        });
        lightMatrices.push(viewMatrix2);
      }
      return lightMatrices;
    }
    _createShadowPasses(gl) {
      for (let i3 = 0; i3 < this.directionalLights.length; i3++) {
        const shadowPass = new ShadowPass(gl);
        this.shadowPasses[i3] = shadowPass;
        this.shadowMaps[i3] = shadowPass.shadowMap;
      }
    }
    _applyDefaultLights() {
      const {
        ambientLight,
        pointLights,
        directionalLights
      } = this;
      if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
        this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
        this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
      }
    }
  };

  // ../core/src/utils/typed-array-manager.ts
  var TypedArrayManager = class {
    _pool = [];
    opts = {
      overAlloc: 2,
      poolSize: 100
    };
    constructor(options = {}) {
      this.setOptions(options);
    }
    setOptions(options) {
      Object.assign(this.opts, options);
    }
    allocate(typedArray, count2, {
      size = 1,
      type,
      padding = 0,
      copy: copy3 = false,
      initialize = false,
      maxCount
    }) {
      const Type2 = type || typedArray && typedArray.constructor || Float32Array;
      const newSize = count2 * size + padding;
      if (ArrayBuffer.isView(typedArray)) {
        if (newSize <= typedArray.length) {
          return typedArray;
        }
        if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
          return new Type2(typedArray.buffer, 0, newSize);
        }
      }
      let maxSize = Infinity;
      if (maxCount) {
        maxSize = maxCount * size + padding;
      }
      const newArray = this._allocate(Type2, newSize, initialize, maxSize);
      if (typedArray && copy3) {
        newArray.set(typedArray);
      } else if (!initialize) {
        newArray.fill(0, 0, 4);
      }
      this._release(typedArray);
      return newArray;
    }
    release(typedArray) {
      this._release(typedArray);
    }
    _allocate(Type2, size, initialize, maxSize) {
      let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
      if (sizeToAllocate > maxSize) {
        sizeToAllocate = maxSize;
      }
      const pool = this._pool;
      const byteLength = Type2.BYTES_PER_ELEMENT * sizeToAllocate;
      const i3 = pool.findIndex((b) => b.byteLength >= byteLength);
      if (i3 >= 0) {
        const array = new Type2(pool.splice(i3, 1)[0], 0, sizeToAllocate);
        if (initialize) {
          array.fill(0);
        }
        return array;
      }
      return new Type2(sizeToAllocate);
    }
    _release(typedArray) {
      if (!ArrayBuffer.isView(typedArray)) {
        return;
      }
      const pool = this._pool;
      const {
        buffer
      } = typedArray;
      const {
        byteLength
      } = buffer;
      const i3 = pool.findIndex((b) => b.byteLength >= byteLength);
      if (i3 < 0) {
        pool.push(buffer);
      } else if (i3 > 0 || pool.length < this.opts.poolSize) {
        pool.splice(i3, 0, buffer);
      }
      if (pool.length > this.opts.poolSize) {
        pool.shift();
      }
    }
  };
  var typed_array_manager_default = new TypedArrayManager();

  // ../core/src/utils/math-utils.ts
  function createMat42() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function mod2(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
  }
  function getCameraPosition(viewMatrixInverse) {
    return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
  }
  function getFrustumPlanes(viewProjectionMatrix) {
    return {
      left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
      right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
      bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
      top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
      near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
      far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
    };
  }
  var scratchVector = new Vector3();
  function getFrustumPlane(a2, b, c, d) {
    scratchVector.set(a2, b, c);
    const L = scratchVector.len();
    return {
      distance: d / L,
      normal: new Vector3(-a2 / L, -b / L, -c / L)
    };
  }
  function fp64LowPart2(x2) {
    return x2 - Math.fround(x2);
  }
  var scratchArray;
  function toDoublePrecisionArray(typedArray, options) {
    const {
      size = 1,
      startIndex = 0
    } = options;
    const endIndex = options.endIndex !== void 0 ? options.endIndex : typedArray.length;
    const count2 = (endIndex - startIndex) / size;
    scratchArray = typed_array_manager_default.allocate(scratchArray, count2, {
      type: Float32Array,
      size: size * 2
    });
    let sourceIndex = startIndex;
    let targetIndex = 0;
    while (sourceIndex < endIndex) {
      for (let j = 0; j < size; j++) {
        const value = typedArray[sourceIndex++];
        scratchArray[targetIndex + j] = value;
        scratchArray[targetIndex + j + size] = fp64LowPart2(value);
      }
      targetIndex += size * 2;
    }
    return scratchArray.subarray(0, count2 * size * 2);
  }
  function mergeBounds(boundsList) {
    let mergedBounds = null;
    let isMerged = false;
    for (const bounds of boundsList) {
      if (!bounds)
        continue;
      if (!mergedBounds) {
        mergedBounds = bounds;
      } else {
        if (!isMerged) {
          mergedBounds = [[mergedBounds[0][0], mergedBounds[0][1]], [mergedBounds[1][0], mergedBounds[1][1]]];
          isMerged = true;
        }
        mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
        mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
        mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
        mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
      }
    }
    return mergedBounds;
  }

  // ../core/src/viewports/viewport.ts
  var DEGREES_TO_RADIANS4 = Math.PI / 180;
  var IDENTITY2 = createMat42();
  var ZERO_VECTOR2 = [0, 0, 0];
  var DEFAULT_DISTANCE_SCALES = {
    unitsPerMeter: [1, 1, 1],
    metersPerUnit: [1, 1, 1]
  };
  function createProjectionMatrix({
    width,
    height,
    orthographic,
    fovyRadians,
    focalDistance,
    padding,
    near,
    far
  }) {
    const aspect = width / height;
    const matrix = orthographic ? new Matrix4().orthographic({
      fovy: fovyRadians,
      aspect,
      focalDistance,
      near,
      far
    }) : new Matrix4().perspective({
      fovy: fovyRadians,
      aspect,
      near,
      far
    });
    if (padding) {
      const {
        left = 0,
        right = 0,
        top = 0,
        bottom = 0
      } = padding;
      const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;
      const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;
      matrix[8] -= offsetX * 2 / width;
      matrix[9] += offsetY * 2 / height;
    }
    return matrix;
  }
  var _Viewport = class {
    _frustumPlanes = {};
    constructor(opts = {}) {
      this.id = opts.id || this.constructor.displayName || "viewport";
      this.x = opts.x || 0;
      this.y = opts.y || 0;
      this.width = opts.width || 1;
      this.height = opts.height || 1;
      this.zoom = opts.zoom || 0;
      this.padding = opts.padding;
      this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
      this.focalDistance = opts.focalDistance || 1;
      this.position = opts.position || ZERO_VECTOR2;
      this.modelMatrix = opts.modelMatrix || null;
      const {
        longitude,
        latitude
      } = opts;
      this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
      this._initProps(opts);
      this._initMatrices(opts);
      this.equals = this.equals.bind(this);
      this.project = this.project.bind(this);
      this.unproject = this.unproject.bind(this);
      this.projectPosition = this.projectPosition.bind(this);
      this.unprojectPosition = this.unprojectPosition.bind(this);
      this.projectFlat = this.projectFlat.bind(this);
      this.unprojectFlat = this.unprojectFlat.bind(this);
    }
    get subViewports() {
      return null;
    }
    get metersPerPixel() {
      return this.distanceScales.metersPerUnit[2] / this.scale;
    }
    get projectionMode() {
      if (this.isGeospatial) {
        return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
      }
      return PROJECTION_MODE.IDENTITY;
    }
    equals(viewport) {
      if (!(viewport instanceof _Viewport)) {
        return false;
      }
      if (this === viewport) {
        return true;
      }
      return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
    }
    project(xyz, {
      topLeft = true
    } = {}) {
      const worldPosition = this.projectPosition(xyz);
      const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
      const [x2, y2] = coord;
      const y22 = topLeft ? y2 : this.height - y2;
      return xyz.length === 2 ? [x2, y22] : [x2, y22, coord[2]];
    }
    unproject(xyz, {
      topLeft = true,
      targetZ
    } = {}) {
      const [x2, y2, z] = xyz;
      const y22 = topLeft ? y2 : this.height - y2;
      const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
      const coord = pixelsToWorld([x2, y22, z], this.pixelUnprojectionMatrix, targetZWorld);
      const [X, Y, Z] = this.unprojectPosition(coord);
      if (Number.isFinite(z)) {
        return [X, Y, Z];
      }
      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }
    projectPosition(xyz) {
      const [X, Y] = this.projectFlat(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
      return [X, Y, Z];
    }
    unprojectPosition(xyz) {
      const [X, Y] = this.unprojectFlat(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
      return [X, Y, Z];
    }
    projectFlat(xyz) {
      if (this.isGeospatial) {
        const result = lngLatToWorld(xyz);
        result[1] = clamp(result[1], -318, 830);
        return result;
      }
      return xyz;
    }
    unprojectFlat(xyz) {
      if (this.isGeospatial) {
        return worldToLngLat(xyz);
      }
      return xyz;
    }
    getBounds(options = {}) {
      const unprojectOption = {
        targetZ: options.z || 0
      };
      const topLeft = this.unproject([0, 0], unprojectOption);
      const topRight = this.unproject([this.width, 0], unprojectOption);
      const bottomLeft = this.unproject([0, this.height], unprojectOption);
      const bottomRight = this.unproject([this.width, this.height], unprojectOption);
      return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
    }
    getDistanceScales(coordinateOrigin) {
      if (coordinateOrigin) {
        return getDistanceScales({
          longitude: coordinateOrigin[0],
          latitude: coordinateOrigin[1],
          highPrecision: true
        });
      }
      return this.distanceScales;
    }
    containsPixel({
      x: x2,
      y: y2,
      width = 1,
      height = 1
    }) {
      return x2 < this.x + this.width && this.x < x2 + width && y2 < this.y + this.height && this.y < y2 + height;
    }
    getFrustumPlanes() {
      if (this._frustumPlanes.near) {
        return this._frustumPlanes;
      }
      Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));
      return this._frustumPlanes;
    }
    panByPosition(coords, pixel) {
      return null;
    }
    _initProps(opts) {
      const longitude = opts.longitude;
      const latitude = opts.latitude;
      if (this.isGeospatial) {
        if (!Number.isFinite(opts.zoom)) {
          this.zoom = getMeterZoom({
            latitude
          }) + Math.log2(this.focalDistance);
        }
        this.distanceScales = opts.distanceScales || getDistanceScales({
          latitude,
          longitude
        });
      }
      const scale8 = Math.pow(2, this.zoom);
      this.scale = scale8;
      const {
        position,
        modelMatrix: modelMatrix2
      } = opts;
      let meterOffset = ZERO_VECTOR2;
      if (position) {
        meterOffset = modelMatrix2 ? new Matrix4(modelMatrix2).transformAsVector(position, []) : position;
      }
      if (this.isGeospatial) {
        const center = this.projectPosition([longitude, latitude, 0]);
        this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
      } else {
        this.center = this.projectPosition(meterOffset);
      }
    }
    _initMatrices(opts) {
      const {
        viewMatrix: viewMatrix2 = IDENTITY2,
        projectionMatrix = null,
        orthographic = false,
        fovyRadians,
        fovy = 75,
        near = 0.1,
        far = 1e3,
        padding = null,
        focalDistance = 1
      } = opts;
      this.viewMatrixUncentered = viewMatrix2;
      this.viewMatrix = new Matrix4().multiplyRight(viewMatrix2).translate(new Vector3(this.center).negate());
      this.projectionMatrix = projectionMatrix || createProjectionMatrix({
        width: this.width,
        height: this.height,
        orthographic,
        fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS4,
        focalDistance,
        padding,
        near,
        far
      });
      const vpm = createMat42();
      multiply4(vpm, vpm, this.projectionMatrix);
      multiply4(vpm, vpm, this.viewMatrix);
      this.viewProjectionMatrix = vpm;
      this.viewMatrixInverse = invert4([], this.viewMatrix) || this.viewMatrix;
      this.cameraPosition = getCameraPosition(this.viewMatrixInverse);
      const viewportMatrix = createMat42();
      const pixelProjectionMatrix = createMat42();
      scale6(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
      translate3(viewportMatrix, viewportMatrix, [1, -1, 0]);
      multiply4(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = pixelProjectionMatrix;
      this.pixelUnprojectionMatrix = invert4(createMat42(), this.pixelProjectionMatrix);
      if (!this.pixelUnprojectionMatrix) {
        log_default.warn("Pixel project matrix not invertible")();
      }
    }
  };
  var Viewport = _Viewport;
  __publicField(Viewport, "displayName", "Viewport");

  // ../core/node_modules/gl-matrix/esm/vec2.js
  function create7() {
    var out = new ARRAY_TYPE2(2);
    if (ARRAY_TYPE2 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function add4(out, a2, b) {
    out[0] = a2[0] + b[0];
    out[1] = a2[1] + b[1];
    return out;
  }
  function negate2(out, a2) {
    out[0] = -a2[0];
    out[1] = -a2[1];
    return out;
  }
  var forEach6 = function() {
    var vec = create7();
    return function(a2, stride, offset, count2, fn, arg) {
      var i3, l2;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l2 = Math.min(count2 * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i3 = offset; i3 < l2; i3 += stride) {
        vec[0] = a2[i3];
        vec[1] = a2[i3 + 1];
        fn(vec, vec, arg);
        a2[i3] = vec[0];
        a2[i3 + 1] = vec[1];
      }
      return a2;
    };
  }();

  // ../core/src/viewports/web-mercator-viewport.ts
  var _WebMercatorViewport = class extends Viewport {
    constructor(opts = {}) {
      const {
        latitude = 0,
        longitude = 0,
        zoom = 0,
        pitch = 0,
        bearing = 0,
        nearZMultiplier = 0.1,
        farZMultiplier = 1.01,
        orthographic = false,
        projectionMatrix,
        repeat = false,
        worldOffset = 0,
        position,
        padding,
        legacyMeterSizes = false
      } = opts;
      let {
        width,
        height,
        altitude = 1.5
      } = opts;
      const scale8 = Math.pow(2, zoom);
      width = width || 1;
      height = height || 1;
      let fovy;
      let projectionParameters = null;
      if (projectionMatrix) {
        altitude = projectionMatrix[5] / 2;
        fovy = altitudeToFovy(altitude);
      } else {
        if (opts.fovy) {
          fovy = opts.fovy;
          altitude = fovyToAltitude(fovy);
        } else {
          fovy = altitudeToFovy(altitude);
        }
        let offset;
        if (padding) {
          const {
            top = 0,
            bottom = 0
          } = padding;
          offset = [0, clamp((top + height - bottom) / 2, 0, height) - height / 2];
        }
        projectionParameters = getProjectionParameters({
          width,
          height,
          scale: scale8,
          center: position && [0, 0, position[2] * unitsPerMeter(latitude)],
          offset,
          pitch,
          fovy,
          nearZMultiplier,
          farZMultiplier
        });
      }
      let viewMatrixUncentered = getViewMatrix({
        height,
        pitch,
        bearing,
        scale: scale8,
        altitude
      });
      if (worldOffset) {
        const viewOffset = new Matrix4().translate([512 * worldOffset, 0, 0]);
        viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
      }
      super({
        ...opts,
        width,
        height,
        viewMatrix: viewMatrixUncentered,
        longitude,
        latitude,
        zoom,
        ...projectionParameters,
        fovy,
        focalDistance: altitude
      });
      this.latitude = latitude;
      this.longitude = longitude;
      this.zoom = zoom;
      this.pitch = pitch;
      this.bearing = bearing;
      this.altitude = altitude;
      this.fovy = fovy;
      this.orthographic = orthographic;
      this._subViewports = repeat ? [] : null;
      this._pseudoMeters = legacyMeterSizes;
      Object.freeze(this);
    }
    get subViewports() {
      if (this._subViewports && !this._subViewports.length) {
        const bounds = this.getBounds();
        const minOffset = Math.floor((bounds[0] + 180) / 360);
        const maxOffset = Math.ceil((bounds[2] - 180) / 360);
        for (let x2 = minOffset; x2 <= maxOffset; x2++) {
          const offsetViewport = x2 ? new _WebMercatorViewport({
            ...this,
            worldOffset: x2
          }) : this;
          this._subViewports.push(offsetViewport);
        }
      }
      return this._subViewports;
    }
    projectPosition(xyz) {
      if (this._pseudoMeters) {
        return super.projectPosition(xyz);
      }
      const [X, Y] = this.projectFlat(xyz);
      const Z = (xyz[2] || 0) * unitsPerMeter(xyz[1]);
      return [X, Y, Z];
    }
    unprojectPosition(xyz) {
      if (this._pseudoMeters) {
        return super.unprojectPosition(xyz);
      }
      const [X, Y] = this.unprojectFlat(xyz);
      const Z = (xyz[2] || 0) / unitsPerMeter(Y);
      return [X, Y, Z];
    }
    addMetersToLngLat(lngLatZ, xyz) {
      return addMetersToLngLat(lngLatZ, xyz);
    }
    panByPosition(coords, pixel) {
      const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
      const toLocation = this.projectFlat(coords);
      const translate4 = add4([], toLocation, negate2([], fromLocation));
      const newCenter = add4([], this.center, translate4);
      const [longitude, latitude] = this.unprojectFlat(newCenter);
      return {
        longitude,
        latitude
      };
    }
    getBounds(options = {}) {
      const corners = getBounds(this, options.z || 0);
      return [Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]), Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])];
    }
    fitBounds(bounds, options = {}) {
      const {
        width,
        height
      } = this;
      const {
        longitude,
        latitude,
        zoom
      } = fitBounds({
        width,
        height,
        bounds,
        ...options
      });
      return new _WebMercatorViewport({
        width,
        height,
        longitude,
        latitude,
        zoom
      });
    }
  };
  var WebMercatorViewport2 = _WebMercatorViewport;
  __publicField(WebMercatorViewport2, "displayName", "WebMercatorViewport");

  // ../core/node_modules/gl-matrix/esm/vec3.js
  function create8() {
    var out = new ARRAY_TYPE2(3);
    if (ARRAY_TYPE2 != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function length5(a2) {
    var x2 = a2[0];
    var y2 = a2[1];
    var z = a2[2];
    return Math.hypot(x2, y2, z);
  }
  function subtract2(out, a2, b) {
    out[0] = a2[0] - b[0];
    out[1] = a2[1] - b[1];
    out[2] = a2[2] - b[2];
    return out;
  }
  function squaredLength3(a2) {
    var x2 = a2[0];
    var y2 = a2[1];
    var z = a2[2];
    return x2 * x2 + y2 * y2 + z * z;
  }
  function lerp6(out, a2, b, t2) {
    var ax = a2[0];
    var ay = a2[1];
    var az = a2[2];
    out[0] = ax + t2 * (b[0] - ax);
    out[1] = ay + t2 * (b[1] - ay);
    out[2] = az + t2 * (b[2] - az);
    return out;
  }
  var sub2 = subtract2;
  var len2 = length5;
  var sqrLen = squaredLength3;
  var forEach7 = function() {
    var vec = create8();
    return function(a2, stride, offset, count2, fn, arg) {
      var i3, l2;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l2 = Math.min(count2 * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i3 = offset; i3 < l2; i3 += stride) {
        vec[0] = a2[i3];
        vec[1] = a2[i3 + 1];
        vec[2] = a2[i3 + 2];
        fn(vec, vec, arg);
        a2[i3] = vec[0];
        a2[i3 + 1] = vec[1];
        a2[i3 + 2] = vec[2];
      }
      return a2;
    };
  }();

  // ../core/src/shaderlib/project/project-functions.ts
  var DEFAULT_COORDINATE_ORIGIN2 = [0, 0, 0];
  function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
    const p2 = viewport.projectPosition(lngLatZ);
    if (offsetMode && viewport instanceof WebMercatorViewport2) {
      const [longitude, latitude, z = 0] = lngLatZ;
      const distanceScales = viewport.getDistanceScales([longitude, latitude]);
      p2[2] = z * distanceScales.unitsPerMeter[2];
    }
    return p2;
  }
  function normalizeParameters(opts) {
    const {
      viewport,
      modelMatrix: modelMatrix2,
      coordinateOrigin
    } = opts;
    let {
      coordinateSystem,
      fromCoordinateSystem,
      fromCoordinateOrigin
    } = opts;
    if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
    }
    if (fromCoordinateSystem === void 0) {
      fromCoordinateSystem = coordinateSystem;
    }
    if (fromCoordinateOrigin === void 0) {
      fromCoordinateOrigin = coordinateOrigin;
    }
    return {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      modelMatrix: modelMatrix2,
      fromCoordinateSystem,
      fromCoordinateOrigin
    };
  }
  function getWorldPosition(position, {
    viewport,
    modelMatrix: modelMatrix2,
    coordinateSystem,
    coordinateOrigin,
    offsetMode
  }) {
    let [x2, y2, z = 0] = position;
    if (modelMatrix2) {
      [x2, y2, z] = transformMat44([], [x2, y2, z, 1], modelMatrix2);
    }
    switch (coordinateSystem) {
      case COORDINATE_SYSTEM.LNGLAT:
        return lngLatZToWorldPosition([x2, y2, z], viewport, offsetMode);
      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        return lngLatZToWorldPosition([x2 + coordinateOrigin[0], y2 + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);
      case COORDINATE_SYSTEM.METER_OFFSETS:
        return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x2, y2, z]), viewport, offsetMode);
      case COORDINATE_SYSTEM.CARTESIAN:
      default:
        return viewport.isGeospatial ? [x2 + coordinateOrigin[0], y2 + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x2, y2, z]);
    }
  }
  function projectPosition(position, params) {
    const {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      modelMatrix: modelMatrix2,
      fromCoordinateSystem,
      fromCoordinateOrigin
    } = normalizeParameters(params);
    const {
      autoOffset = true
    } = params;
    const {
      geospatialOrigin = DEFAULT_COORDINATE_ORIGIN2,
      shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN2,
      offsetMode = false
    } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};
    const worldPosition = getWorldPosition(position, {
      viewport,
      modelMatrix: modelMatrix2,
      coordinateSystem: fromCoordinateSystem,
      coordinateOrigin: fromCoordinateOrigin,
      offsetMode
    });
    if (offsetMode) {
      const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
      sub2(worldPosition, worldPosition, positionCommonSpace);
    }
    return worldPosition;
  }

  // ../core/src/effects/lighting/point-light.ts
  var DEFAULT_LIGHT_COLOR3 = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY3 = 1;
  var DEFAULT_ATTENUATION = [0, 0, 1];
  var DEFAULT_LIGHT_POSITION = [0, 0, 1];
  var idCount3 = 0;
  var PointLight = class {
    type = "point";
    constructor(props = {}) {
      const {
        color = DEFAULT_LIGHT_COLOR3
      } = props;
      const {
        intensity = DEFAULT_LIGHT_INTENSITY3
      } = props;
      const {
        position = DEFAULT_LIGHT_POSITION
      } = props;
      this.id = props.id || `point-${idCount3++}`;
      this.color = color;
      this.intensity = intensity;
      this.type = "point";
      this.position = position;
      this.attenuation = getAttenuation(props);
      this.projectedLight = {
        ...this
      };
    }
    getProjectedLight({
      layer
    }) {
      const {
        projectedLight
      } = this;
      const viewport = layer.context.viewport;
      const {
        coordinateSystem,
        coordinateOrigin
      } = layer.props;
      const position = projectPosition(this.position, {
        viewport,
        coordinateSystem,
        coordinateOrigin,
        fromCoordinateSystem: viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
        fromCoordinateOrigin: [0, 0, 0]
      });
      projectedLight.color = this.color;
      projectedLight.intensity = this.intensity;
      projectedLight.position = position;
      return projectedLight;
    }
  };
  function getAttenuation(props) {
    if (props.attenuation) {
      return props.attenuation;
    }
    if ("intensity" in props) {
      return [0, 0, props.intensity || 0];
    }
    return DEFAULT_ATTENUATION;
  }

  // ../core/src/effects/lighting/camera-light.ts
  var CameraLight = class extends PointLight {
    getProjectedLight({
      layer
    }) {
      const {
        projectedLight
      } = this;
      const viewport = layer.context.viewport;
      const {
        coordinateSystem,
        coordinateOrigin,
        modelMatrix: modelMatrix2
      } = layer.props;
      const {
        project_uCameraPosition
      } = getUniformsFromViewport({
        viewport,
        modelMatrix: modelMatrix2,
        coordinateSystem,
        coordinateOrigin
      });
      projectedLight.color = this.color;
      projectedLight.intensity = this.intensity;
      projectedLight.position = project_uCameraPosition;
      return projectedLight;
    }
  };

  // ../../node_modules/@math.gl/sun/dist/esm/suncalc.js
  var DEGREES_TO_RADIANS5 = Math.PI / 180;
  var DAY_IN_MS = 1e3 * 60 * 60 * 24;
  var JD1970 = 2440588;
  var JD2000 = 2451545;
  var e = DEGREES_TO_RADIANS5 * 23.4397;
  var M0 = 357.5291;
  var M1 = 0.98560028;
  var THETA0 = 280.147;
  var THETA1 = 360.9856235;
  function getSunPosition(timestamp, latitude, longitude) {
    const longitudeWestInRadians = DEGREES_TO_RADIANS5 * -longitude;
    const phi = DEGREES_TO_RADIANS5 * latitude;
    const d = toDays(timestamp);
    const c = getSunCoords(d);
    const H = getSiderealTime(d, longitudeWestInRadians) - c.rightAscension;
    return {
      azimuth: getAzimuth(H, phi, c.declination),
      altitude: getAltitude(H, phi, c.declination)
    };
  }
  function getSunDirection(timestamp, latitude, longitude) {
    const {
      azimuth,
      altitude
    } = getSunPosition(timestamp, latitude, longitude);
    return [Math.sin(azimuth) * Math.cos(altitude), Math.cos(azimuth) * Math.cos(altitude), -Math.sin(altitude)];
  }
  function toJulianDay(timestamp) {
    const ts = typeof timestamp === "number" ? timestamp : timestamp.getTime();
    return ts / DAY_IN_MS - 0.5 + JD1970;
  }
  function toDays(timestamp) {
    return toJulianDay(timestamp) - JD2000;
  }
  function getRightAscension(eclipticLongitude, b) {
    const lambda = eclipticLongitude;
    return Math.atan2(Math.sin(lambda) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(lambda));
  }
  function getDeclination(eclipticLongitude, b) {
    const lambda = eclipticLongitude;
    return Math.asin(Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(lambda));
  }
  function getAzimuth(hourAngle, latitudeInRadians, declination) {
    const H = hourAngle;
    const phi = latitudeInRadians;
    const delta = declination;
    return Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(delta) * Math.cos(phi));
  }
  function getAltitude(hourAngle, latitudeInRadians, declination) {
    const H = hourAngle;
    const phi = latitudeInRadians;
    const delta = declination;
    return Math.asin(Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(H));
  }
  function getSiderealTime(dates, longitudeWestInRadians) {
    return DEGREES_TO_RADIANS5 * (THETA0 + THETA1 * dates) - longitudeWestInRadians;
  }
  function getSolarMeanAnomaly(days) {
    return DEGREES_TO_RADIANS5 * (M0 + M1 * days);
  }
  function getEclipticLongitude(meanAnomaly) {
    const M = meanAnomaly;
    const C = DEGREES_TO_RADIANS5 * (1.9148 * Math.sin(M) + 0.02 * Math.sin(2 * M) + 3e-4 * Math.sin(3 * M));
    const P = DEGREES_TO_RADIANS5 * 102.9372;
    return M + C + P + Math.PI;
  }
  function getSunCoords(dates) {
    const M = getSolarMeanAnomaly(dates);
    const L = getEclipticLongitude(M);
    return {
      declination: getDeclination(L, 0),
      rightAscension: getRightAscension(L, 0)
    };
  }

  // ../core/src/effects/lighting/sun-light.ts
  var SunLight = class extends DirectionalLight {
    constructor(opts) {
      super(opts);
      this.timestamp = opts.timestamp;
    }
    getProjectedLight({
      layer
    }) {
      const {
        viewport
      } = layer.context;
      const isGlobe = viewport.resolution && viewport.resolution > 0;
      if (isGlobe) {
        const [x2, y2, z] = getSunDirection(this.timestamp, 0, 0);
        this.direction = [x2, -z, y2];
      } else {
        const {
          latitude,
          longitude
        } = viewport;
        this.direction = getSunDirection(this.timestamp, latitude, longitude);
      }
      return this;
    }
  };

  // ../core/src/passes/screen-pass.ts
  var ScreenPass = class extends Pass {
    constructor(gl, props) {
      super(gl, props);
      const {
        module: module2,
        fs: fs8,
        id
      } = props;
      this.model = new ClipSpace(gl, {
        id,
        fs: fs8,
        modules: [module2]
      });
    }
    render(params) {
      const gl = this.gl;
      setParameters(gl, {
        viewport: [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]
      });
      withParameters(gl, {
        framebuffer: params.outputBuffer,
        clearColor: [0, 0, 0, 0]
      }, () => this._renderPass(gl, params));
    }
    delete() {
      this.model.delete();
      this.model = null;
    }
    _renderPass(gl, options) {
      const {
        inputBuffer
      } = options;
      clear(gl, {
        color: true
      });
      this.model.draw({
        moduleSettings: options.moduleSettings,
        uniforms: {
          texture: inputBuffer,
          texSize: [inputBuffer.width, inputBuffer.height]
        },
        parameters: {
          depthWrite: false,
          depthTest: false
        }
      });
    }
  };

  // ../core/src/effects/post-process-effect.ts
  var PostProcessEffect = class {
    constructor(module2, props = {}) {
      this.id = `${module2.name}-pass`;
      this.props = props;
      normalizeShaderModule(module2);
      this.module = module2;
    }
    setProps(props) {
      this.props = props;
    }
    preRender() {
    }
    postRender(gl, params) {
      const passes = this.passes || createPasses(gl, this.module, this.id);
      this.passes = passes;
      const {
        target
      } = params;
      let inputBuffer = params.inputBuffer;
      let outputBuffer = params.swapBuffer;
      for (let index = 0; index < this.passes.length; index++) {
        if (target && index === this.passes.length - 1) {
          outputBuffer = target;
        }
        this.passes[index].render({
          inputBuffer,
          outputBuffer,
          moduleSettings: this.props
        });
        const switchBuffer = outputBuffer;
        outputBuffer = inputBuffer;
        inputBuffer = switchBuffer;
      }
      return inputBuffer;
    }
    cleanup() {
      if (this.passes) {
        for (const pass of this.passes) {
          pass.delete();
        }
        this.passes = void 0;
      }
    }
  };
  function createPasses(gl, module2, id) {
    if (!module2.passes) {
      const fs8 = getFragmentShaderForRenderPass(module2);
      const pass = new ScreenPass(gl, {
        id,
        module: module2,
        fs: fs8
      });
      return [pass];
    }
    return module2.passes.map((pass, index) => {
      const fs8 = getFragmentShaderForRenderPass(module2, pass);
      const idn = `${id}-${index}`;
      return new ScreenPass(gl, {
        id: idn,
        module: module2,
        fs: fs8
      });
    });
  }
  var FILTER_FS_TEMPLATE = (func) => `uniform sampler2D texture;
uniform vec2 texSize;

varying vec2 position;
varying vec2 coordinate;
varying vec2 uv;

void main() {
  vec2 texCoord = coordinate;

  gl_FragColor = texture2D(texture, texCoord);
  gl_FragColor = ${func}(gl_FragColor, texSize, texCoord);
}
`;
  var SAMPLER_FS_TEMPLATE = (func) => `uniform sampler2D texture;
uniform vec2 texSize;

varying vec2 position;
varying vec2 coordinate;
varying vec2 uv;

void main() {
  vec2 texCoord = coordinate;

  gl_FragColor = ${func}(texture, texSize, texCoord);
}
`;
  function getFragmentShaderForRenderPass(module2, pass = module2) {
    if (pass.filter) {
      const func = typeof pass.filter === "string" ? pass.filter : `${module2.name}_filterColor`;
      return FILTER_FS_TEMPLATE(func);
    }
    if (pass.sampler) {
      const func = typeof pass.sampler === "string" ? pass.sampler : `${module2.name}_sampleColor`;
      return SAMPLER_FS_TEMPLATE(func);
    }
    return null;
  }

  // ../core/src/passes/pick-layers-pass.ts
  var PICKING_PARAMETERS = {
    blendFunc: [esm_default2.ONE, esm_default2.ZERO, esm_default2.CONSTANT_ALPHA, esm_default2.ZERO],
    blendEquation: esm_default2.FUNC_ADD
  };
  var PickLayersPass = class extends LayersPass {
    _colorEncoderState = null;
    render(props) {
      if ("pickingFBO" in props) {
        return this._drawPickingBuffer(props);
      }
      return super.render(props);
    }
    _drawPickingBuffer({
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect: {
        x: x2,
        y: y2,
        width,
        height
      },
      cullRect,
      effects,
      pass = "picking",
      pickZ,
      moduleParameters
    }) {
      const gl = this.gl;
      this.pickZ = pickZ;
      const colorEncoderState = this._resetColorEncoder(pickZ);
      const renderStatus = withParameters(gl, {
        scissorTest: true,
        scissor: [x2, y2, width, height],
        clearColor: [0, 0, 0, 0],
        depthMask: true,
        depthTest: true,
        depthRange: [0, 1],
        colorMask: [true, true, true, true],
        ...PICKING_PARAMETERS,
        blend: !pickZ
      }, () => super.render({
        target: pickingFBO,
        layers,
        layerFilter,
        views,
        viewports,
        onViewportActive,
        cullRect,
        effects: effects?.filter((e2) => e2.useInPicking),
        pass,
        isPicking: true,
        moduleParameters
      }));
      this._colorEncoderState = null;
      const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);
      return {
        decodePickingColor,
        stats: renderStatus
      };
    }
    shouldDrawLayer(layer) {
      const {
        pickable,
        operation
      } = layer.props;
      return pickable && operation.includes("draw") || operation.includes("terrain");
    }
    getModuleParameters() {
      return {
        pickingActive: 1,
        pickingAttribute: this.pickZ,
        lightSources: {}
      };
    }
    getLayerParameters(layer, layerIndex, viewport) {
      const pickParameters = {
        ...layer.props.parameters
      };
      const {
        pickable,
        operation
      } = layer.props;
      if (!this._colorEncoderState) {
        pickParameters.blend = false;
      } else if (pickable && operation.includes("draw")) {
        Object.assign(pickParameters, PICKING_PARAMETERS);
        pickParameters.blend = true;
        pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
      }
      if (operation.includes("terrain")) {
        pickParameters.blend = false;
      }
      return pickParameters;
    }
    _resetColorEncoder(pickZ) {
      this._colorEncoderState = pickZ ? null : {
        byLayer: /* @__PURE__ */ new Map(),
        byAlpha: []
      };
      return this._colorEncoderState;
    }
  };
  function encodeColor(encoded, layer, viewport) {
    const {
      byLayer,
      byAlpha
    } = encoded;
    let a2;
    let entry = byLayer.get(layer);
    if (entry) {
      entry.viewports.push(viewport);
      a2 = entry.a;
    } else {
      a2 = byLayer.size + 1;
      if (a2 <= 255) {
        entry = {
          a: a2,
          layer,
          viewports: [viewport]
        };
        byLayer.set(layer, entry);
        byAlpha[a2] = entry;
      } else {
        log_default.warn("Too many pickable layers, only picking the first 255")();
        a2 = 0;
      }
    }
    return [0, 0, 0, a2 / 255];
  }
  function decodeColor(encoded, pickedColor) {
    const entry = encoded.byAlpha[pickedColor[3]];
    return entry && {
      pickedLayer: entry.layer,
      pickedViewports: entry.viewports,
      pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
    };
  }

  // ../core/src/lifecycle/constants.ts
  var LIFECYCLE = {
    NO_STATE: "Awaiting state",
    MATCHED: "Matched. State transferred from previous layer",
    INITIALIZED: "Initialized",
    AWAITING_GC: "Discarded. Awaiting garbage collection",
    AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
    FINALIZED: "Finalized! Awaiting garbage collection"
  };
  var COMPONENT_SYMBOL = Symbol.for("component");
  var PROP_TYPES_SYMBOL = Symbol.for("propTypes");
  var DEPRECATED_PROPS_SYMBOL = Symbol.for("deprecatedProps");
  var ASYNC_DEFAULTS_SYMBOL = Symbol.for("asyncPropDefaults");
  var ASYNC_ORIGINAL_SYMBOL = Symbol.for("asyncPropOriginal");
  var ASYNC_RESOLVED_SYMBOL = Symbol.for("asyncPropResolved");

  // ../core/src/utils/flatten.ts
  function flatten(array, filter = () => true) {
    if (!Array.isArray(array)) {
      return filter(array) ? [array] : [];
    }
    return flattenArray(array, filter, []);
  }
  function flattenArray(array, filter, result) {
    let index = -1;
    while (++index < array.length) {
      const value = array[index];
      if (Array.isArray(value)) {
        flattenArray(value, filter, result);
      } else if (filter(value)) {
        result.push(value);
      }
    }
    return result;
  }
  function fillArray2({
    target,
    source,
    start = 0,
    count: count2 = 1
  }) {
    const length7 = source.length;
    const total = count2 * length7;
    let copied = 0;
    for (let i3 = start; copied < length7; copied++) {
      target[i3++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target.copyWithin(start + copied, start, start + copied);
        copied *= 2;
      } else {
        target.copyWithin(start + copied, start, start + total - copied);
        copied = total;
      }
    }
    return target;
  }

  // ../core/src/lib/resource/resource.ts
  var Resource2 = class {
    _loadCount = 0;
    _subscribers = /* @__PURE__ */ new Set();
    constructor(id, data, context) {
      this.id = id;
      this.context = context;
      this.setData(data);
    }
    subscribe(consumer) {
      this._subscribers.add(consumer);
    }
    unsubscribe(consumer) {
      this._subscribers.delete(consumer);
    }
    inUse() {
      return this._subscribers.size > 0;
    }
    delete() {
    }
    getData() {
      return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
    }
    setData(data, forceUpdate) {
      if (data === this._data && !forceUpdate) {
        return;
      }
      this._data = data;
      const loadCount = ++this._loadCount;
      let loader = data;
      if (typeof data === "string") {
        loader = load(data);
      }
      if (loader instanceof Promise) {
        this.isLoaded = false;
        this._loader = loader.then((result) => {
          if (this._loadCount === loadCount) {
            this.isLoaded = true;
            this._error = void 0;
            this._content = result;
          }
        }).catch((error2) => {
          if (this._loadCount === loadCount) {
            this.isLoaded = true;
            this._error = error2 || true;
          }
        });
      } else {
        this.isLoaded = true;
        this._error = void 0;
        this._content = data;
      }
      for (const subscriber of this._subscribers) {
        subscriber.onChange(this.getData());
      }
    }
  };

  // ../core/src/lib/resource/resource-manager.ts
  var ResourceManager = class {
    constructor({
      gl,
      protocol
    }) {
      this.protocol = protocol || "resource://";
      this._context = {
        gl,
        resourceManager: this
      };
      this._resources = {};
      this._consumers = {};
      this._pruneRequest = null;
    }
    contains(resourceId) {
      if (resourceId.startsWith(this.protocol)) {
        return true;
      }
      return resourceId in this._resources;
    }
    add({
      resourceId,
      data,
      forceUpdate = false,
      persistent = true
    }) {
      let res = this._resources[resourceId];
      if (res) {
        res.setData(data, forceUpdate);
      } else {
        res = new Resource2(resourceId, data, this._context);
        this._resources[resourceId] = res;
      }
      res.persistent = persistent;
    }
    remove(resourceId) {
      const res = this._resources[resourceId];
      if (res) {
        res.delete();
        delete this._resources[resourceId];
      }
    }
    unsubscribe({
      consumerId
    }) {
      const consumer = this._consumers[consumerId];
      if (consumer) {
        for (const requestId in consumer) {
          const request = consumer[requestId];
          const resource = this._resources[request.resourceId];
          if (resource) {
            resource.unsubscribe(request);
          }
        }
        delete this._consumers[consumerId];
        this.prune();
      }
    }
    subscribe({
      resourceId,
      onChange,
      consumerId,
      requestId = "default"
    }) {
      const {
        _resources: resources,
        protocol
      } = this;
      if (resourceId.startsWith(protocol)) {
        resourceId = resourceId.replace(protocol, "");
        if (!resources[resourceId]) {
          this.add({
            resourceId,
            data: null,
            persistent: false
          });
        }
      }
      const res = resources[resourceId];
      this._track(consumerId, requestId, res, onChange);
      if (res) {
        return res.getData();
      }
      return void 0;
    }
    prune() {
      if (!this._pruneRequest) {
        this._pruneRequest = setTimeout(() => this._prune(), 0);
      }
    }
    finalize() {
      for (const key in this._resources) {
        this._resources[key].delete();
      }
    }
    _track(consumerId, requestId, resource, onChange) {
      const consumers = this._consumers;
      const consumer = consumers[consumerId] = consumers[consumerId] || {};
      const request = consumer[requestId] || {};
      const oldResource = request.resourceId && this._resources[request.resourceId];
      if (oldResource) {
        oldResource.unsubscribe(request);
        this.prune();
      }
      if (resource) {
        consumer[requestId] = request;
        request.onChange = onChange;
        request.resourceId = resource.id;
        resource.subscribe(request);
      }
    }
    _prune() {
      this._pruneRequest = null;
      for (const key of Object.keys(this._resources)) {
        const res = this._resources[key];
        if (!res.persistent && !res.inUse()) {
          res.delete();
          delete this._resources[key];
        }
      }
    }
  };

  // ../core/src/shaderlib/project32/project32.ts
  var vs5 = `
vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`;
  var project32_default = {
    name: "project32",
    dependencies: [project_default],
    vs: vs5
  };

  // ../core/src/shaderlib/picking/picking.ts
  var picking_default = {
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
      "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
      "fs:#decl": `
uniform bool picking_uAttribute;
  `,
      "fs:DECKGL_FILTER_COLOR": {
        order: 99,
        injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
      }
    },
    ...picking
  };

  // ../core/src/shaderlib/index.ts
  var DEFAULT_MODULES = [project_default];
  var SHADER_HOOKS = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
  function createProgramManager(gl) {
    const programManager = ProgramManager.getDefaultProgramManager(gl);
    for (const shaderModule2 of DEFAULT_MODULES) {
      programManager.addDefaultModule(shaderModule2);
    }
    for (const shaderHook of SHADER_HOOKS) {
      programManager.addShaderHook(shaderHook);
    }
    return programManager;
  }

  // ../core/src/lib/layer-manager.ts
  var TRACE_SET_LAYERS = "layerManager.setLayers";
  var TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
  var LayerManager = class {
    _lastRenderedLayers = [];
    _needsRedraw = false;
    _needsUpdate = false;
    _nextLayers = null;
    _debug = false;
    constructor(gl, {
      deck,
      stats,
      viewport,
      timeline
    } = {}) {
      this.layers = [];
      this.resourceManager = new ResourceManager({
        gl,
        protocol: "deck://"
      });
      this.context = {
        mousePosition: null,
        userData: {},
        layerManager: this,
        gl,
        deck,
        programManager: gl && createProgramManager(gl),
        stats: stats || new Stats2({
          id: "deck.gl"
        }),
        viewport: viewport || new Viewport({
          id: "DEFAULT-INITIAL-VIEWPORT"
        }),
        timeline: timeline || new Timeline(),
        resourceManager: this.resourceManager,
        onError: void 0
      };
      Object.seal(this);
    }
    finalize() {
      this.resourceManager.finalize();
      for (const layer of this.layers) {
        this._finalizeLayer(layer);
      }
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      let redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      for (const layer of this.layers) {
        const layerNeedsRedraw = layer.getNeedsRedraw(opts);
        redraw = redraw || layerNeedsRedraw;
      }
      return redraw;
    }
    needsUpdate() {
      if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {
        return "layers changed";
      }
      return this._needsUpdate;
    }
    setNeedsRedraw(reason) {
      this._needsRedraw = this._needsRedraw || reason;
    }
    setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
    }
    getLayers({
      layerIds
    } = {}) {
      return layerIds ? this.layers.filter((layer) => layerIds.find((layerId) => layer.id.indexOf(layerId) === 0)) : this.layers;
    }
    setProps(props) {
      if ("debug" in props) {
        this._debug = props.debug;
      }
      if ("userData" in props) {
        this.context.userData = props.userData;
      }
      if ("layers" in props) {
        this._nextLayers = props.layers;
      }
      if ("onError" in props) {
        this.context.onError = props.onError;
      }
    }
    setLayers(newLayers, reason) {
      debug(TRACE_SET_LAYERS, this, reason, newLayers);
      this._lastRenderedLayers = newLayers;
      const flatLayers = flatten(newLayers, Boolean);
      for (const layer of flatLayers) {
        layer.context = this.context;
      }
      this._updateLayers(this.layers, flatLayers);
    }
    updateLayers() {
      const reason = this.needsUpdate();
      if (reason) {
        this.setNeedsRedraw(`updating layers: ${reason}`);
        this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
      }
      this._nextLayers = null;
    }
    activateViewport = (viewport) => {
      debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);
      if (viewport) {
        this.context.viewport = viewport;
      }
    };
    _handleError(stage, error2, layer) {
      layer.raiseError(error2, `${stage} of ${layer}`);
    }
    _updateLayers(oldLayers, newLayers) {
      const oldLayerMap = {};
      for (const oldLayer of oldLayers) {
        if (oldLayerMap[oldLayer.id]) {
          log_default.warn(`Multiple old layers with same id ${oldLayer.id}`)();
        } else {
          oldLayerMap[oldLayer.id] = oldLayer;
        }
      }
      const generatedLayers = [];
      this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
      this._finalizeOldLayers(oldLayerMap);
      let needsUpdate = false;
      for (const layer of generatedLayers) {
        if (layer.hasUniformTransition()) {
          needsUpdate = `Uniform transition in ${layer}`;
          break;
        }
      }
      this._needsUpdate = needsUpdate;
      this.layers = generatedLayers;
    }
    _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
      for (const newLayer of newLayers) {
        newLayer.context = this.context;
        const oldLayer = oldLayerMap[newLayer.id];
        if (oldLayer === null) {
          log_default.warn(`Multiple new layers with same id ${newLayer.id}`)();
        }
        oldLayerMap[newLayer.id] = null;
        let sublayers = null;
        try {
          if (this._debug && oldLayer !== newLayer) {
            newLayer.validateProps();
          }
          if (!oldLayer) {
            this._initializeLayer(newLayer);
          } else {
            this._transferLayerState(oldLayer, newLayer);
            this._updateLayer(newLayer);
          }
          generatedLayers.push(newLayer);
          sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
        } catch (err) {
          this._handleError("matching", err, newLayer);
        }
        if (sublayers) {
          this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
        }
      }
    }
    _finalizeOldLayers(oldLayerMap) {
      for (const layerId in oldLayerMap) {
        const layer = oldLayerMap[layerId];
        if (layer) {
          this._finalizeLayer(layer);
        }
      }
    }
    _initializeLayer(layer) {
      try {
        layer._initialize();
        layer.lifecycle = LIFECYCLE.INITIALIZED;
      } catch (err) {
        this._handleError("initialization", err, layer);
      }
    }
    _transferLayerState(oldLayer, newLayer) {
      newLayer._transferState(oldLayer);
      newLayer.lifecycle = LIFECYCLE.MATCHED;
      if (newLayer !== oldLayer) {
        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
      }
    }
    _updateLayer(layer) {
      try {
        layer._update();
      } catch (err) {
        this._handleError("update", err, layer);
      }
    }
    _finalizeLayer(layer) {
      this._needsRedraw = this._needsRedraw || `finalized ${layer}`;
      layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
      try {
        layer._finalize();
        layer.lifecycle = LIFECYCLE.FINALIZED;
      } catch (err) {
        this._handleError("finalization", err, layer);
      }
    }
  };

  // ../core/src/utils/deep-equal.ts
  function deepEqual(a2, b, depth) {
    if (a2 === b) {
      return true;
    }
    if (!depth || !a2 || !b) {
      return false;
    }
    if (Array.isArray(a2)) {
      if (!Array.isArray(b) || a2.length !== b.length) {
        return false;
      }
      for (let i3 = 0; i3 < a2.length; i3++) {
        if (!deepEqual(a2[i3], b[i3], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    if (Array.isArray(b)) {
      return false;
    }
    if (typeof a2 === "object" && typeof b === "object") {
      const aKeys = Object.keys(a2);
      const bKeys = Object.keys(b);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      for (const key of aKeys) {
        if (!b.hasOwnProperty(key)) {
          return false;
        }
        if (!deepEqual(a2[key], b[key], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../core/src/lib/view-manager.ts
  var ViewManager = class {
    constructor(props) {
      this.views = [];
      this.width = 100;
      this.height = 100;
      this.viewState = {};
      this.controllers = {};
      this.timeline = props.timeline;
      this._viewports = [];
      this._viewportMap = {};
      this._isUpdating = false;
      this._needsRedraw = "First render";
      this._needsUpdate = "Initialize";
      this._eventManager = props.eventManager;
      this._eventCallbacks = {
        onViewStateChange: props.onViewStateChange,
        onInteractionStateChange: props.onInteractionStateChange
      };
      Object.seal(this);
      this.setProps(props);
    }
    finalize() {
      for (const key in this.controllers) {
        const controller = this.controllers[key];
        if (controller) {
          controller.finalize();
        }
      }
      this.controllers = {};
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
      this._needsRedraw = this._needsRedraw || reason;
    }
    updateViewStates() {
      for (const viewId in this.controllers) {
        const controller = this.controllers[viewId];
        if (controller) {
          controller.updateTransition();
        }
      }
    }
    getViewports(rect) {
      if (rect) {
        return this._viewports.filter((viewport) => viewport.containsPixel(rect));
      }
      return this._viewports;
    }
    getViews() {
      const viewMap = {};
      this.views.forEach((view) => {
        viewMap[view.id] = view;
      });
      return viewMap;
    }
    getView(viewId) {
      return this.views.find((view) => view.id === viewId);
    }
    getViewState(viewOrViewId) {
      const view = typeof viewOrViewId === "string" ? this.getView(viewOrViewId) : viewOrViewId;
      const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
      return view ? view.filterViewState(viewState) : viewState;
    }
    getViewport(viewId) {
      return this._viewportMap[viewId];
    }
    unproject(xyz, opts) {
      const viewports = this.getViewports();
      const pixel = {
        x: xyz[0],
        y: xyz[1]
      };
      for (let i3 = viewports.length - 1; i3 >= 0; --i3) {
        const viewport = viewports[i3];
        if (viewport.containsPixel(pixel)) {
          const p2 = xyz.slice();
          p2[0] -= viewport.x;
          p2[1] -= viewport.y;
          return viewport.unproject(p2, opts);
        }
      }
      return null;
    }
    setProps(props) {
      if (props.views) {
        this._setViews(props.views);
      }
      if (props.viewState) {
        this._setViewState(props.viewState);
      }
      if ("width" in props || "height" in props) {
        this._setSize(props.width, props.height);
      }
      if (!this._isUpdating) {
        this._update();
      }
    }
    _update() {
      this._isUpdating = true;
      if (this._needsUpdate) {
        this._needsUpdate = false;
        this._rebuildViewports();
      }
      if (this._needsUpdate) {
        this._needsUpdate = false;
        this._rebuildViewports();
      }
      this._isUpdating = false;
    }
    _setSize(width, height) {
      if (width !== this.width || height !== this.height) {
        this.width = width;
        this.height = height;
        this.setNeedsUpdate("Size changed");
      }
    }
    _setViews(views) {
      views = flatten(views, Boolean);
      const viewsChanged = this._diffViews(views, this.views);
      if (viewsChanged) {
        this.setNeedsUpdate("views changed");
      }
      this.views = views;
    }
    _setViewState(viewState) {
      if (viewState) {
        const viewStateChanged = !deepEqual(viewState, this.viewState, 3);
        if (viewStateChanged) {
          this.setNeedsUpdate("viewState changed");
        }
        this.viewState = viewState;
      } else {
        log_default.warn("missing `viewState` or `initialViewState`")();
      }
    }
    _onViewStateChange(viewId, event) {
      if (this._eventCallbacks.onViewStateChange) {
        this._eventCallbacks.onViewStateChange({
          ...event,
          viewId
        });
      }
    }
    _createController(view, props) {
      const Controller2 = props.type;
      const controller = new Controller2({
        timeline: this.timeline,
        eventManager: this._eventManager,
        onViewStateChange: this._onViewStateChange.bind(this, props.id),
        onStateChange: this._eventCallbacks.onInteractionStateChange,
        makeViewport: (viewState) => this.getView(view.id)?.makeViewport({
          viewState,
          width: this.width,
          height: this.height
        })
      });
      return controller;
    }
    _updateController(view, viewState, viewport, controller) {
      const controllerProps = view.controller;
      if (controllerProps && viewport) {
        const resolvedProps = {
          ...viewState,
          ...controllerProps,
          id: view.id,
          x: viewport.x,
          y: viewport.y,
          width: viewport.width,
          height: viewport.height
        };
        if (!controller || controller.constructor !== view.ControllerType) {
          controller = this._createController(view, resolvedProps);
        }
        if (controller) {
          controller.setProps(resolvedProps);
        }
        return controller;
      }
      return null;
    }
    _rebuildViewports() {
      const {
        views
      } = this;
      const oldControllers = this.controllers;
      this._viewports = [];
      this.controllers = {};
      let invalidateControllers = false;
      for (let i3 = views.length; i3--; ) {
        const view = views[i3];
        const viewState = this.getViewState(view);
        const viewport = view.makeViewport({
          viewState,
          width: this.width,
          height: this.height
        });
        let oldController = oldControllers[view.id];
        const hasController = Boolean(view.controller);
        if (hasController && !oldController) {
          invalidateControllers = true;
        }
        if ((invalidateControllers || !hasController) && oldController) {
          oldController.finalize();
          oldController = null;
        }
        this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
        if (viewport) {
          this._viewports.unshift(viewport);
        }
      }
      for (const id in oldControllers) {
        const oldController = oldControllers[id];
        if (oldController && !this.controllers[id]) {
          oldController.finalize();
        }
      }
      this._buildViewportMap();
    }
    _buildViewportMap() {
      this._viewportMap = {};
      this._viewports.forEach((viewport) => {
        if (viewport.id) {
          this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
        }
      });
    }
    _diffViews(newViews, oldViews) {
      if (newViews.length !== oldViews.length) {
        return true;
      }
      return newViews.some((_, i3) => !newViews[i3].equals(oldViews[i3]));
    }
  };

  // ../core/src/utils/positions.ts
  var PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
  function parsePosition(value) {
    switch (typeof value) {
      case "number":
        return {
          position: value,
          relative: false
        };
      case "string":
        const match = PERCENT_OR_PIXELS_REGEX.exec(value);
        if (match && match.length >= 3) {
          const relative = match[2] === "%";
          const position = parseFloat(match[1]);
          return {
            position: relative ? position / 100 : position,
            relative
          };
        }
      default:
        throw new Error(`Could not parse position string ${value}`);
    }
  }
  function getPosition(position, extent) {
    return position.relative ? Math.round(position.position * extent) : position.position;
  }

  // ../core/src/utils/assert.ts
  function assert11(condition, message) {
    if (!condition) {
      throw new Error(message || "deck.gl: assertion failed.");
    }
  }

  // ../core/src/views/view.ts
  var View = class {
    constructor(props) {
      const {
        id,
        x: x2 = 0,
        y: y2 = 0,
        width = "100%",
        height = "100%",
        padding = null,
        viewportInstance
      } = props || {};
      assert11(!viewportInstance || viewportInstance instanceof Viewport);
      this.viewportInstance = viewportInstance;
      this.id = id || this.constructor.displayName || "view";
      this.props = {
        ...props,
        id: this.id
      };
      this._x = parsePosition(x2);
      this._y = parsePosition(y2);
      this._width = parsePosition(width);
      this._height = parsePosition(height);
      this._padding = padding && {
        left: parsePosition(padding.left || 0),
        right: parsePosition(padding.right || 0),
        top: parsePosition(padding.top || 0),
        bottom: parsePosition(padding.bottom || 0)
      };
      this.equals = this.equals.bind(this);
      Object.seal(this);
    }
    equals(view) {
      if (this === view) {
        return true;
      }
      if (this.viewportInstance) {
        return view.viewportInstance ? this.viewportInstance.equals(view.viewportInstance) : false;
      }
      return this.ViewportType === view.ViewportType && deepEqual(this.props, view.props, 2);
    }
    makeViewport({
      width,
      height,
      viewState
    }) {
      if (this.viewportInstance) {
        return this.viewportInstance;
      }
      viewState = this.filterViewState(viewState);
      const viewportDimensions = this.getDimensions({
        width,
        height
      });
      if (!viewportDimensions.height || !viewportDimensions.width) {
        return null;
      }
      return new this.ViewportType({
        ...viewState,
        ...this.props,
        ...viewportDimensions
      });
    }
    getViewStateId() {
      const {
        viewState
      } = this.props;
      if (typeof viewState === "string") {
        return viewState;
      }
      return viewState?.id || this.id;
    }
    filterViewState(viewState) {
      if (this.props.viewState && typeof this.props.viewState === "object") {
        if (!this.props.viewState.id) {
          return this.props.viewState;
        }
        const newViewState = {
          ...viewState
        };
        for (const key in this.props.viewState) {
          if (key !== "id") {
            newViewState[key] = this.props.viewState[key];
          }
        }
        return newViewState;
      }
      return viewState;
    }
    getDimensions({
      width,
      height
    }) {
      const dimensions = {
        x: getPosition(this._x, width),
        y: getPosition(this._y, height),
        width: getPosition(this._width, width),
        height: getPosition(this._height, height)
      };
      if (this._padding) {
        dimensions.padding = {
          left: getPosition(this._padding.left, width),
          top: getPosition(this._padding.top, height),
          right: getPosition(this._padding.right, width),
          bottom: getPosition(this._padding.bottom, height)
        };
      }
      return dimensions;
    }
    get controller() {
      const opts = this.props.controller;
      if (!opts) {
        return null;
      }
      if (opts === true) {
        return {
          type: this.ControllerType
        };
      }
      if (typeof opts === "function") {
        return {
          type: opts
        };
      }
      return {
        type: this.ControllerType,
        ...opts
      };
    }
  };

  // ../core/src/transitions/transition.ts
  var Transition = class {
    constructor(timeline) {
      this._inProgress = false;
      this._handle = null;
      this._timeline = timeline;
      this.time = 0;
      this.settings = {
        duration: 0
      };
    }
    get inProgress() {
      return this._inProgress;
    }
    start(settings) {
      this.cancel();
      this.settings = settings;
      this._inProgress = true;
      this.settings.onStart?.(this);
    }
    end() {
      if (this._inProgress) {
        this._timeline.removeChannel(this._handle);
        this._handle = null;
        this._inProgress = false;
        this.settings.onEnd?.(this);
      }
    }
    cancel() {
      if (this._inProgress) {
        this.settings.onInterrupt?.(this);
        this._timeline.removeChannel(this._handle);
        this._handle = null;
        this._inProgress = false;
      }
    }
    update() {
      if (!this._inProgress) {
        return false;
      }
      if (this._handle === null) {
        const {
          _timeline: timeline,
          settings
        } = this;
        this._handle = timeline.addChannel({
          delay: timeline.getTime(),
          duration: settings.duration
        });
      }
      this.time = this._timeline.getTime(this._handle);
      this._onUpdate();
      this.settings.onUpdate?.(this);
      if (this._timeline.isFinished(this._handle)) {
        this.end();
      }
      return true;
    }
    _onUpdate() {
    }
  };

  // ../core/src/controllers/transition-manager.ts
  var noop3 = () => {
  };
  var TRANSITION_EVENTS = {
    BREAK: 1,
    SNAP_TO_END: 2,
    IGNORE: 3
  };
  var DEFAULT_EASING = (t2) => t2;
  var DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
  var TransitionManager = class {
    constructor(opts) {
      this.getControllerState = opts.getControllerState;
      this.propsInTransition = null;
      this.transition = new Transition(opts.timeline);
      this.onViewStateChange = opts.onViewStateChange || noop3;
      this.onStateChange = opts.onStateChange || noop3;
    }
    finalize() {
      this.transition.cancel();
    }
    getViewportInTransition() {
      return this.propsInTransition;
    }
    processViewStateChange(nextProps) {
      let transitionTriggered = false;
      const currentProps = this.props;
      this.props = nextProps;
      if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
        return false;
      }
      if (this._isTransitionEnabled(nextProps)) {
        let startProps = currentProps;
        if (this.transition.inProgress) {
          const {
            interruption,
            endProps
          } = this.transition.settings;
          startProps = {
            ...currentProps,
            ...interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps
          };
        }
        this._triggerTransition(startProps, nextProps);
        transitionTriggered = true;
      } else {
        this.transition.cancel();
      }
      return transitionTriggered;
    }
    updateTransition() {
      this.transition.update();
    }
    _isTransitionEnabled(props) {
      const {
        transitionDuration,
        transitionInterpolator
      } = props;
      return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
    }
    _isUpdateDueToCurrentTransition(props) {
      if (this.transition.inProgress && this.propsInTransition) {
        return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
      }
      return false;
    }
    _shouldIgnoreViewportChange(currentProps, nextProps) {
      if (this.transition.inProgress) {
        return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
      }
      if (this._isTransitionEnabled(nextProps)) {
        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
      }
      return true;
    }
    _triggerTransition(startProps, endProps) {
      const startViewstate = this.getControllerState(startProps);
      const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
      const transitionInterpolator = endProps.transitionInterpolator;
      const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
      if (duration === 0) {
        return;
      }
      const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
      this.propsInTransition = {};
      const transitionSettings = {
        duration,
        easing: endProps.transitionEasing || DEFAULT_EASING,
        interpolator: transitionInterpolator,
        interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
        startProps: initialProps.start,
        endProps: initialProps.end,
        onStart: endProps.onTransitionStart,
        onUpdate: this._onTransitionUpdate,
        onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
        onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
      };
      this.transition.start(transitionSettings);
      this.onStateChange({
        inTransition: true
      });
      this.updateTransition();
    }
    _onTransitionEnd(callback) {
      return (transition) => {
        this.propsInTransition = null;
        this.onStateChange({
          inTransition: false,
          isZooming: false,
          isPanning: false,
          isRotating: false
        });
        callback?.(transition);
      };
    }
    _onTransitionUpdate = (transition) => {
      const {
        time,
        settings: {
          interpolator,
          startProps,
          endProps,
          duration,
          easing
        }
      } = transition;
      const t2 = easing(time / duration);
      const viewport = interpolator.interpolateProps(startProps, endProps, t2);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...viewport
      }).getViewportProps();
      this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    };
  };

  // ../core/src/transitions/transition-interpolator.ts
  var TransitionInterpolator = class {
    constructor(opts) {
      const {
        compare: compare2,
        extract,
        required
      } = opts;
      this._propsToCompare = compare2;
      this._propsToExtract = extract || compare2;
      this._requiredProps = required;
    }
    arePropsEqual(currentProps, nextProps) {
      for (const key of this._propsToCompare) {
        if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {
          return false;
        }
      }
      return true;
    }
    initializeProps(startProps, endProps) {
      const startViewStateProps = {};
      const endViewStateProps = {};
      for (const key of this._propsToExtract) {
        if (key in startProps || key in endProps) {
          startViewStateProps[key] = startProps[key];
          endViewStateProps[key] = endProps[key];
        }
      }
      this._checkRequiredProps(startViewStateProps);
      this._checkRequiredProps(endViewStateProps);
      return {
        start: startViewStateProps,
        end: endViewStateProps
      };
    }
    getDuration(startProps, endProps) {
      return endProps.transitionDuration;
    }
    _checkRequiredProps(props) {
      if (!this._requiredProps) {
        return;
      }
      this._requiredProps.forEach((propName) => {
        const value = props[propName];
        assert11(Number.isFinite(value) || Array.isArray(value), `${propName} is required for transition`);
      });
    }
  };

  // ../core/src/transitions/linear-interpolator.ts
  var DEFAULT_PROPS3 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
  var DEFAULT_REQUIRED_PROPS = ["longitude", "latitude", "zoom"];
  var LinearInterpolator = class extends TransitionInterpolator {
    constructor(opts = {}) {
      const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
      const normalizedOpts = Array.isArray(opts) ? {} : opts;
      normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
        compare: transitionProps,
        required: transitionProps
      } : transitionProps || {
        compare: DEFAULT_PROPS3,
        required: DEFAULT_REQUIRED_PROPS
      };
      super(normalizedOpts.transitionProps);
      this.opts = normalizedOpts;
    }
    initializeProps(startProps, endProps) {
      const result = super.initializeProps(startProps, endProps);
      const {
        makeViewport: makeViewport2,
        around
      } = this.opts;
      if (makeViewport2 && around) {
        const startViewport = makeViewport2(startProps);
        const endViewport = makeViewport2(endProps);
        const aroundPosition = startViewport.unproject(around);
        result.start.around = around;
        Object.assign(result.end, {
          around: endViewport.project(aroundPosition),
          aroundPosition,
          width: endProps.width,
          height: endProps.height
        });
      }
      return result;
    }
    interpolateProps(startProps, endProps, t2) {
      const propsInTransition = {};
      for (const key of this._propsToExtract) {
        propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t2);
      }
      if (endProps.aroundPosition && this.opts.makeViewport) {
        const viewport = this.opts.makeViewport({
          ...endProps,
          ...propsInTransition
        });
        Object.assign(propsInTransition, viewport.panByPosition(
          endProps.aroundPosition,
          lerp(startProps.around, endProps.around, t2)
        ));
      }
      return propsInTransition;
    }
  };

  // ../core/src/controllers/controller.ts
  var NO_TRANSITION_PROPS = {
    transitionDuration: 0
  };
  var DEFAULT_INERTIA = 300;
  var INERTIA_EASING = (t2) => 1 - (1 - t2) * (1 - t2);
  var EVENT_TYPES = {
    WHEEL: ["wheel"],
    PAN: ["panstart", "panmove", "panend"],
    PINCH: ["pinchstart", "pinchmove", "pinchend"],
    TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
    DOUBLE_TAP: ["doubletap"],
    KEYBOARD: ["keydown"]
  };
  var pinchEventWorkaround = {};
  var Controller = class {
    state = {};
    _events = {};
    _interactionState = {
      isDragging: false
    };
    _customEvents = [];
    _eventStartBlocked = null;
    _panMove = false;
    invertPan = false;
    dragMode = "rotate";
    inertia = 0;
    scrollZoom = true;
    dragPan = true;
    dragRotate = true;
    doubleClickZoom = true;
    touchZoom = true;
    touchRotate = false;
    keyboard = true;
    constructor(opts) {
      this.transitionManager = new TransitionManager({
        ...opts,
        getControllerState: (props) => new this.ControllerState(props),
        onViewStateChange: this._onTransition.bind(this),
        onStateChange: this._setInteractionState.bind(this)
      });
      this.handleEvent = this.handleEvent.bind(this);
      this.eventManager = opts.eventManager;
      this.onViewStateChange = opts.onViewStateChange || (() => {
      });
      this.onStateChange = opts.onStateChange || (() => {
      });
      this.makeViewport = opts.makeViewport;
    }
    set events(customEvents) {
      this.toggleEvents(this._customEvents, false);
      this.toggleEvents(customEvents, true);
      this._customEvents = customEvents;
      if (this.props) {
        this.setProps(this.props);
      }
    }
    finalize() {
      for (const eventName in this._events) {
        if (this._events[eventName]) {
          this.eventManager?.off(eventName, this.handleEvent);
        }
      }
      this.transitionManager.finalize();
    }
    handleEvent(event) {
      this._controllerState = void 0;
      const eventStartBlocked = this._eventStartBlocked;
      switch (event.type) {
        case "panstart":
          return eventStartBlocked ? false : this._onPanStart(event);
        case "panmove":
          return this._onPan(event);
        case "panend":
          return this._onPanEnd(event);
        case "pinchstart":
          return eventStartBlocked ? false : this._onPinchStart(event);
        case "pinchmove":
          return this._onPinch(event);
        case "pinchend":
          return this._onPinchEnd(event);
        case "tripanstart":
          return eventStartBlocked ? false : this._onTriplePanStart(event);
        case "tripanmove":
          return this._onTriplePan(event);
        case "tripanend":
          return this._onTriplePanEnd(event);
        case "doubletap":
          return this._onDoubleTap(event);
        case "wheel":
          return this._onWheel(event);
        case "keydown":
          return this._onKeyDown(event);
        default:
          return false;
      }
    }
    get controllerState() {
      this._controllerState = this._controllerState || new this.ControllerState({
        makeViewport: this.makeViewport,
        ...this.props,
        ...this.state
      });
      return this._controllerState;
    }
    getCenter(event) {
      const {
        x: x2,
        y: y2
      } = this.props;
      const {
        offsetCenter
      } = event;
      return [offsetCenter.x - x2, offsetCenter.y - y2];
    }
    isPointInBounds(pos, event) {
      const {
        width,
        height
      } = this.props;
      if (event && event.handled) {
        return false;
      }
      const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
      if (inside && event) {
        event.stopPropagation();
      }
      return inside;
    }
    isFunctionKeyPressed(event) {
      const {
        srcEvent
      } = event;
      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
    isDragging() {
      return this._interactionState.isDragging || false;
    }
    blockEvents(timeout) {
      const timer = setTimeout(() => {
        if (this._eventStartBlocked === timer) {
          this._eventStartBlocked = null;
        }
      }, timeout);
      this._eventStartBlocked = timer;
    }
    setProps(props) {
      if (props.dragMode) {
        this.dragMode = props.dragMode;
      }
      this.props = props;
      if (!("transitionInterpolator" in props)) {
        props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
      }
      this.transitionManager.processViewStateChange(props);
      const {
        inertia
      } = props;
      this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
      const {
        scrollZoom = true,
        dragPan = true,
        dragRotate = true,
        doubleClickZoom = true,
        touchZoom = true,
        touchRotate = false,
        keyboard = true
      } = props;
      const isInteractive = Boolean(this.onViewStateChange);
      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
      this.toggleEvents(EVENT_TYPES.PAN, isInteractive);
      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
      this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoom = touchZoom;
      this.touchRotate = touchRotate;
      this.keyboard = keyboard;
    }
    updateTransition() {
      this.transitionManager.updateTransition();
    }
    toggleEvents(eventNames, enabled) {
      if (this.eventManager) {
        eventNames.forEach((eventName) => {
          if (this._events[eventName] !== enabled) {
            this._events[eventName] = enabled;
            if (enabled) {
              this.eventManager.on(eventName, this.handleEvent);
            } else {
              this.eventManager.off(eventName, this.handleEvent);
            }
          }
        });
      }
    }
    updateViewport(newControllerState, extraProps = null, interactionState = {}) {
      const viewState = {
        ...newControllerState.getViewportProps(),
        ...extraProps
      };
      const changed = this.controllerState !== newControllerState;
      this.state = newControllerState.getState();
      this._setInteractionState(interactionState);
      if (changed) {
        const oldViewState = this.controllerState && this.controllerState.getViewportProps();
        if (this.onViewStateChange) {
          this.onViewStateChange({
            viewState,
            interactionState: this._interactionState,
            oldViewState
          });
        }
      }
    }
    _onTransition(params) {
      this.onViewStateChange({
        ...params,
        interactionState: this._interactionState
      });
    }
    _setInteractionState(newStates) {
      Object.assign(this._interactionState, newStates);
      this.onStateChange(this._interactionState);
    }
    _onPanStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
      if (this.invertPan || this.dragMode === "pan") {
        alternateMode = !alternateMode;
      }
      const newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({
        pos
      });
      this._panMove = alternateMode;
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
    _onPan(event) {
      if (!this.isDragging()) {
        return false;
      }
      return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
    }
    _onPanEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
    }
    _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }
      const pos = this.getCenter(event);
      const newControllerState = this.controllerState.pan({
        pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isPanning: true
      });
      return true;
    }
    _onPanMoveEnd(event) {
      const {
        inertia
      } = this;
      if (this.dragPan && inertia && event.velocity) {
        const pos = this.getCenter(event);
        const endPos2 = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
        const newControllerState = this.controllerState.pan({
          pos: endPos2
        }).panEnd();
        this.updateViewport(newControllerState, {
          ...this._getTransitionProps(),
          transitionDuration: inertia,
          transitionEasing: INERTIA_EASING
        }, {
          isDragging: false,
          isPanning: true
        });
      } else {
        const newControllerState = this.controllerState.panEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isPanning: false
        });
      }
      return true;
    }
    _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }
      const pos = this.getCenter(event);
      const newControllerState = this.controllerState.rotate({
        pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isRotating: true
      });
      return true;
    }
    _onPanRotateEnd(event) {
      const {
        inertia
      } = this;
      if (this.dragRotate && inertia && event.velocity) {
        const pos = this.getCenter(event);
        const endPos2 = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
        const newControllerState = this.controllerState.rotate({
          pos: endPos2
        }).rotateEnd();
        this.updateViewport(newControllerState, {
          ...this._getTransitionProps(),
          transitionDuration: inertia,
          transitionEasing: INERTIA_EASING
        }, {
          isDragging: false,
          isRotating: true
        });
      } else {
        const newControllerState = this.controllerState.rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isRotating: false
        });
      }
      return true;
    }
    _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }
      event.srcEvent.preventDefault();
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const {
        speed = 0.01,
        smooth = false
      } = this.scrollZoom === true ? {} : this.scrollZoom;
      const {
        delta
      } = event;
      let scale8 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
      if (delta < 0 && scale8 !== 0) {
        scale8 = 1 / scale8;
      }
      const newControllerState = this.controllerState.zoom({
        pos,
        scale: scale8
      });
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps({
          around: pos
        }),
        transitionDuration: smooth ? 250 : 1
      }, {
        isZooming: true,
        isPanning: true
      });
      return true;
    }
    _onTriplePanStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const newControllerState = this.controllerState.rotateStart({
        pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
    _onTriplePan(event) {
      if (!this.touchRotate) {
        return false;
      }
      if (!this.isDragging()) {
        return false;
      }
      const pos = this.getCenter(event);
      pos[0] -= event.deltaX;
      const newControllerState = this.controllerState.rotate({
        pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isRotating: true
      });
      return true;
    }
    _onTriplePanEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      const {
        inertia
      } = this;
      if (this.touchRotate && inertia && event.velocityY) {
        const pos = this.getCenter(event);
        const endPos2 = [pos[0], pos[1] += event.velocityY * inertia / 2];
        const newControllerState = this.controllerState.rotate({
          pos: endPos2
        });
        this.updateViewport(newControllerState, {
          ...this._getTransitionProps(),
          transitionDuration: inertia,
          transitionEasing: INERTIA_EASING
        }, {
          isDragging: false,
          isRotating: true
        });
        this.blockEvents(inertia);
      } else {
        const newControllerState = this.controllerState.rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isRotating: false
        });
      }
      return true;
    }
    _onPinchStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const newControllerState = this.controllerState.zoomStart({
        pos
      }).rotateStart({
        pos
      });
      pinchEventWorkaround._startPinchRotation = event.rotation;
      pinchEventWorkaround._lastPinchEvent = event;
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
    _onPinch(event) {
      if (!this.touchZoom && !this.touchRotate) {
        return false;
      }
      if (!this.isDragging()) {
        return false;
      }
      let newControllerState = this.controllerState;
      if (this.touchZoom) {
        const {
          scale: scale8
        } = event;
        const pos = this.getCenter(event);
        newControllerState = newControllerState.zoom({
          pos,
          scale: scale8
        });
      }
      if (this.touchRotate) {
        const {
          rotation
        } = event;
        newControllerState = newControllerState.rotate({
          deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation
        });
      }
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: this.touchRotate
      });
      pinchEventWorkaround._lastPinchEvent = event;
      return true;
    }
    _onPinchEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      const {
        inertia
      } = this;
      const {
        _lastPinchEvent
      } = pinchEventWorkaround;
      if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
        const pos = this.getCenter(event);
        let newControllerState = this.controllerState.rotateEnd();
        const z = Math.log2(event.scale);
        const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
        const endScale = Math.pow(2, z + velocityZ * inertia / 2);
        newControllerState = newControllerState.zoom({
          pos,
          scale: endScale
        }).zoomEnd();
        this.updateViewport(newControllerState, {
          ...this._getTransitionProps({
            around: pos
          }),
          transitionDuration: inertia,
          transitionEasing: INERTIA_EASING
        }, {
          isDragging: false,
          isPanning: this.touchZoom,
          isZooming: this.touchZoom,
          isRotating: false
        });
        this.blockEvents(inertia);
      } else {
        const newControllerState = this.controllerState.zoomEnd().rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isPanning: false,
          isZooming: false,
          isRotating: false
        });
      }
      pinchEventWorkaround._startPinchRotation = null;
      pinchEventWorkaround._lastPinchEvent = null;
      return true;
    }
    _onDoubleTap(event) {
      if (!this.doubleClickZoom) {
        return false;
      }
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const isZoomOut = this.isFunctionKeyPressed(event);
      const newControllerState = this.controllerState.zoom({
        pos,
        scale: isZoomOut ? 0.5 : 2
      });
      this.updateViewport(newControllerState, this._getTransitionProps({
        around: pos
      }), {
        isZooming: true,
        isPanning: true
      });
      this.blockEvents(100);
      return true;
    }
    _onKeyDown(event) {
      if (!this.keyboard) {
        return false;
      }
      const funcKey = this.isFunctionKeyPressed(event);
      const {
        zoomSpeed,
        moveSpeed,
        rotateSpeedX,
        rotateSpeedY
      } = this.keyboard === true ? {} : this.keyboard;
      const {
        controllerState
      } = this;
      let newControllerState;
      const interactionState = {};
      switch (event.srcEvent.code) {
        case "Minus":
          newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
          interactionState.isZooming = true;
          break;
        case "Equal":
          newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
          interactionState.isZooming = true;
          break;
        case "ArrowLeft":
          if (funcKey) {
            newControllerState = controllerState.rotateLeft(rotateSpeedX);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveLeft(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowRight":
          if (funcKey) {
            newControllerState = controllerState.rotateRight(rotateSpeedX);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveRight(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowUp":
          if (funcKey) {
            newControllerState = controllerState.rotateUp(rotateSpeedY);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveUp(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowDown":
          if (funcKey) {
            newControllerState = controllerState.rotateDown(rotateSpeedY);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveDown(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        default:
          return false;
      }
      this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
      return true;
    }
    _getTransitionProps(opts) {
      const {
        transition
      } = this;
      if (!transition || !transition.transitionInterpolator) {
        return NO_TRANSITION_PROPS;
      }
      return opts ? {
        ...transition,
        transitionInterpolator: new LinearInterpolator({
          ...opts,
          ...transition.transitionInterpolator.opts,
          makeViewport: this.controllerState.makeViewport
        })
      } : transition;
    }
  };

  // ../core/src/controllers/view-state.ts
  var ViewState = class {
    constructor(props, state) {
      this._viewportProps = this.applyConstraints(props);
      this._state = state;
    }
    getViewportProps() {
      return this._viewportProps;
    }
    getState() {
      return this._state;
    }
  };

  // ../core/src/controllers/map-controller.ts
  var PITCH_MOUSE_THRESHOLD = 5;
  var PITCH_ACCEL = 1.2;
  var MapState = class extends ViewState {
    constructor(options) {
      const {
        width,
        height,
        latitude,
        longitude,
        zoom,
        bearing = 0,
        pitch = 0,
        altitude = 1.5,
        position = [0, 0, 0],
        maxZoom = 20,
        minZoom = 0,
        maxPitch = 60,
        minPitch = 0,
        startPanLngLat,
        startZoomLngLat,
        startRotatePos,
        startBearing,
        startPitch,
        startZoom,
        normalize: normalize5 = true
      } = options;
      assert11(Number.isFinite(longitude));
      assert11(Number.isFinite(latitude));
      assert11(Number.isFinite(zoom));
      super({
        width,
        height,
        latitude,
        longitude,
        zoom,
        bearing,
        pitch,
        altitude,
        maxZoom,
        minZoom,
        maxPitch,
        minPitch,
        normalize: normalize5,
        position
      }, {
        startPanLngLat,
        startZoomLngLat,
        startRotatePos,
        startBearing,
        startPitch,
        startZoom
      });
      this.makeViewport = options.makeViewport;
    }
    panStart({
      pos
    }) {
      return this._getUpdatedState({
        startPanLngLat: this._unproject(pos)
      });
    }
    pan({
      pos,
      startPos
    }) {
      const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
      if (!startPanLngLat) {
        return this;
      }
      const viewport = this.makeViewport(this.getViewportProps());
      const newProps = viewport.panByPosition(startPanLngLat, pos);
      return this._getUpdatedState(newProps);
    }
    panEnd() {
      return this._getUpdatedState({
        startPanLngLat: null
      });
    }
    rotateStart({
      pos
    }) {
      return this._getUpdatedState({
        startRotatePos: pos,
        startBearing: this.getViewportProps().bearing,
        startPitch: this.getViewportProps().pitch
      });
    }
    rotate({
      pos,
      deltaAngleX = 0,
      deltaAngleY = 0
    }) {
      const {
        startRotatePos,
        startBearing,
        startPitch
      } = this.getState();
      if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
        return this;
      }
      let newRotation;
      if (pos) {
        newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
      } else {
        newRotation = {
          bearing: startBearing + deltaAngleX,
          pitch: startPitch + deltaAngleY
        };
      }
      return this._getUpdatedState(newRotation);
    }
    rotateEnd() {
      return this._getUpdatedState({
        startBearing: null,
        startPitch: null
      });
    }
    zoomStart({
      pos
    }) {
      return this._getUpdatedState({
        startZoomLngLat: this._unproject(pos),
        startZoom: this.getViewportProps().zoom
      });
    }
    zoom({
      pos,
      startPos,
      scale: scale8
    }) {
      let {
        startZoom,
        startZoomLngLat
      } = this.getState();
      if (!startZoomLngLat) {
        startZoom = this.getViewportProps().zoom;
        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
      }
      if (!startZoomLngLat) {
        return this;
      }
      const {
        maxZoom,
        minZoom
      } = this.getViewportProps();
      let zoom = startZoom + Math.log2(scale8);
      zoom = clamp(zoom, minZoom, maxZoom);
      const zoomedViewport = this.makeViewport({
        ...this.getViewportProps(),
        zoom
      });
      return this._getUpdatedState({
        zoom,
        ...zoomedViewport.panByPosition(startZoomLngLat, pos)
      });
    }
    zoomEnd() {
      return this._getUpdatedState({
        startZoomLngLat: null,
        startZoom: null
      });
    }
    zoomIn(speed = 2) {
      return this._zoomFromCenter(speed);
    }
    zoomOut(speed = 2) {
      return this._zoomFromCenter(1 / speed);
    }
    moveLeft(speed = 100) {
      return this._panFromCenter([speed, 0]);
    }
    moveRight(speed = 100) {
      return this._panFromCenter([-speed, 0]);
    }
    moveUp(speed = 100) {
      return this._panFromCenter([0, speed]);
    }
    moveDown(speed = 100) {
      return this._panFromCenter([0, -speed]);
    }
    rotateLeft(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing - speed
      });
    }
    rotateRight(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing + speed
      });
    }
    rotateUp(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch + speed
      });
    }
    rotateDown(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch - speed
      });
    }
    shortestPathFrom(viewState) {
      const fromProps = viewState.getViewportProps();
      const props = {
        ...this.getViewportProps()
      };
      const {
        bearing,
        longitude
      } = props;
      if (Math.abs(bearing - fromProps.bearing) > 180) {
        props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
      }
      if (Math.abs(longitude - fromProps.longitude) > 180) {
        props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
      }
      return props;
    }
    applyConstraints(props) {
      const {
        maxZoom,
        minZoom,
        zoom
      } = props;
      props.zoom = clamp(zoom, minZoom, maxZoom);
      const {
        maxPitch,
        minPitch,
        pitch
      } = props;
      props.pitch = clamp(pitch, minPitch, maxPitch);
      const {
        normalize: normalize5 = true
      } = props;
      if (normalize5) {
        Object.assign(props, normalizeViewportProps(props));
      }
      return props;
    }
    _zoomFromCenter(scale8) {
      const {
        width,
        height
      } = this.getViewportProps();
      return this.zoom({
        pos: [width / 2, height / 2],
        scale: scale8
      });
    }
    _panFromCenter(offset) {
      const {
        width,
        height
      } = this.getViewportProps();
      return this.pan({
        startPos: [width / 2, height / 2],
        pos: [width / 2 + offset[0], height / 2 + offset[1]]
      });
    }
    _getUpdatedState(newProps) {
      return new this.constructor({
        makeViewport: this.makeViewport,
        ...this.getViewportProps(),
        ...this.getState(),
        ...newProps
      });
    }
    _unproject(pos) {
      const viewport = this.makeViewport(this.getViewportProps());
      return pos && viewport.unproject(pos);
    }
    _getNewRotation(pos, startPos, startPitch, startBearing) {
      const deltaX = pos[0] - startPos[0];
      const deltaY = pos[1] - startPos[1];
      const centerY = pos[1];
      const startY = startPos[1];
      const {
        width,
        height
      } = this.getViewportProps();
      const deltaScaleX = deltaX / width;
      let deltaScaleY = 0;
      if (deltaY > 0) {
        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
        }
      } else if (deltaY < 0) {
        if (startY > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = 1 - centerY / startY;
        }
      }
      deltaScaleY = clamp(deltaScaleY, -1, 1);
      const {
        minPitch,
        maxPitch
      } = this.getViewportProps();
      const bearing = startBearing + 180 * deltaScaleX;
      let pitch = startPitch;
      if (deltaScaleY > 0) {
        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
      } else if (deltaScaleY < 0) {
        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
      }
      return {
        pitch,
        bearing
      };
    }
  };
  var MapController = class extends Controller {
    ControllerState = MapState;
    transition = {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    };
    dragMode = "pan";
    setProps(props) {
      props.position = props.position || [0, 0, 0];
      const oldProps = this.props;
      super.setProps(props);
      const dimensionChanged = !oldProps || oldProps.height !== props.height;
      if (dimensionChanged) {
        this.updateViewport(new this.ControllerState({
          makeViewport: this.makeViewport,
          ...props,
          ...this.state
        }));
      }
    }
  };

  // ../core/src/views/map-view.ts
  var MapView = class extends View {
    get ViewportType() {
      return WebMercatorViewport2;
    }
    get ControllerType() {
      return MapController;
    }
  };
  __publicField(MapView, "displayName", "MapView");

  // ../core/src/lib/effect-manager.ts
  var DEFAULT_LIGHTING_EFFECT = new LightingEffect();
  function compareEffects(e1, e2) {
    const o1 = e1.order ?? Infinity;
    const o2 = e2.order ?? Infinity;
    return o1 - o2;
  }
  var EffectManager = class {
    _resolvedEffects = [];
    _defaultEffects = [];
    constructor() {
      this.effects = [];
      this._needsRedraw = "Initial render";
      this._setEffects([]);
    }
    addDefaultEffect(effect) {
      const defaultEffects = this._defaultEffects;
      if (!defaultEffects.find((e2) => e2.id === effect.id)) {
        const index = defaultEffects.findIndex((e2) => compareEffects(e2, effect) > 0);
        if (index < 0) {
          defaultEffects.push(effect);
        } else {
          defaultEffects.splice(index, 0, effect);
        }
        this._setEffects(this.effects);
      }
    }
    setProps(props) {
      if ("effects" in props) {
        if (!deepEqual(props.effects, this.effects, 1)) {
          this._setEffects(props.effects);
        }
      }
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    getEffects() {
      return this._resolvedEffects;
    }
    _setEffects(effects) {
      const oldEffectsMap = {};
      for (const effect of this.effects) {
        oldEffectsMap[effect.id] = effect;
      }
      const nextEffects = [];
      for (const effect of effects) {
        const oldEffect = oldEffectsMap[effect.id];
        if (oldEffect && oldEffect !== effect) {
          if (oldEffect.setProps) {
            oldEffect.setProps(effect.props);
            nextEffects.push(oldEffect);
          } else {
            oldEffect.cleanup();
            nextEffects.push(effect);
          }
        } else {
          nextEffects.push(effect);
        }
        delete oldEffectsMap[effect.id];
      }
      for (const removedEffectId in oldEffectsMap) {
        oldEffectsMap[removedEffectId].cleanup();
      }
      this.effects = nextEffects;
      this._resolvedEffects = nextEffects.concat(this._defaultEffects);
      if (!effects.some((effect) => effect instanceof LightingEffect)) {
        this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
      }
      this._needsRedraw = "effects changed";
    }
    finalize() {
      for (const effect of this._resolvedEffects) {
        effect.cleanup();
      }
      this.effects.length = 0;
      this._resolvedEffects.length = 0;
      this._defaultEffects.length = 0;
    }
  };

  // ../core/src/passes/draw-layers-pass.ts
  var DrawLayersPass = class extends LayersPass {
    shouldDrawLayer(layer) {
      const {
        operation
      } = layer.props;
      return operation.includes("draw") || operation.includes("terrain");
    }
  };

  // ../core/src/lib/deck-renderer.ts
  var TRACE_RENDER_LAYERS = "deckRenderer.renderLayers";
  var DeckRenderer = class {
    constructor(gl) {
      this.gl = gl;
      this.layerFilter = null;
      this.drawPickingColors = false;
      this.drawLayersPass = new DrawLayersPass(gl);
      this.pickLayersPass = new PickLayersPass(gl);
      this.renderCount = 0;
      this._needsRedraw = "Initial render";
      this.renderBuffers = [];
      this.lastPostProcessEffect = null;
    }
    setProps(props) {
      if (this.layerFilter !== props.layerFilter) {
        this.layerFilter = props.layerFilter;
        this._needsRedraw = "layerFilter changed";
      }
      if (this.drawPickingColors !== props.drawPickingColors) {
        this.drawPickingColors = props.drawPickingColors;
        this._needsRedraw = "drawPickingColors changed";
      }
    }
    renderLayers(opts) {
      const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
      const renderOpts = {
        layerFilter: this.layerFilter,
        isPicking: this.drawPickingColors,
        ...opts,
        target: opts.target || Framebuffer.getDefaultFramebuffer(this.gl)
      };
      if (renderOpts.effects) {
        this._preRender(renderOpts.effects, renderOpts);
      }
      const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
      const renderStats = layerPass.render({
        ...renderOpts,
        target: outputBuffer
      });
      if (renderOpts.effects) {
        this._postRender(renderOpts.effects, renderOpts);
      }
      this.renderCount++;
      debug(TRACE_RENDER_LAYERS, this, renderStats, opts);
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    finalize() {
      const {
        renderBuffers
      } = this;
      for (const buffer of renderBuffers) {
        buffer.delete();
      }
      renderBuffers.length = 0;
    }
    _preRender(effects, opts) {
      this.lastPostProcessEffect = null;
      opts.preRenderStats = opts.preRenderStats || {};
      for (const effect of effects) {
        opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);
        if (effect.postRender) {
          this.lastPostProcessEffect = effect.id;
        }
      }
      if (this.lastPostProcessEffect) {
        this._resizeRenderBuffers();
      }
    }
    _resizeRenderBuffers() {
      const {
        renderBuffers
      } = this;
      if (renderBuffers.length === 0) {
        renderBuffers.push(new Framebuffer(this.gl), new Framebuffer(this.gl));
      }
      for (const buffer of renderBuffers) {
        buffer.resize();
      }
    }
    _postRender(effects, opts) {
      const {
        renderBuffers
      } = this;
      const params = {
        ...opts,
        inputBuffer: renderBuffers[0],
        swapBuffer: renderBuffers[1],
        target: null
      };
      for (const effect of effects) {
        if (effect.postRender) {
          if (effect.id === this.lastPostProcessEffect) {
            params.target = opts.target;
            effect.postRender(this.gl, params);
            break;
          }
          const buffer = effect.postRender(this.gl, params);
          params.inputBuffer = buffer;
          params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
        }
      }
    }
  };

  // ../core/src/lib/picking/query-object.ts
  var NO_PICKED_OBJECT = {
    pickedColor: null,
    pickedObjectIndex: -1
  };
  function getClosestObject({
    pickedColors,
    decodePickingColor,
    deviceX,
    deviceY,
    deviceRadius,
    deviceRect
  }) {
    const {
      x: x2,
      y: y2,
      width,
      height
    } = deviceRect;
    let minSquareDistanceToCenter = deviceRadius * deviceRadius;
    let closestPixelIndex = -1;
    let i3 = 0;
    for (let row = 0; row < height; row++) {
      const dy = row + y2 - deviceY;
      const dy2 = dy * dy;
      if (dy2 > minSquareDistanceToCenter) {
        i3 += 4 * width;
      } else {
        for (let col = 0; col < width; col++) {
          const pickedLayerIndex = pickedColors[i3 + 3] - 1;
          if (pickedLayerIndex >= 0) {
            const dx = col + x2 - deviceX;
            const d2 = dx * dx + dy2;
            if (d2 <= minSquareDistanceToCenter) {
              minSquareDistanceToCenter = d2;
              closestPixelIndex = i3;
            }
          }
          i3 += 4;
        }
      }
    }
    if (closestPixelIndex >= 0) {
      const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
      const pickedObject = decodePickingColor(pickedColor);
      if (pickedObject) {
        const dy = Math.floor(closestPixelIndex / 4 / width);
        const dx = closestPixelIndex / 4 - dy * width;
        return {
          ...pickedObject,
          pickedColor,
          pickedX: x2 + dx,
          pickedY: y2 + dy
        };
      }
      log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
    }
    return NO_PICKED_OBJECT;
  }
  function getUniqueObjects({
    pickedColors,
    decodePickingColor
  }) {
    const uniqueColors = /* @__PURE__ */ new Map();
    if (pickedColors) {
      for (let i3 = 0; i3 < pickedColors.length; i3 += 4) {
        const pickedLayerIndex = pickedColors[i3 + 3] - 1;
        if (pickedLayerIndex >= 0) {
          const pickedColor = pickedColors.slice(i3, i3 + 4);
          const colorKey = pickedColor.join(",");
          if (!uniqueColors.has(colorKey)) {
            const pickedObject = decodePickingColor(pickedColor);
            if (pickedObject) {
              uniqueColors.set(colorKey, {
                ...pickedObject,
                color: pickedColor
              });
            } else {
              log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
            }
          }
        }
      }
    }
    return Array.from(uniqueColors.values());
  }

  // ../core/src/lib/picking/pick-info.ts
  function getEmptyPickingInfo({
    pickInfo,
    viewports,
    pixelRatio,
    x: x2,
    y: y2,
    z
  }) {
    let pickedViewport = viewports[0];
    if (viewports.length > 1) {
      pickedViewport = getViewportFromCoordinates(pickInfo?.pickedViewports || viewports, {
        x: x2,
        y: y2
      });
    }
    let coordinate;
    if (pickedViewport) {
      const point = [x2 - pickedViewport.x, y2 - pickedViewport.y];
      if (z !== void 0) {
        point[2] = z;
      }
      coordinate = pickedViewport.unproject(point);
    }
    return {
      color: null,
      layer: null,
      viewport: pickedViewport,
      index: -1,
      picked: false,
      x: x2,
      y: y2,
      pixel: [x2, y2],
      coordinate,
      devicePixel: pickInfo && "pickedX" in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : void 0,
      pixelRatio
    };
  }
  function processPickInfo(opts) {
    const {
      pickInfo,
      lastPickedInfo,
      mode,
      layers
    } = opts;
    const {
      pickedColor,
      pickedLayer,
      pickedObjectIndex
    } = pickInfo;
    const affectedLayers = pickedLayer ? [pickedLayer] : [];
    if (mode === "hover") {
      const lastPickedPixelIndex = lastPickedInfo.index;
      const lastPickedLayerId = lastPickedInfo.layerId;
      const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
      if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
        if (pickedLayerId !== lastPickedLayerId) {
          const lastPickedLayer = layers.find((layer) => layer.props.id === lastPickedLayerId);
          if (lastPickedLayer) {
            affectedLayers.unshift(lastPickedLayer);
          }
        }
        lastPickedInfo.layerId = pickedLayerId;
        lastPickedInfo.index = pickedObjectIndex;
        lastPickedInfo.info = null;
      }
    }
    const baseInfo = getEmptyPickingInfo(opts);
    const infos = /* @__PURE__ */ new Map();
    infos.set(null, baseInfo);
    affectedLayers.forEach((layer) => {
      let info = {
        ...baseInfo
      };
      if (layer === pickedLayer) {
        info.color = pickedColor;
        info.index = pickedObjectIndex;
        info.picked = true;
      }
      info = getLayerPickingInfo({
        layer,
        info,
        mode
      });
      const rootLayer = info.layer;
      if (layer === pickedLayer && mode === "hover") {
        lastPickedInfo.info = info;
      }
      infos.set(rootLayer.id, info);
      if (mode === "hover") {
        rootLayer.updateAutoHighlight(info);
      }
    });
    return infos;
  }
  function getLayerPickingInfo({
    layer,
    info,
    mode
  }) {
    while (layer && info) {
      const sourceLayer = info.layer || null;
      info.sourceLayer = sourceLayer;
      info.layer = layer;
      info = layer.getPickingInfo({
        info,
        mode,
        sourceLayer
      });
      layer = layer.parent;
    }
    return info;
  }
  function getViewportFromCoordinates(viewports, pixel) {
    for (let i3 = viewports.length - 1; i3 >= 0; i3--) {
      const viewport = viewports[i3];
      if (viewport.containsPixel(pixel)) {
        return viewport;
      }
    }
    return viewports[0];
  }

  // ../core/src/lib/deck-picker.ts
  var DeckPicker = class {
    _pickable = true;
    constructor(gl) {
      this.gl = gl;
      this.pickLayersPass = new PickLayersPass(gl);
      this.lastPickedInfo = {
        index: -1,
        layerId: null,
        info: null
      };
    }
    setProps(props) {
      if ("layerFilter" in props) {
        this.layerFilter = props.layerFilter;
      }
      if ("_pickable" in props) {
        this._pickable = props._pickable;
      }
    }
    finalize() {
      if (this.pickingFBO) {
        this.pickingFBO.delete();
      }
      if (this.depthFBO) {
        this.depthFBO.color.delete();
        this.depthFBO.delete();
      }
    }
    pickObject(opts) {
      return this._pickClosestObject(opts);
    }
    pickObjects(opts) {
      return this._pickVisibleObjects(opts);
    }
    getLastPickedObject({
      x: x2,
      y: y2,
      layers,
      viewports
    }, lastPickedInfo = this.lastPickedInfo.info) {
      const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
      const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
      const layer = lastPickedLayerId ? layers.find((l2) => l2.id === lastPickedLayerId) : null;
      const viewport = lastPickedViewportId && viewports.find((v) => v.id === lastPickedViewportId) || viewports[0];
      const coordinate = viewport && viewport.unproject([x2 - viewport.x, y2 - viewport.y]);
      const info = {
        x: x2,
        y: y2,
        viewport,
        coordinate,
        layer
      };
      return {
        ...lastPickedInfo,
        ...info
      };
    }
    _resizeBuffer() {
      const {
        gl
      } = this;
      if (!this.pickingFBO) {
        this.pickingFBO = new Framebuffer(gl);
        if (Framebuffer.isSupported(gl, {
          colorBufferFloat: true
        })) {
          const depthFBO = new Framebuffer(gl);
          depthFBO.attach({
            [esm_default2.COLOR_ATTACHMENT0]: new Texture2D(gl, {
              format: isWebGL2(gl) ? esm_default2.RGBA32F : esm_default2.RGBA,
              type: esm_default2.FLOAT
            })
          });
          this.depthFBO = depthFBO;
        }
      }
      this.pickingFBO?.resize({
        width: gl.canvas.width,
        height: gl.canvas.height
      });
      this.depthFBO?.resize({
        width: gl.canvas.width,
        height: gl.canvas.height
      });
    }
    _getPickable(layers) {
      if (this._pickable === false) {
        return null;
      }
      const pickableLayers = layers.filter((layer) => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);
      return pickableLayers.length ? pickableLayers : null;
    }
    _pickClosestObject({
      layers,
      views,
      viewports,
      x: x2,
      y: y2,
      radius = 0,
      depth = 1,
      mode = "query",
      unproject3D,
      onViewportActive,
      effects
    }) {
      const pickableLayers = this._getPickable(layers);
      const pixelRatio = cssToDeviceRatio(this.gl);
      if (!pickableLayers) {
        return {
          result: [],
          emptyInfo: getEmptyPickingInfo({
            viewports,
            x: x2,
            y: y2,
            pixelRatio
          })
        };
      }
      this._resizeBuffer();
      const devicePixelRange = cssToDevicePixels(this.gl, [x2, y2], true);
      const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
      const deviceRadius = Math.round(radius * pixelRatio);
      const {
        width,
        height
      } = this.pickingFBO;
      const deviceRect = this._getPickingRect({
        deviceX: devicePixel[0],
        deviceY: devicePixel[1],
        deviceRadius,
        deviceWidth: width,
        deviceHeight: height
      });
      const cullRect = {
        x: x2 - radius,
        y: y2 - radius,
        width: radius * 2 + 1,
        height: radius * 2 + 1
      };
      let infos;
      const result = [];
      const affectedLayers = /* @__PURE__ */ new Set();
      for (let i3 = 0; i3 < depth; i3++) {
        let pickInfo;
        if (deviceRect) {
          const pickedResult = this._drawAndSample({
            layers: pickableLayers,
            views,
            viewports,
            onViewportActive,
            deviceRect,
            cullRect,
            effects,
            pass: `picking:${mode}`
          });
          pickInfo = getClosestObject({
            ...pickedResult,
            deviceX: devicePixel[0],
            deviceY: devicePixel[1],
            deviceRadius,
            deviceRect
          });
        } else {
          pickInfo = {
            pickedColor: null,
            pickedObjectIndex: -1
          };
        }
        let z;
        if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
          const {
            pickedColors: pickedColors2
          } = this._drawAndSample({
            layers: [pickInfo.pickedLayer],
            views,
            viewports,
            onViewportActive,
            deviceRect: {
              x: pickInfo.pickedX,
              y: pickInfo.pickedY,
              width: 1,
              height: 1
            },
            cullRect,
            effects,
            pass: `picking:${mode}:z`
          }, true);
          if (pickedColors2[3]) {
            z = pickedColors2[0];
          }
        }
        if (pickInfo.pickedLayer && i3 + 1 < depth) {
          affectedLayers.add(pickInfo.pickedLayer);
          pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
        }
        infos = processPickInfo({
          pickInfo,
          lastPickedInfo: this.lastPickedInfo,
          mode,
          layers: pickableLayers,
          viewports,
          x: x2,
          y: y2,
          z,
          pixelRatio
        });
        for (const info of infos.values()) {
          if (info.layer) {
            result.push(info);
          }
        }
        if (!pickInfo.pickedColor) {
          break;
        }
      }
      for (const layer of affectedLayers) {
        layer.restorePickingColors();
      }
      return {
        result,
        emptyInfo: infos.get(null)
      };
    }
    _pickVisibleObjects({
      layers,
      views,
      viewports,
      x: x2,
      y: y2,
      width = 1,
      height = 1,
      mode = "query",
      maxObjects = null,
      onViewportActive,
      effects
    }) {
      const pickableLayers = this._getPickable(layers);
      if (!pickableLayers) {
        return [];
      }
      this._resizeBuffer();
      const pixelRatio = cssToDeviceRatio(this.gl);
      const leftTop = cssToDevicePixels(this.gl, [x2, y2], true);
      const deviceLeft = leftTop.x;
      const deviceTop = leftTop.y + leftTop.height;
      const rightBottom = cssToDevicePixels(this.gl, [x2 + width, y2 + height], true);
      const deviceRight = rightBottom.x + rightBottom.width;
      const deviceBottom = rightBottom.y;
      const deviceRect = {
        x: deviceLeft,
        y: deviceBottom,
        width: deviceRight - deviceLeft,
        height: deviceTop - deviceBottom
      };
      const pickedResult = this._drawAndSample({
        layers: pickableLayers,
        views,
        viewports,
        onViewportActive,
        deviceRect,
        cullRect: {
          x: x2,
          y: y2,
          width,
          height
        },
        effects,
        pass: `picking:${mode}`
      });
      const pickInfos = getUniqueObjects(pickedResult);
      const uniqueInfos = /* @__PURE__ */ new Map();
      const isMaxObjects = Number.isFinite(maxObjects);
      for (let i3 = 0; i3 < pickInfos.length; i3++) {
        if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {
          break;
        }
        const pickInfo = pickInfos[i3];
        let info = {
          color: pickInfo.pickedColor,
          layer: null,
          index: pickInfo.pickedObjectIndex,
          picked: true,
          x: x2,
          y: y2,
          pixelRatio
        };
        info = getLayerPickingInfo({
          layer: pickInfo.pickedLayer,
          info,
          mode
        });
        if (!uniqueInfos.has(info.object)) {
          uniqueInfos.set(info.object, info);
        }
      }
      return Array.from(uniqueInfos.values());
    }
    _drawAndSample({
      layers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      cullRect,
      effects,
      pass
    }, pickZ = false) {
      const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
      const opts = {
        layers,
        layerFilter: this.layerFilter,
        views,
        viewports,
        onViewportActive,
        pickingFBO,
        deviceRect,
        cullRect,
        effects,
        pass,
        pickZ,
        preRenderStats: {}
      };
      for (const effect of effects) {
        if (effect.useInPicking) {
          opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);
        }
      }
      const {
        decodePickingColor
      } = this.pickLayersPass.render(opts);
      const {
        x: x2,
        y: y2,
        width,
        height
      } = deviceRect;
      const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
      readPixelsToArray(pickingFBO, {
        sourceX: x2,
        sourceY: y2,
        sourceWidth: width,
        sourceHeight: height,
        target: pickedColors
      });
      return {
        pickedColors,
        decodePickingColor
      };
    }
    _getPickingRect({
      deviceX,
      deviceY,
      deviceRadius,
      deviceWidth,
      deviceHeight
    }) {
      const x2 = Math.max(0, deviceX - deviceRadius);
      const y2 = Math.max(0, deviceY - deviceRadius);
      const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x2;
      const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y2;
      if (width <= 0 || height <= 0) {
        return null;
      }
      return {
        x: x2,
        y: y2,
        width,
        height
      };
    }
  };

  // ../core/src/lib/tooltip.ts
  var defaultStyle = {
    zIndex: "1",
    position: "absolute",
    pointerEvents: "none",
    color: "#a0a7b4",
    backgroundColor: "#29323c",
    padding: "10px",
    top: "0",
    left: "0",
    display: "none"
  };
  var Tooltip = class {
    el = null;
    isVisible = false;
    constructor(canvas) {
      const canvasParent = canvas.parentElement;
      if (canvasParent) {
        this.el = document.createElement("div");
        this.el.className = "deck-tooltip";
        Object.assign(this.el.style, defaultStyle);
        canvasParent.appendChild(this.el);
      }
    }
    setTooltip(displayInfo, x2, y2) {
      const el = this.el;
      if (!el) {
        return;
      }
      if (typeof displayInfo === "string") {
        el.innerText = displayInfo;
      } else if (!displayInfo) {
        this.isVisible = false;
        el.style.display = "none";
        return;
      } else {
        if (displayInfo.text) {
          el.innerText = displayInfo.text;
        }
        if (displayInfo.html) {
          el.innerHTML = displayInfo.html;
        }
        if (displayInfo.className) {
          el.className = displayInfo.className;
        }
      }
      this.isVisible = true;
      el.style.display = "block";
      el.style.transform = `translate(${x2}px, ${y2}px)`;
      if (displayInfo && typeof displayInfo === "object" && "style" in displayInfo) {
        Object.assign(el.style, displayInfo.style);
      }
    }
    remove() {
      if (this.el) {
        this.el.remove();
        this.el = null;
      }
    }
  };

  // ../core/node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
  var import_hammerjs = __toESM(require_hammer());

  // ../core/node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  function some(array, predict) {
    for (let i3 = 0; i3 < array.length; i3++) {
      if (predict(array[i3])) {
        return true;
      }
    }
    return false;
  }
  function enhancePointerEventInput(PointerEventInput) {
    const oldHandler = PointerEventInput.prototype.handler;
    PointerEventInput.prototype.handler = function handler(ev) {
      const store = this.store;
      if (ev.button > 0 && ev.type === "pointerdown") {
        if (!some(store, (e2) => e2.pointerId === ev.pointerId)) {
          store.push(ev);
        }
      }
      oldHandler.call(this, ev);
    };
  }
  function enhanceMouseInput(MouseInput) {
    MouseInput.prototype.handler = function handler(ev) {
      let eventType = MOUSE_INPUT_MAP[ev.type];
      if (eventType & INPUT_START && ev.button >= 0) {
        this.pressed = true;
      }
      if (eventType & INPUT_MOVE && ev.which === 0) {
        eventType = INPUT_END;
      }
      if (!this.pressed) {
        return;
      }
      if (eventType & INPUT_END) {
        this.pressed = false;
      }
      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: "mouse",
        srcEvent: ev
      });
    };
  }

  // ../core/node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
  enhancePointerEventInput(import_hammerjs.default.PointerEventInput);
  enhanceMouseInput(import_hammerjs.default.MouseInput);
  var Manager = import_hammerjs.default.Manager;
  var hammer_browser_default = import_hammerjs.default;

  // ../core/node_modules/mjolnir.js/dist/esm/inputs/input.js
  var Input = class {
    constructor(element, callback, options) {
      this.element = element;
      this.callback = callback;
      this.options = { enable: true, ...options };
    }
  };

  // ../core/node_modules/mjolnir.js/dist/esm/constants.js
  var RECOGNIZERS = hammer_browser_default ? [
    [hammer_browser_default.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: false }],
    [hammer_browser_default.Rotate, { enable: false }],
    [hammer_browser_default.Pinch, { enable: false }],
    [hammer_browser_default.Swipe, { enable: false }],
    [hammer_browser_default.Pan, { threshold: 0, enable: false }],
    [hammer_browser_default.Press, { enable: false }],
    [hammer_browser_default.Tap, { event: "doubletap", taps: 2, enable: false }],
    [hammer_browser_default.Tap, { event: "anytap", enable: false }],
    [hammer_browser_default.Tap, { enable: false }]
  ] : null;
  var RECOGNIZER_COMPATIBLE_MAP = {
    tripan: ["rotate", "pinch", "pan"],
    rotate: ["pinch"],
    pinch: ["pan"],
    pan: ["press", "doubletap", "anytap", "tap"],
    doubletap: ["anytap"],
    anytap: ["tap"]
  };
  var RECOGNIZER_FALLBACK_MAP = {
    doubletap: ["tap"]
  };
  var BASIC_EVENT_ALIASES = {
    pointerdown: "pointerdown",
    pointermove: "pointermove",
    pointerup: "pointerup",
    touchstart: "pointerdown",
    touchmove: "pointermove",
    touchend: "pointerup",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup"
  };
  var INPUT_EVENT_TYPES = {
    KEY_EVENTS: ["keydown", "keyup"],
    MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
    WHEEL_EVENTS: [
      "wheel",
      "mousewheel"
    ]
  };
  var EVENT_RECOGNIZER_MAP = {
    tap: "tap",
    anytap: "anytap",
    doubletap: "doubletap",
    press: "press",
    pinch: "pinch",
    pinchin: "pinch",
    pinchout: "pinch",
    pinchstart: "pinch",
    pinchmove: "pinch",
    pinchend: "pinch",
    pinchcancel: "pinch",
    rotate: "rotate",
    rotatestart: "rotate",
    rotatemove: "rotate",
    rotateend: "rotate",
    rotatecancel: "rotate",
    tripan: "tripan",
    tripanstart: "tripan",
    tripanmove: "tripan",
    tripanup: "tripan",
    tripandown: "tripan",
    tripanleft: "tripan",
    tripanright: "tripan",
    tripanend: "tripan",
    tripancancel: "tripan",
    pan: "pan",
    panstart: "pan",
    panmove: "pan",
    panup: "pan",
    pandown: "pan",
    panleft: "pan",
    panright: "pan",
    panend: "pan",
    pancancel: "pan",
    swipe: "swipe",
    swipeleft: "swipe",
    swiperight: "swipe",
    swipeup: "swipe",
    swipedown: "swipe"
  };
  var GESTURE_EVENT_ALIASES = {
    click: "tap",
    anyclick: "anytap",
    dblclick: "doubletap",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup",
    mouseover: "pointerover",
    mouseout: "pointerout",
    mouseleave: "pointerleave"
  };

  // ../core/node_modules/mjolnir.js/dist/esm/utils/globals.js
  var userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
  var window_5 = typeof window !== "undefined" ? window : global;
  var passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return true;
      }
    };
    window_5.addEventListener("test", null, options);
    window_5.removeEventListener("test", null);
  } catch (err) {
    passiveSupported = false;
  }

  // ../core/node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js
  var firefox = userAgent.indexOf("firefox") !== -1;
  var { WHEEL_EVENTS } = INPUT_EVENT_TYPES;
  var EVENT_TYPE = "wheel";
  var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
  var WHEEL_DELTA_PER_LINE = 40;
  var SHIFT_MULTIPLIER = 0.25;
  var WheelInput = class extends Input {
    constructor(element, callback, options) {
      super(element, callback, options);
      this.handleEvent = (event) => {
        if (!this.options.enable) {
          return;
        }
        let value = event.deltaY;
        if (window_5.WheelEvent) {
          if (firefox && event.deltaMode === window_5.WheelEvent.DOM_DELTA_PIXEL) {
            value /= window_5.devicePixelRatio;
          }
          if (event.deltaMode === window_5.WheelEvent.DOM_DELTA_LINE) {
            value *= WHEEL_DELTA_PER_LINE;
          }
        }
        if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
          value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
        }
        if (event.shiftKey && value) {
          value = value * SHIFT_MULTIPLIER;
        }
        this.callback({
          type: EVENT_TYPE,
          center: {
            x: event.clientX,
            y: event.clientY
          },
          delta: -value,
          srcEvent: event,
          pointerType: "mouse",
          target: event.target
        });
      };
      this.events = (this.options.events || []).concat(WHEEL_EVENTS);
      this.events.forEach((event) => element.addEventListener(event, this.handleEvent, passiveSupported ? { passive: false } : false));
    }
    destroy() {
      this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    enableEventType(eventType, enabled) {
      if (eventType === EVENT_TYPE) {
        this.options.enable = enabled;
      }
    }
  };

  // ../core/node_modules/mjolnir.js/dist/esm/inputs/move-input.js
  var { MOUSE_EVENTS } = INPUT_EVENT_TYPES;
  var MOVE_EVENT_TYPE = "pointermove";
  var OVER_EVENT_TYPE = "pointerover";
  var OUT_EVENT_TYPE = "pointerout";
  var ENTER_EVENT_TYPE = "pointerenter";
  var LEAVE_EVENT_TYPE = "pointerleave";
  var MoveInput = class extends Input {
    constructor(element, callback, options) {
      super(element, callback, options);
      this.handleEvent = (event) => {
        this.handleOverEvent(event);
        this.handleOutEvent(event);
        this.handleEnterEvent(event);
        this.handleLeaveEvent(event);
        this.handleMoveEvent(event);
      };
      this.pressed = false;
      const { enable: enable2 } = this.options;
      this.enableMoveEvent = enable2;
      this.enableLeaveEvent = enable2;
      this.enableEnterEvent = enable2;
      this.enableOutEvent = enable2;
      this.enableOverEvent = enable2;
      this.events = (this.options.events || []).concat(MOUSE_EVENTS);
      this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
      this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    enableEventType(eventType, enabled) {
      if (eventType === MOVE_EVENT_TYPE) {
        this.enableMoveEvent = enabled;
      }
      if (eventType === OVER_EVENT_TYPE) {
        this.enableOverEvent = enabled;
      }
      if (eventType === OUT_EVENT_TYPE) {
        this.enableOutEvent = enabled;
      }
      if (eventType === ENTER_EVENT_TYPE) {
        this.enableEnterEvent = enabled;
      }
      if (eventType === LEAVE_EVENT_TYPE) {
        this.enableLeaveEvent = enabled;
      }
    }
    handleOverEvent(event) {
      if (this.enableOverEvent) {
        if (event.type === "mouseover") {
          this._emit(OVER_EVENT_TYPE, event);
        }
      }
    }
    handleOutEvent(event) {
      if (this.enableOutEvent) {
        if (event.type === "mouseout") {
          this._emit(OUT_EVENT_TYPE, event);
        }
      }
    }
    handleEnterEvent(event) {
      if (this.enableEnterEvent) {
        if (event.type === "mouseenter") {
          this._emit(ENTER_EVENT_TYPE, event);
        }
      }
    }
    handleLeaveEvent(event) {
      if (this.enableLeaveEvent) {
        if (event.type === "mouseleave") {
          this._emit(LEAVE_EVENT_TYPE, event);
        }
      }
    }
    handleMoveEvent(event) {
      if (this.enableMoveEvent) {
        switch (event.type) {
          case "mousedown":
            if (event.button >= 0) {
              this.pressed = true;
            }
            break;
          case "mousemove":
            if (event.which === 0) {
              this.pressed = false;
            }
            if (!this.pressed) {
              this._emit(MOVE_EVENT_TYPE, event);
            }
            break;
          case "mouseup":
            this.pressed = false;
            break;
          default:
        }
      }
    }
    _emit(type, event) {
      this.callback({
        type,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    }
  };

  // ../core/node_modules/mjolnir.js/dist/esm/inputs/key-input.js
  var { KEY_EVENTS } = INPUT_EVENT_TYPES;
  var DOWN_EVENT_TYPE = "keydown";
  var UP_EVENT_TYPE = "keyup";
  var KeyInput = class extends Input {
    constructor(element, callback, options) {
      super(element, callback, options);
      this.handleEvent = (event) => {
        const targetElement = event.target || event.srcElement;
        if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") {
          return;
        }
        if (this.enableDownEvent && event.type === "keydown") {
          this.callback({
            type: DOWN_EVENT_TYPE,
            srcEvent: event,
            key: event.key,
            target: event.target
          });
        }
        if (this.enableUpEvent && event.type === "keyup") {
          this.callback({
            type: UP_EVENT_TYPE,
            srcEvent: event,
            key: event.key,
            target: event.target
          });
        }
      };
      this.enableDownEvent = this.options.enable;
      this.enableUpEvent = this.options.enable;
      this.events = (this.options.events || []).concat(KEY_EVENTS);
      element.tabIndex = this.options.tabIndex || 0;
      element.style.outline = "none";
      this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
      this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    enableEventType(eventType, enabled) {
      if (eventType === DOWN_EVENT_TYPE) {
        this.enableDownEvent = enabled;
      }
      if (eventType === UP_EVENT_TYPE) {
        this.enableUpEvent = enabled;
      }
    }
  };

  // ../core/node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js
  var EVENT_TYPE2 = "contextmenu";
  var ContextmenuInput = class extends Input {
    constructor(element, callback, options) {
      super(element, callback, options);
      this.handleEvent = (event) => {
        if (!this.options.enable) {
          return;
        }
        this.callback({
          type: EVENT_TYPE2,
          center: {
            x: event.clientX,
            y: event.clientY
          },
          srcEvent: event,
          pointerType: "mouse",
          target: event.target
        });
      };
      element.addEventListener("contextmenu", this.handleEvent);
    }
    destroy() {
      this.element.removeEventListener("contextmenu", this.handleEvent);
    }
    enableEventType(eventType, enabled) {
      if (eventType === EVENT_TYPE2) {
        this.options.enable = enabled;
      }
    }
  };

  // ../core/node_modules/mjolnir.js/dist/esm/utils/event-utils.js
  var DOWN_EVENT = 1;
  var MOVE_EVENT = 2;
  var UP_EVENT = 4;
  var MOUSE_EVENTS2 = {
    pointerdown: DOWN_EVENT,
    pointermove: MOVE_EVENT,
    pointerup: UP_EVENT,
    mousedown: DOWN_EVENT,
    mousemove: MOVE_EVENT,
    mouseup: UP_EVENT
  };
  var MOUSE_EVENT_WHICH_LEFT = 1;
  var MOUSE_EVENT_WHICH_MIDDLE = 2;
  var MOUSE_EVENT_WHICH_RIGHT = 3;
  var MOUSE_EVENT_BUTTON_LEFT = 0;
  var MOUSE_EVENT_BUTTON_MIDDLE = 1;
  var MOUSE_EVENT_BUTTON_RIGHT = 2;
  var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
  var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
  var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
  function whichButtons(event) {
    const eventType = MOUSE_EVENTS2[event.srcEvent.type];
    if (!eventType) {
      return null;
    }
    const { buttons, button, which } = event.srcEvent;
    let leftButton = false;
    let middleButton = false;
    let rightButton = false;
    if (eventType === UP_EVENT || eventType === MOVE_EVENT && !Number.isFinite(buttons)) {
      leftButton = which === MOUSE_EVENT_WHICH_LEFT;
      middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
      rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
    } else if (eventType === MOVE_EVENT) {
      leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
      middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
      rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
    } else if (eventType === DOWN_EVENT) {
      leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
      middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
      rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
    }
    return { leftButton, middleButton, rightButton };
  }
  function getOffsetPosition(event, rootElement) {
    const center = event.center;
    if (!center) {
      return null;
    }
    const rect = rootElement.getBoundingClientRect();
    const scaleX2 = rect.width / rootElement.offsetWidth || 1;
    const scaleY2 = rect.height / rootElement.offsetHeight || 1;
    const offsetCenter = {
      x: (center.x - rect.left - rootElement.clientLeft) / scaleX2,
      y: (center.y - rect.top - rootElement.clientTop) / scaleY2
    };
    return { center, offsetCenter };
  }

  // ../core/node_modules/mjolnir.js/dist/esm/utils/event-registrar.js
  var DEFAULT_OPTIONS = {
    srcElement: "root",
    priority: 0
  };
  var EventRegistrar = class {
    constructor(eventManager) {
      this.handleEvent = (event) => {
        if (this.isEmpty()) {
          return;
        }
        const mjolnirEvent = this._normalizeEvent(event);
        let target = event.srcEvent.target;
        while (target && target !== mjolnirEvent.rootElement) {
          this._emit(mjolnirEvent, target);
          if (mjolnirEvent.handled) {
            return;
          }
          target = target.parentNode;
        }
        this._emit(mjolnirEvent, "root");
      };
      this.eventManager = eventManager;
      this.handlers = [];
      this.handlersByElement = /* @__PURE__ */ new Map();
      this._active = false;
    }
    isEmpty() {
      return !this._active;
    }
    add(type, handler, options, once = false, passive = false) {
      const { handlers, handlersByElement } = this;
      let opts = DEFAULT_OPTIONS;
      if (typeof options === "string" || options && options.addEventListener) {
        opts = { ...DEFAULT_OPTIONS, srcElement: options };
      } else if (options) {
        opts = { ...DEFAULT_OPTIONS, ...options };
      }
      let entries = handlersByElement.get(opts.srcElement);
      if (!entries) {
        entries = [];
        handlersByElement.set(opts.srcElement, entries);
      }
      const entry = {
        type,
        handler,
        srcElement: opts.srcElement,
        priority: opts.priority
      };
      if (once) {
        entry.once = true;
      }
      if (passive) {
        entry.passive = true;
      }
      handlers.push(entry);
      this._active = this._active || !entry.passive;
      let insertPosition = entries.length - 1;
      while (insertPosition >= 0) {
        if (entries[insertPosition].priority >= entry.priority) {
          break;
        }
        insertPosition--;
      }
      entries.splice(insertPosition + 1, 0, entry);
    }
    remove(type, handler) {
      const { handlers, handlersByElement } = this;
      for (let i3 = handlers.length - 1; i3 >= 0; i3--) {
        const entry = handlers[i3];
        if (entry.type === type && entry.handler === handler) {
          handlers.splice(i3, 1);
          const entries = handlersByElement.get(entry.srcElement);
          entries.splice(entries.indexOf(entry), 1);
          if (entries.length === 0) {
            handlersByElement.delete(entry.srcElement);
          }
        }
      }
      this._active = handlers.some((entry) => !entry.passive);
    }
    _emit(event, srcElement) {
      const entries = this.handlersByElement.get(srcElement);
      if (entries) {
        let immediatePropagationStopped = false;
        const stopPropagation = () => {
          event.handled = true;
        };
        const stopImmediatePropagation = () => {
          event.handled = true;
          immediatePropagationStopped = true;
        };
        const entriesToRemove = [];
        for (let i3 = 0; i3 < entries.length; i3++) {
          const { type, handler, once } = entries[i3];
          handler({
            ...event,
            type,
            stopPropagation,
            stopImmediatePropagation
          });
          if (once) {
            entriesToRemove.push(entries[i3]);
          }
          if (immediatePropagationStopped) {
            break;
          }
        }
        for (let i3 = 0; i3 < entriesToRemove.length; i3++) {
          const { type, handler } = entriesToRemove[i3];
          this.remove(type, handler);
        }
      }
    }
    _normalizeEvent(event) {
      const rootElement = this.eventManager.getElement();
      return {
        ...event,
        ...whichButtons(event),
        ...getOffsetPosition(event, rootElement),
        preventDefault: () => {
          event.srcEvent.preventDefault();
        },
        stopImmediatePropagation: null,
        stopPropagation: null,
        handled: false,
        rootElement
      };
    }
  };

  // ../core/node_modules/mjolnir.js/dist/esm/event-manager.js
  var DEFAULT_OPTIONS2 = {
    events: null,
    recognizers: null,
    recognizerOptions: {},
    Manager,
    touchAction: "none",
    tabIndex: 0
  };
  var EventManager = class {
    constructor(element = null, options) {
      this._onBasicInput = (event) => {
        const { srcEvent } = event;
        const alias = BASIC_EVENT_ALIASES[srcEvent.type];
        if (alias) {
          this.manager.emit(alias, event);
        }
      };
      this._onOtherEvent = (event) => {
        this.manager.emit(event.type, event);
      };
      this.options = { ...DEFAULT_OPTIONS2, ...options };
      this.events = /* @__PURE__ */ new Map();
      this.setElement(element);
      const { events } = this.options;
      if (events) {
        this.on(events);
      }
    }
    getElement() {
      return this.element;
    }
    setElement(element) {
      if (this.element) {
        this.destroy();
      }
      this.element = element;
      if (!element) {
        return;
      }
      const { options } = this;
      const ManagerClass = options.Manager;
      this.manager = new ManagerClass(element, {
        touchAction: options.touchAction,
        recognizers: options.recognizers || RECOGNIZERS
      }).on("hammer.input", this._onBasicInput);
      if (!options.recognizers) {
        Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach((name10) => {
          const recognizer = this.manager.get(name10);
          if (recognizer) {
            RECOGNIZER_COMPATIBLE_MAP[name10].forEach((otherName) => {
              recognizer.recognizeWith(otherName);
            });
          }
        });
      }
      for (const recognizerName in options.recognizerOptions) {
        const recognizer = this.manager.get(recognizerName);
        if (recognizer) {
          const recognizerOption = options.recognizerOptions[recognizerName];
          delete recognizerOption.enable;
          recognizer.set(recognizerOption);
        }
      }
      this.wheelInput = new WheelInput(element, this._onOtherEvent, {
        enable: false
      });
      this.moveInput = new MoveInput(element, this._onOtherEvent, {
        enable: false
      });
      this.keyInput = new KeyInput(element, this._onOtherEvent, {
        enable: false,
        tabIndex: options.tabIndex
      });
      this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
        enable: false
      });
      for (const [eventAlias, eventRegistrar] of this.events) {
        if (!eventRegistrar.isEmpty()) {
          this._toggleRecognizer(eventRegistrar.recognizerName, true);
          this.manager.on(eventAlias, eventRegistrar.handleEvent);
        }
      }
    }
    destroy() {
      if (this.element) {
        this.wheelInput.destroy();
        this.moveInput.destroy();
        this.keyInput.destroy();
        this.contextmenuInput.destroy();
        this.manager.destroy();
        this.wheelInput = null;
        this.moveInput = null;
        this.keyInput = null;
        this.contextmenuInput = null;
        this.manager = null;
        this.element = null;
      }
    }
    on(event, handler, opts) {
      this._addEventHandler(event, handler, opts, false);
    }
    once(event, handler, opts) {
      this._addEventHandler(event, handler, opts, true);
    }
    watch(event, handler, opts) {
      this._addEventHandler(event, handler, opts, false, true);
    }
    off(event, handler) {
      this._removeEventHandler(event, handler);
    }
    _toggleRecognizer(name10, enabled) {
      const { manager } = this;
      if (!manager) {
        return;
      }
      const recognizer = manager.get(name10);
      if (recognizer && recognizer.options.enable !== enabled) {
        recognizer.set({ enable: enabled });
        const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name10];
        if (fallbackRecognizers && !this.options.recognizers) {
          fallbackRecognizers.forEach((otherName) => {
            const otherRecognizer = manager.get(otherName);
            if (enabled) {
              otherRecognizer.requireFailure(name10);
              recognizer.dropRequireFailure(otherName);
            } else {
              otherRecognizer.dropRequireFailure(name10);
            }
          });
        }
      }
      this.wheelInput.enableEventType(name10, enabled);
      this.moveInput.enableEventType(name10, enabled);
      this.keyInput.enableEventType(name10, enabled);
      this.contextmenuInput.enableEventType(name10, enabled);
    }
    _addEventHandler(event, handler, opts, once, passive) {
      if (typeof event !== "string") {
        opts = handler;
        for (const eventName in event) {
          this._addEventHandler(eventName, event[eventName], opts, once, passive);
        }
        return;
      }
      const { manager, events } = this;
      const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
      let eventRegistrar = events.get(eventAlias);
      if (!eventRegistrar) {
        eventRegistrar = new EventRegistrar(this);
        events.set(eventAlias, eventRegistrar);
        eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
        if (manager) {
          manager.on(eventAlias, eventRegistrar.handleEvent);
        }
      }
      eventRegistrar.add(event, handler, opts, once, passive);
      if (!eventRegistrar.isEmpty()) {
        this._toggleRecognizer(eventRegistrar.recognizerName, true);
      }
    }
    _removeEventHandler(event, handler) {
      if (typeof event !== "string") {
        for (const eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
        return;
      }
      const { events } = this;
      const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
      const eventRegistrar = events.get(eventAlias);
      if (!eventRegistrar) {
        return;
      }
      eventRegistrar.remove(event, handler);
      if (eventRegistrar.isEmpty()) {
        const { recognizerName } = eventRegistrar;
        let isRecognizerUsed = false;
        for (const eh of events.values()) {
          if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
            isRecognizerUsed = true;
            break;
          }
        }
        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }
  };

  // ../core/src/lib/deck.ts
  function noop4() {
  }
  var getCursor = ({
    isDragging
  }) => isDragging ? "grabbing" : "grab";
  var defaultProps = {
    id: "",
    width: "100%",
    height: "100%",
    style: null,
    viewState: null,
    initialViewState: null,
    pickingRadius: 0,
    layerFilter: null,
    glOptions: {},
    parameters: {},
    parent: null,
    gl: null,
    canvas: null,
    layers: [],
    effects: [],
    views: null,
    controller: null,
    useDevicePixels: true,
    touchAction: "none",
    eventRecognizerOptions: {},
    _framebuffer: null,
    _animate: false,
    _pickable: true,
    _typedArrayManagerProps: {},
    _customRender: null,
    onWebGLInitialized: noop4,
    onResize: noop4,
    onViewStateChange: noop4,
    onInteractionStateChange: noop4,
    onBeforeRender: noop4,
    onAfterRender: noop4,
    onLoad: noop4,
    onError: (error2) => log_default.error(error2.message)(),
    onHover: null,
    onClick: null,
    onDragStart: null,
    onDrag: null,
    onDragEnd: null,
    _onMetrics: null,
    getCursor,
    getTooltip: null,
    debug: false,
    drawPickingColors: false
  };
  var Deck = class {
    width = 0;
    height = 0;
    userData = {};
    canvas = null;
    viewManager = null;
    layerManager = null;
    effectManager = null;
    deckRenderer = null;
    deckPicker = null;
    eventManager = null;
    tooltip = null;
    _lastPointerDownInfo = null;
    constructor(props) {
      this.props = {
        ...defaultProps,
        ...props
      };
      props = this.props;
      this._needsRedraw = "Initial render";
      this._pickRequest = {
        mode: "hover",
        x: -1,
        y: -1,
        radius: 0,
        event: null
      };
      this.cursorState = {
        isHovering: false,
        isDragging: false
      };
      if (props.viewState && props.initialViewState) {
        log_default.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")();
      }
      if (getBrowser() === "IE") {
        log_default.warn("IE 11 is not supported")();
      }
      this.viewState = props.initialViewState;
      if (!props.gl) {
        if (typeof document !== "undefined") {
          this.canvas = this._createCanvas(props);
        }
      }
      this.animationLoop = this._createAnimationLoop(props);
      this.stats = new Stats2({
        id: "deck.gl"
      });
      this.metrics = {
        fps: 0,
        setPropsTime: 0,
        updateAttributesTime: 0,
        framesRedrawn: 0,
        pickTime: 0,
        pickCount: 0,
        gpuTime: 0,
        gpuTimePerFrame: 0,
        cpuTime: 0,
        cpuTimePerFrame: 0,
        bufferMemory: 0,
        textureMemory: 0,
        renderbufferMemory: 0,
        gpuMemory: 0
      };
      this._metricsCounter = 0;
      this.setProps(props);
      if (props._typedArrayManagerProps) {
        typed_array_manager_default.setOptions(props._typedArrayManagerProps);
      }
      this.animationLoop.start();
    }
    finalize() {
      this.animationLoop?.stop();
      this.animationLoop = null;
      this._lastPointerDownInfo = null;
      this.layerManager?.finalize();
      this.layerManager = null;
      this.viewManager?.finalize();
      this.viewManager = null;
      this.effectManager?.finalize();
      this.effectManager = null;
      this.deckRenderer?.finalize();
      this.deckRenderer = null;
      this.deckPicker?.finalize();
      this.deckPicker = null;
      this.eventManager?.destroy();
      this.eventManager = null;
      this.tooltip?.remove();
      this.tooltip = null;
      if (!this.props.canvas && !this.props.gl && this.canvas) {
        this.canvas.parentElement?.removeChild(this.canvas);
        this.canvas = null;
      }
    }
    setProps(props) {
      this.stats.get("setProps Time").timeStart();
      if ("onLayerHover" in props) {
        log_default.removed("onLayerHover", "onHover")();
      }
      if ("onLayerClick" in props) {
        log_default.removed("onLayerClick", "onClick")();
      }
      if (props.initialViewState && !deepEqual(this.props.initialViewState, props.initialViewState, 3)) {
        this.viewState = props.initialViewState;
      }
      Object.assign(this.props, props);
      this._setCanvasSize(this.props);
      const resolvedProps = Object.create(this.props);
      Object.assign(resolvedProps, {
        views: this._getViews(),
        width: this.width,
        height: this.height,
        viewState: this._getViewState()
      });
      this.animationLoop.setProps(resolvedProps);
      if (this.layerManager) {
        this.viewManager.setProps(resolvedProps);
        this.layerManager.activateViewport(this.getViewports()[0]);
        this.layerManager.setProps(resolvedProps);
        this.effectManager.setProps(resolvedProps);
        this.deckRenderer.setProps(resolvedProps);
        this.deckPicker.setProps(resolvedProps);
      }
      this.stats.get("setProps Time").timeEnd();
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      if (!this.layerManager) {
        return false;
      }
      if (this.props._animate) {
        return "Deck._animate";
      }
      let redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
      const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
      const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
      const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
      redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
      return redraw;
    }
    redraw(reason) {
      if (!this.layerManager) {
        return;
      }
      let redrawReason = this.needsRedraw({
        clearRedrawFlags: true
      });
      redrawReason = reason || redrawReason;
      if (!redrawReason) {
        return;
      }
      this.stats.get("Redraw Count").incrementCount();
      if (this.props._customRender) {
        this.props._customRender(redrawReason);
      } else {
        this._drawLayers(redrawReason);
      }
    }
    get isInitialized() {
      return this.viewManager !== null;
    }
    getViews() {
      assert11(this.viewManager);
      return this.viewManager.views;
    }
    getViewports(rect) {
      assert11(this.viewManager);
      return this.viewManager.getViewports(rect);
    }
    pickObject(opts) {
      const infos = this._pick("pickObject", "pickObject Time", opts).result;
      return infos.length ? infos[0] : null;
    }
    pickMultipleObjects(opts) {
      opts.depth = opts.depth || 10;
      return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
    }
    pickObjects(opts) {
      return this._pick("pickObjects", "pickObjects Time", opts);
    }
    _addResources(resources, forceUpdate = false) {
      for (const id in resources) {
        this.layerManager.resourceManager.add({
          resourceId: id,
          data: resources[id],
          forceUpdate
        });
      }
    }
    _removeResources(resourceIds) {
      for (const id of resourceIds) {
        this.layerManager.resourceManager.remove(id);
      }
    }
    _addDefaultEffect(effect) {
      this.effectManager.addDefaultEffect(effect);
    }
    _pick(method, statKey, opts) {
      assert11(this.deckPicker);
      const {
        stats
      } = this;
      stats.get("Pick Count").incrementCount();
      stats.get(statKey).timeStart();
      const infos = this.deckPicker[method]({
        layers: this.layerManager.getLayers(opts),
        views: this.viewManager.getViews(),
        viewports: this.getViewports(opts),
        onViewportActive: this.layerManager.activateViewport,
        effects: this.effectManager.getEffects(),
        ...opts
      });
      stats.get(statKey).timeEnd();
      return infos;
    }
    _createCanvas(props) {
      let canvas = props.canvas;
      if (typeof canvas === "string") {
        canvas = document.getElementById(canvas);
        assert11(canvas);
      }
      if (!canvas) {
        canvas = document.createElement("canvas");
        canvas.id = props.id || "deckgl-overlay";
        const parent = props.parent || document.body;
        parent.appendChild(canvas);
      }
      Object.assign(canvas.style, props.style);
      return canvas;
    }
    _setCanvasSize(props) {
      if (!this.canvas) {
        return;
      }
      const {
        width,
        height
      } = props;
      if (width || width === 0) {
        const cssWidth = Number.isFinite(width) ? `${width}px` : width;
        this.canvas.style.width = cssWidth;
      }
      if (height || height === 0) {
        const cssHeight = Number.isFinite(height) ? `${height}px` : height;
        this.canvas.style.position = props.style?.position || "absolute";
        this.canvas.style.height = cssHeight;
      }
    }
    _updateCanvasSize() {
      const {
        canvas
      } = this;
      if (!canvas) {
        return;
      }
      const newWidth = canvas.clientWidth ?? canvas.width;
      const newHeight = canvas.clientHeight ?? canvas.height;
      if (newWidth !== this.width || newHeight !== this.height) {
        this.width = newWidth;
        this.height = newHeight;
        this.viewManager?.setProps({
          width: newWidth,
          height: newHeight
        });
        this.layerManager?.activateViewport(this.getViewports()[0]);
        this.props.onResize({
          width: newWidth,
          height: newHeight
        });
      }
    }
    _createAnimationLoop(props) {
      const {
        width,
        height,
        gl,
        glOptions,
        debug: debug2,
        onError,
        onBeforeRender,
        onAfterRender,
        useDevicePixels
      } = props;
      return new AnimationLoop({
        width,
        height,
        useDevicePixels,
        autoResizeDrawingBuffer: !gl,
        autoResizeViewport: false,
        gl,
        onCreateContext: (opts) => createGLContext({
          ...glOptions,
          ...opts,
          canvas: this.canvas,
          debug: debug2,
          onContextLost: () => this._onContextLost()
        }),
        onInitialize: (context) => this._setGLContext(context.gl),
        onRender: this._onRenderFrame.bind(this),
        onBeforeRender,
        onAfterRender,
        onError
      });
    }
    _getViewState() {
      return this.props.viewState || this.viewState;
    }
    _getViews() {
      let views = this.props.views || [new MapView({
        id: "default-view"
      })];
      views = Array.isArray(views) ? views : [views];
      if (views.length && this.props.controller) {
        views[0].props.controller = this.props.controller;
      }
      return views;
    }
    _onContextLost() {
      const {
        onError
      } = this.props;
      if (this.animationLoop && onError) {
        onError(new Error("WebGL context is lost"));
      }
    }
    _onPointerMove = (event) => {
      const {
        _pickRequest
      } = this;
      if (event.type === "pointerleave") {
        _pickRequest.x = -1;
        _pickRequest.y = -1;
        _pickRequest.radius = 0;
      } else if (event.leftButton || event.rightButton) {
        return;
      } else {
        const pos = event.offsetCenter;
        if (!pos) {
          return;
        }
        _pickRequest.x = pos.x;
        _pickRequest.y = pos.y;
        _pickRequest.radius = this.props.pickingRadius;
      }
      if (this.layerManager) {
        this.layerManager.context.mousePosition = {
          x: _pickRequest.x,
          y: _pickRequest.y
        };
      }
      _pickRequest.event = event;
    };
    _pickAndCallback() {
      const {
        _pickRequest
      } = this;
      if (_pickRequest.event) {
        const {
          result,
          emptyInfo
        } = this._pick("pickObject", "pickObject Time", _pickRequest);
        this.cursorState.isHovering = result.length > 0;
        let pickedInfo = emptyInfo;
        let handled = false;
        for (const info of result) {
          pickedInfo = info;
          handled = info.layer?.onHover(info, _pickRequest.event) || handled;
        }
        if (!handled && this.props.onHover) {
          this.props.onHover(pickedInfo, _pickRequest.event);
        }
        if (this.props.getTooltip && this.tooltip) {
          const displayInfo = this.props.getTooltip(pickedInfo);
          this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);
        }
        _pickRequest.event = null;
      }
    }
    _updateCursor() {
      const container = this.props.parent || this.canvas;
      if (container) {
        container.style.cursor = this.props.getCursor(this.cursorState);
      }
    }
    _setGLContext(gl) {
      if (this.layerManager) {
        return;
      }
      if (!this.canvas) {
        this.canvas = gl.canvas;
        instrumentGLContext(gl, {
          enable: true,
          copyState: true
        });
      }
      this.tooltip = new Tooltip(this.canvas);
      setParameters(gl, {
        blend: true,
        blendFunc: [esm_default2.SRC_ALPHA, esm_default2.ONE_MINUS_SRC_ALPHA, esm_default2.ONE, esm_default2.ONE_MINUS_SRC_ALPHA],
        polygonOffsetFill: true,
        depthTest: true,
        depthFunc: esm_default2.LEQUAL
      });
      this.props.onWebGLInitialized(gl);
      const timeline = new Timeline();
      timeline.play();
      this.animationLoop.attachTimeline(timeline);
      this.eventManager = new EventManager(this.props.parent || gl.canvas, {
        touchAction: this.props.touchAction,
        recognizerOptions: this.props.eventRecognizerOptions,
        events: {
          pointerdown: this._onPointerDown,
          pointermove: this._onPointerMove,
          pointerleave: this._onPointerMove
        }
      });
      for (const eventType in EVENTS) {
        this.eventManager.on(eventType, this._onEvent);
      }
      this.viewManager = new ViewManager({
        timeline,
        eventManager: this.eventManager,
        onViewStateChange: this._onViewStateChange.bind(this),
        onInteractionStateChange: this._onInteractionStateChange.bind(this),
        views: this._getViews(),
        viewState: this._getViewState(),
        width: this.width,
        height: this.height
      });
      const viewport = this.viewManager.getViewports()[0];
      this.layerManager = new LayerManager(gl, {
        deck: this,
        stats: this.stats,
        viewport,
        timeline
      });
      this.effectManager = new EffectManager();
      this.deckRenderer = new DeckRenderer(gl);
      this.deckPicker = new DeckPicker(gl);
      this.setProps(this.props);
      this._updateCanvasSize();
      this.props.onLoad();
    }
    _drawLayers(redrawReason, renderOptions) {
      const {
        gl
      } = this.layerManager.context;
      setParameters(gl, this.props.parameters);
      this.props.onBeforeRender({
        gl
      });
      this.deckRenderer.renderLayers({
        target: this.props._framebuffer,
        layers: this.layerManager.getLayers(),
        viewports: this.viewManager.getViewports(),
        onViewportActive: this.layerManager.activateViewport,
        views: this.viewManager.getViews(),
        pass: "screen",
        effects: this.effectManager.getEffects(),
        ...renderOptions
      });
      this.props.onAfterRender({
        gl
      });
    }
    _onRenderFrame(animationProps) {
      this._getFrameStats();
      if (this._metricsCounter++ % 60 === 0) {
        this._getMetrics();
        this.stats.reset();
        log_default.table(4, this.metrics)();
        if (this.props._onMetrics) {
          this.props._onMetrics(this.metrics);
        }
      }
      this._updateCanvasSize();
      this._updateCursor();
      if (this.tooltip.isVisible && this.viewManager.needsRedraw()) {
        this.tooltip.setTooltip(null);
      }
      this.layerManager.updateLayers();
      this._pickAndCallback();
      this.redraw();
      if (this.viewManager) {
        this.viewManager.updateViewStates();
      }
    }
    _onViewStateChange(params) {
      const viewState = this.props.onViewStateChange(params) || params.viewState;
      if (this.viewState) {
        this.viewState = {
          ...this.viewState,
          [params.viewId]: viewState
        };
        if (!this.props.viewState) {
          if (this.viewManager) {
            this.viewManager.setProps({
              viewState: this.viewState
            });
          }
        }
      }
    }
    _onInteractionStateChange(interactionState) {
      this.cursorState.isDragging = interactionState.isDragging || false;
      this.props.onInteractionStateChange(interactionState);
    }
    _onEvent = (event) => {
      const eventOptions = EVENTS[event.type];
      const pos = event.offsetCenter;
      if (!eventOptions || !pos || !this.layerManager) {
        return;
      }
      const layers = this.layerManager.getLayers();
      const info = this.deckPicker.getLastPickedObject({
        x: pos.x,
        y: pos.y,
        layers,
        viewports: this.getViewports(pos)
      }, this._lastPointerDownInfo);
      const {
        layer
      } = info;
      const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
      const rootHandler = this.props[eventOptions.handler];
      let handled = false;
      if (layerHandler) {
        handled = layerHandler.call(layer, info, event);
      }
      if (!handled && rootHandler) {
        rootHandler(info, event);
      }
    };
    _onPointerDown = (event) => {
      const pos = event.offsetCenter;
      const pickedInfo = this._pick("pickObject", "pickObject Time", {
        x: pos.x,
        y: pos.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
    };
    _getFrameStats() {
      const {
        stats
      } = this;
      stats.get("frameRate").timeEnd();
      stats.get("frameRate").timeStart();
      const animationLoopStats = this.animationLoop.stats;
      stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
      stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
    }
    _getMetrics() {
      const {
        metrics,
        stats
      } = this;
      metrics.fps = stats.get("frameRate").getHz();
      metrics.setPropsTime = stats.get("setProps Time").time;
      metrics.updateAttributesTime = stats.get("Update Attributes").time;
      metrics.framesRedrawn = stats.get("Redraw Count").count;
      metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
      metrics.pickCount = stats.get("Pick Count").count;
      metrics.gpuTime = stats.get("GPU Time").time;
      metrics.cpuTime = stats.get("CPU Time").time;
      metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
      metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
      const memoryStats = lumaStats.get("Memory Usage");
      metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
      metrics.textureMemory = memoryStats.get("Texture Memory").count;
      metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
      metrics.gpuMemory = memoryStats.get("GPU Memory").count;
    }
  };
  __publicField(Deck, "defaultProps", defaultProps);
  __publicField(Deck, "VERSION", VERSION6);

  // ../core/src/lib/attribute/shader-attribute.ts
  var ShaderAttribute = class {
    constructor(dataColumn, opts) {
      this.opts = opts;
      this.source = dataColumn;
    }
    get value() {
      return this.source.value;
    }
    getValue() {
      const buffer = this.source.getBuffer();
      const accessor = this.getAccessor();
      if (buffer) {
        return [buffer, accessor];
      }
      const {
        value
      } = this.source;
      const {
        size
      } = accessor;
      let constantValue = value;
      if (value && value.length !== size) {
        constantValue = new Float32Array(size);
        const index = accessor.elementOffset || 0;
        for (let i3 = 0; i3 < size; ++i3) {
          constantValue[i3] = value[index + i3];
        }
      }
      return constantValue;
    }
    getAccessor() {
      return {
        ...this.source.getAccessor(),
        ...this.opts
      };
    }
  };

  // ../core/src/lib/attribute/gl-utils.ts
  function glArrayFromType(glType) {
    switch (glType) {
      case esm_default2.FLOAT:
        return Float32Array;
      case esm_default2.DOUBLE:
        return Float64Array;
      case esm_default2.UNSIGNED_SHORT:
      case esm_default2.UNSIGNED_SHORT_5_6_5:
      case esm_default2.UNSIGNED_SHORT_4_4_4_4:
      case esm_default2.UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;
      case esm_default2.UNSIGNED_INT:
        return Uint32Array;
      case esm_default2.UNSIGNED_BYTE:
        return Uint8ClampedArray;
      case esm_default2.BYTE:
        return Int8Array;
      case esm_default2.SHORT:
        return Int16Array;
      case esm_default2.INT:
        return Int32Array;
      default:
        throw new Error("Unknown GL type");
    }
  }

  // ../core/src/lib/attribute/data-column.ts
  function getStride(accessor) {
    return accessor.stride || accessor.size * accessor.bytesPerElement;
  }
  function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
    if (shaderAttributeOptions.offset) {
      log_default.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
    }
    const stride = getStride(baseAccessor);
    const vertexOffset = shaderAttributeOptions.vertexOffset !== void 0 ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
    const elementOffset = shaderAttributeOptions.elementOffset || 0;
    const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
    return {
      ...shaderAttributeOptions,
      offset,
      stride
    };
  }
  function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
    const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
    return {
      high: resolvedOptions,
      low: {
        ...resolvedOptions,
        offset: resolvedOptions.offset + baseAccessor.size * 4
      }
    };
  }
  var DataColumn = class {
    constructor(gl, opts, state) {
      this.gl = gl;
      this.id = opts.id || "";
      this.size = opts.size || 1;
      const logicalType = opts.logicalType || opts.type;
      const doublePrecision = logicalType === esm_default2.DOUBLE;
      let {
        defaultValue: defaultValue2
      } = opts;
      defaultValue2 = Number.isFinite(defaultValue2) ? [defaultValue2] : defaultValue2 || new Array(this.size).fill(0);
      let bufferType;
      if (doublePrecision) {
        bufferType = esm_default2.FLOAT;
      } else if (!logicalType && opts.isIndexed) {
        bufferType = gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? esm_default2.UNSIGNED_INT : esm_default2.UNSIGNED_SHORT;
      } else {
        bufferType = logicalType || esm_default2.FLOAT;
      }
      let defaultType = glArrayFromType(logicalType || bufferType || esm_default2.FLOAT);
      this.doublePrecision = doublePrecision;
      if (doublePrecision && opts.fp64 === false) {
        defaultType = Float32Array;
      }
      this.value = null;
      this.settings = {
        ...opts,
        defaultType,
        defaultValue: defaultValue2,
        logicalType,
        type: bufferType,
        size: this.size,
        bytesPerElement: defaultType.BYTES_PER_ELEMENT
      };
      this.state = {
        ...state,
        externalBuffer: null,
        bufferAccessor: this.settings,
        allocatedValue: null,
        numInstances: 0,
        bounds: null,
        constant: false
      };
      this._buffer = null;
    }
    get isConstant() {
      return this.state.constant;
    }
    get buffer() {
      if (!this._buffer) {
        const {
          isIndexed,
          type
        } = this.settings;
        this._buffer = new Buffer2(this.gl, {
          id: this.id,
          target: isIndexed ? esm_default2.ELEMENT_ARRAY_BUFFER : esm_default2.ARRAY_BUFFER,
          accessor: {
            type
          }
        });
      }
      return this._buffer;
    }
    get byteOffset() {
      const accessor = this.getAccessor();
      if (accessor.vertexOffset) {
        return accessor.vertexOffset * getStride(accessor);
      }
      return 0;
    }
    get numInstances() {
      return this.state.numInstances;
    }
    set numInstances(n2) {
      this.state.numInstances = n2;
    }
    delete() {
      if (this._buffer) {
        this._buffer.delete();
        this._buffer = null;
      }
      typed_array_manager_default.release(this.state.allocatedValue);
    }
    getShaderAttributes(id, options) {
      if (this.doublePrecision) {
        const shaderAttributes = {};
        const isBuffer64Bit = this.value instanceof Float64Array;
        const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});
        shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);
        shaderAttributes[`${id}64Low`] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);
        return shaderAttributes;
      }
      if (options) {
        const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
        return {
          [id]: new ShaderAttribute(this, shaderAttributeDef)
        };
      }
      return {
        [id]: this
      };
    }
    getBuffer() {
      if (this.state.constant) {
        return null;
      }
      return this.state.externalBuffer || this._buffer;
    }
    getValue() {
      if (this.state.constant) {
        return this.value;
      }
      return [this.getBuffer(), this.getAccessor()];
    }
    getAccessor() {
      return this.state.bufferAccessor;
    }
    getBounds() {
      if (this.state.bounds) {
        return this.state.bounds;
      }
      let result = null;
      if (this.state.constant && this.value) {
        const min = Array.from(this.value);
        result = [min, min];
      } else {
        const {
          value,
          numInstances,
          size
        } = this;
        const len3 = numInstances * size;
        if (value && len3 && value.length >= len3) {
          const min = new Array(size).fill(Infinity);
          const max = new Array(size).fill(-Infinity);
          for (let i3 = 0; i3 < len3; ) {
            for (let j = 0; j < size; j++) {
              const v = value[i3++];
              if (v < min[j])
                min[j] = v;
              if (v > max[j])
                max[j] = v;
            }
          }
          result = [min, max];
        }
      }
      this.state.bounds = result;
      return result;
    }
    setData(data) {
      const {
        state
      } = this;
      let opts;
      if (ArrayBuffer.isView(data)) {
        opts = {
          value: data
        };
      } else if (data instanceof Buffer2) {
        opts = {
          buffer: data
        };
      } else {
        opts = data;
      }
      const accessor = {
        ...this.settings,
        ...opts
      };
      state.bufferAccessor = accessor;
      state.bounds = null;
      if (opts.constant) {
        let value = opts.value;
        value = this._normalizeValue(value, [], 0);
        if (this.settings.normalized) {
          value = this.normalizeConstant(value);
        }
        const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);
        if (!hasChanged) {
          return false;
        }
        state.externalBuffer = null;
        state.constant = true;
        this.value = value;
      } else if (opts.buffer) {
        const buffer = opts.buffer;
        state.externalBuffer = buffer;
        state.constant = false;
        this.value = opts.value || null;
        const isBuffer64Bit = opts.value instanceof Float64Array;
        accessor.type = opts.type || buffer.accessor.type;
        accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);
        accessor.stride = getStride(accessor);
      } else if (opts.value) {
        this._checkExternalBuffer(opts);
        let value = opts.value;
        state.externalBuffer = null;
        state.constant = false;
        this.value = value;
        accessor.bytesPerElement = value.BYTES_PER_ELEMENT;
        accessor.stride = getStride(accessor);
        const {
          buffer,
          byteOffset
        } = this;
        if (this.doublePrecision && value instanceof Float64Array) {
          value = toDoublePrecisionArray(value, accessor);
        }
        const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;
        if (buffer.byteLength < requiredBufferSize) {
          buffer.reallocate(requiredBufferSize);
        }
        buffer.setAccessor(null);
        buffer.subData({
          data: value,
          offset: byteOffset
        });
        accessor.type = opts.type || buffer.accessor.type;
      }
      return true;
    }
    updateSubBuffer(opts = {}) {
      this.state.bounds = null;
      const value = this.value;
      const {
        startOffset = 0,
        endOffset
      } = opts;
      this.buffer.subData({
        data: this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {
          size: this.size,
          startIndex: startOffset,
          endIndex: endOffset
        }) : value.subarray(startOffset, endOffset),
        offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset
      });
    }
    allocate(numInstances, copy3 = false) {
      const {
        state
      } = this;
      const oldValue = state.allocatedValue;
      const value = typed_array_manager_default.allocate(oldValue, numInstances + 1, {
        size: this.size,
        type: this.settings.defaultType,
        copy: copy3
      });
      this.value = value;
      const {
        buffer,
        byteOffset
      } = this;
      if (buffer.byteLength < value.byteLength + byteOffset) {
        buffer.reallocate(value.byteLength + byteOffset);
        if (copy3 && oldValue) {
          buffer.subData({
            data: oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,
            offset: byteOffset
          });
        }
      }
      state.allocatedValue = value;
      state.constant = false;
      state.externalBuffer = null;
      state.bufferAccessor = this.settings;
      return true;
    }
    _checkExternalBuffer(opts) {
      const {
        value
      } = opts;
      if (!ArrayBuffer.isView(value)) {
        throw new Error(`Attribute ${this.id} value is not TypedArray`);
      }
      const ArrayType = this.settings.defaultType;
      let illegalArrayType = false;
      if (this.doublePrecision) {
        illegalArrayType = value.BYTES_PER_ELEMENT < 4;
      }
      if (illegalArrayType) {
        throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);
      }
      if (!(value instanceof ArrayType) && this.settings.normalized && !("normalized" in opts)) {
        log_default.warn(`Attribute ${this.id} is normalized`)();
      }
    }
    normalizeConstant(value) {
      switch (this.settings.type) {
        case esm_default2.BYTE:
          return new Float32Array(value).map((x2) => (x2 + 128) / 255 * 2 - 1);
        case esm_default2.SHORT:
          return new Float32Array(value).map((x2) => (x2 + 32768) / 65535 * 2 - 1);
        case esm_default2.UNSIGNED_BYTE:
          return new Float32Array(value).map((x2) => x2 / 255);
        case esm_default2.UNSIGNED_SHORT:
          return new Float32Array(value).map((x2) => x2 / 65535);
        default:
          return value;
      }
    }
    _normalizeValue(value, out, start) {
      const {
        defaultValue: defaultValue2,
        size
      } = this.settings;
      if (Number.isFinite(value)) {
        out[start] = value;
        return out;
      }
      if (!value) {
        let i3 = size;
        while (--i3 >= 0) {
          out[start + i3] = defaultValue2[i3];
        }
        return out;
      }
      switch (size) {
        case 4:
          out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue2[3];
        case 3:
          out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue2[2];
        case 2:
          out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue2[1];
        case 1:
          out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue2[0];
          break;
        default:
          let i3 = size;
          while (--i3 >= 0) {
            out[start + i3] = Number.isFinite(value[i3]) ? value[i3] : defaultValue2[i3];
          }
      }
      return out;
    }
    _areValuesEqual(value1, value2) {
      if (!value1 || !value2) {
        return false;
      }
      const {
        size
      } = this;
      for (let i3 = 0; i3 < size; i3++) {
        if (value1[i3] !== value2[i3]) {
          return false;
        }
      }
      return true;
    }
  };

  // ../core/src/utils/iterable-utils.ts
  var EMPTY_ARRAY = [];
  var placeholderArray = [];
  function createIterable(data, startRow = 0, endRow = Infinity) {
    let iterable = EMPTY_ARRAY;
    const objectInfo = {
      index: -1,
      data,
      target: []
    };
    if (!data) {
      iterable = EMPTY_ARRAY;
    } else if (typeof data[Symbol.iterator] === "function") {
      iterable = data;
    } else if (data.length > 0) {
      placeholderArray.length = data.length;
      iterable = placeholderArray;
    }
    if (startRow > 0 || Number.isFinite(endRow)) {
      iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
      objectInfo.index = startRow - 1;
    }
    return {
      iterable,
      objectInfo
    };
  }
  function isAsyncIterable2(data) {
    return data && data[Symbol.asyncIterator];
  }
  function getAccessorFromBuffer(typedArray, options) {
    const {
      size,
      stride,
      offset,
      startIndices,
      nested
    } = options;
    const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
    const elementStride = stride ? stride / bytesPerElement : size;
    const elementOffset = offset ? offset / bytesPerElement : 0;
    const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
    return (_, {
      index,
      target
    }) => {
      if (!startIndices) {
        const sourceIndex = index * elementStride + elementOffset;
        for (let j = 0; j < size; j++) {
          target[j] = typedArray[sourceIndex + j];
        }
        return target;
      }
      const startIndex = startIndices[index];
      const endIndex = startIndices[index + 1] || vertexCount;
      let result;
      if (nested) {
        result = new Array(endIndex - startIndex);
        for (let i3 = startIndex; i3 < endIndex; i3++) {
          const sourceIndex = i3 * elementStride + elementOffset;
          target = new Array(size);
          for (let j = 0; j < size; j++) {
            target[j] = typedArray[sourceIndex + j];
          }
          result[i3 - startIndex] = target;
        }
      } else if (elementStride === size) {
        result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
      } else {
        result = new typedArray.constructor((endIndex - startIndex) * size);
        let targetIndex = 0;
        for (let i3 = startIndex; i3 < endIndex; i3++) {
          const sourceIndex = i3 * elementStride + elementOffset;
          for (let j = 0; j < size; j++) {
            result[targetIndex++] = typedArray[sourceIndex + j];
          }
        }
      }
      return result;
    };
  }

  // ../core/src/utils/range.ts
  var EMPTY = [];
  var FULL = [[0, Infinity]];
  function add5(rangeList, range) {
    if (rangeList === FULL) {
      return rangeList;
    }
    if (range[0] < 0) {
      range[0] = 0;
    }
    if (range[0] >= range[1]) {
      return rangeList;
    }
    const newRangeList = [];
    const len3 = rangeList.length;
    let insertPosition = 0;
    for (let i3 = 0; i3 < len3; i3++) {
      const range0 = rangeList[i3];
      if (range0[1] < range[0]) {
        newRangeList.push(range0);
        insertPosition = i3 + 1;
      } else if (range0[0] > range[1]) {
        newRangeList.push(range0);
      } else {
        range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
      }
    }
    newRangeList.splice(insertPosition, 0, range);
    return newRangeList;
  }

  // ../core/src/utils/array-utils.ts
  function padArrayChunk(options) {
    const {
      source,
      target,
      start = 0,
      size,
      getData
    } = options;
    const end = options.end || target.length;
    const sourceLength = source.length;
    const targetLength = end - start;
    if (sourceLength > targetLength) {
      target.set(source.subarray(0, targetLength), start);
      return;
    }
    target.set(source, start);
    if (!getData) {
      return;
    }
    let i3 = sourceLength;
    while (i3 < targetLength) {
      const datum = getData(i3, source);
      for (let j = 0; j < size; j++) {
        target[start + i3] = datum[j] || 0;
        i3++;
      }
    }
  }
  function padArray({
    source,
    target,
    size,
    getData,
    sourceStartIndices,
    targetStartIndices
  }) {
    if (!Array.isArray(targetStartIndices)) {
      padArrayChunk({
        source,
        target,
        size,
        getData
      });
      return target;
    }
    let sourceIndex = 0;
    let targetIndex = 0;
    const getChunkData = getData && ((i3, chunk) => getData(i3 + targetIndex, chunk));
    const n2 = Math.min(sourceStartIndices.length, targetStartIndices.length);
    for (let i3 = 1; i3 < n2; i3++) {
      const nextSourceIndex = sourceStartIndices[i3] * size;
      const nextTargetIndex = targetStartIndices[i3] * size;
      padArrayChunk({
        source: source.subarray(sourceIndex, nextSourceIndex),
        target,
        start: targetIndex,
        end: nextTargetIndex,
        size,
        getData: getChunkData
      });
      sourceIndex = nextSourceIndex;
      targetIndex = nextTargetIndex;
    }
    if (targetIndex < target.length) {
      padArrayChunk({
        source: [],
        target,
        start: targetIndex,
        size,
        getData: getChunkData
      });
    }
    return target;
  }

  // ../core/src/lib/attribute/attribute-transition-utils.ts
  var DEFAULT_TRANSITION_SETTINGS = {
    interpolation: {
      duration: 0,
      easing: (t2) => t2
    },
    spring: {
      stiffness: 0.05,
      damping: 0.5
    }
  };
  function normalizeTransitionSettings(userSettings, layerSettings) {
    if (!userSettings) {
      return null;
    }
    if (Number.isFinite(userSettings)) {
      userSettings = {
        type: "interpolation",
        duration: userSettings
      };
    }
    const type = userSettings.type || "interpolation";
    return {
      ...DEFAULT_TRANSITION_SETTINGS[type],
      ...layerSettings,
      ...userSettings,
      type
    };
  }
  function getSourceBufferAttribute(gl, attribute) {
    const buffer = attribute.getBuffer();
    if (buffer) {
      return [buffer, {
        divisor: 0,
        size: attribute.size,
        normalized: attribute.settings.normalized
      }];
    }
    return attribute.value;
  }
  function getAttributeTypeFromSize(size) {
    switch (size) {
      case 1:
        return "float";
      case 2:
        return "vec2";
      case 3:
        return "vec3";
      case 4:
        return "vec4";
      default:
        throw new Error(`No defined attribute type for size "${size}"`);
    }
  }
  function cycleBuffers(buffers) {
    buffers.push(buffers.shift());
  }
  function getAttributeBufferLength(attribute, numInstances) {
    const {
      doublePrecision,
      settings,
      value,
      size
    } = attribute;
    const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
    return (settings.noAlloc ? value.length : numInstances * size) * multiplier;
  }
  function padBuffer({
    buffer,
    numInstances,
    attribute,
    fromLength,
    fromStartIndices,
    getData = (x2) => x2
  }) {
    const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
    const size = attribute.size * precisionMultiplier;
    const byteOffset = attribute.byteOffset;
    const toStartIndices = attribute.startIndices;
    const hasStartIndices = fromStartIndices && toStartIndices;
    const toLength = getAttributeBufferLength(attribute, numInstances);
    const isConstant = attribute.isConstant;
    if (!hasStartIndices && fromLength >= toLength) {
      return;
    }
    const toData = isConstant ? attribute.value : attribute.getBuffer().getData({
      srcByteOffset: byteOffset
    });
    if (attribute.settings.normalized && !isConstant) {
      const getter = getData;
      getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
    }
    const getMissingData = isConstant ? (i3, chunk) => getData(toData, chunk) : (i3, chunk) => getData(toData.subarray(i3, i3 + size), chunk);
    const source = buffer.getData({
      length: fromLength
    });
    const data = new Float32Array(toLength);
    padArray({
      source,
      target: data,
      sourceStartIndices: fromStartIndices,
      targetStartIndices: toStartIndices,
      size,
      getData: getMissingData
    });
    if (buffer.byteLength < data.byteLength + byteOffset) {
      buffer.reallocate(data.byteLength + byteOffset);
    }
    buffer.subData({
      data,
      offset: byteOffset
    });
  }

  // ../core/src/lib/attribute/attribute.ts
  var Attribute = class extends DataColumn {
    constant = false;
    constructor(gl, opts) {
      super(gl, opts, {
        startIndices: null,
        lastExternalBuffer: null,
        binaryValue: null,
        binaryAccessor: null,
        needsUpdate: true,
        needsRedraw: false,
        updateRanges: FULL
      });
      this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : void 0);
      Object.seal(this.settings);
      Object.seal(this.state);
      this._validateAttributeUpdaters();
    }
    get startIndices() {
      return this.state.startIndices;
    }
    set startIndices(layout) {
      this.state.startIndices = layout;
    }
    needsUpdate() {
      return this.state.needsUpdate;
    }
    needsRedraw({
      clearChangedFlags = false
    } = {}) {
      const needsRedraw = this.state.needsRedraw;
      this.state.needsRedraw = needsRedraw && !clearChangedFlags;
      return needsRedraw;
    }
    getUpdateTriggers() {
      const {
        accessor
      } = this.settings;
      return [this.id].concat(typeof accessor !== "function" && accessor || []);
    }
    supportsTransition() {
      return Boolean(this.settings.transition);
    }
    getTransitionSetting(opts) {
      if (!opts || !this.supportsTransition()) {
        return null;
      }
      const {
        accessor
      } = this.settings;
      const layerSettings = this.settings.transition;
      const userSettings = Array.isArray(accessor) ? opts[accessor.find((a2) => opts[a2])] : opts[accessor];
      return normalizeTransitionSettings(userSettings, layerSettings);
    }
    setNeedsUpdate(reason = this.id, dataRange) {
      this.state.needsUpdate = this.state.needsUpdate || reason;
      this.setNeedsRedraw(reason);
      if (dataRange) {
        const {
          startRow = 0,
          endRow = Infinity
        } = dataRange;
        this.state.updateRanges = add5(this.state.updateRanges, [startRow, endRow]);
      } else {
        this.state.updateRanges = FULL;
      }
    }
    clearNeedsUpdate() {
      this.state.needsUpdate = false;
      this.state.updateRanges = EMPTY;
    }
    setNeedsRedraw(reason = this.id) {
      this.state.needsRedraw = this.state.needsRedraw || reason;
    }
    allocate(numInstances) {
      const {
        state,
        settings
      } = this;
      if (settings.noAlloc) {
        return false;
      }
      if (settings.update) {
        super.allocate(numInstances, state.updateRanges !== FULL);
        return true;
      }
      return false;
    }
    updateBuffer({
      numInstances,
      data,
      props,
      context
    }) {
      if (!this.needsUpdate()) {
        return false;
      }
      const {
        state: {
          updateRanges
        },
        settings: {
          update,
          noAlloc
        }
      } = this;
      let updated = true;
      if (update) {
        for (const [startRow, endRow] of updateRanges) {
          update.call(context, this, {
            data,
            startRow,
            endRow,
            props,
            numInstances
          });
        }
        if (!this.value) {
        } else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
          this.setData({
            value: this.value,
            constant: this.constant
          });
          this.constant = false;
        } else {
          for (const [startRow, endRow] of updateRanges) {
            const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
            const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
            super.updateSubBuffer({
              startOffset,
              endOffset
            });
          }
        }
        this._checkAttributeArray();
      } else {
        updated = false;
      }
      this.clearNeedsUpdate();
      this.setNeedsRedraw();
      return updated;
    }
    setConstantValue(value) {
      if (value === void 0 || typeof value === "function") {
        return false;
      }
      const hasChanged = this.setData({
        constant: true,
        value
      });
      if (hasChanged) {
        this.setNeedsRedraw();
      }
      this.clearNeedsUpdate();
      return true;
    }
    setExternalBuffer(buffer) {
      const {
        state
      } = this;
      if (!buffer) {
        state.lastExternalBuffer = null;
        return false;
      }
      this.clearNeedsUpdate();
      if (state.lastExternalBuffer === buffer) {
        return true;
      }
      state.lastExternalBuffer = buffer;
      this.setNeedsRedraw();
      this.setData(buffer);
      return true;
    }
    setBinaryValue(buffer, startIndices = null) {
      const {
        state,
        settings
      } = this;
      if (!buffer) {
        state.binaryValue = null;
        state.binaryAccessor = null;
        return false;
      }
      if (settings.noAlloc) {
        return false;
      }
      if (state.binaryValue === buffer) {
        this.clearNeedsUpdate();
        return true;
      }
      state.binaryValue = buffer;
      this.setNeedsRedraw();
      const needsUpdate = settings.transform || startIndices !== this.startIndices;
      if (needsUpdate) {
        if (ArrayBuffer.isView(buffer)) {
          buffer = {
            value: buffer
          };
        }
        const binaryValue = buffer;
        assert11(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);
        const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
        state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {
          size: binaryValue.size || this.size,
          stride: binaryValue.stride,
          offset: binaryValue.offset,
          startIndices,
          nested: needsNormalize
        });
        return false;
      }
      this.clearNeedsUpdate();
      this.setData(buffer);
      return true;
    }
    getVertexOffset(row) {
      const {
        startIndices
      } = this;
      const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;
      return vertexIndex * this.size;
    }
    getShaderAttributes() {
      const shaderAttributeDefs = this.settings.shaderAttributes || {
        [this.id]: null
      };
      const shaderAttributes = {};
      for (const shaderAttributeName in shaderAttributeDefs) {
        Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
      }
      return shaderAttributes;
    }
    _autoUpdater(attribute, {
      data,
      startRow,
      endRow,
      props,
      numInstances
    }) {
      if (attribute.constant) {
        return;
      }
      const {
        settings,
        state,
        value,
        size,
        startIndices
      } = attribute;
      const {
        accessor,
        transform: transform3
      } = settings;
      const accessorFunc = state.binaryAccessor || (typeof accessor === "function" ? accessor : props[accessor]);
      assert11(typeof accessorFunc === "function", `accessor "${accessor}" is not a function`);
      let i3 = attribute.getVertexOffset(startRow);
      const {
        iterable,
        objectInfo
      } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        let objectValue = accessorFunc(object, objectInfo);
        if (transform3) {
          objectValue = transform3.call(this, objectValue);
        }
        if (startIndices) {
          const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
          if (objectValue && Array.isArray(objectValue[0])) {
            let startIndex = i3;
            for (const item of objectValue) {
              attribute._normalizeValue(item, value, startIndex);
              startIndex += size;
            }
          } else if (objectValue && objectValue.length > size) {
            value.set(objectValue, i3);
          } else {
            attribute._normalizeValue(objectValue, objectInfo.target, 0);
            fillArray2({
              target: value,
              source: objectInfo.target,
              start: i3,
              count: numVertices
            });
          }
          i3 += numVertices * size;
        } else {
          attribute._normalizeValue(objectValue, value, i3);
          i3 += size;
        }
      }
    }
    _validateAttributeUpdaters() {
      const {
        settings
      } = this;
      const hasUpdater = settings.noAlloc || typeof settings.update === "function";
      if (!hasUpdater) {
        throw new Error(`Attribute ${this.id} missing update or accessor`);
      }
    }
    _checkAttributeArray() {
      const {
        value
      } = this;
      const limit = Math.min(4, this.size);
      if (value && value.length >= limit) {
        let valid = true;
        switch (limit) {
          case 4:
            valid = valid && Number.isFinite(value[3]);
          case 3:
            valid = valid && Number.isFinite(value[2]);
          case 2:
            valid = valid && Number.isFinite(value[1]);
          case 1:
            valid = valid && Number.isFinite(value[0]);
            break;
          default:
            valid = false;
        }
        if (!valid) {
          throw new Error(`Illegal attribute generated for ${this.id}`);
        }
      }
    }
  };

  // ../core/src/transitions/gpu-interpolation-transition.ts
  var GPUInterpolationTransition = class {
    type = "interpolation";
    constructor({
      gl,
      attribute,
      timeline
    }) {
      this.gl = gl;
      this.transition = new Transition(timeline);
      this.attribute = attribute;
      this.attributeInTransition = new Attribute(gl, attribute.settings);
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = 0;
      this.transform = getTransform(gl, attribute);
      const bufferOpts = {
        byteLength: 0,
        usage: esm_default2.DYNAMIC_COPY
      };
      this.buffers = [
        new Buffer2(gl, bufferOpts),
        new Buffer2(gl, bufferOpts)
      ];
    }
    get inProgress() {
      return this.transition.inProgress;
    }
    start(transitionSettings, numInstances) {
      if (transitionSettings.duration <= 0) {
        this.transition.cancel();
        return;
      }
      this.settings = transitionSettings;
      const {
        gl,
        buffers,
        attribute
      } = this;
      cycleBuffers(buffers);
      const padBufferOpts = {
        numInstances,
        attribute,
        fromLength: this.currentLength,
        fromStartIndices: this.currentStartIndices,
        getData: transitionSettings.enter
      };
      for (const buffer of buffers) {
        padBuffer({
          buffer,
          ...padBufferOpts
        });
      }
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = getAttributeBufferLength(attribute, numInstances);
      this.attributeInTransition.setData({
        buffer: buffers[1],
        value: attribute.value
      });
      this.transition.start(transitionSettings);
      this.transform.update({
        elementCount: Math.floor(this.currentLength / attribute.size),
        sourceBuffers: {
          aFrom: buffers[0],
          aTo: getSourceBufferAttribute(gl, attribute)
        },
        feedbackBuffers: {
          vCurrent: buffers[1]
        }
      });
    }
    update() {
      const updated = this.transition.update();
      if (updated) {
        const {
          duration,
          easing
        } = this.settings;
        const {
          time
        } = this.transition;
        let t2 = time / duration;
        if (easing) {
          t2 = easing(t2);
        }
        this.transform.run({
          uniforms: {
            time: t2
          }
        });
      }
      return updated;
    }
    cancel() {
      this.transition.cancel();
      this.transform.delete();
      for (const buffer of this.buffers) {
        buffer.delete();
      }
      this.buffers.length = 0;
    }
  };
  var vs6 = `
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
attribute ATTRIBUTE_TYPE aFrom;
attribute ATTRIBUTE_TYPE aTo;
varying ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, time);
  gl_Position = vec4(0.0);
}
`;
  function getTransform(gl, attribute) {
    const attributeType = getAttributeTypeFromSize(attribute.size);
    return new Transform(gl, {
      vs: vs6,
      defines: {
        ATTRIBUTE_TYPE: attributeType
      },
      varyings: ["vCurrent"]
    });
  }

  // ../core/src/transitions/gpu-spring-transition.ts
  var GPUSpringTransition = class {
    type = "spring";
    constructor({
      gl,
      attribute,
      timeline
    }) {
      this.gl = gl;
      this.type = "spring";
      this.transition = new Transition(timeline);
      this.attribute = attribute;
      this.attributeInTransition = new Attribute(gl, {
        ...attribute.settings,
        normalized: false
      });
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = 0;
      this.texture = getTexture(gl);
      this.framebuffer = getFramebuffer2(gl, this.texture);
      this.transform = getTransform2(gl, attribute, this.framebuffer);
      const bufferOpts = {
        byteLength: 0,
        usage: esm_default2.DYNAMIC_COPY
      };
      this.buffers = [
        new Buffer2(gl, bufferOpts),
        new Buffer2(gl, bufferOpts),
        new Buffer2(gl, bufferOpts)
      ];
    }
    get inProgress() {
      return this.transition.inProgress;
    }
    start(transitionSettings, numInstances) {
      const {
        gl,
        buffers,
        attribute
      } = this;
      const padBufferOpts = {
        numInstances,
        attribute,
        fromLength: this.currentLength,
        fromStartIndices: this.currentStartIndices,
        getData: transitionSettings.enter
      };
      for (const buffer of buffers) {
        padBuffer({
          buffer,
          ...padBufferOpts
        });
      }
      this.settings = transitionSettings;
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = getAttributeBufferLength(attribute, numInstances);
      this.attributeInTransition.setData({
        buffer: buffers[1],
        value: attribute.value
      });
      this.transition.start({
        ...transitionSettings,
        duration: Infinity
      });
      this.transform.update({
        elementCount: Math.floor(this.currentLength / attribute.size),
        sourceBuffers: {
          aTo: getSourceBufferAttribute(gl, attribute)
        }
      });
    }
    update() {
      const {
        buffers,
        transform: transform3,
        framebuffer,
        transition
      } = this;
      const updated = transition.update();
      if (!updated) {
        return false;
      }
      const settings = this.settings;
      transform3.update({
        sourceBuffers: {
          aPrev: buffers[0],
          aCur: buffers[1]
        },
        feedbackBuffers: {
          vNext: buffers[2]
        }
      });
      transform3.run({
        framebuffer,
        discard: false,
        clearRenderTarget: true,
        uniforms: {
          stiffness: settings.stiffness,
          damping: settings.damping
        },
        parameters: {
          depthTest: false,
          blend: true,
          viewport: [0, 0, 1, 1],
          blendFunc: [esm_default2.ONE, esm_default2.ONE],
          blendEquation: [esm_default2.MAX, esm_default2.MAX]
        }
      });
      cycleBuffers(buffers);
      this.attributeInTransition.setData({
        buffer: buffers[1],
        value: this.attribute.value
      });
      const isTransitioning = readPixelsToArray(framebuffer)[0] > 0;
      if (!isTransitioning) {
        transition.end();
      }
      return true;
    }
    cancel() {
      this.transition.cancel();
      this.transform.delete();
      for (const buffer of this.buffers) {
        buffer.delete();
      }
      this.buffers.length = 0;
      this.texture.delete();
      this.framebuffer.delete();
    }
  };
  function getTransform2(gl, attribute, framebuffer) {
    const attributeType = getAttributeTypeFromSize(attribute.size);
    return new Transform(gl, {
      framebuffer,
      vs: `
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

uniform float stiffness;
uniform float damping;
attribute ATTRIBUTE_TYPE aPrev;
attribute ATTRIBUTE_TYPE aCur;
attribute ATTRIBUTE_TYPE aTo;
varying ATTRIBUTE_TYPE vNext;
varying float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE spring = delta * stiffness;
  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;
  return spring + damper + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`,
      fs: `
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

varying float vIsTransitioningFlag;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  gl_FragColor = vec4(1.0);
}`,
      defines: {
        ATTRIBUTE_TYPE: attributeType
      },
      varyings: ["vNext"]
    });
  }
  function getTexture(gl) {
    return new Texture2D(gl, {
      data: new Uint8Array(4),
      format: esm_default2.RGBA,
      type: esm_default2.UNSIGNED_BYTE,
      border: 0,
      mipmaps: false,
      dataFormat: esm_default2.RGBA,
      width: 1,
      height: 1
    });
  }
  function getFramebuffer2(gl, texture) {
    return new Framebuffer(gl, {
      id: "spring-transition-is-transitioning-framebuffer",
      width: 1,
      height: 1,
      attachments: {
        [esm_default2.COLOR_ATTACHMENT0]: texture
      }
    });
  }

  // ../core/src/lib/attribute/attribute-transition-manager.ts
  var TRANSITION_TYPES = {
    interpolation: GPUInterpolationTransition,
    spring: GPUSpringTransition
  };
  var AttributeTransitionManager = class {
    constructor(gl, {
      id,
      timeline
    }) {
      this.id = id;
      this.gl = gl;
      this.timeline = timeline;
      this.transitions = {};
      this.needsRedraw = false;
      this.numInstances = 1;
      this.isSupported = Transform.isSupported(gl);
    }
    finalize() {
      for (const attributeName in this.transitions) {
        this._removeTransition(attributeName);
      }
    }
    update({
      attributes,
      transitions,
      numInstances
    }) {
      this.numInstances = numInstances || 1;
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        const settings = attribute.getTransitionSetting(transitions);
        if (!settings)
          continue;
        this._updateAttribute(attributeName, attribute, settings);
      }
      for (const attributeName in this.transitions) {
        const attribute = attributes[attributeName];
        if (!attribute || !attribute.getTransitionSetting(transitions)) {
          this._removeTransition(attributeName);
        }
      }
    }
    hasAttribute(attributeName) {
      const transition = this.transitions[attributeName];
      return transition && transition.inProgress;
    }
    getAttributes() {
      const animatedAttributes = {};
      for (const attributeName in this.transitions) {
        const transition = this.transitions[attributeName];
        if (transition.inProgress) {
          animatedAttributes[attributeName] = transition.attributeInTransition;
        }
      }
      return animatedAttributes;
    }
    run() {
      if (!this.isSupported || this.numInstances === 0) {
        return false;
      }
      for (const attributeName in this.transitions) {
        const updated = this.transitions[attributeName].update();
        if (updated) {
          this.needsRedraw = true;
        }
      }
      const needsRedraw = this.needsRedraw;
      this.needsRedraw = false;
      return needsRedraw;
    }
    _removeTransition(attributeName) {
      this.transitions[attributeName].cancel();
      delete this.transitions[attributeName];
    }
    _updateAttribute(attributeName, attribute, settings) {
      const transition = this.transitions[attributeName];
      let isNew = !transition || transition.type !== settings.type;
      if (isNew) {
        if (!this.isSupported) {
          log_default.warn(`WebGL2 not supported by this browser. Transition for ${attributeName} is disabled.`)();
          return;
        }
        if (transition) {
          this._removeTransition(attributeName);
        }
        const TransitionType = TRANSITION_TYPES[settings.type];
        if (TransitionType) {
          this.transitions[attributeName] = new TransitionType({
            attribute,
            timeline: this.timeline,
            gl: this.gl
          });
        } else {
          log_default.error(`unsupported transition type '${settings.type}'`)();
          isNew = false;
        }
      }
      if (isNew || attribute.needsRedraw()) {
        this.needsRedraw = true;
        this.transitions[attributeName].start(settings, this.numInstances);
      }
    }
  };

  // ../core/src/lib/attribute/attribute-manager.ts
  var TRACE_INVALIDATE = "attributeManager.invalidate";
  var TRACE_UPDATE_START = "attributeManager.updateStart";
  var TRACE_UPDATE_END = "attributeManager.updateEnd";
  var TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
  var TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
  var TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
  var AttributeManager = class {
    mergeBoundsMemoized = memoize(mergeBounds);
    constructor(gl, {
      id = "attribute-manager",
      stats,
      timeline
    } = {}) {
      this.id = id;
      this.gl = gl;
      this.attributes = {};
      this.updateTriggers = {};
      this.needsRedraw = true;
      this.userData = {};
      this.stats = stats;
      this.attributeTransitionManager = new AttributeTransitionManager(gl, {
        id: `${id}-transitions`,
        timeline
      });
      Object.seal(this);
    }
    finalize() {
      for (const attributeName in this.attributes) {
        this.attributes[attributeName].delete();
      }
      this.attributeTransitionManager.finalize();
    }
    getNeedsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      const redraw = this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
      return redraw && this.id;
    }
    setNeedsRedraw() {
      this.needsRedraw = true;
    }
    add(attributes) {
      this._add(attributes);
    }
    addInstanced(attributes) {
      this._add(attributes, {
        instanced: 1
      });
    }
    remove(attributeNameArray) {
      for (const name10 of attributeNameArray) {
        if (this.attributes[name10] !== void 0) {
          this.attributes[name10].delete();
          delete this.attributes[name10];
        }
      }
    }
    invalidate(triggerName, dataRange) {
      const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
      debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
    }
    invalidateAll(dataRange) {
      for (const attributeName in this.attributes) {
        this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
      }
      debug(TRACE_INVALIDATE, this, "all");
    }
    update({
      data,
      numInstances,
      startIndices = null,
      transitions,
      props = {},
      buffers = {},
      context = {}
    }) {
      let updated = false;
      debug(TRACE_UPDATE_START, this);
      if (this.stats) {
        this.stats.get("Update Attributes").timeStart();
      }
      for (const attributeName in this.attributes) {
        const attribute = this.attributes[attributeName];
        const accessorName = attribute.settings.accessor;
        attribute.startIndices = startIndices;
        attribute.numInstances = numInstances;
        if (props[attributeName]) {
          log_default.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();
        }
        if (attribute.setExternalBuffer(buffers[attributeName])) {
        } else if (attribute.setBinaryValue(typeof accessorName === "string" ? buffers[accessorName] : void 0, data.startIndices)) {
        } else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {
        } else if (attribute.needsUpdate()) {
          updated = true;
          this._updateAttribute({
            attribute,
            numInstances,
            data,
            props,
            context
          });
        }
        this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
      }
      if (updated) {
        debug(TRACE_UPDATE_END, this, numInstances);
      }
      if (this.stats) {
        this.stats.get("Update Attributes").timeEnd();
      }
      this.attributeTransitionManager.update({
        attributes: this.attributes,
        numInstances,
        transitions
      });
    }
    updateTransition() {
      const {
        attributeTransitionManager
      } = this;
      const transitionUpdated = attributeTransitionManager.run();
      this.needsRedraw = this.needsRedraw || transitionUpdated;
      return transitionUpdated;
    }
    getAttributes() {
      return this.attributes;
    }
    getBounds(attributeNames) {
      const bounds = attributeNames.map((attributeName) => this.attributes[attributeName]?.getBounds());
      return this.mergeBoundsMemoized(bounds);
    }
    getChangedAttributes(opts = {
      clearChangedFlags: false
    }) {
      const {
        attributes,
        attributeTransitionManager
      } = this;
      const changedAttributes = {
        ...attributeTransitionManager.getAttributes()
      };
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
          changedAttributes[attributeName] = attribute;
        }
      }
      return changedAttributes;
    }
    getShaderAttributes(attributes, excludeAttributes = {}) {
      if (!attributes) {
        attributes = this.getAttributes();
      }
      const shaderAttributes = {};
      for (const attributeName in attributes) {
        if (!excludeAttributes[attributeName]) {
          Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());
        }
      }
      return shaderAttributes;
    }
    _add(attributes, extraProps = {}) {
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);
      }
      this._mapUpdateTriggersToAttributes();
    }
    _createAttribute(name10, attribute, extraProps) {
      const props = {
        ...attribute,
        id: name10,
        size: attribute.isIndexed && 1 || attribute.size || 1,
        divisor: extraProps.instanced ? 1 : attribute.divisor || 0
      };
      return new Attribute(this.gl, props);
    }
    _mapUpdateTriggersToAttributes() {
      const triggers = {};
      for (const attributeName in this.attributes) {
        const attribute = this.attributes[attributeName];
        attribute.getUpdateTriggers().forEach((triggerName) => {
          if (!triggers[triggerName]) {
            triggers[triggerName] = [];
          }
          triggers[triggerName].push(attributeName);
        });
      }
      this.updateTriggers = triggers;
    }
    _invalidateTrigger(triggerName, dataRange) {
      const {
        attributes,
        updateTriggers
      } = this;
      const invalidatedAttributes = updateTriggers[triggerName];
      if (invalidatedAttributes) {
        invalidatedAttributes.forEach((name10) => {
          const attribute = attributes[name10];
          if (attribute) {
            attribute.setNeedsUpdate(attribute.id, dataRange);
          }
        });
      }
      return invalidatedAttributes;
    }
    _updateAttribute(opts) {
      const {
        attribute,
        numInstances
      } = opts;
      debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
      if (attribute.constant) {
        attribute.setConstantValue(attribute.value);
        return;
      }
      if (attribute.allocate(numInstances)) {
        debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
      }
      const updated = attribute.updateBuffer(opts);
      if (updated) {
        this.needsRedraw = true;
        debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
      }
    }
  };

  // ../core/src/transitions/cpu-interpolation-transition.js
  var CPUInterpolationTransition = class extends Transition {
    get value() {
      return this._value;
    }
    _onUpdate() {
      const {
        time,
        settings: {
          fromValue: fromValue2,
          toValue,
          duration,
          easing
        }
      } = this;
      const t2 = easing(time / duration);
      this._value = lerp(fromValue2, toValue, t2);
    }
  };

  // ../core/src/transitions/cpu-spring-transition.js
  var EPSILON5 = 1e-5;
  function updateSpringElement(prev, cur, dest, damping, stiffness) {
    const velocity = cur - prev;
    const delta = dest - cur;
    const spring = delta * stiffness;
    const damper = -velocity * damping;
    return spring + damper + velocity + cur;
  }
  function updateSpring(prev, cur, dest, damping, stiffness) {
    if (Array.isArray(dest)) {
      const next = [];
      for (let i3 = 0; i3 < dest.length; i3++) {
        next[i3] = updateSpringElement(prev[i3], cur[i3], dest[i3], damping, stiffness);
      }
      return next;
    }
    return updateSpringElement(prev, cur, dest, damping, stiffness);
  }
  function distance2(value1, value2) {
    if (Array.isArray(value1)) {
      let distanceSquare = 0;
      for (let i3 = 0; i3 < value1.length; i3++) {
        const d = value1[i3] - value2[i3];
        distanceSquare += d * d;
      }
      return Math.sqrt(distanceSquare);
    }
    return Math.abs(value1 - value2);
  }
  var CPUSpringTransition = class extends Transition {
    get value() {
      return this._currValue;
    }
    _onUpdate() {
      const {
        fromValue: fromValue2,
        toValue,
        damping,
        stiffness
      } = this.settings;
      const {
        _prevValue = fromValue2,
        _currValue = fromValue2
      } = this;
      let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
      const delta = distance2(nextValue, toValue);
      const velocity = distance2(nextValue, _currValue);
      if (delta < EPSILON5 && velocity < EPSILON5) {
        nextValue = toValue;
        this.end();
      }
      this._prevValue = _currValue;
      this._currValue = nextValue;
    }
  };

  // ../core/src/lib/uniform-transition-manager.js
  var TRANSITION_TYPES2 = {
    interpolation: CPUInterpolationTransition,
    spring: CPUSpringTransition
  };
  var UniformTransitionManager = class {
    constructor(timeline) {
      this.transitions = /* @__PURE__ */ new Map();
      this.timeline = timeline;
    }
    get active() {
      return this.transitions.size > 0;
    }
    add(key, fromValue2, toValue, settings) {
      const {
        transitions
      } = this;
      if (transitions.has(key)) {
        const transition2 = transitions.get(key);
        const {
          value = transition2.settings.fromValue
        } = transition2;
        fromValue2 = value;
        this.remove(key);
      }
      settings = normalizeTransitionSettings(settings);
      if (!settings) {
        return;
      }
      const TransitionType = TRANSITION_TYPES2[settings.type];
      if (!TransitionType) {
        log_default.error(`unsupported transition type '${settings.type}'`)();
        return;
      }
      const transition = new TransitionType(this.timeline);
      transition.start({
        ...settings,
        fromValue: fromValue2,
        toValue
      });
      transitions.set(key, transition);
    }
    remove(key) {
      const {
        transitions
      } = this;
      if (transitions.has(key)) {
        transitions.get(key).cancel();
        transitions.delete(key);
      }
    }
    update() {
      const propsInTransition = {};
      for (const [key, transition] of this.transitions) {
        transition.update();
        propsInTransition[key] = transition.value;
        if (!transition.inProgress) {
          this.remove(key);
        }
      }
      return propsInTransition;
    }
    clear() {
      for (const key of this.transitions.keys()) {
        this.remove(key);
      }
    }
  };

  // ../core/src/lifecycle/props.ts
  function validateProps(props) {
    const propTypes2 = props[PROP_TYPES_SYMBOL];
    for (const propName in propTypes2) {
      const propType = propTypes2[propName];
      const {
        validate: validate2
      } = propType;
      if (validate2 && !validate2(props[propName], propType)) {
        throw new Error(`Invalid prop ${propName}: ${props[propName]}`);
      }
    }
  }
  function diffProps(props, oldProps) {
    const propsChangedReason = compareProps({
      newProps: props,
      oldProps,
      propTypes: props[PROP_TYPES_SYMBOL],
      ignoreProps: {
        data: null,
        updateTriggers: null,
        extensions: null,
        transitions: null
      }
    });
    const dataChangedReason = diffDataProps(props, oldProps);
    let updateTriggersChangedReason = false;
    if (!dataChangedReason) {
      updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
    }
    return {
      dataChanged: dataChangedReason,
      propsChanged: propsChangedReason,
      updateTriggersChanged: updateTriggersChangedReason,
      extensionsChanged: diffExtensions(props, oldProps),
      transitionsChanged: diffTransitions(props, oldProps)
    };
  }
  function diffTransitions(props, oldProps) {
    if (!props.transitions) {
      return false;
    }
    const result = {};
    const propTypes2 = props[PROP_TYPES_SYMBOL];
    let changed = false;
    for (const key in props.transitions) {
      const propType = propTypes2[key];
      const type = propType && propType.type;
      const isTransitionable = type === "number" || type === "color" || type === "array";
      if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
        result[key] = true;
        changed = true;
      }
    }
    return changed ? result : false;
  }
  function compareProps({
    newProps,
    oldProps,
    ignoreProps = {},
    propTypes: propTypes2 = {},
    triggerName = "props"
  }) {
    if (oldProps === newProps) {
      return false;
    }
    if (typeof newProps !== "object" || newProps === null) {
      return `${triggerName} changed shallowly`;
    }
    if (typeof oldProps !== "object" || oldProps === null) {
      return `${triggerName} changed shallowly`;
    }
    for (const key of Object.keys(newProps)) {
      if (!(key in ignoreProps)) {
        if (!(key in oldProps)) {
          return `${triggerName}.${key} added`;
        }
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes2[key]);
        if (changed) {
          return `${triggerName}.${key} ${changed}`;
        }
      }
    }
    for (const key of Object.keys(oldProps)) {
      if (!(key in ignoreProps)) {
        if (!(key in newProps)) {
          return `${triggerName}.${key} dropped`;
        }
        if (!Object.hasOwnProperty.call(newProps, key)) {
          const changed = comparePropValues(newProps[key], oldProps[key], propTypes2[key]);
          if (changed) {
            return `${triggerName}.${key} ${changed}`;
          }
        }
      }
    }
    return false;
  }
  function comparePropValues(newProp, oldProp, propType) {
    let equal = propType && propType.equal;
    if (equal && !equal(newProp, oldProp, propType)) {
      return "changed deeply";
    }
    if (!equal) {
      equal = newProp && oldProp && newProp.equals;
      if (equal && !equal.call(newProp, oldProp)) {
        return "changed deeply";
      }
    }
    if (!equal && oldProp !== newProp) {
      return "changed shallowly";
    }
    return null;
  }
  function diffDataProps(props, oldProps) {
    if (oldProps === null) {
      return "oldProps is null, initial diff";
    }
    let dataChanged = false;
    const {
      dataComparator,
      _dataDiff
    } = props;
    if (dataComparator) {
      if (!dataComparator(props.data, oldProps.data)) {
        dataChanged = "Data comparator detected a change";
      }
    } else if (props.data !== oldProps.data) {
      dataChanged = "A new data container was supplied";
    }
    if (dataChanged && _dataDiff) {
      dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
    }
    return dataChanged;
  }
  function diffUpdateTriggers(props, oldProps) {
    if (oldProps === null) {
      return {
        all: true
      };
    }
    if ("all" in props.updateTriggers) {
      const diffReason = diffUpdateTrigger(props, oldProps, "all");
      if (diffReason) {
        return {
          all: true
        };
      }
    }
    const reason = {};
    let changed = false;
    for (const triggerName in props.updateTriggers) {
      if (triggerName !== "all") {
        const diffReason = diffUpdateTrigger(props, oldProps, triggerName);
        if (diffReason) {
          reason[triggerName] = true;
          changed = true;
        }
      }
    }
    return changed ? reason : false;
  }
  function diffExtensions(props, oldProps) {
    if (oldProps === null) {
      return true;
    }
    const oldExtensions = oldProps.extensions;
    const {
      extensions
    } = props;
    if (extensions === oldExtensions) {
      return false;
    }
    if (!oldExtensions || !extensions) {
      return true;
    }
    if (extensions.length !== oldExtensions.length) {
      return true;
    }
    for (let i3 = 0; i3 < extensions.length; i3++) {
      if (!extensions[i3].equals(oldExtensions[i3])) {
        return true;
      }
    }
    return false;
  }
  function diffUpdateTrigger(props, oldProps, triggerName) {
    let newTriggers = props.updateTriggers[triggerName];
    newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
    let oldTriggers = oldProps.updateTriggers[triggerName];
    oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
    const diffReason = compareProps({
      oldProps: oldTriggers,
      newProps: newTriggers,
      triggerName
    });
    return diffReason;
  }

  // ../core/src/utils/count.ts
  var ERR_NOT_OBJECT = "count(): argument not an object";
  var ERR_NOT_CONTAINER = "count(): argument not a container";
  function count(container) {
    if (!isObject2(container)) {
      throw new Error(ERR_NOT_OBJECT);
    }
    if (typeof container.count === "function") {
      return container.count();
    }
    if (Number.isFinite(container.size)) {
      return container.size;
    }
    if (Number.isFinite(container.length)) {
      return container.length;
    }
    if (isPlainObject(container)) {
      return Object.keys(container).length;
    }
    throw new Error(ERR_NOT_CONTAINER);
  }
  function isPlainObject(value) {
    return value !== null && typeof value === "object" && value.constructor === Object;
  }
  function isObject2(value) {
    return value !== null && typeof value === "object";
  }

  // ../core/src/utils/shader.ts
  function mergeShaders(target, source) {
    if (!source) {
      return target;
    }
    const result = {
      ...target,
      ...source
    };
    if ("defines" in source) {
      result.defines = {
        ...target.defines,
        ...source.defines
      };
    }
    if ("modules" in source) {
      result.modules = (target.modules || []).concat(source.modules);
      if (source.modules.some((module2) => module2.name === "project64")) {
        const index = result.modules.findIndex((module2) => module2.name === "project32");
        if (index >= 0) {
          result.modules.splice(index, 1);
        }
      }
    }
    if ("inject" in source) {
      if (!target.inject) {
        result.inject = source.inject;
      } else {
        const mergedInjection = {
          ...target.inject
        };
        for (const key in source.inject) {
          mergedInjection[key] = (mergedInjection[key] || "") + source.inject[key];
        }
        result.inject = mergedInjection;
      }
    }
    return result;
  }

  // ../core/src/utils/texture.ts
  var DEFAULT_TEXTURE_PARAMETERS = {
    [esm_default2.TEXTURE_MIN_FILTER]: esm_default2.LINEAR_MIPMAP_LINEAR,
    [esm_default2.TEXTURE_MAG_FILTER]: esm_default2.LINEAR,
    [esm_default2.TEXTURE_WRAP_S]: esm_default2.CLAMP_TO_EDGE,
    [esm_default2.TEXTURE_WRAP_T]: esm_default2.CLAMP_TO_EDGE
  };
  var internalTextures = {};
  function createTexture(owner, gl, image, parameters2) {
    if (image instanceof Texture2D) {
      return image;
    } else if (image.constructor && image.constructor.name !== "Object") {
      image = {
        data: image
      };
    }
    let specialTextureParameters = null;
    if (image.compressed) {
      specialTextureParameters = {
        [esm_default2.TEXTURE_MIN_FILTER]: image.data.length > 1 ? esm_default2.LINEAR_MIPMAP_NEAREST : esm_default2.LINEAR
      };
    }
    const texture = new Texture2D(gl, {
      ...image,
      parameters: {
        ...DEFAULT_TEXTURE_PARAMETERS,
        ...specialTextureParameters,
        ...parameters2
      }
    });
    internalTextures[texture.id] = owner;
    return texture;
  }
  function destroyTexture(owner, texture) {
    if (!texture || !(texture instanceof Texture2D)) {
      return;
    }
    if (internalTextures[texture.id] === owner) {
      texture.delete();
      delete internalTextures[texture.id];
    }
  }

  // ../core/src/lifecycle/prop-types.ts
  var TYPE_DEFINITIONS2 = {
    boolean: {
      validate(value, propType) {
        return true;
      },
      equal(value1, value2, propType) {
        return Boolean(value1) === Boolean(value2);
      }
    },
    number: {
      validate(value, propType) {
        return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
      }
    },
    color: {
      validate(value, propType) {
        return propType.optional && !value || isArray3(value) && (value.length === 3 || value.length === 4);
      },
      equal(value1, value2, propType) {
        return deepEqual(value1, value2, 1);
      }
    },
    accessor: {
      validate(value, propType) {
        const valueType = getTypeOf2(value);
        return valueType === "function" || valueType === getTypeOf2(propType.value);
      },
      equal(value1, value2, propType) {
        if (typeof value2 === "function") {
          return true;
        }
        return deepEqual(value1, value2, 1);
      }
    },
    array: {
      validate(value, propType) {
        return propType.optional && !value || isArray3(value);
      },
      equal(value1, value2, propType) {
        const {
          compare: compare2
        } = propType;
        const depth = Number.isInteger(compare2) ? compare2 : compare2 ? 1 : 0;
        return compare2 ? deepEqual(value1, value2, depth) : value1 === value2;
      }
    },
    object: {
      equal(value1, value2, propType) {
        if (propType.ignore) {
          return true;
        }
        const {
          compare: compare2
        } = propType;
        const depth = Number.isInteger(compare2) ? compare2 : compare2 ? 1 : 0;
        return compare2 ? deepEqual(value1, value2, depth) : value1 === value2;
      }
    },
    function: {
      validate(value, propType) {
        return propType.optional && !value || typeof value === "function";
      },
      equal(value1, value2, propType) {
        const shouldIgnore = !propType.compare && propType.ignore !== false;
        return shouldIgnore || value1 === value2;
      }
    },
    data: {
      transform: (value, propType, component) => {
        const {
          dataTransform
        } = component.props;
        return dataTransform && value ? dataTransform(value) : value;
      }
    },
    image: {
      transform: (value, propType, component) => {
        const context = component.context;
        if (!context || !context.gl) {
          return null;
        }
        return createTexture(component.id, context.gl, value, {
          ...propType.parameters,
          ...component.props.textureParameters
        });
      },
      release: (value, propType, component) => {
        destroyTexture(component.id, value);
      }
    }
  };
  function parsePropTypes2(propDefs) {
    const propTypes2 = {};
    const defaultProps54 = {};
    const deprecatedProps = {};
    for (const [propName, propDef] of Object.entries(propDefs)) {
      const deprecated = propDef?.deprecatedFor;
      if (deprecated) {
        deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
      } else {
        const propType = parsePropType2(propName, propDef);
        propTypes2[propName] = propType;
        defaultProps54[propName] = propType.value;
      }
    }
    return {
      propTypes: propTypes2,
      defaultProps: defaultProps54,
      deprecatedProps
    };
  }
  function parsePropType2(name10, propDef) {
    switch (getTypeOf2(propDef)) {
      case "object":
        return normalizePropDefinition(name10, propDef);
      case "array":
        return normalizePropDefinition(name10, {
          type: "array",
          value: propDef,
          compare: false
        });
      case "boolean":
        return normalizePropDefinition(name10, {
          type: "boolean",
          value: propDef
        });
      case "number":
        return normalizePropDefinition(name10, {
          type: "number",
          value: propDef
        });
      case "function":
        return normalizePropDefinition(name10, {
          type: "function",
          value: propDef,
          compare: true
        });
      default:
        return {
          name: name10,
          type: "unknown",
          value: propDef
        };
    }
  }
  function normalizePropDefinition(name10, propDef) {
    if (!("type" in propDef)) {
      if (!("value" in propDef)) {
        return {
          name: name10,
          type: "object",
          value: propDef
        };
      }
      return {
        name: name10,
        type: getTypeOf2(propDef.value),
        ...propDef
      };
    }
    return {
      name: name10,
      ...TYPE_DEFINITIONS2[propDef.type],
      ...propDef
    };
  }
  function isArray3(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value);
  }
  function getTypeOf2(value) {
    if (isArray3(value)) {
      return "array";
    }
    if (value === null) {
      return "null";
    }
    return typeof value;
  }

  // ../core/src/lifecycle/create-props.ts
  function createProps(component, propObjects) {
    let extensions;
    for (let i3 = propObjects.length - 1; i3 >= 0; i3--) {
      const props = propObjects[i3];
      if ("extensions" in props) {
        extensions = props.extensions;
      }
    }
    const propsPrototype = getPropsPrototype(component.constructor, extensions);
    const propsInstance = Object.create(propsPrototype);
    propsInstance[COMPONENT_SYMBOL] = component;
    propsInstance[ASYNC_ORIGINAL_SYMBOL] = {};
    propsInstance[ASYNC_RESOLVED_SYMBOL] = {};
    for (let i3 = 0; i3 < propObjects.length; ++i3) {
      const props = propObjects[i3];
      for (const key in props) {
        propsInstance[key] = props[key];
      }
    }
    Object.freeze(propsInstance);
    return propsInstance;
  }
  var MergedDefaultPropsCacheKey = "_mergedDefaultProps";
  function getPropsPrototype(componentClass, extensions) {
    let cacheKey = MergedDefaultPropsCacheKey;
    if (extensions) {
      for (const extension of extensions) {
        const ExtensionClass = extension.constructor;
        if (ExtensionClass) {
          cacheKey += `:${ExtensionClass.extensionName || ExtensionClass.name}`;
        }
      }
    }
    const defaultProps54 = getOwnProperty(componentClass, cacheKey);
    if (!defaultProps54) {
      return componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []);
    }
    return defaultProps54;
  }
  function createPropsPrototypeAndTypes(componentClass, extensions) {
    const parent = componentClass.prototype;
    if (!parent) {
      return null;
    }
    const parentClass = Object.getPrototypeOf(componentClass);
    const parentDefaultProps = getPropsPrototype(parentClass);
    const componentDefaultProps = getOwnProperty(componentClass, "defaultProps") || {};
    const componentPropDefs = parsePropTypes2(componentDefaultProps);
    const defaultProps54 = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);
    const propTypes2 = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps?.[PROP_TYPES_SYMBOL], componentPropDefs.propTypes);
    const deprecatedProps = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps?.[DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);
    for (const extension of extensions) {
      const extensionDefaultProps = getPropsPrototype(extension.constructor);
      if (extensionDefaultProps) {
        Object.assign(defaultProps54, extensionDefaultProps);
        Object.assign(propTypes2, extensionDefaultProps[PROP_TYPES_SYMBOL]);
        Object.assign(deprecatedProps, extensionDefaultProps[DEPRECATED_PROPS_SYMBOL]);
      }
    }
    createPropsPrototype(defaultProps54, componentClass);
    addAsyncPropsToPropPrototype(defaultProps54, propTypes2);
    addDeprecatedPropsToPropPrototype(defaultProps54, deprecatedProps);
    defaultProps54[PROP_TYPES_SYMBOL] = propTypes2;
    defaultProps54[DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
    if (extensions.length === 0 && !hasOwnProperty(componentClass, "_propTypes")) {
      componentClass._propTypes = propTypes2;
    }
    return defaultProps54;
  }
  function createPropsPrototype(defaultProps54, componentClass) {
    const id = getComponentName(componentClass);
    Object.defineProperties(defaultProps54, {
      id: {
        writable: true,
        value: id
      }
    });
  }
  function addDeprecatedPropsToPropPrototype(defaultProps54, deprecatedProps) {
    for (const propName in deprecatedProps) {
      Object.defineProperty(defaultProps54, propName, {
        enumerable: false,
        set(newValue) {
          const nameStr = `${this.id}: ${propName}`;
          for (const newPropName of deprecatedProps[propName]) {
            if (!hasOwnProperty(this, newPropName)) {
              this[newPropName] = newValue;
            }
          }
          log_default.deprecated(nameStr, deprecatedProps[propName].join("/"))();
        }
      });
    }
  }
  function addAsyncPropsToPropPrototype(defaultProps54, propTypes2) {
    const defaultValues = {};
    const descriptors = {};
    for (const propName in propTypes2) {
      const propType = propTypes2[propName];
      const {
        name: name10,
        value
      } = propType;
      if (propType.async) {
        defaultValues[name10] = value;
        descriptors[name10] = getDescriptorForAsyncProp(name10);
      }
    }
    defaultProps54[ASYNC_DEFAULTS_SYMBOL] = defaultValues;
    defaultProps54[ASYNC_ORIGINAL_SYMBOL] = {};
    Object.defineProperties(defaultProps54, descriptors);
  }
  function getDescriptorForAsyncProp(name10) {
    return {
      enumerable: true,
      set(newValue) {
        if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable2(newValue)) {
          this[ASYNC_ORIGINAL_SYMBOL][name10] = newValue;
        } else {
          this[ASYNC_RESOLVED_SYMBOL][name10] = newValue;
        }
      },
      get() {
        if (this[ASYNC_RESOLVED_SYMBOL]) {
          if (name10 in this[ASYNC_RESOLVED_SYMBOL]) {
            const value = this[ASYNC_RESOLVED_SYMBOL][name10];
            return value || this[ASYNC_DEFAULTS_SYMBOL][name10];
          }
          if (name10 in this[ASYNC_ORIGINAL_SYMBOL]) {
            const state = this[COMPONENT_SYMBOL] && this[COMPONENT_SYMBOL].internalState;
            if (state && state.hasAsyncProp(name10)) {
              return state.getAsyncProp(name10) || this[ASYNC_DEFAULTS_SYMBOL][name10];
            }
          }
        }
        return this[ASYNC_DEFAULTS_SYMBOL][name10];
      }
    };
  }
  function hasOwnProperty(object, prop) {
    return Object.prototype.hasOwnProperty.call(object, prop);
  }
  function getOwnProperty(object, prop) {
    return hasOwnProperty(object, prop) && object[prop];
  }
  function getComponentName(componentClass) {
    const componentName = componentClass.componentName;
    if (!componentName) {
      log_default.warn(`${componentClass.name}.componentName not specified`)();
    }
    return componentName || componentClass.name;
  }

  // ../core/src/lifecycle/component.ts
  var counter = 0;
  var Component = class {
    constructor(...propObjects) {
      this.props = createProps(this, propObjects);
      this.id = this.props.id;
      this.count = counter++;
    }
    clone(newProps) {
      const {
        props
      } = this;
      const asyncProps = {};
      for (const key in props[ASYNC_DEFAULTS_SYMBOL]) {
        if (key in props[ASYNC_RESOLVED_SYMBOL]) {
          asyncProps[key] = props[ASYNC_RESOLVED_SYMBOL][key];
        } else if (key in props[ASYNC_ORIGINAL_SYMBOL]) {
          asyncProps[key] = props[ASYNC_ORIGINAL_SYMBOL][key];
        }
      }
      return new this.constructor({
        ...props,
        ...asyncProps,
        ...newProps
      });
    }
  };
  __publicField(Component, "componentName", "Component");
  __publicField(Component, "defaultProps", {});

  // ../core/src/lifecycle/component-state.ts
  var EMPTY_PROPS = Object.freeze({});
  var ComponentState = class {
    constructor(component) {
      this.component = component;
      this.asyncProps = {};
      this.onAsyncPropUpdated = () => {
      };
      this.oldProps = null;
      this.oldAsyncProps = null;
    }
    finalize() {
      for (const propName in this.asyncProps) {
        const asyncProp = this.asyncProps[propName];
        if (asyncProp && asyncProp.type && asyncProp.type.release) {
          asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
        }
      }
      this.asyncProps = {};
      this.component = null;
      this.resetOldProps();
    }
    getOldProps() {
      return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
    }
    resetOldProps() {
      this.oldAsyncProps = null;
      this.oldProps = this.component ? this.component.props : null;
    }
    hasAsyncProp(propName) {
      return propName in this.asyncProps;
    }
    getAsyncProp(propName) {
      const asyncProp = this.asyncProps[propName];
      return asyncProp && asyncProp.resolvedValue;
    }
    isAsyncPropLoading(propName) {
      if (propName) {
        const asyncProp = this.asyncProps[propName];
        return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
      }
      for (const key in this.asyncProps) {
        if (this.isAsyncPropLoading(key)) {
          return true;
        }
      }
      return false;
    }
    reloadAsyncProp(propName, value) {
      this._watchPromise(propName, Promise.resolve(value));
    }
    setAsyncProps(props) {
      this.component = props[COMPONENT_SYMBOL] || this.component;
      const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};
      const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;
      const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};
      for (const propName in resolvedValues) {
        const value = resolvedValues[propName];
        this._createAsyncPropData(propName, defaultValues[propName]);
        this._updateAsyncProp(propName, value);
        resolvedValues[propName] = this.getAsyncProp(propName);
      }
      for (const propName in originalValues) {
        const value = originalValues[propName];
        this._createAsyncPropData(propName, defaultValues[propName]);
        this._updateAsyncProp(propName, value);
      }
    }
    _fetch(propName, url) {
      return null;
    }
    _onResolve(propName, value) {
    }
    _onError(propName, error2) {
    }
    _updateAsyncProp(propName, value) {
      if (!this._didAsyncInputValueChange(propName, value)) {
        return;
      }
      if (typeof value === "string") {
        value = this._fetch(propName, value);
      }
      if (value instanceof Promise) {
        this._watchPromise(propName, value);
        return;
      }
      if (isAsyncIterable2(value)) {
        this._resolveAsyncIterable(propName, value);
        return;
      }
      this._setPropValue(propName, value);
    }
    _freezeAsyncOldProps() {
      if (!this.oldAsyncProps && this.oldProps) {
        this.oldAsyncProps = Object.create(this.oldProps);
        for (const propName in this.asyncProps) {
          Object.defineProperty(this.oldAsyncProps, propName, {
            enumerable: true,
            value: this.oldProps[propName]
          });
        }
      }
    }
    _didAsyncInputValueChange(propName, value) {
      const asyncProp = this.asyncProps[propName];
      if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {
        return false;
      }
      asyncProp.lastValue = value;
      return true;
    }
    _setPropValue(propName, value) {
      this._freezeAsyncOldProps();
      const asyncProp = this.asyncProps[propName];
      if (asyncProp) {
        value = this._postProcessValue(asyncProp, value);
        asyncProp.resolvedValue = value;
        asyncProp.pendingLoadCount++;
        asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
      }
    }
    _setAsyncPropValue(propName, value, loadCount) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== void 0) {
        this._freezeAsyncOldProps();
        asyncProp.resolvedValue = value;
        asyncProp.resolvedLoadCount = loadCount;
        this.onAsyncPropUpdated(propName, value);
      }
    }
    _watchPromise(propName, promise) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp) {
        asyncProp.pendingLoadCount++;
        const loadCount = asyncProp.pendingLoadCount;
        promise.then((data) => {
          if (!this.component) {
            return;
          }
          data = this._postProcessValue(asyncProp, data);
          this._setAsyncPropValue(propName, data, loadCount);
          this._onResolve(propName, data);
        }).catch((error2) => {
          this._onError(propName, error2);
        });
      }
    }
    async _resolveAsyncIterable(propName, iterable) {
      if (propName !== "data") {
        this._setPropValue(propName, iterable);
        return;
      }
      const asyncProp = this.asyncProps[propName];
      if (!asyncProp) {
        return;
      }
      asyncProp.pendingLoadCount++;
      const loadCount = asyncProp.pendingLoadCount;
      let data = [];
      let count2 = 0;
      for await (const chunk of iterable) {
        if (!this.component) {
          return;
        }
        const {
          dataTransform
        } = this.component.props;
        if (dataTransform) {
          data = dataTransform(chunk, data);
        } else {
          data = data.concat(chunk);
        }
        Object.defineProperty(data, "__diff", {
          enumerable: false,
          value: [{
            startRow: count2,
            endRow: data.length
          }]
        });
        count2 = data.length;
        this._setAsyncPropValue(propName, data, loadCount);
      }
      this._onResolve(propName, data);
    }
    _postProcessValue(asyncProp, value) {
      const propType = asyncProp.type;
      if (propType && this.component) {
        if (propType.release) {
          propType.release(asyncProp.resolvedValue, propType, this.component);
        }
        if (propType.transform) {
          return propType.transform(value, propType, this.component);
        }
      }
      return value;
    }
    _createAsyncPropData(propName, defaultValue2) {
      const asyncProp = this.asyncProps[propName];
      if (!asyncProp) {
        const propTypes2 = this.component && this.component.props[PROP_TYPES_SYMBOL];
        this.asyncProps[propName] = {
          type: propTypes2 && propTypes2[propName],
          lastValue: null,
          resolvedValue: defaultValue2,
          pendingLoadCount: 0,
          resolvedLoadCount: 0
        };
      }
    }
  };

  // ../core/src/lib/layer-state.ts
  var LayerState = class extends ComponentState {
    constructor({
      attributeManager,
      layer
    }) {
      super(layer);
      this.attributeManager = attributeManager;
      this.needsRedraw = true;
      this.needsUpdate = true;
      this.subLayers = null;
      this.usesPickingColorCache = false;
    }
    get layer() {
      return this.component;
    }
    _fetch(propName, url) {
      const layer = this.layer;
      const fetch2 = layer?.props.fetch;
      if (fetch2) {
        return fetch2(url, {
          propName,
          layer
        });
      }
      return super._fetch(propName, url);
    }
    _onResolve(propName, value) {
      const layer = this.layer;
      if (layer) {
        const onDataLoad = layer.props.onDataLoad;
        if (propName === "data" && onDataLoad) {
          onDataLoad(value, {
            propName,
            layer
          });
        }
      }
    }
    _onError(propName, error2) {
      const layer = this.layer;
      if (layer) {
        layer.raiseError(error2, `loading ${propName} of ${this.layer}`);
      }
    }
  };

  // ../core/src/lib/layer.ts
  var TRACE_CHANGE_FLAG = "layer.changeFlag";
  var TRACE_INITIALIZE = "layer.initialize";
  var TRACE_UPDATE = "layer.update";
  var TRACE_FINALIZE = "layer.finalize";
  var TRACE_MATCHED = "layer.matched";
  var MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
  var EMPTY_ARRAY2 = Object.freeze([]);
  var areViewportsEqual = memoize(({
    oldViewport,
    viewport
  }) => {
    return oldViewport.equals(viewport);
  });
  var pickingColorCache = new Uint8ClampedArray(0);
  var defaultProps2 = {
    data: {
      type: "data",
      value: EMPTY_ARRAY2,
      async: true
    },
    dataComparator: {
      type: "function",
      value: null,
      optional: true
    },
    _dataDiff: {
      type: "function",
      value: (data) => data && data.__diff,
      optional: true
    },
    dataTransform: {
      type: "function",
      value: null,
      optional: true
    },
    onDataLoad: {
      type: "function",
      value: null,
      optional: true
    },
    onError: {
      type: "function",
      value: null,
      optional: true
    },
    fetch: {
      type: "function",
      value: (url, {
        propName,
        layer,
        loaders,
        loadOptions,
        signal
      }) => {
        const {
          resourceManager
        } = layer.context;
        loadOptions = loadOptions || layer.getLoadOptions();
        loaders = loaders || layer.props.loaders;
        if (signal) {
          loadOptions = {
            ...loadOptions,
            fetch: {
              ...loadOptions?.fetch,
              signal
            }
          };
        }
        let inResourceManager = resourceManager.contains(url);
        if (!inResourceManager && !loadOptions) {
          resourceManager.add({
            resourceId: url,
            data: load(url, loaders),
            persistent: false
          });
          inResourceManager = true;
        }
        if (inResourceManager) {
          return resourceManager.subscribe({
            resourceId: url,
            onChange: (data) => layer.internalState?.reloadAsyncProp(propName, data),
            consumerId: layer.id,
            requestId: propName
          });
        }
        return load(url, loaders, loadOptions);
      }
    },
    updateTriggers: {},
    visible: true,
    pickable: false,
    opacity: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    operation: "draw",
    onHover: {
      type: "function",
      value: null,
      optional: true
    },
    onClick: {
      type: "function",
      value: null,
      optional: true
    },
    onDragStart: {
      type: "function",
      value: null,
      optional: true
    },
    onDrag: {
      type: "function",
      value: null,
      optional: true
    },
    onDragEnd: {
      type: "function",
      value: null,
      optional: true
    },
    coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
    coordinateOrigin: {
      type: "array",
      value: [0, 0, 0],
      compare: true
    },
    modelMatrix: {
      type: "array",
      value: null,
      compare: true,
      optional: true
    },
    wrapLongitude: false,
    positionFormat: "XYZ",
    colorFormat: "RGBA",
    parameters: {
      type: "object",
      value: {},
      optional: true,
      compare: 2
    },
    loadOptions: {
      type: "object",
      value: null,
      optional: true,
      ignore: true
    },
    transitions: null,
    extensions: [],
    loaders: {
      type: "array",
      value: [],
      optional: true,
      ignore: true
    },
    getPolygonOffset: {
      type: "function",
      value: ({
        layerIndex
      }) => [0, -layerIndex * 100]
    },
    highlightedObjectIndex: null,
    autoHighlight: false,
    highlightColor: {
      type: "accessor",
      value: [0, 0, 128, 128]
    }
  };
  var Layer = class extends Component {
    static get componentName() {
      return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
    }
    internalState = null;
    lifecycle = LIFECYCLE.NO_STATE;
    parent = null;
    get root() {
      let layer = this;
      while (layer.parent) {
        layer = layer.parent;
      }
      return layer;
    }
    toString() {
      const className = this.constructor.layerName || this.constructor.name;
      return `${className}({id: '${this.props.id}'})`;
    }
    project(xyz) {
      assert11(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      const worldPosition = getWorldPosition(xyz, {
        viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem
      });
      const [x2, y2, z] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);
      return xyz.length === 2 ? [x2, y2] : [x2, y2, z];
    }
    unproject(xy) {
      assert11(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      return viewport.unproject(xy);
    }
    projectPosition(xyz, params) {
      assert11(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      return projectPosition(xyz, {
        viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem,
        ...params
      });
    }
    get isComposite() {
      return false;
    }
    setState(partialState) {
      this.setChangeFlags({
        stateChanged: true
      });
      Object.assign(this.state, partialState);
      this.setNeedsRedraw();
    }
    setNeedsRedraw() {
      if (this.internalState) {
        this.internalState.needsRedraw = true;
      }
    }
    setNeedsUpdate() {
      if (this.internalState) {
        this.context.layerManager.setNeedsUpdate(String(this));
        this.internalState.needsUpdate = true;
      }
    }
    get isLoaded() {
      return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
    }
    get wrapLongitude() {
      return this.props.wrapLongitude;
    }
    isPickable() {
      return this.props.pickable && this.props.visible;
    }
    getModels() {
      return this.state && (this.state.models || this.state.model && [this.state.model]) || [];
    }
    setModuleParameters(moduleParameters) {
      for (const model of this.getModels()) {
        model.updateModuleSettings(moduleParameters);
      }
    }
    getAttributeManager() {
      return this.internalState && this.internalState.attributeManager;
    }
    getCurrentLayer() {
      return this.internalState && this.internalState.layer;
    }
    getLoadOptions() {
      return this.props.loadOptions;
    }
    use64bitPositions() {
      const {
        coordinateSystem
      } = this.props;
      return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
    }
    onHover(info, pickingEvent) {
      if (this.props.onHover) {
        return this.props.onHover(info, pickingEvent) || false;
      }
      return false;
    }
    onClick(info, pickingEvent) {
      if (this.props.onClick) {
        return this.props.onClick(info, pickingEvent) || false;
      }
      return false;
    }
    nullPickingColor() {
      return [0, 0, 0];
    }
    encodePickingColor(i3, target = []) {
      target[0] = i3 + 1 & 255;
      target[1] = i3 + 1 >> 8 & 255;
      target[2] = i3 + 1 >> 8 >> 8 & 255;
      return target;
    }
    decodePickingColor(color) {
      assert11(color instanceof Uint8Array);
      const [i1, i22, i3] = color;
      const index = i1 + i22 * 256 + i3 * 65536 - 1;
      return index;
    }
    getNumInstances() {
      if (Number.isFinite(this.props.numInstances)) {
        return this.props.numInstances;
      }
      if (this.state && this.state.numInstances !== void 0) {
        return this.state.numInstances;
      }
      return count(this.props.data);
    }
    getStartIndices() {
      if (this.props.startIndices) {
        return this.props.startIndices;
      }
      if (this.state && this.state.startIndices) {
        return this.state.startIndices;
      }
      return null;
    }
    getBounds() {
      return this.getAttributeManager()?.getBounds(["positions", "instancePositions"]);
    }
    getShaders(shaders) {
      for (const extension of this.props.extensions) {
        shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
      }
      return shaders;
    }
    shouldUpdateState(params) {
      return params.changeFlags.propsOrDataChanged;
    }
    updateState(params) {
      const attributeManager = this.getAttributeManager();
      const {
        dataChanged
      } = params.changeFlags;
      if (dataChanged && attributeManager) {
        if (Array.isArray(dataChanged)) {
          for (const dataRange of dataChanged) {
            attributeManager.invalidateAll(dataRange);
          }
        } else {
          attributeManager.invalidateAll();
        }
      }
      if (attributeManager) {
        const {
          props
        } = params;
        const hasPickingBuffer = this.internalState.hasPickingBuffer;
        const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some((extension) => extension.getNeedsPickingBuffer.call(this, extension));
        if (hasPickingBuffer !== needsPickingBuffer) {
          this.internalState.hasPickingBuffer = needsPickingBuffer;
          const {
            pickingColors,
            instancePickingColors
          } = attributeManager.attributes;
          const pickingColorsAttribute = pickingColors || instancePickingColors;
          if (pickingColorsAttribute) {
            if (needsPickingBuffer && pickingColorsAttribute.constant) {
              pickingColorsAttribute.constant = false;
              attributeManager.invalidate(pickingColorsAttribute.id);
            }
            if (!pickingColorsAttribute.value && !needsPickingBuffer) {
              pickingColorsAttribute.constant = true;
              pickingColorsAttribute.value = [0, 0, 0];
            }
          }
        }
      }
    }
    finalizeState(context) {
      for (const model of this.getModels()) {
        model.delete();
      }
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.finalize();
      }
      if (this.context) {
        this.context.resourceManager.unsubscribe({
          consumerId: this.id
        });
      }
      if (this.internalState) {
        this.internalState.uniformTransitions.clear();
        this.internalState.finalize();
      }
    }
    draw(opts) {
      for (const model of this.getModels()) {
        model.draw(opts);
      }
    }
    getPickingInfo({
      info,
      mode,
      sourceLayer
    }) {
      const {
        index
      } = info;
      if (index >= 0) {
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }
      return info;
    }
    raiseError(error2, message) {
      if (message) {
        error2.message = `${message}: ${error2.message}`;
      }
      if (!this.props.onError?.(error2)) {
        this.context?.onError?.(error2, this);
      }
    }
    getNeedsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      return this._getNeedsRedraw(opts);
    }
    needsUpdate() {
      if (!this.internalState) {
        return false;
      }
      return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
    }
    hasUniformTransition() {
      return this.internalState?.uniformTransitions.active || false;
    }
    activateViewport(viewport) {
      if (!this.internalState) {
        return;
      }
      const oldViewport = this.internalState.viewport;
      this.internalState.viewport = viewport;
      if (!oldViewport || !areViewportsEqual({
        oldViewport,
        viewport
      })) {
        this.setChangeFlags({
          viewportChanged: true
        });
        if (this.isComposite) {
          if (this.needsUpdate()) {
            this.setNeedsUpdate();
          }
        } else {
          this._update();
        }
      }
    }
    invalidateAttribute(name10 = "all") {
      const attributeManager = this.getAttributeManager();
      if (!attributeManager) {
        return;
      }
      if (name10 === "all") {
        attributeManager.invalidateAll();
      } else {
        attributeManager.invalidate(name10);
      }
    }
    updateAttributes(changedAttributes) {
      for (const model of this.getModels()) {
        this._setModelAttributes(model, changedAttributes);
      }
    }
    _updateAttributes() {
      const attributeManager = this.getAttributeManager();
      if (!attributeManager) {
        return;
      }
      const props = this.props;
      const numInstances = this.getNumInstances();
      const startIndices = this.getStartIndices();
      attributeManager.update({
        data: props.data,
        numInstances,
        startIndices,
        props,
        transitions: props.transitions,
        buffers: props.data.attributes,
        context: this
      });
      const changedAttributes = attributeManager.getChangedAttributes({
        clearChangedFlags: true
      });
      this.updateAttributes(changedAttributes);
    }
    _updateAttributeTransition() {
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.updateTransition();
      }
    }
    _updateUniformTransition() {
      const {
        uniformTransitions
      } = this.internalState;
      if (uniformTransitions.active) {
        const propsInTransition = uniformTransitions.update();
        const props = Object.create(this.props);
        for (const key in propsInTransition) {
          Object.defineProperty(props, key, {
            value: propsInTransition[key]
          });
        }
        return props;
      }
      return this.props;
    }
    calculateInstancePickingColors(attribute, {
      numInstances
    }) {
      if (attribute.constant) {
        return;
      }
      const cacheSize = Math.floor(pickingColorCache.length / 3);
      this.internalState.usesPickingColorCache = true;
      if (cacheSize < numInstances) {
        if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
          log_default.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")();
        }
        pickingColorCache = typed_array_manager_default.allocate(pickingColorCache, numInstances, {
          size: 3,
          copy: true,
          maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
        });
        const newCacheSize = Math.floor(pickingColorCache.length / 3);
        const pickingColor = [];
        for (let i3 = cacheSize; i3 < newCacheSize; i3++) {
          this.encodePickingColor(i3, pickingColor);
          pickingColorCache[i3 * 3 + 0] = pickingColor[0];
          pickingColorCache[i3 * 3 + 1] = pickingColor[1];
          pickingColorCache[i3 * 3 + 2] = pickingColor[2];
        }
      }
      attribute.value = pickingColorCache.subarray(0, numInstances * 3);
    }
    _setModelAttributes(model, changedAttributes) {
      const attributeManager = this.getAttributeManager();
      const excludeAttributes = model.userData.excludeAttributes || {};
      const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);
      model.setAttributes(shaderAttributes);
    }
    disablePickingIndex(objectIndex) {
      const data = this.props.data;
      if (!("attributes" in data)) {
        this._disablePickingIndex(objectIndex);
        return;
      }
      const {
        pickingColors,
        instancePickingColors
      } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];
      if (externalColorAttribute && externalColorAttribute.value) {
        const values = externalColorAttribute.value;
        const objectColor = this.encodePickingColor(objectIndex);
        for (let index = 0; index < data.length; index++) {
          const i3 = colors.getVertexOffset(index);
          if (values[i3] === objectColor[0] && values[i3 + 1] === objectColor[1] && values[i3 + 2] === objectColor[2]) {
            this._disablePickingIndex(index);
          }
        }
      } else {
        this._disablePickingIndex(objectIndex);
      }
    }
    _disablePickingIndex(objectIndex) {
      const {
        pickingColors,
        instancePickingColors
      } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      if (!colors) {
        return;
      }
      const start = colors.getVertexOffset(objectIndex);
      const end = colors.getVertexOffset(objectIndex + 1);
      colors.buffer.subData({
        data: new Uint8Array(end - start),
        offset: start
      });
    }
    restorePickingColors() {
      const {
        pickingColors,
        instancePickingColors
      } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      if (!colors) {
        return;
      }
      if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {
        colors.value = pickingColorCache.subarray(0, colors.value.length);
      }
      colors.updateSubBuffer({
        startOffset: 0
      });
    }
    _initialize() {
      assert11(!this.internalState);
      assert11(Number.isFinite(this.props.coordinateSystem));
      debug(TRACE_INITIALIZE, this);
      const attributeManager = this._getAttributeManager();
      if (attributeManager) {
        attributeManager.addInstanced({
          instancePickingColors: {
            type: esm_default2.UNSIGNED_BYTE,
            size: 3,
            noAlloc: true,
            update: this.calculateInstancePickingColors
          }
        });
      }
      this.internalState = new LayerState({
        attributeManager,
        layer: this
      });
      this._clearChangeFlags();
      this.state = {};
      Object.defineProperty(this.state, "attributeManager", {
        get: () => {
          log_default.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
          return attributeManager;
        }
      });
      this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
      this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
      this.internalState.setAsyncProps(this.props);
      this.initializeState(this.context);
      for (const extension of this.props.extensions) {
        extension.initializeState.call(this, this.context, extension);
      }
      this.setChangeFlags({
        dataChanged: "init",
        propsChanged: "init",
        viewportChanged: true,
        extensionsChanged: true
      });
      this._update();
    }
    _transferState(oldLayer) {
      debug(TRACE_MATCHED, this, this === oldLayer);
      const {
        state,
        internalState
      } = oldLayer;
      if (this === oldLayer) {
        return;
      }
      this.internalState = internalState;
      this.state = state;
      this.internalState.setAsyncProps(this.props);
      this._diffProps(this.props, this.internalState.getOldProps());
    }
    _update() {
      const stateNeedsUpdate = this.needsUpdate();
      debug(TRACE_UPDATE, this, stateNeedsUpdate);
      if (!stateNeedsUpdate) {
        return;
      }
      const currentProps = this.props;
      const context = this.context;
      const internalState = this.internalState;
      const currentViewport = context.viewport;
      const propsInTransition = this._updateUniformTransition();
      internalState.propsInTransition = propsInTransition;
      context.viewport = internalState.viewport || currentViewport;
      this.props = propsInTransition;
      try {
        const updateParams = this._getUpdateParams();
        const oldModels = this.getModels();
        if (context.gl) {
          this.updateState(updateParams);
        } else {
          try {
            this.updateState(updateParams);
          } catch (error2) {
          }
        }
        for (const extension of this.props.extensions) {
          extension.updateState.call(this, updateParams, extension);
        }
        const modelChanged = this.getModels()[0] !== oldModels[0];
        this._postUpdate(updateParams, modelChanged);
      } finally {
        context.viewport = currentViewport;
        this.props = currentProps;
        this._clearChangeFlags();
        internalState.needsUpdate = false;
        internalState.resetOldProps();
      }
    }
    _finalize() {
      debug(TRACE_FINALIZE, this);
      this.finalizeState(this.context);
      for (const extension of this.props.extensions) {
        extension.finalizeState.call(this, this.context, extension);
      }
    }
    _drawLayer({
      moduleParameters = null,
      uniforms = {},
      parameters: parameters2 = {}
    }) {
      this._updateAttributeTransition();
      const currentProps = this.props;
      const context = this.context;
      this.props = this.internalState.propsInTransition || currentProps;
      const opacity = this.props.opacity;
      uniforms.opacity = Math.pow(opacity, 1 / 2.2);
      try {
        if (moduleParameters) {
          this.setModuleParameters(moduleParameters);
        }
        const {
          getPolygonOffset
        } = this.props;
        const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
        setParameters(context.gl, {
          polygonOffset: offsets
        });
        withParameters(context.gl, parameters2, () => {
          const opts = {
            moduleParameters,
            uniforms,
            parameters: parameters2,
            context
          };
          for (const extension of this.props.extensions) {
            extension.draw.call(this, opts, extension);
          }
          this.draw(opts);
        });
      } finally {
        this.props = currentProps;
      }
    }
    getChangeFlags() {
      return this.internalState?.changeFlags;
    }
    setChangeFlags(flags) {
      if (!this.internalState) {
        return;
      }
      const {
        changeFlags
      } = this.internalState;
      for (const key in flags) {
        if (flags[key]) {
          let flagChanged = false;
          switch (key) {
            case "dataChanged":
              const dataChangedReason = flags[key];
              const prevDataChangedReason = changeFlags[key];
              if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
                changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
                flagChanged = true;
              }
            default:
              if (!changeFlags[key]) {
                changeFlags[key] = flags[key];
                flagChanged = true;
              }
          }
          if (flagChanged) {
            debug(TRACE_CHANGE_FLAG, this, key, flags);
          }
        }
      }
      const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
      changeFlags.propsOrDataChanged = propsOrDataChanged;
      changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
    }
    _clearChangeFlags() {
      this.internalState.changeFlags = {
        dataChanged: false,
        propsChanged: false,
        updateTriggersChanged: false,
        viewportChanged: false,
        stateChanged: false,
        extensionsChanged: false,
        propsOrDataChanged: false,
        somethingChanged: false
      };
    }
    _diffProps(newProps, oldProps) {
      const changeFlags = diffProps(newProps, oldProps);
      if (changeFlags.updateTriggersChanged) {
        for (const key in changeFlags.updateTriggersChanged) {
          if (changeFlags.updateTriggersChanged[key]) {
            this.invalidateAttribute(key);
          }
        }
      }
      if (changeFlags.transitionsChanged) {
        for (const key in changeFlags.transitionsChanged) {
          this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], newProps.transitions?.[key]);
        }
      }
      return this.setChangeFlags(changeFlags);
    }
    validateProps() {
      validateProps(this.props);
    }
    updateAutoHighlight(info) {
      if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
        this._updateAutoHighlight(info);
      }
    }
    _updateAutoHighlight(info) {
      const pickingModuleParameters = {
        pickingSelectedColor: info.picked ? info.color : null
      };
      const {
        highlightColor
      } = this.props;
      if (info.picked && typeof highlightColor === "function") {
        pickingModuleParameters.pickingHighlightColor = highlightColor(info);
      }
      this.setModuleParameters(pickingModuleParameters);
      this.setNeedsRedraw();
    }
    _getAttributeManager() {
      const context = this.context;
      return new AttributeManager(context.gl, {
        id: this.props.id,
        stats: context.stats,
        timeline: context.timeline
      });
    }
    _postUpdate(updateParams, forceUpdate) {
      const {
        props,
        oldProps
      } = updateParams;
      this.setNeedsRedraw();
      this._updateAttributes();
      const {
        model
      } = this.state;
      model?.setInstanceCount(this.getNumInstances());
      const {
        autoHighlight,
        highlightedObjectIndex,
        highlightColor
      } = props;
      if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
        const parameters2 = {};
        if (!autoHighlight) {
          parameters2.pickingSelectedColor = null;
        }
        if (Array.isArray(highlightColor)) {
          parameters2.pickingHighlightColor = highlightColor;
        }
        if (forceUpdate || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {
          parameters2.pickingSelectedColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
        }
        this.setModuleParameters(parameters2);
      }
    }
    _getUpdateParams() {
      return {
        props: this.props,
        oldProps: this.internalState.getOldProps(),
        context: this.context,
        changeFlags: this.internalState.changeFlags
      };
    }
    _getNeedsRedraw(opts) {
      if (!this.internalState) {
        return false;
      }
      let redraw = false;
      redraw = redraw || this.internalState.needsRedraw && this.id;
      const attributeManager = this.getAttributeManager();
      const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
      redraw = redraw || attributeManagerNeedsRedraw;
      if (redraw) {
        for (const extension of this.props.extensions) {
          extension.onNeedsRedraw.call(this, extension);
        }
      }
      this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
      return redraw;
    }
    _onAsyncPropUpdated() {
      this._diffProps(this.props, this.internalState.getOldProps());
      this.setNeedsUpdate();
    }
  };
  __publicField(Layer, "defaultProps", defaultProps2);
  __publicField(Layer, "layerName", "Layer");

  // ../core/src/lib/composite-layer.ts
  var TRACE_RENDER_LAYERS2 = "compositeLayer.renderLayers";
  var CompositeLayer = class extends Layer {
    get isComposite() {
      return true;
    }
    get isLoaded() {
      return super.isLoaded && this.getSubLayers().every((layer) => layer.isLoaded);
    }
    getSubLayers() {
      return this.internalState && this.internalState.subLayers || [];
    }
    initializeState(context) {
    }
    setState(updateObject) {
      super.setState(updateObject);
      this.setNeedsUpdate();
    }
    getPickingInfo({
      info
    }) {
      const {
        object
      } = info;
      const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;
      if (!isDataWrapped) {
        return info;
      }
      info.object = object.__source.object;
      info.index = object.__source.index;
      return info;
    }
    filterSubLayer(context) {
      return true;
    }
    shouldRenderSubLayer(subLayerId, data) {
      return data && data.length;
    }
    getSubLayerClass(subLayerId, DefaultLayerClass) {
      const {
        _subLayerProps: overridingProps
      } = this.props;
      return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;
    }
    getSubLayerRow(row, sourceObject, sourceObjectIndex) {
      row.__source = {
        parent: this,
        object: sourceObject,
        index: sourceObjectIndex
      };
      return row;
    }
    getSubLayerAccessor(accessor) {
      if (typeof accessor === "function") {
        const objectInfo = {
          index: -1,
          data: this.props.data,
          target: []
        };
        return (x2, i3) => {
          if (x2 && x2.__source) {
            objectInfo.index = x2.__source.index;
            return accessor(x2.__source.object, objectInfo);
          }
          return accessor(x2, i3);
        };
      }
      return accessor;
    }
    getSubLayerProps(sublayerProps = {}) {
      const {
        opacity,
        pickable,
        visible,
        parameters: parameters2,
        getPolygonOffset,
        highlightedObjectIndex,
        autoHighlight,
        highlightColor,
        coordinateSystem,
        coordinateOrigin,
        wrapLongitude,
        positionFormat,
        modelMatrix: modelMatrix2,
        extensions,
        fetch: fetch2,
        operation,
        _subLayerProps: overridingProps
      } = this.props;
      const newProps = {
        id: "",
        updateTriggers: {},
        opacity,
        pickable,
        visible,
        parameters: parameters2,
        getPolygonOffset,
        highlightedObjectIndex,
        autoHighlight,
        highlightColor,
        coordinateSystem,
        coordinateOrigin,
        wrapLongitude,
        positionFormat,
        modelMatrix: modelMatrix2,
        extensions,
        fetch: fetch2,
        operation
      };
      const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];
      const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
      const sublayerId = sublayerProps.id || "sublayer";
      if (overridingSublayerProps) {
        const propTypes2 = this.props[PROP_TYPES_SYMBOL];
        const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};
        for (const key in overridingSublayerProps) {
          const propType = subLayerPropTypes[key] || propTypes2[key];
          if (propType && propType.type === "accessor") {
            overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
          }
        }
      }
      Object.assign(
        newProps,
        sublayerProps,
        overridingSublayerProps
      );
      newProps.id = `${this.props.id}-${sublayerId}`;
      newProps.updateTriggers = {
        all: this.props.updateTriggers?.all,
        ...sublayerProps.updateTriggers,
        ...overridingSublayerTriggers
      };
      for (const extension of extensions) {
        const passThroughProps = extension.getSubLayerProps.call(this, extension);
        if (passThroughProps) {
          Object.assign(newProps, passThroughProps, {
            updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
          });
        }
      }
      return newProps;
    }
    _updateAutoHighlight(info) {
      for (const layer of this.getSubLayers()) {
        layer.updateAutoHighlight(info);
      }
    }
    _getAttributeManager() {
      return null;
    }
    _postUpdate(updateParams, forceUpdate) {
      let subLayers = this.internalState.subLayers;
      const shouldUpdate = !subLayers || this.needsUpdate();
      if (shouldUpdate) {
        const subLayersList = this.renderLayers();
        subLayers = flatten(subLayersList, Boolean);
        this.internalState.subLayers = subLayers;
      }
      debug(TRACE_RENDER_LAYERS2, this, shouldUpdate, subLayers);
      for (const layer of subLayers) {
        layer.parent = this;
      }
    }
  };
  __publicField(CompositeLayer, "layerName", "CompositeLayer");

  // ../core/src/viewports/globe-viewport.ts
  var DEGREES_TO_RADIANS6 = Math.PI / 180;
  var RADIANS_TO_DEGREES3 = 180 / Math.PI;
  var EARTH_RADIUS = 6370972;
  var GLOBE_RADIUS = 256;
  function getDistanceScales2() {
    const unitsPerMeter2 = GLOBE_RADIUS / EARTH_RADIUS;
    const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;
    return {
      unitsPerMeter: [unitsPerMeter2, unitsPerMeter2, unitsPerMeter2],
      unitsPerMeter2: [0, 0, 0],
      metersPerUnit: [1 / unitsPerMeter2, 1 / unitsPerMeter2, 1 / unitsPerMeter2],
      unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter2],
      unitsPerDegree2: [0, 0, 0],
      degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter2]
    };
  }
  var GlobeViewport = class extends Viewport {
    constructor(opts = {}) {
      const {
        latitude = 0,
        longitude = 0,
        zoom = 0,
        nearZMultiplier = 0.1,
        farZMultiplier = 2,
        resolution = 10
      } = opts;
      let {
        height,
        altitude = 1.5
      } = opts;
      height = height || 1;
      altitude = Math.max(0.75, altitude);
      const viewMatrix2 = new Matrix4().lookAt({
        eye: [0, -altitude, 0],
        up: [0, 0, 1]
      });
      const scale8 = Math.pow(2, zoom);
      viewMatrix2.rotateX(latitude * DEGREES_TO_RADIANS6);
      viewMatrix2.rotateZ(-longitude * DEGREES_TO_RADIANS6);
      viewMatrix2.scale(scale8 / height);
      const halfFov = Math.atan(0.5 / altitude);
      const relativeScale = GLOBE_RADIUS * 2 * scale8 / height;
      super({
        ...opts,
        height,
        viewMatrix: viewMatrix2,
        longitude,
        latitude,
        zoom,
        distanceScales: getDistanceScales2(),
        fovyRadians: halfFov * 2,
        focalDistance: altitude,
        near: nearZMultiplier,
        far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier
      });
      this.latitude = latitude;
      this.longitude = longitude;
      this.resolution = resolution;
    }
    get projectionMode() {
      return PROJECTION_MODE.GLOBE;
    }
    getDistanceScales() {
      return this.distanceScales;
    }
    getBounds(options = {}) {
      const unprojectOption = {
        targetZ: options.z || 0
      };
      const left = this.unproject([0, this.height / 2], unprojectOption);
      const top = this.unproject([this.width / 2, 0], unprojectOption);
      const right = this.unproject([this.width, this.height / 2], unprojectOption);
      const bottom = this.unproject([this.width / 2, this.height], unprojectOption);
      if (right[0] < this.longitude)
        right[0] += 360;
      if (left[0] > this.longitude)
        left[0] -= 360;
      return [Math.min(left[0], right[0], top[0], bottom[0]), Math.min(left[1], right[1], top[1], bottom[1]), Math.max(left[0], right[0], top[0], bottom[0]), Math.max(left[1], right[1], top[1], bottom[1])];
    }
    unproject(xyz, {
      topLeft = true,
      targetZ
    } = {}) {
      const [x2, y2, z] = xyz;
      const y22 = topLeft ? y2 : this.height - y2;
      const {
        pixelUnprojectionMatrix
      } = this;
      let coord;
      if (Number.isFinite(z)) {
        coord = transformVector2(pixelUnprojectionMatrix, [x2, y22, z, 1]);
      } else {
        const coord0 = transformVector2(pixelUnprojectionMatrix, [x2, y22, -1, 1]);
        const coord1 = transformVector2(pixelUnprojectionMatrix, [x2, y22, 1, 1]);
        const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;
        const lSqr = sqrLen(sub2([], coord0, coord1));
        const l0Sqr = sqrLen(coord0);
        const l1Sqr = sqrLen(coord1);
        const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;
        const dSqr = 4 * sSqr / lSqr;
        const r0 = Math.sqrt(l0Sqr - dSqr);
        const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));
        const t2 = (r0 - dr) / Math.sqrt(lSqr);
        coord = lerp6([], coord0, coord1, t2);
      }
      const [X, Y, Z] = this.unprojectPosition(coord);
      if (Number.isFinite(z)) {
        return [X, Y, Z];
      }
      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }
    projectPosition(xyz) {
      const [lng, lat, Z = 0] = xyz;
      const lambda = lng * DEGREES_TO_RADIANS6;
      const phi = lat * DEGREES_TO_RADIANS6;
      const cosPhi = Math.cos(phi);
      const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;
      return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];
    }
    unprojectPosition(xyz) {
      const [x2, y2, z] = xyz;
      const D = len2(xyz);
      const phi = Math.asin(z / D);
      const lambda = Math.atan2(x2, -y2);
      const lng = lambda * RADIANS_TO_DEGREES3;
      const lat = phi * RADIANS_TO_DEGREES3;
      const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;
      return [lng, lat, Z];
    }
    projectFlat(xyz) {
      return xyz;
    }
    unprojectFlat(xyz) {
      return xyz;
    }
    panByPosition(coords, pixel) {
      const fromPosition = this.unproject(pixel);
      return {
        longitude: coords[0] - fromPosition[0] + this.longitude,
        latitude: coords[1] - fromPosition[1] + this.latitude
      };
    }
  };
  function transformVector2(matrix, vector) {
    const result = transformMat44([], vector, matrix);
    scale7(result, result, 1 / result[3]);
    return result;
  }

  // ../core/src/viewports/orbit-viewport.ts
  var DEGREES_TO_RADIANS7 = Math.PI / 180;
  function getViewMatrix2({
    height,
    focalDistance,
    orbitAxis,
    rotationX,
    rotationOrbit,
    zoom
  }) {
    const up = orbitAxis === "Z" ? [0, 0, 1] : [0, 1, 0];
    const eye = orbitAxis === "Z" ? [0, -focalDistance, 0] : [0, 0, focalDistance];
    const viewMatrix2 = new Matrix4().lookAt({
      eye,
      up
    });
    viewMatrix2.rotateX(rotationX * DEGREES_TO_RADIANS7);
    if (orbitAxis === "Z") {
      viewMatrix2.rotateZ(rotationOrbit * DEGREES_TO_RADIANS7);
    } else {
      viewMatrix2.rotateY(rotationOrbit * DEGREES_TO_RADIANS7);
    }
    const projectionScale = Math.pow(2, zoom) / height;
    viewMatrix2.scale(projectionScale);
    return viewMatrix2;
  }
  var OrbitViewport = class extends Viewport {
    constructor(props) {
      const {
        height,
        projectionMatrix,
        fovy = 50,
        orbitAxis = "Z",
        target = [0, 0, 0],
        rotationX = 0,
        rotationOrbit = 0,
        zoom = 0
      } = props;
      const focalDistance = projectionMatrix ? projectionMatrix[5] / 2 : fovyToAltitude(fovy);
      super({
        ...props,
        longitude: void 0,
        viewMatrix: getViewMatrix2({
          height: height || 1,
          focalDistance,
          orbitAxis,
          rotationX,
          rotationOrbit,
          zoom
        }),
        fovy,
        focalDistance,
        position: target,
        zoom
      });
      this.projectedCenter = this.project(this.center);
    }
    unproject(xyz, {
      topLeft = true
    } = {}) {
      const [x2, y2, z = this.projectedCenter[2]] = xyz;
      const y22 = topLeft ? y2 : this.height - y2;
      const [X, Y, Z] = pixelsToWorld([x2, y22, z], this.pixelUnprojectionMatrix);
      return [X, Y, Z];
    }
    panByPosition(coords, pixel) {
      const p0 = this.project(coords);
      const nextCenter = [this.width / 2 + p0[0] - pixel[0], this.height / 2 + p0[1] - pixel[1], this.projectedCenter[2]];
      return {
        target: this.unproject(nextCenter)
      };
    }
  };

  // ../core/src/viewports/orthographic-viewport.ts
  var viewMatrix = new Matrix4().lookAt({
    eye: [0, 0, 1]
  });
  function getProjectionMatrix2({
    width,
    height,
    near,
    far,
    padding
  }) {
    let left = -width / 2;
    let right = width / 2;
    let bottom = -height / 2;
    let top = height / 2;
    if (padding) {
      const {
        left: l2 = 0,
        right: r2 = 0,
        top: t2 = 0,
        bottom: b = 0
      } = padding;
      const offsetX = clamp((l2 + width - r2) / 2, 0, width) - width / 2;
      const offsetY = clamp((t2 + height - b) / 2, 0, height) - height / 2;
      left -= offsetX;
      right -= offsetX;
      bottom += offsetY;
      top += offsetY;
    }
    return new Matrix4().ortho({
      left,
      right,
      bottom,
      top,
      near,
      far
    });
  }
  var OrthographicViewport = class extends Viewport {
    constructor(props) {
      const {
        width,
        height,
        near = 0.1,
        far = 1e3,
        zoom = 0,
        target = [0, 0, 0],
        padding = null,
        flipY = true
      } = props;
      const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;
      const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;
      const zoom_ = Math.min(zoomX, zoomY);
      const scale8 = Math.pow(2, zoom_);
      let distanceScales;
      if (zoomX !== zoomY) {
        const scaleX2 = Math.pow(2, zoomX);
        const scaleY2 = Math.pow(2, zoomY);
        distanceScales = {
          unitsPerMeter: [scaleX2 / scale8, scaleY2 / scale8, 1],
          metersPerUnit: [scale8 / scaleX2, scale8 / scaleY2, 1]
        };
      }
      super({
        ...props,
        longitude: void 0,
        position: target,
        viewMatrix: viewMatrix.clone().scale([scale8, scale8 * (flipY ? -1 : 1), scale8]),
        projectionMatrix: getProjectionMatrix2({
          width: width || 1,
          height: height || 1,
          padding,
          near,
          far
        }),
        zoom: zoom_,
        distanceScales
      });
    }
    projectFlat([X, Y]) {
      const {
        unitsPerMeter: unitsPerMeter2
      } = this.distanceScales;
      return [X * unitsPerMeter2[0], Y * unitsPerMeter2[1]];
    }
    unprojectFlat([x2, y2]) {
      const {
        metersPerUnit
      } = this.distanceScales;
      return [x2 * metersPerUnit[0], y2 * metersPerUnit[1]];
    }
    panByPosition(coords, pixel) {
      const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
      const toLocation = this.projectFlat(coords);
      const translate4 = add4([], toLocation, negate2([], fromLocation));
      const newCenter = add4([], this.center, translate4);
      return {
        target: this.unprojectFlat(newCenter)
      };
    }
  };

  // ../core/src/viewports/first-person-viewport.ts
  var FirstPersonViewport = class extends Viewport {
    constructor(props) {
      const {
        longitude,
        latitude,
        modelMatrix: modelMatrix2,
        bearing = 0,
        pitch = 0,
        up = [0, 0, 1]
      } = props;
      const spherical = new SphericalCoordinates({
        bearing,
        pitch: pitch === -90 ? 1e-4 : 90 + pitch
      });
      const dir = spherical.toVector3().normalize();
      const center = modelMatrix2 ? new Matrix4(modelMatrix2).transformAsVector(dir) : dir;
      const zoom = Number.isFinite(latitude) ? getMeterZoom({
        latitude
      }) : 0;
      const scale8 = Math.pow(2, zoom);
      const viewMatrix2 = new Matrix4().lookAt({
        eye: [0, 0, 0],
        center,
        up
      }).scale(scale8);
      super({
        ...props,
        zoom,
        viewMatrix: viewMatrix2
      });
      this.latitude = latitude;
      this.longitude = longitude;
    }
  };

  // ../core/src/controllers/first-person-controller.ts
  var MOVEMENT_SPEED = 20;
  var FirstPersonState = class extends ViewState {
    constructor(options) {
      const {
        width,
        height,
        position = [0, 0, 0],
        bearing = 0,
        pitch = 0,
        longitude = null,
        latitude = null,
        maxPitch = 90,
        minPitch = -90,
        startRotatePos,
        startBearing,
        startPitch,
        startZoomPosition
      } = options;
      super({
        width,
        height,
        position,
        bearing,
        pitch,
        longitude,
        latitude,
        maxPitch,
        minPitch
      }, {
        startRotatePos,
        startBearing,
        startPitch,
        startZoomPosition
      });
    }
    panStart() {
      return this;
    }
    pan() {
      return this;
    }
    panEnd() {
      return this;
    }
    rotateStart({
      pos
    }) {
      return this._getUpdatedState({
        startRotatePos: pos,
        startBearing: this.getViewportProps().bearing,
        startPitch: this.getViewportProps().pitch
      });
    }
    rotate({
      pos,
      deltaAngleX = 0,
      deltaAngleY = 0
    }) {
      const {
        startRotatePos,
        startBearing,
        startPitch
      } = this.getState();
      const {
        width,
        height
      } = this.getViewportProps();
      if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
        return this;
      }
      let newRotation;
      if (pos) {
        const deltaScaleX = (pos[0] - startRotatePos[0]) / width;
        const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
        newRotation = {
          bearing: startBearing - deltaScaleX * 180,
          pitch: startPitch - deltaScaleY * 90
        };
      } else {
        newRotation = {
          bearing: startBearing - deltaAngleX,
          pitch: startPitch - deltaAngleY
        };
      }
      return this._getUpdatedState(newRotation);
    }
    rotateEnd() {
      return this._getUpdatedState({
        startRotatePos: null,
        startBearing: null,
        startPitch: null
      });
    }
    zoomStart() {
      return this._getUpdatedState({
        startZoomPosition: this.getViewportProps().position
      });
    }
    zoom({
      scale: scale8
    }) {
      let {
        startZoomPosition
      } = this.getState();
      if (!startZoomPosition) {
        startZoomPosition = this.getViewportProps().position;
      }
      const direction = this.getDirection();
      return this._move(direction, Math.log2(scale8) * MOVEMENT_SPEED, startZoomPosition);
    }
    zoomEnd() {
      return this._getUpdatedState({
        startZoomPosition: null
      });
    }
    moveLeft(speed = MOVEMENT_SPEED) {
      const direction = this.getDirection(true);
      return this._move(direction.rotateZ({
        radians: Math.PI / 2
      }), speed);
    }
    moveRight(speed = MOVEMENT_SPEED) {
      const direction = this.getDirection(true);
      return this._move(direction.rotateZ({
        radians: -Math.PI / 2
      }), speed);
    }
    moveUp(speed = MOVEMENT_SPEED) {
      const direction = this.getDirection(true);
      return this._move(direction, speed);
    }
    moveDown(speed = MOVEMENT_SPEED) {
      const direction = this.getDirection(true);
      return this._move(direction.negate(), speed);
    }
    rotateLeft(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing - speed
      });
    }
    rotateRight(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing + speed
      });
    }
    rotateUp(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch + speed
      });
    }
    rotateDown(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch - speed
      });
    }
    zoomIn(speed = 2) {
      return this.zoom({
        scale: speed
      });
    }
    zoomOut(speed = 2) {
      return this.zoom({
        scale: 1 / speed
      });
    }
    shortestPathFrom(viewState) {
      const fromProps = viewState.getViewportProps();
      const props = {
        ...this.getViewportProps()
      };
      const {
        bearing,
        longitude
      } = props;
      if (Math.abs(bearing - fromProps.bearing) > 180) {
        props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
      }
      if (longitude !== null && fromProps.longitude !== null && Math.abs(longitude - fromProps.longitude) > 180) {
        props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
      }
      return props;
    }
    _move(direction, speed, fromPosition = this.getViewportProps().position) {
      const delta = direction.scale(speed);
      return this._getUpdatedState({
        position: new Vector3(fromPosition).add(delta)
      });
    }
    getDirection(use2D = false) {
      const spherical = new SphericalCoordinates({
        bearing: this.getViewportProps().bearing,
        pitch: use2D ? 90 : 90 + this.getViewportProps().pitch
      });
      const direction = spherical.toVector3().normalize();
      return direction;
    }
    _getUpdatedState(newProps) {
      return new FirstPersonState({
        ...this.getViewportProps(),
        ...this.getState(),
        ...newProps
      });
    }
    applyConstraints(props) {
      const {
        pitch,
        maxPitch,
        minPitch,
        longitude,
        bearing
      } = props;
      props.pitch = clamp(pitch, minPitch, maxPitch);
      if (longitude !== null && (longitude < -180 || longitude > 180)) {
        props.longitude = mod2(longitude + 180, 360) - 180;
      }
      if (bearing < -180 || bearing > 180) {
        props.bearing = mod2(bearing + 180, 360) - 180;
      }
      return props;
    }
  };
  var FirstPersonController = class extends Controller {
    ControllerState = FirstPersonState;
    transition = {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator(["position", "pitch", "bearing"])
    };
  };

  // ../core/src/views/first-person-view.ts
  var FirstPersonView = class extends View {
    get ViewportType() {
      return FirstPersonViewport;
    }
    get ControllerType() {
      return FirstPersonController;
    }
  };
  __publicField(FirstPersonView, "displayName", "FirstPersonView");

  // ../core/src/controllers/orbit-controller.ts
  var OrbitState = class extends ViewState {
    constructor(options) {
      const {
        width,
        height,
        rotationX = 0,
        rotationOrbit = 0,
        target = [0, 0, 0],
        zoom = 0,
        minRotationX = -90,
        maxRotationX = 90,
        minZoom = -Infinity,
        maxZoom = Infinity,
        startPanPosition,
        startRotatePos,
        startRotationX,
        startRotationOrbit,
        startZoomPosition,
        startZoom
      } = options;
      super({
        width,
        height,
        rotationX,
        rotationOrbit,
        target,
        zoom,
        minRotationX,
        maxRotationX,
        minZoom,
        maxZoom
      }, {
        startPanPosition,
        startRotatePos,
        startRotationX,
        startRotationOrbit,
        startZoomPosition,
        startZoom
      });
      this.makeViewport = options.makeViewport;
    }
    panStart({
      pos
    }) {
      return this._getUpdatedState({
        startPanPosition: this._unproject(pos)
      });
    }
    pan({
      pos,
      startPosition
    }) {
      const startPanPosition = this.getState().startPanPosition || startPosition;
      if (!startPanPosition) {
        return this;
      }
      const viewport = this.makeViewport(this.getViewportProps());
      const newProps = viewport.panByPosition(startPanPosition, pos);
      return this._getUpdatedState(newProps);
    }
    panEnd() {
      return this._getUpdatedState({
        startPanPosition: null
      });
    }
    rotateStart({
      pos
    }) {
      return this._getUpdatedState({
        startRotatePos: pos,
        startRotationX: this.getViewportProps().rotationX,
        startRotationOrbit: this.getViewportProps().rotationOrbit
      });
    }
    rotate({
      pos,
      deltaAngleX = 0,
      deltaAngleY = 0
    }) {
      const {
        startRotatePos,
        startRotationX,
        startRotationOrbit
      } = this.getState();
      const {
        width,
        height
      } = this.getViewportProps();
      if (!startRotatePos || startRotationX === void 0 || startRotationOrbit === void 0) {
        return this;
      }
      let newRotation;
      if (pos) {
        let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
        const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
        if (startRotationX < -90 || startRotationX > 90) {
          deltaScaleX *= -1;
        }
        newRotation = {
          rotationX: startRotationX + deltaScaleY * 180,
          rotationOrbit: startRotationOrbit + deltaScaleX * 180
        };
      } else {
        newRotation = {
          rotationX: startRotationX + deltaAngleY,
          rotationOrbit: startRotationOrbit + deltaAngleX
        };
      }
      return this._getUpdatedState(newRotation);
    }
    rotateEnd() {
      return this._getUpdatedState({
        startRotationX: null,
        startRotationOrbit: null
      });
    }
    shortestPathFrom(viewState) {
      const fromProps = viewState.getViewportProps();
      const props = {
        ...this.getViewportProps()
      };
      const {
        rotationOrbit
      } = props;
      if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {
        props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
      }
      return props;
    }
    zoomStart({
      pos
    }) {
      return this._getUpdatedState({
        startZoomPosition: this._unproject(pos),
        startZoom: this.getViewportProps().zoom
      });
    }
    zoom({
      pos,
      startPos,
      scale: scale8
    }) {
      let {
        startZoom,
        startZoomPosition
      } = this.getState();
      if (!startZoomPosition) {
        startZoom = this.getViewportProps().zoom;
        startZoomPosition = this._unproject(startPos) || this._unproject(pos);
      }
      if (!startZoomPosition) {
        return this;
      }
      const newZoom = this._calculateNewZoom({
        scale: scale8,
        startZoom
      });
      const zoomedViewport = this.makeViewport({
        ...this.getViewportProps(),
        zoom: newZoom
      });
      return this._getUpdatedState({
        zoom: newZoom,
        ...zoomedViewport.panByPosition(startZoomPosition, pos)
      });
    }
    zoomEnd() {
      return this._getUpdatedState({
        startZoomPosition: null,
        startZoom: null
      });
    }
    zoomIn(speed = 2) {
      return this._getUpdatedState({
        zoom: this._calculateNewZoom({
          scale: speed
        })
      });
    }
    zoomOut(speed = 2) {
      return this._getUpdatedState({
        zoom: this._calculateNewZoom({
          scale: 1 / speed
        })
      });
    }
    moveLeft(speed = 50) {
      return this._panFromCenter([-speed, 0]);
    }
    moveRight(speed = 50) {
      return this._panFromCenter([speed, 0]);
    }
    moveUp(speed = 50) {
      return this._panFromCenter([0, -speed]);
    }
    moveDown(speed = 50) {
      return this._panFromCenter([0, speed]);
    }
    rotateLeft(speed = 15) {
      return this._getUpdatedState({
        rotationOrbit: this.getViewportProps().rotationOrbit - speed
      });
    }
    rotateRight(speed = 15) {
      return this._getUpdatedState({
        rotationOrbit: this.getViewportProps().rotationOrbit + speed
      });
    }
    rotateUp(speed = 10) {
      return this._getUpdatedState({
        rotationX: this.getViewportProps().rotationX - speed
      });
    }
    rotateDown(speed = 10) {
      return this._getUpdatedState({
        rotationX: this.getViewportProps().rotationX + speed
      });
    }
    _unproject(pos) {
      const viewport = this.makeViewport(this.getViewportProps());
      return pos && viewport.unproject(pos);
    }
    _calculateNewZoom({
      scale: scale8,
      startZoom
    }) {
      const {
        maxZoom,
        minZoom
      } = this.getViewportProps();
      if (startZoom === void 0) {
        startZoom = this.getViewportProps().zoom;
      }
      const zoom = startZoom + Math.log2(scale8);
      return clamp(zoom, minZoom, maxZoom);
    }
    _panFromCenter(offset) {
      const {
        width,
        height,
        target
      } = this.getViewportProps();
      return this.pan({
        startPosition: target,
        pos: [width / 2 + offset[0], height / 2 + offset[1]]
      });
    }
    _getUpdatedState(newProps) {
      return new this.constructor({
        makeViewport: this.makeViewport,
        ...this.getViewportProps(),
        ...this.getState(),
        ...newProps
      });
    }
    applyConstraints(props) {
      const {
        maxZoom,
        minZoom,
        zoom,
        maxRotationX,
        minRotationX,
        rotationOrbit
      } = props;
      props.zoom = Array.isArray(zoom) ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)] : clamp(zoom, minZoom, maxZoom);
      props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);
      if (rotationOrbit < -180 || rotationOrbit > 180) {
        props.rotationOrbit = mod2(rotationOrbit + 180, 360) - 180;
      }
      return props;
    }
  };
  var OrbitController = class extends Controller {
    ControllerState = OrbitState;
    transition = {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator({
        transitionProps: {
          compare: ["target", "zoom", "rotationX", "rotationOrbit"],
          required: ["target", "zoom"]
        }
      })
    };
  };

  // ../core/src/views/orbit-view.ts
  var OrbitView = class extends View {
    constructor(props = {}) {
      super(props);
      this.props.orbitAxis = props.orbitAxis || "Z";
    }
    get ViewportType() {
      return OrbitViewport;
    }
    get ControllerType() {
      return OrbitController;
    }
  };
  __publicField(OrbitView, "displayName", "OrbitView");

  // ../core/src/controllers/orthographic-controller.ts
  var OrthographicState = class extends OrbitState {
    constructor(props) {
      super(props);
      this.zoomAxis = props.zoomAxis || "all";
    }
    _calculateNewZoom({
      scale: scale8,
      startZoom
    }) {
      const {
        maxZoom,
        minZoom
      } = this.getViewportProps();
      if (startZoom === void 0) {
        startZoom = this.getViewportProps().zoom;
      }
      let deltaZoom = Math.log2(scale8);
      if (Array.isArray(startZoom)) {
        let [newZoomX, newZoomY] = startZoom;
        switch (this.zoomAxis) {
          case "X":
            newZoomX = clamp(newZoomX + deltaZoom, minZoom, maxZoom);
            break;
          case "Y":
            newZoomY = clamp(newZoomY + deltaZoom, minZoom, maxZoom);
            break;
          default:
            let z = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);
            if (z < minZoom) {
              deltaZoom += minZoom - z;
            }
            z = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);
            if (z > maxZoom) {
              deltaZoom += maxZoom - z;
            }
            newZoomX += deltaZoom;
            newZoomY += deltaZoom;
        }
        return [newZoomX, newZoomY];
      }
      return clamp(startZoom + deltaZoom, minZoom, maxZoom);
    }
  };
  var OrthographicController = class extends Controller {
    ControllerState = OrthographicState;
    transition = {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator(["target", "zoom"])
    };
    dragMode = "pan";
    _onPanRotate() {
      return false;
    }
  };

  // ../core/src/views/orthographic-view.ts
  var OrthographicView = class extends View {
    get ViewportType() {
      return OrthographicViewport;
    }
    get ControllerType() {
      return OrthographicController;
    }
  };
  __publicField(OrthographicView, "displayName", "OrthographicView");

  // ../core/src/controllers/globe-controller.ts
  var GlobeState = class extends MapState {
    applyConstraints(props) {
      const {
        maxZoom,
        minZoom,
        zoom
      } = props;
      props.zoom = clamp(zoom, minZoom, maxZoom);
      const {
        longitude,
        latitude
      } = props;
      if (longitude < -180 || longitude > 180) {
        props.longitude = mod2(longitude + 180, 360) - 180;
      }
      props.latitude = clamp(latitude, -89, 89);
      return props;
    }
  };
  var GlobeController = class extends Controller {
    ControllerState = GlobeState;
    transition = {
      transitionDuration: 300,
      transitionInterpolator: new LinearInterpolator(["longitude", "latitude", "zoom"])
    };
    dragMode = "pan";
    setProps(props) {
      super.setProps(props);
      this.dragRotate = false;
      this.touchRotate = false;
    }
  };

  // ../core/src/views/globe-view.ts
  var GlobeView = class extends View {
    get ViewportType() {
      return GlobeViewport;
    }
    get ControllerType() {
      return GlobeController;
    }
  };
  __publicField(GlobeView, "displayName", "GlobeView");

  // ../core/src/lib/layer-extension.ts
  var LayerExtension = class {
    static get componentName() {
      return Object.prototype.hasOwnProperty.call(this, "extensionName") ? this.extensionName : "";
    }
    constructor(opts) {
      if (opts) {
        this.opts = opts;
      }
    }
    equals(extension) {
      if (this === extension) {
        return true;
      }
      return this.constructor === extension.constructor && deepEqual(this.opts, extension.opts, 1);
    }
    getShaders(extension) {
      return null;
    }
    getSubLayerProps(extension) {
      const {
        defaultProps: defaultProps54
      } = extension.constructor;
      const newProps = {
        updateTriggers: {}
      };
      for (const key in defaultProps54) {
        if (key in this.props) {
          const propDef = defaultProps54[key];
          const propValue = this.props[key];
          newProps[key] = propValue;
          if (propDef && propDef.type === "accessor") {
            newProps.updateTriggers[key] = this.props.updateTriggers[key];
            if (typeof propValue === "function") {
              newProps[key] = this.getSubLayerAccessor(propValue);
            }
          }
        }
      }
      return newProps;
    }
    initializeState(context, extension) {
    }
    updateState(params, extension) {
    }
    onNeedsRedraw(extension) {
    }
    getNeedsPickingBuffer(extension) {
      return false;
    }
    draw(params, extension) {
    }
    finalizeState(context, extension) {
    }
  };
  __publicField(LayerExtension, "defaultProps", {});
  __publicField(LayerExtension, "extensionName", "LayerExtension");

  // ../core/src/transitions/fly-to-interpolator.ts
  var LINEARLY_INTERPOLATED_PROPS = {
    bearing: 0,
    pitch: 0,
    position: [0, 0, 0]
  };
  var DEFAULT_OPTS2 = {
    speed: 1.2,
    curve: 1.414
  };
  var FlyToInterpolator = class extends TransitionInterpolator {
    constructor(opts = {}) {
      super({
        compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
        extract: ["width", "height", "longitude", "latitude", "zoom", "bearing", "pitch", "position"],
        required: ["width", "height", "latitude", "longitude", "zoom"]
      });
      this.opts = {
        ...DEFAULT_OPTS2,
        ...opts
      };
    }
    interpolateProps(startProps, endProps, t2) {
      const viewport = flyToViewport(startProps, endProps, t2, this.opts);
      for (const key in LINEARLY_INTERPOLATED_PROPS) {
        viewport[key] = lerp(startProps[key] || LINEARLY_INTERPOLATED_PROPS[key], endProps[key] || LINEARLY_INTERPOLATED_PROPS[key], t2);
      }
      return viewport;
    }
    getDuration(startProps, endProps) {
      let {
        transitionDuration
      } = endProps;
      if (transitionDuration === "auto") {
        transitionDuration = getFlyToDuration(startProps, endProps, this.opts);
      }
      return transitionDuration;
    }
  };

  // ../core/src/utils/tesselator.ts
  var Tesselator = class {
    indexStarts = [0];
    vertexStarts = [0];
    vertexCount = 0;
    instanceCount = 0;
    constructor(opts) {
      const {
        attributes = {}
      } = opts;
      this.typedArrayManager = typed_array_manager_default;
      this.attributes = {};
      this._attributeDefs = attributes;
      this.opts = opts;
      this.updateGeometry(opts);
    }
    updateGeometry(opts) {
      Object.assign(this.opts, opts);
      const {
        data,
        buffers = {},
        getGeometry: getGeometry2,
        geometryBuffer,
        positionFormat,
        dataChanged,
        normalize: normalize5 = true
      } = this.opts;
      this.data = data;
      this.getGeometry = getGeometry2;
      this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === "XY" ? 2 : 3);
      this.buffers = buffers;
      this.normalize = normalize5;
      if (geometryBuffer) {
        assert11(data.startIndices);
        this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
        if (!normalize5) {
          buffers.positions = geometryBuffer;
        }
      }
      this.geometryBuffer = buffers.positions;
      if (Array.isArray(dataChanged)) {
        for (const dataRange of dataChanged) {
          this._rebuildGeometry(dataRange);
        }
      } else {
        this._rebuildGeometry();
      }
    }
    updatePartialGeometry({
      startRow,
      endRow
    }) {
      this._rebuildGeometry({
        startRow,
        endRow
      });
    }
    getGeometryFromBuffer(geometryBuffer) {
      const value = geometryBuffer.value || geometryBuffer;
      if (!ArrayBuffer.isView(value)) {
        return null;
      }
      return getAccessorFromBuffer(value, {
        size: this.positionSize,
        offset: geometryBuffer.offset,
        stride: geometryBuffer.stride,
        startIndices: this.data.startIndices
      });
    }
    _allocate(instanceCount, copy3) {
      const {
        attributes,
        buffers,
        _attributeDefs,
        typedArrayManager
      } = this;
      for (const name10 in _attributeDefs) {
        if (name10 in buffers) {
          typedArrayManager.release(attributes[name10]);
          attributes[name10] = null;
        } else {
          const def = _attributeDefs[name10];
          def.copy = copy3;
          attributes[name10] = typedArrayManager.allocate(attributes[name10], instanceCount, def);
        }
      }
    }
    _forEachGeometry(visitor, startRow, endRow) {
      const {
        data,
        getGeometry: getGeometry2
      } = this;
      const {
        iterable,
        objectInfo
      } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        const geometry = getGeometry2 ? getGeometry2(object, objectInfo) : null;
        visitor(geometry, objectInfo.index);
      }
    }
    _rebuildGeometry(dataRange) {
      if (!this.data) {
        return;
      }
      let {
        indexStarts,
        vertexStarts,
        instanceCount
      } = this;
      const {
        data,
        geometryBuffer
      } = this;
      const {
        startRow = 0,
        endRow = Infinity
      } = dataRange || {};
      const normalizedData = {};
      if (!dataRange) {
        indexStarts = [0];
        vertexStarts = [0];
      }
      if (this.normalize || !geometryBuffer) {
        this._forEachGeometry((geometry, dataIndex) => {
          const normalizedGeometry = geometry && this.normalizeGeometry(geometry);
          normalizedData[dataIndex] = normalizedGeometry;
          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
        }, startRow, endRow);
        instanceCount = vertexStarts[vertexStarts.length - 1];
      } else {
        vertexStarts = data.startIndices;
        instanceCount = vertexStarts[data.length] || 0;
        if (ArrayBuffer.isView(geometryBuffer)) {
          instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
        } else if (geometryBuffer instanceof Buffer2) {
          const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;
          instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
        } else if (geometryBuffer.buffer) {
          const byteStride = geometryBuffer.stride || this.positionSize * 4;
          instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
        } else if (geometryBuffer.value) {
          const bufferValue = geometryBuffer.value;
          const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;
          instanceCount = instanceCount || bufferValue.length / elementStride;
        }
      }
      this._allocate(instanceCount, Boolean(dataRange));
      this.indexStarts = indexStarts;
      this.vertexStarts = vertexStarts;
      this.instanceCount = instanceCount;
      const context = {};
      this._forEachGeometry((geometry, dataIndex) => {
        const normalizedGeometry = normalizedData[dataIndex] || geometry;
        context.vertexStart = vertexStarts[dataIndex];
        context.indexStart = indexStarts[dataIndex];
        const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
        context.geometrySize = vertexEnd - vertexStarts[dataIndex];
        context.geometryIndex = dataIndex;
        this.updateGeometryAttributes(normalizedGeometry, context);
      }, startRow, endRow);
      this.vertexCount = indexStarts[indexStarts.length - 1];
    }
  };

  // ../layers/src/arc-layer/arc-layer-vertex.glsl.ts
  var arc_layer_vertex_glsl_default = `#define SHADER_NAME arc-layer-vertex-shader

attribute vec3 positions;
attribute vec4 instanceSourceColors;
attribute vec4 instanceTargetColors;
attribute vec3 instanceSourcePositions;
attribute vec3 instanceSourcePositions64Low;
attribute vec3 instanceTargetPositions;
attribute vec3 instanceTargetPositions64Low;
attribute vec3 instancePickingColors;
attribute float instanceWidths;
attribute float instanceHeights;
attribute float instanceTilts;

uniform bool greatCircle;
uniform bool useShortestPath;
uniform float numSegments;
uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform int widthUnits;

varying vec4 vColor;
varying vec2 uv;
varying float isValid;

float paraboloid(float distance, float sourceZ, float targetZ, float ratio) {
  // d: distance on the xy plane
  // r: ratio of the current point
  // p: ratio of the peak of the arc
  // h: height multiplier
  // z = f(r) = sqrt(r * (p * 2 - r)) * d * h
  // f(0) = 0
  // f(1) = dz

  float deltaZ = targetZ - sourceZ;
  float dh = distance * instanceHeights;
  if (dh == 0.0) {
    return sourceZ + deltaZ * ratio;
  }
  float unitZ = deltaZ / dh;
  float p2 = unitZ * unitZ + 1.0;

  // sqrt does not deal with negative values, manually flip source and target if delta.z < 0
  float dir = step(deltaZ, 0.0);
  float z0 = mix(sourceZ, targetZ, dir);
  float r = mix(ratio, 1.0 - ratio, dir);
  return sqrt(r * (p2 - r)) * dh + z0;
}

// offset vector by strokeWidth pixels
// offset_direction is -1 (left) or 1 (right)
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
  // normalized direction of the line
  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);
  // rotate by 90 degrees
  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);

  return dir_screenspace * offset_direction * width / 2.0;
}

float getSegmentRatio(float index) {
  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));
}

vec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {
  float distance = length(source.xy - target.xy);
  float z = paraboloid(distance, source.z, target.z, segmentRatio);

  float tiltAngle = radians(instanceTilts);
  vec2 tiltDirection = normalize(target.xy - source.xy);
  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);

  return vec3(
    mix(source.xy, target.xy, segmentRatio) + tilt,
    z * cos(tiltAngle)
  );
}

/* Great circle interpolation
 * http://www.movable-type.co.uk/scripts/latlong.html
 */
float getAngularDist (vec2 source, vec2 target) {
  vec2 sourceRadians = radians(source);
  vec2 targetRadians = radians(target);
  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);
  vec2 shd_sq = sin_half_delta * sin_half_delta;

  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;
  return 2.0 * asin(sqrt(a));
}

vec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {
  vec2 lngLat;

  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation
  if(abs(angularDist - PI) < 0.001) {
    lngLat = (1.0 - t) * source.xy + t * target.xy;
  } else {
    float a = sin((1.0 - t) * angularDist);
    float b = sin(t * angularDist);
    vec3 p = source3D.yxz * a + target3D.yxz * b;
    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));
  }

  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);

  return vec3(lngLat, z);
}

/* END GREAT CIRCLE */

void main(void) {
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;

  float segmentIndex = positions.x;
  float segmentRatio = getSegmentRatio(segmentIndex);
  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));
  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));

  // if it's the first point, use next - current as direction
  // otherwise use current - prev
  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));
  isValid = 1.0;

  uv = vec2(segmentRatio, positions.y);
  geometry.uv = uv;
  geometry.pickingColor = instancePickingColors;

  vec4 curr;
  vec4 next;
  vec3 source;
  vec3 target;

  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));
    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));
    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);

    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);
    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);
    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);

    if (abs(currPos.x - prevPos.x) > 180.0) {
      indexDir = -1.0;
      isValid = 0.0;
    } else if (abs(currPos.x - nextPos.x) > 180.0) {
      indexDir = 1.0;
      isValid = 0.0;
    }
    nextPos = indexDir < 0.0 ? prevPos : nextPos;
    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;

    if (isValid == 0.0) {
      // split at the 180th meridian
      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;
      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);
      currPos = mix(currPos, nextPos, t);
      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);
    }

    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);
    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);
  
    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);
    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));
  
  } else {
    vec3 source_world = instanceSourcePositions;
    vec3 target_world = instanceTargetPositions;
    if (useShortestPath) {
      source_world.x = mod(source_world.x + 180., 360.0) - 180.;
      target_world.x = mod(target_world.x + 180., 360.0) - 180.;

      float deltaLng = target_world.x - source_world.x;
      if (deltaLng > 180.) target_world.x -= 360.;
      if (deltaLng < -180.) source_world.x -= 360.;
    }
    source = project_position(source_world, instanceSourcePositions64Low);
    target = project_position(target_world, instanceTargetPositions64Low);

    // common x at longitude=-180
    float antiMeridianX = 0.0;

    if (useShortestPath) {
      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;
      }
      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);

      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {
        isValid = 0.0;
        indexDir = sign(segmentRatio - thresholdRatio);
        segmentRatio = thresholdRatio;
      }
    }

    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
    vec3 currPos = interpolateFlat(source, target, segmentRatio);
    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);

    if (useShortestPath) {
      if (nextPos.x < antiMeridianX) {
        currPos.x += TILE_SIZE;
        nextPos.x += TILE_SIZE;
      }
    }

    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));
    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));
    geometry.position = vec4(currPos, 1.0);
  }

  // Multiply out width and clamp to limits
  // mercator pixels are interpreted as screen pixels
  float widthPixels = clamp(
    project_size_to_pixel(instanceWidths * widthScale, widthUnits),
    widthMinPixels, widthMaxPixels
  );

  // extrude
  vec3 offset = vec3(
    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),
    0.0);
  DECKGL_FILTER_SIZE(offset, geometry);
  DECKGL_FILTER_GL_POSITION(curr, geometry);
  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);

  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);
  vColor = vec4(color.rgb, color.a * opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/arc-layer/arc-layer-fragment.glsl.ts
  var arc_layer_fragment_glsl_default = `#define SHADER_NAME arc-layer-fragment-shader

precision highp float;

varying vec4 vColor;
varying vec2 uv;
varying float isValid;

void main(void) {
  if (isValid == 0.0) {
    discard;
  }

  gl_FragColor = vColor;
  geometry.uv = uv;

  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;

  // ../layers/src/arc-layer/arc-layer.ts
  var DEFAULT_COLOR = [0, 0, 0, 255];
  var defaultProps3 = {
    getSourcePosition: {
      type: "accessor",
      value: (x2) => x2.sourcePosition
    },
    getTargetPosition: {
      type: "accessor",
      value: (x2) => x2.targetPosition
    },
    getSourceColor: {
      type: "accessor",
      value: DEFAULT_COLOR
    },
    getTargetColor: {
      type: "accessor",
      value: DEFAULT_COLOR
    },
    getWidth: {
      type: "accessor",
      value: 1
    },
    getHeight: {
      type: "accessor",
      value: 1
    },
    getTilt: {
      type: "accessor",
      value: 0
    },
    greatCircle: false,
    widthUnits: "pixels",
    widthScale: {
      type: "number",
      value: 1,
      min: 0
    },
    widthMinPixels: {
      type: "number",
      value: 0,
      min: 0
    },
    widthMaxPixels: {
      type: "number",
      value: Number.MAX_SAFE_INTEGER,
      min: 0
    }
  };
  var ArcLayer = class extends Layer {
    getBounds() {
      return this.getAttributeManager()?.getBounds(["instanceSourcePositions", "instanceTargetPositions"]);
    }
    getShaders() {
      return super.getShaders({
        vs: arc_layer_vertex_glsl_default,
        fs: arc_layer_fragment_glsl_default,
        modules: [project32_default, picking_default]
      });
    }
    get wrapLongitude() {
      return false;
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceSourcePositions: {
          size: 3,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getSourcePosition"
        },
        instanceTargetPositions: {
          size: 3,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getTargetPosition"
        },
        instanceSourceColors: {
          size: this.props.colorFormat.length,
          type: esm_default2.UNSIGNED_BYTE,
          normalized: true,
          transition: true,
          accessor: "getSourceColor",
          defaultValue: DEFAULT_COLOR
        },
        instanceTargetColors: {
          size: this.props.colorFormat.length,
          type: esm_default2.UNSIGNED_BYTE,
          normalized: true,
          transition: true,
          accessor: "getTargetColor",
          defaultValue: DEFAULT_COLOR
        },
        instanceWidths: {
          size: 1,
          transition: true,
          accessor: "getWidth",
          defaultValue: 1
        },
        instanceHeights: {
          size: 1,
          transition: true,
          accessor: "getHeight",
          defaultValue: 1
        },
        instanceTilts: {
          size: 1,
          transition: true,
          accessor: "getTilt",
          defaultValue: 0
        }
      });
    }
    updateState(opts) {
      super.updateState(opts);
      if (opts.changeFlags.extensionsChanged) {
        const {
          gl
        } = this.context;
        this.state.model?.delete();
        this.state.model = this._getModel(gl);
        this.getAttributeManager().invalidateAll();
      }
    }
    draw({
      uniforms
    }) {
      const {
        widthUnits,
        widthScale,
        widthMinPixels,
        widthMaxPixels,
        greatCircle,
        wrapLongitude
      } = this.props;
      this.state.model.setUniforms(uniforms).setUniforms({
        greatCircle,
        widthUnits: UNIT[widthUnits],
        widthScale,
        widthMinPixels,
        widthMaxPixels,
        useShortestPath: wrapLongitude
      }).draw();
    }
    _getModel(gl) {
      let positions = [];
      const NUM_SEGMENTS = 50;
      for (let i3 = 0; i3 < NUM_SEGMENTS; i3++) {
        positions = positions.concat([i3, 1, 0, i3, -1, 0]);
      }
      const model = new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new Geometry({
          drawMode: esm_default2.TRIANGLE_STRIP,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true
      });
      model.setUniforms({
        numSegments: NUM_SEGMENTS
      });
      return model;
    }
  };
  __publicField(ArcLayer, "layerName", "ArcLayer");
  __publicField(ArcLayer, "defaultProps", defaultProps3);

  // ../layers/src/bitmap-layer/create-mesh.ts
  var DEFAULT_INDICES = new Uint16Array([0, 2, 1, 0, 3, 2]);
  var DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
  function createMesh(bounds, resolution) {
    if (!resolution) {
      return createQuad(bounds);
    }
    const maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));
    const maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));
    const uCount = Math.ceil(maxXSpan / resolution) + 1;
    const vCount = Math.ceil(maxYSpan / resolution) + 1;
    const vertexCount = (uCount - 1) * (vCount - 1) * 6;
    const indices = new Uint32Array(vertexCount);
    const texCoords = new Float32Array(uCount * vCount * 2);
    const positions = new Float64Array(uCount * vCount * 3);
    let vertex = 0;
    let index = 0;
    for (let u = 0; u < uCount; u++) {
      const ut = u / (uCount - 1);
      for (let v = 0; v < vCount; v++) {
        const vt = v / (vCount - 1);
        const p2 = interpolateQuad(bounds, ut, vt);
        positions[vertex * 3 + 0] = p2[0];
        positions[vertex * 3 + 1] = p2[1];
        positions[vertex * 3 + 2] = p2[2] || 0;
        texCoords[vertex * 2 + 0] = ut;
        texCoords[vertex * 2 + 1] = 1 - vt;
        if (u > 0 && v > 0) {
          indices[index++] = vertex - vCount;
          indices[index++] = vertex - vCount - 1;
          indices[index++] = vertex - 1;
          indices[index++] = vertex - vCount;
          indices[index++] = vertex - 1;
          indices[index++] = vertex;
        }
        vertex++;
      }
    }
    return {
      vertexCount,
      positions,
      indices,
      texCoords
    };
  }
  function createQuad(bounds) {
    const positions = new Float64Array(12);
    for (let i3 = 0; i3 < bounds.length; i3++) {
      positions[i3 * 3 + 0] = bounds[i3][0];
      positions[i3 * 3 + 1] = bounds[i3][1];
      positions[i3 * 3 + 2] = bounds[i3][2] || 0;
    }
    return {
      vertexCount: 6,
      positions,
      indices: DEFAULT_INDICES,
      texCoords: DEFAULT_TEX_COORDS
    };
  }
  function interpolateQuad(quad, ut, vt) {
    return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut);
  }

  // ../layers/src/bitmap-layer/bitmap-layer-vertex.ts
  var bitmap_layer_vertex_default = `
#define SHADER_NAME bitmap-layer-vertex-shader

attribute vec2 texCoords;
attribute vec3 positions;
attribute vec3 positions64Low;

varying vec2 vTexCoord;
varying vec2 vTexPos;

uniform float coordinateConversion;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if (coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy + project_uCommonOrigin.xy;
  } else if (coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}
`;

  // ../layers/src/bitmap-layer/bitmap-layer-fragment.ts
  var packUVsIntoRGB = `
vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}
`;
  var bitmap_layer_fragment_default = `
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

varying vec2 vTexCoord;
varying vec2 vTexPos;

uniform float desaturate;
uniform vec4 transparentColor;
uniform vec3 tintColor;
uniform float opacity;

uniform float coordinateConversion;
uniform vec4 bounds;

/* projection utils */
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

// from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(
    xy.x - PI,
    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5
  ));
}
/* End projection utils */

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * tintColor;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  if (transparentColor.a == 0.0) {
    return vec4(color, alpha);
  }
  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);
  float highLightRatio = alpha / blendedAlpha;
  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);
  return vec4(blendedRGB, blendedAlpha);
}

vec2 getUV(vec2 pos) {
  return vec2(
    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),
    (pos.y - bounds[3]) / (bounds[1] - bounds[3])
  );
}

${packUVsIntoRGB}

void main(void) {
  vec2 uv = vTexCoord;
  if (coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if (coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }
  vec4 bitmapColor = texture2D(bitmapTexture, uv);

  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);

  geometry.uv = uv;
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);

  if (picking_uActive && !picking_uAttribute) {
    // Since instance information is not used, we can use picking color for pixel index
    gl_FragColor.rgb = packUVsIntoRGB(uv);
  }
}
`;

  // ../layers/src/bitmap-layer/bitmap-layer.ts
  var defaultProps4 = {
    image: {
      type: "image",
      value: null,
      async: true
    },
    bounds: {
      type: "array",
      value: [1, 0, 0, 1],
      compare: true
    },
    _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,
    desaturate: {
      type: "number",
      min: 0,
      max: 1,
      value: 0
    },
    transparentColor: {
      type: "color",
      value: [0, 0, 0, 0]
    },
    tintColor: {
      type: "color",
      value: [255, 255, 255]
    },
    textureParameters: {
      type: "object",
      ignore: true
    }
  };
  var BitmapLayer = class extends Layer {
    getShaders() {
      return super.getShaders({
        vs: bitmap_layer_vertex_default,
        fs: bitmap_layer_fragment_default,
        modules: [project32_default, picking_default]
      });
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.remove(["instancePickingColors"]);
      const noAlloc = true;
      attributeManager.add({
        indices: {
          size: 1,
          isIndexed: true,
          update: (attribute) => attribute.value = this.state.mesh.indices,
          noAlloc
        },
        positions: {
          size: 3,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          update: (attribute) => attribute.value = this.state.mesh.positions,
          noAlloc
        },
        texCoords: {
          size: 2,
          update: (attribute) => attribute.value = this.state.mesh.texCoords,
          noAlloc
        }
      });
    }
    updateState({
      props,
      oldProps,
      changeFlags
    }) {
      const attributeManager = this.getAttributeManager();
      if (changeFlags.extensionsChanged) {
        const {
          gl
        } = this.context;
        this.state.model?.delete();
        this.state.model = this._getModel(gl);
        attributeManager.invalidateAll();
      }
      if (props.bounds !== oldProps.bounds) {
        const oldMesh = this.state.mesh;
        const mesh = this._createMesh();
        this.state.model.setVertexCount(mesh.vertexCount);
        for (const key in mesh) {
          if (oldMesh && oldMesh[key] !== mesh[key]) {
            attributeManager.invalidate(key);
          }
        }
        this.setState({
          mesh,
          ...this._getCoordinateUniforms()
        });
      } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {
        this.setState(this._getCoordinateUniforms());
      }
    }
    getPickingInfo(params) {
      const {
        image
      } = this.props;
      const info = params.info;
      if (!info.color || !image) {
        info.bitmap = null;
        return info;
      }
      const {
        width,
        height
      } = image;
      info.index = 0;
      const uv = unpackUVsFromRGB(info.color);
      const pixel = [Math.floor(uv[0] * width), Math.floor(uv[1] * height)];
      info.bitmap = {
        size: {
          width,
          height
        },
        uv,
        pixel
      };
      return info;
    }
    disablePickingIndex() {
      this.setState({
        disablePicking: true
      });
    }
    restorePickingColors() {
      this.setState({
        disablePicking: false
      });
    }
    _updateAutoHighlight(info) {
      super._updateAutoHighlight({
        ...info,
        color: this.encodePickingColor(0)
      });
    }
    _createMesh() {
      const {
        bounds
      } = this.props;
      let normalizedBounds = bounds;
      if (isRectangularBounds(bounds)) {
        normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];
      }
      return createMesh(normalizedBounds, this.context.viewport.resolution);
    }
    _getModel(gl) {
      if (!gl) {
        return null;
      }
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new Geometry({
          drawMode: esm_default2.TRIANGLES,
          vertexCount: 6
        }),
        isInstanced: false
      });
    }
    draw(opts) {
      const {
        uniforms,
        moduleParameters
      } = opts;
      const {
        model,
        coordinateConversion,
        bounds,
        disablePicking
      } = this.state;
      const {
        image,
        desaturate,
        transparentColor,
        tintColor
      } = this.props;
      if (moduleParameters.pickingActive && disablePicking) {
        return;
      }
      if (image && model) {
        model.setUniforms(uniforms).setUniforms({
          bitmapTexture: image,
          desaturate,
          transparentColor: transparentColor.map((x2) => x2 / 255),
          tintColor: tintColor.slice(0, 3).map((x2) => x2 / 255),
          coordinateConversion,
          bounds
        }).draw();
      }
    }
    _getCoordinateUniforms() {
      const {
        LNGLAT,
        CARTESIAN,
        DEFAULT
      } = COORDINATE_SYSTEM;
      let {
        _imageCoordinateSystem: imageCoordinateSystem
      } = this.props;
      if (imageCoordinateSystem !== DEFAULT) {
        const {
          bounds
        } = this.props;
        if (!isRectangularBounds(bounds)) {
          throw new Error("_imageCoordinateSystem only supports rectangular bounds");
        }
        const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
        imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;
        if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {
          return {
            coordinateConversion: -1,
            bounds
          };
        }
        if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
          const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);
          const topRight = lngLatToWorld([bounds[2], bounds[3]]);
          return {
            coordinateConversion: 1,
            bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]
          };
        }
      }
      return {
        coordinateConversion: 0,
        bounds: [0, 0, 0, 0]
      };
    }
  };
  __publicField(BitmapLayer, "layerName", "BitmapLayer");
  __publicField(BitmapLayer, "defaultProps", defaultProps4);
  function unpackUVsFromRGB(color) {
    const [u, v, fracUV] = color;
    const vFrac = (fracUV & 240) / 256;
    const uFrac = (fracUV & 15) / 16;
    return [(u + uFrac) / 256, (v + vFrac) / 256];
  }
  function isRectangularBounds(bounds) {
    return Number.isFinite(bounds[0]);
  }

  // ../layers/src/icon-layer/icon-layer-vertex.glsl.ts
  var icon_layer_vertex_glsl_default = `#define SHADER_NAME icon-layer-vertex-shader

attribute vec2 positions;

attribute vec3 instancePositions;
attribute vec3 instancePositions64Low;
attribute float instanceSizes;
attribute float instanceAngles;
attribute vec4 instanceColors;
attribute vec3 instancePickingColors;
attribute vec4 instanceIconFrames;
attribute float instanceColorModes;
attribute vec2 instanceOffsets;
attribute vec2 instancePixelOffset;

uniform float sizeScale;
uniform vec2 iconsTextureDim;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform bool billboard;
uniform int sizeUnits;

varying float vColorMode;
varying vec4 vColor;
varying vec2 vTextureCoords;
varying vec2 uv;

vec2 rotate_by_angle(vec2 vertex, float angle) {
  float angle_radian = angle * PI / 180.0;
  float cos_angle = cos(angle_radian);
  float sin_angle = sin(angle_radian);
  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
  return rotationMatrix * vertex;
}

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = positions;
  geometry.pickingColor = instancePickingColors;
  uv = positions;

  vec2 iconSize = instanceIconFrames.zw;
  // convert size in meters to pixels, then scaled and clamp
 
  // project meters to pixels and clamp to limits 
  float sizePixels = clamp(
    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), 
    sizeMinPixels, sizeMaxPixels
  );

  // scale icon height to match instanceSize
  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;

  // scale and rotate vertex in "pixel" value and convert back to fraction in clipspace
  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
  pixelOffset += instancePixelOffset;
  pixelOffset.y *= -1.0;

  if (billboard)  {
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
    vec3 offset = vec3(pixelOffset, 0.0);
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);

  } else {
    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
    DECKGL_FILTER_SIZE(offset_common, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); 
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  }

  vTextureCoords = mix(
    instanceIconFrames.xy,
    instanceIconFrames.xy + iconSize,
    (positions.xy + 1.0) / 2.0
  ) / iconsTextureDim;

  vColor = instanceColors;
  DECKGL_FILTER_COLOR(vColor, geometry);

  vColorMode = instanceColorModes;
}
`;

  // ../layers/src/icon-layer/icon-layer-fragment.glsl.ts
  var icon_layer_fragment_glsl_default = `#define SHADER_NAME icon-layer-fragment-shader

precision highp float;

uniform float opacity;
uniform sampler2D iconsTexture;
uniform float alphaCutoff;

varying float vColorMode;
varying vec4 vColor;
varying vec2 vTextureCoords;
varying vec2 uv;

void main(void) {
  geometry.uv = uv;

  vec4 texColor = texture2D(iconsTexture, vTextureCoords);

  // if colorMode == 0, use pixel color from the texture
  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask
  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
  // Take the global opacity and the alpha from vColor into account for the alpha component
  float a = texColor.a * opacity * vColor.a;

  if (a < alphaCutoff) {
    discard;
  }

  gl_FragColor = vec4(color, a);
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;

  // ../layers/src/icon-layer/icon-manager.ts
  var DEFAULT_CANVAS_WIDTH = 1024;
  var DEFAULT_BUFFER = 4;
  var noop5 = () => {
  };
  var DEFAULT_TEXTURE_PARAMETERS2 = {
    [esm_default2.TEXTURE_MIN_FILTER]: esm_default2.LINEAR_MIPMAP_LINEAR,
    [esm_default2.TEXTURE_MAG_FILTER]: esm_default2.LINEAR,
    [esm_default2.TEXTURE_WRAP_S]: esm_default2.CLAMP_TO_EDGE,
    [esm_default2.TEXTURE_WRAP_T]: esm_default2.CLAMP_TO_EDGE
  };
  function nextPowOfTwo(number) {
    return Math.pow(2, Math.ceil(Math.log2(number)));
  }
  function resizeImage(ctx, imageData, maxWidth, maxHeight) {
    const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
    const width = Math.floor(imageData.width * resizeRatio);
    const height = Math.floor(imageData.height * resizeRatio);
    if (resizeRatio === 1) {
      return {
        data: imageData,
        width,
        height
      };
    }
    ctx.canvas.height = height;
    ctx.canvas.width = width;
    ctx.clearRect(0, 0, width, height);
    ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
    return {
      data: ctx.canvas,
      width,
      height
    };
  }
  function getIconId(icon) {
    return icon && (icon.id || icon.url);
  }
  function resizeTexture(texture, width, height, parameters2) {
    const oldWidth = texture.width;
    const oldHeight = texture.height;
    const newTexture = new Texture2D(texture.gl, {
      width,
      height,
      parameters: parameters2
    });
    copyToTexture(texture, newTexture, {
      targetY: 0,
      width: oldWidth,
      height: oldHeight
    });
    texture.delete();
    return newTexture;
  }
  function buildRowMapping(mapping, columns, yOffset) {
    for (let i3 = 0; i3 < columns.length; i3++) {
      const {
        icon,
        xOffset
      } = columns[i3];
      const id = getIconId(icon);
      mapping[id] = {
        ...icon,
        x: xOffset,
        y: yOffset
      };
    }
  }
  function buildMapping({
    icons,
    buffer,
    mapping = {},
    xOffset = 0,
    yOffset = 0,
    rowHeight = 0,
    canvasWidth
  }) {
    let columns = [];
    for (let i3 = 0; i3 < icons.length; i3++) {
      const icon = icons[i3];
      const id = getIconId(icon);
      if (!mapping[id]) {
        const {
          height,
          width
        } = icon;
        if (xOffset + width + buffer > canvasWidth) {
          buildRowMapping(mapping, columns, yOffset);
          xOffset = 0;
          yOffset = rowHeight + yOffset + buffer;
          rowHeight = 0;
          columns = [];
        }
        columns.push({
          icon,
          xOffset
        });
        xOffset = xOffset + width + buffer;
        rowHeight = Math.max(rowHeight, height);
      }
    }
    if (columns.length > 0) {
      buildRowMapping(mapping, columns, yOffset);
    }
    return {
      mapping,
      rowHeight,
      xOffset,
      yOffset,
      canvasWidth,
      canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
    };
  }
  function getDiffIcons(data, getIcon, cachedIcons) {
    if (!data || !getIcon) {
      return null;
    }
    cachedIcons = cachedIcons || {};
    const icons = {};
    const {
      iterable,
      objectInfo
    } = createIterable(data);
    for (const object of iterable) {
      objectInfo.index++;
      const icon = getIcon(object, objectInfo);
      const id = getIconId(icon);
      if (!icon) {
        throw new Error("Icon is missing.");
      }
      if (!icon.url) {
        throw new Error("Icon url is missing.");
      }
      if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
        icons[id] = {
          ...icon,
          source: object,
          sourceIndex: objectInfo.index
        };
      }
    }
    return icons;
  }
  var IconManager = class {
    _loadOptions = null;
    _texture = null;
    _externalTexture = null;
    _mapping = {};
    _textureParameters = null;
    _pendingCount = 0;
    _autoPacking = false;
    _xOffset = 0;
    _yOffset = 0;
    _rowHeight = 0;
    _buffer = DEFAULT_BUFFER;
    _canvasWidth = DEFAULT_CANVAS_WIDTH;
    _canvasHeight = 0;
    _canvas = null;
    constructor(gl, {
      onUpdate = noop5,
      onError = noop5
    }) {
      this.gl = gl;
      this.onUpdate = onUpdate;
      this.onError = onError;
    }
    finalize() {
      this._texture?.delete();
    }
    getTexture() {
      return this._texture || this._externalTexture;
    }
    getIconMapping(icon) {
      const id = this._autoPacking ? getIconId(icon) : icon;
      return this._mapping[id] || {};
    }
    setProps({
      loadOptions,
      autoPacking,
      iconAtlas,
      iconMapping,
      textureParameters
    }) {
      if (loadOptions) {
        this._loadOptions = loadOptions;
      }
      if (autoPacking !== void 0) {
        this._autoPacking = autoPacking;
      }
      if (iconMapping) {
        this._mapping = iconMapping;
      }
      if (iconAtlas) {
        this._texture?.delete();
        this._texture = null;
        this._externalTexture = iconAtlas;
      }
      if (textureParameters) {
        this._textureParameters = textureParameters;
      }
    }
    get isLoaded() {
      return this._pendingCount === 0;
    }
    packIcons(data, getIcon) {
      if (!this._autoPacking || typeof document === "undefined") {
        return;
      }
      const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});
      if (icons.length > 0) {
        const {
          mapping,
          xOffset,
          yOffset,
          rowHeight,
          canvasHeight
        } = buildMapping({
          icons,
          buffer: this._buffer,
          canvasWidth: this._canvasWidth,
          mapping: this._mapping,
          rowHeight: this._rowHeight,
          xOffset: this._xOffset,
          yOffset: this._yOffset
        });
        this._rowHeight = rowHeight;
        this._mapping = mapping;
        this._xOffset = xOffset;
        this._yOffset = yOffset;
        this._canvasHeight = canvasHeight;
        if (!this._texture) {
          this._texture = new Texture2D(this.gl, {
            width: this._canvasWidth,
            height: this._canvasHeight,
            parameters: this._textureParameters || DEFAULT_TEXTURE_PARAMETERS2
          });
        }
        if (this._texture.height !== this._canvasHeight) {
          this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || DEFAULT_TEXTURE_PARAMETERS2);
        }
        this.onUpdate();
        this._canvas = this._canvas || document.createElement("canvas");
        this._loadIcons(icons);
      }
    }
    _loadIcons(icons) {
      const ctx = this._canvas.getContext("2d", {
        willReadFrequently: true
      });
      for (const icon of icons) {
        this._pendingCount++;
        load(icon.url, this._loadOptions).then((imageData) => {
          const id = getIconId(icon);
          const iconDef = this._mapping[id];
          const {
            x: x2,
            y: y2,
            width: maxWidth,
            height: maxHeight
          } = iconDef;
          const {
            data,
            width,
            height
          } = resizeImage(ctx, imageData, maxWidth, maxHeight);
          this._texture.setSubImageData({
            data,
            x: x2 + (maxWidth - width) / 2,
            y: y2 + (maxHeight - height) / 2,
            width,
            height
          });
          iconDef.width = width;
          iconDef.height = height;
          this._texture.generateMipmap();
          this.onUpdate();
        }).catch((error2) => {
          this.onError({
            url: icon.url,
            source: icon.source,
            sourceIndex: icon.sourceIndex,
            loadOptions: this._loadOptions,
            error: error2
          });
        }).finally(() => {
          this._pendingCount--;
        });
      }
    }
  };

  // ../layers/src/icon-layer/icon-layer.ts
  var DEFAULT_COLOR2 = [0, 0, 0, 255];
  var defaultProps5 = {
    iconAtlas: {
      type: "image",
      value: null,
      async: true
    },
    iconMapping: {
      type: "object",
      value: {},
      async: true
    },
    sizeScale: {
      type: "number",
      value: 1,
      min: 0
    },
    billboard: true,
    sizeUnits: "pixels",
    sizeMinPixels: {
      type: "number",
      min: 0,
      value: 0
    },
    sizeMaxPixels: {
      type: "number",
      min: 0,
      value: Number.MAX_SAFE_INTEGER
    },
    alphaCutoff: {
      type: "number",
      value: 0.05,
      min: 0,
      max: 1
    },
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    getIcon: {
      type: "accessor",
      value: (x2) => x2.icon
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR2
    },
    getSize: {
      type: "accessor",
      value: 1
    },
    getAngle: {
      type: "accessor",
      value: 0
    },
    getPixelOffset: {
      type: "accessor",
      value: [0, 0]
    },
    onIconError: {
      type: "function",
      value: null,
      optional: true
    },
    textureParameters: {
      type: "object",
      ignore: true
    }
  };
  var IconLayer = class extends Layer {
    getShaders() {
      return super.getShaders({
        vs: icon_layer_vertex_glsl_default,
        fs: icon_layer_fragment_glsl_default,
        modules: [project32_default, picking_default]
      });
    }
    initializeState() {
      this.state = {
        iconManager: new IconManager(this.context.gl, {
          onUpdate: this._onUpdate.bind(this),
          onError: this._onError.bind(this)
        })
      };
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceSizes: {
          size: 1,
          transition: true,
          accessor: "getSize",
          defaultValue: 1
        },
        instanceOffsets: {
          size: 2,
          accessor: "getIcon",
          transform: this.getInstanceOffset
        },
        instanceIconFrames: {
          size: 4,
          accessor: "getIcon",
          transform: this.getInstanceIconFrame
        },
        instanceColorModes: {
          size: 1,
          type: esm_default2.UNSIGNED_BYTE,
          accessor: "getIcon",
          transform: this.getInstanceColorMode
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: esm_default2.UNSIGNED_BYTE,
          normalized: true,
          transition: true,
          accessor: "getColor",
          defaultValue: DEFAULT_COLOR2
        },
        instanceAngles: {
          size: 1,
          transition: true,
          accessor: "getAngle"
        },
        instancePixelOffset: {
          size: 2,
          transition: true,
          accessor: "getPixelOffset"
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const {
        props,
        oldProps,
        changeFlags
      } = params;
      const attributeManager = this.getAttributeManager();
      const {
        iconAtlas,
        iconMapping,
        data,
        getIcon,
        textureParameters
      } = props;
      const {
        iconManager
      } = this.state;
      const prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
      iconManager.setProps({
        loadOptions: props.loadOptions,
        autoPacking: !prePacked,
        iconAtlas,
        iconMapping: prePacked ? iconMapping : null,
        textureParameters
      });
      if (prePacked) {
        if (oldProps.iconMapping !== props.iconMapping) {
          attributeManager.invalidate("getIcon");
        }
      } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
        iconManager.packIcons(data, getIcon);
      }
      if (changeFlags.extensionsChanged) {
        const {
          gl
        } = this.context;
        this.state.model?.delete();
        this.state.model = this._getModel(gl);
        attributeManager.invalidateAll();
      }
    }
    get isLoaded() {
      return super.isLoaded && this.state.iconManager.isLoaded;
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.iconManager.finalize();
    }
    draw({
      uniforms
    }) {
      const {
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels,
        sizeUnits,
        billboard,
        alphaCutoff
      } = this.props;
      const {
        iconManager
      } = this.state;
      const iconsTexture = iconManager.getTexture();
      if (iconsTexture) {
        this.state.model.setUniforms(uniforms).setUniforms({
          iconsTexture,
          iconsTextureDim: [iconsTexture.width, iconsTexture.height],
          sizeUnits: UNIT[sizeUnits],
          sizeScale,
          sizeMinPixels,
          sizeMaxPixels,
          billboard,
          alphaCutoff
        }).draw();
      }
    }
    _getModel(gl) {
      const positions = [-1, -1, -1, 1, 1, 1, 1, -1];
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new Geometry({
          drawMode: esm_default2.TRIANGLE_FAN,
          attributes: {
            positions: {
              size: 2,
              value: new Float32Array(positions)
            }
          }
        }),
        isInstanced: true
      });
    }
    _onUpdate() {
      this.setNeedsRedraw();
    }
    _onError(evt) {
      const onIconError = this.getCurrentLayer()?.props.onIconError;
      if (onIconError) {
        onIconError(evt);
      } else {
        log_default.error(evt.error.message)();
      }
    }
    getInstanceOffset(icon) {
      const {
        width,
        height,
        anchorX = width / 2,
        anchorY = height / 2
      } = this.state.iconManager.getIconMapping(icon);
      return [width / 2 - anchorX, height / 2 - anchorY];
    }
    getInstanceColorMode(icon) {
      const mapping = this.state.iconManager.getIconMapping(icon);
      return mapping.mask ? 1 : 0;
    }
    getInstanceIconFrame(icon) {
      const {
        x: x2,
        y: y2,
        width,
        height
      } = this.state.iconManager.getIconMapping(icon);
      return [x2, y2, width, height];
    }
  };
  __publicField(IconLayer, "defaultProps", defaultProps5);
  __publicField(IconLayer, "layerName", "IconLayer");

  // ../layers/src/line-layer/line-layer-vertex.glsl.ts
  var line_layer_vertex_glsl_default = `#define SHADER_NAME line-layer-vertex-shader

attribute vec3 positions;
attribute vec3 instanceSourcePositions;
attribute vec3 instanceTargetPositions;
attribute vec3 instanceSourcePositions64Low;
attribute vec3 instanceTargetPositions64Low;
attribute vec4 instanceColors;
attribute vec3 instancePickingColors;
attribute float instanceWidths;

uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float useShortestPath;
uniform int widthUnits;

varying vec4 vColor;
varying vec2 uv;

// offset vector by strokeWidth pixels
// offset_direction is -1 (left) or 1 (right)
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
  // normalized direction of the line
  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);
  // rotate by 90 degrees
  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);

  return dir_screenspace * offset_direction * width / 2.0;
}

vec3 splitLine(vec3 a, vec3 b, float x) {
  float t = (x - a.x) / (b.x - a.x);
  return vec3(x, mix(a.yz, b.yz, t));
}

void main(void) {
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;

  vec3 source_world = instanceSourcePositions;
  vec3 target_world = instanceTargetPositions;
  vec3 source_world_64low = instanceSourcePositions64Low;
  vec3 target_world_64low = instanceTargetPositions64Low;

  if (useShortestPath > 0.5 || useShortestPath < -0.5) {
    source_world.x = mod(source_world.x + 180., 360.0) - 180.;
    target_world.x = mod(target_world.x + 180., 360.0) - 180.;
    float deltaLng = target_world.x - source_world.x;

    if (deltaLng * useShortestPath > 180.) {
      source_world.x += 360. * useShortestPath;
      source_world = splitLine(source_world, target_world, 180. * useShortestPath);
      source_world_64low = vec3(0.0);
    } else if (deltaLng * useShortestPath < -180.) {
      target_world.x += 360. * useShortestPath;
      target_world = splitLine(source_world, target_world, 180. * useShortestPath);
      target_world_64low = vec3(0.0);
    } else if (useShortestPath < 0.) {
      // Line is not split, abort
      gl_Position = vec4(0.);
      return;
    }
  }

  // Position
  vec4 source_commonspace;
  vec4 target_commonspace;
  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);
  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);
  
  // linear interpolation of source & target to pick right coord
  float segmentIndex = positions.x;
  vec4 p = mix(source, target, segmentIndex);
  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);
  uv = positions.xy;
  geometry.uv = uv;
  geometry.pickingColor = instancePickingColors;

  // Multiply out width and clamp to limits
  float widthPixels = clamp(
    project_size_to_pixel(instanceWidths * widthScale, widthUnits),
    widthMinPixels, widthMaxPixels
  );

  // extrude
  vec3 offset = vec3(
    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),
    0.0);
  DECKGL_FILTER_SIZE(offset, geometry);
  DECKGL_FILTER_GL_POSITION(p, geometry);
  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);

  // Color
  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/line-layer/line-layer-fragment.glsl.ts
  var line_layer_fragment_glsl_default = `#define SHADER_NAME line-layer-fragment-shader

precision highp float;

varying vec4 vColor;
varying vec2 uv;

void main(void) {
  geometry.uv = uv;

  gl_FragColor = vColor;

  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;

  // ../layers/src/line-layer/line-layer.ts
  var DEFAULT_COLOR3 = [0, 0, 0, 255];
  var defaultProps6 = {
    getSourcePosition: {
      type: "accessor",
      value: (x2) => x2.sourcePosition
    },
    getTargetPosition: {
      type: "accessor",
      value: (x2) => x2.targetPosition
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR3
    },
    getWidth: {
      type: "accessor",
      value: 1
    },
    widthUnits: "pixels",
    widthScale: {
      type: "number",
      value: 1,
      min: 0
    },
    widthMinPixels: {
      type: "number",
      value: 0,
      min: 0
    },
    widthMaxPixels: {
      type: "number",
      value: Number.MAX_SAFE_INTEGER,
      min: 0
    }
  };
  var LineLayer = class extends Layer {
    getBounds() {
      return this.getAttributeManager()?.getBounds(["instanceSourcePositions", "instanceTargetPositions"]);
    }
    getShaders() {
      return super.getShaders({
        vs: line_layer_vertex_glsl_default,
        fs: line_layer_fragment_glsl_default,
        modules: [project32_default, picking_default]
      });
    }
    get wrapLongitude() {
      return false;
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceSourcePositions: {
          size: 3,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getSourcePosition"
        },
        instanceTargetPositions: {
          size: 3,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getTargetPosition"
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: esm_default2.UNSIGNED_BYTE,
          normalized: true,
          transition: true,
          accessor: "getColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceWidths: {
          size: 1,
          transition: true,
          accessor: "getWidth",
          defaultValue: 1
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      if (params.changeFlags.extensionsChanged) {
        const {
          gl
        } = this.context;
        this.state.model?.delete();
        this.state.model = this._getModel(gl);
        this.getAttributeManager().invalidateAll();
      }
    }
    draw({
      uniforms
    }) {
      const {
        widthUnits,
        widthScale,
        widthMinPixels,
        widthMaxPixels,
        wrapLongitude
      } = this.props;
      this.state.model.setUniforms(uniforms).setUniforms({
        widthUnits: UNIT[widthUnits],
        widthScale,
        widthMinPixels,
        widthMaxPixels,
        useShortestPath: wrapLongitude ? 1 : 0
      }).draw();
      if (wrapLongitude) {
        this.state.model.setUniforms({
          useShortestPath: -1
        }).draw();
      }
    }
    _getModel(gl) {
      const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new Geometry({
          drawMode: esm_default2.TRIANGLE_STRIP,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true
      });
    }
  };
  __publicField(LineLayer, "layerName", "LineLayer");
  __publicField(LineLayer, "defaultProps", defaultProps6);

  // ../layers/src/point-cloud-layer/point-cloud-layer-vertex.glsl.ts
  var point_cloud_layer_vertex_glsl_default = `#define SHADER_NAME point-cloud-layer-vertex-shader

attribute vec3 positions;
attribute vec3 instanceNormals;
attribute vec4 instanceColors;
attribute vec3 instancePositions;
attribute vec3 instancePositions64Low;
attribute vec3 instancePickingColors;

uniform float opacity;
uniform float radiusPixels;
uniform int sizeUnits;

varying vec4 vColor;
varying vec2 unitPosition;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.normal = project_normal(instanceNormals);

  // position on the containing square in [-1, 1] space
  unitPosition = positions.xy;
  geometry.uv = unitPosition;
  geometry.pickingColor = instancePickingColors;

  // Find the center of the point and add the current vertex
  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);
  DECKGL_FILTER_SIZE(offset, geometry);

  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);

  // Apply lighting
  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);

  // Apply opacity to instance color, or return instance picking color
  vColor = vec4(lightColor, instanceColors.a * opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/point-cloud-layer/point-cloud-layer-fragment.glsl.ts
  var point_cloud_layer_fragment_glsl_default = `#define SHADER_NAME point-cloud-layer-fragment-shader

precision highp float;

varying vec4 vColor;
varying vec2 unitPosition;

void main(void) {
  geometry.uv = unitPosition;

  float distToCenter = length(unitPosition);

  if (distToCenter > 1.0) {
    discard;
  }

  gl_FragColor = vColor;
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;

  // ../layers/src/point-cloud-layer/point-cloud-layer.ts
  var DEFAULT_COLOR4 = [0, 0, 0, 255];
  var DEFAULT_NORMAL = [0, 0, 1];
  var defaultProps7 = {
    sizeUnits: "pixels",
    pointSize: {
      type: "number",
      min: 0,
      value: 10
    },
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    getNormal: {
      type: "accessor",
      value: DEFAULT_NORMAL
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR4
    },
    material: true,
    radiusPixels: {
      deprecatedFor: "pointSize"
    }
  };
  function normalizeData(data) {
    const {
      header,
      attributes
    } = data;
    if (!header || !attributes) {
      return;
    }
    data.length = header.vertexCount;
    if (attributes.POSITION) {
      attributes.instancePositions = attributes.POSITION;
    }
    if (attributes.NORMAL) {
      attributes.instanceNormals = attributes.NORMAL;
    }
    if (attributes.COLOR_0) {
      attributes.instanceColors = attributes.COLOR_0;
    }
  }
  var PointCloudLayer = class extends Layer {
    getShaders() {
      return super.getShaders({
        vs: point_cloud_layer_vertex_glsl_default,
        fs: point_cloud_layer_fragment_glsl_default,
        modules: [project32_default, gouraudLighting, picking_default]
      });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceNormals: {
          size: 3,
          transition: true,
          accessor: "getNormal",
          defaultValue: DEFAULT_NORMAL
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: esm_default2.UNSIGNED_BYTE,
          normalized: true,
          transition: true,
          accessor: "getColor",
          defaultValue: DEFAULT_COLOR4
        }
      });
    }
    updateState(params) {
      const {
        changeFlags,
        props
      } = params;
      super.updateState(params);
      if (changeFlags.extensionsChanged) {
        const {
          gl
        } = this.context;
        this.state.model?.delete();
        this.state.model = this._getModel(gl);
        this.getAttributeManager().invalidateAll();
      }
      if (changeFlags.dataChanged) {
        normalizeData(props.data);
      }
    }
    draw({
      uniforms
    }) {
      const {
        pointSize,
        sizeUnits
      } = this.props;
      this.state.model.setUniforms(uniforms).setUniforms({
        sizeUnits: UNIT[sizeUnits],
        radiusPixels: pointSize
      }).draw();
    }
    _getModel(gl) {
      const positions = [];
      for (let i3 = 0; i3 < 3; i3++) {
        const angle2 = i3 / 3 * Math.PI * 2;
        positions.push(Math.cos(angle2) * 2, Math.sin(angle2) * 2, 0);
      }
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new Geometry({
          drawMode: esm_default2.TRIANGLES,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true
      });
    }
  };
  __publicField(PointCloudLayer, "layerName", "PointCloudLayer");
  __publicField(PointCloudLayer, "defaultProps", defaultProps7);

  // ../layers/src/scatterplot-layer/scatterplot-layer-vertex.glsl.ts
  var scatterplot_layer_vertex_glsl_default = `#define SHADER_NAME scatterplot-layer-vertex-shader

attribute vec3 positions;

attribute vec3 instancePositions;
attribute vec3 instancePositions64Low;
attribute float instanceRadius;
attribute float instanceLineWidths;
attribute vec4 instanceFillColors;
attribute vec4 instanceLineColors;
attribute vec3 instancePickingColors;

uniform float opacity;
uniform float radiusScale;
uniform float radiusMinPixels;
uniform float radiusMaxPixels;
uniform float lineWidthScale;
uniform float lineWidthMinPixels;
uniform float lineWidthMaxPixels;
uniform float stroked;
uniform bool filled;
uniform bool antialiasing;
uniform bool billboard;
uniform int radiusUnits;
uniform int lineWidthUnits;

varying vec4 vFillColor;
varying vec4 vLineColor;
varying vec2 unitPosition;
varying float innerUnitRadius;
varying float outerRadiusPixels;


void main(void) {
  geometry.worldPosition = instancePositions;

  // Multiply out radius and clamp to limits
  outerRadiusPixels = clamp(
    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),
    radiusMinPixels, radiusMaxPixels
  );
  
  // Multiply out line width and clamp to limits
  float lineWidthPixels = clamp(
    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),
    lineWidthMinPixels, lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  outerRadiusPixels += stroked * lineWidthPixels / 2.0;

  // Expand geometry to accomodate edge smoothing
  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;

  // position on the containing square in [-1, 1] space
  unitPosition = edgePadding * positions.xy;
  geometry.uv = unitPosition;
  geometry.pickingColor = instancePickingColors;

  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;
  
  if (billboard) {
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
    vec3 offset = edgePadding * positions * outerRadiusPixels;
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
  } else {
    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
  DECKGL_FILTER_COLOR(vFillColor, geometry);
  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
  DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;

  // ../layers/src/scatterplot-layer/scatterplot-layer-fragment.glsl.ts
  var scatterplot_layer_fragment_glsl_default = `#define SHADER_NAME scatterplot-layer-fragment-shader

precision highp float;

uniform bool filled;
uniform float stroked;
uniform bool antialiasing;

varying vec4 vFillColor;
varying vec4 vLineColor;
varying vec2 unitPosition;
varying float innerUnitRadius;
varying float outerRadiusPixels;

void main(void) {
  geometry.uv = unitPosition;

  float distToCenter = length(unitPosition) * outerRadiusPixels;
  float inCircle = antialiasing ? 
    smoothedge(distToCenter, outerRadiusPixels) : 
    step(distToCenter, outerRadiusPixels);

  if (inCircle == 0.0) {
    discard;
  }

  if (stroked > 0.5) {
    float isLine = antialiasing ? 
      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
      step(innerUnitRadius * outerRadiusPixels, distToCenter);

    if (filled) {
      gl_FragColor = mix(vFillColor, vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        discard;
      }
      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
    }
  } else if (filled) {
    gl_FragColor = vFillColor;
  } else {
    discard;
  }

  gl_FragColor.a *= inCircle;
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;

  // ../layers/src/scatterplot-layer/scatterplot-layer.ts
  var DEFAULT_COLOR5 = [0, 0, 0, 255];
  var defaultProps8 = {
    radiusUnits: "meters",
    radiusScale: {
      type: "number",
      min: 0,
      value: 1
    },
    radiusMinPixels: {
      type: "number",
      min: 0,
      value: 0
    },
    radiusMaxPixels: {
      type: "number",
      min: 0,
      value: Number.MAX_SAFE_INTEGER
    },
    lineWidthUnits: "meters",
    lineWidthScale: {
      type: "number",
      min: 0,
      value: 1
    },
    lineWidthMinPixels: {
      type: "number",
      min: 0,
      value: 0
    },
    lineWidthMaxPixels: {
      type: "number",
      min: 0,
      value: Number.MAX_SAFE_INTEGER
    },
    stroked: false,
    filled: true,
    billboard: false,
    antialiasing: true,
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    getRadius: {
      type: "accessor",
      value: 1
    },
    getFillColor: {
      type: "accessor",
      value: DEFAULT_COLOR5
    },
    getLineColor: {
      type: "accessor",
      value: DEFAULT_COLOR5
    },
    getLineWidth: {
      type: "accessor",
      value: 1
    },
    strokeWidth: {
      deprecatedFor: "getLineWidth"
    },
    outline: {
      deprecatedFor: "stroked"
    },
    getColor: {
      deprecatedFor: ["getFillColor", "getLineColor"]
    }
  };
  var ScatterplotLayer = class extends Layer {
    getShaders() {
      return super.getShaders({
        vs: scatterplot_layer_vertex_glsl_default,
        fs: scatterplot_layer_fragment_glsl_default,
        modules: [project32_default, picking_default]
      });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceRadius: {
          size: 1,
          transition: true,
          accessor: "getRadius",
          defaultValue: 1
        },
        instanceFillColors: {
          size: this.props.colorFormat.length,
          transition: true,
          normalized: true,
          type: esm_default2.UNSIGNED_BYTE,
          accessor: "getFillColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineColors: {
          size: this.props.colorFormat.length,
          transition: true,
          normalized: true,
          type: esm_default2.UNSIGNED_BYTE,
          accessor: "getLineColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineWidths: {
          size: 1,
          transition: true,
          accessor: "getLineWidth",
          defaultValue: 1
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      if (params.changeFlags.extensionsChanged) {
        const {
          gl
        } = this.context;
        this.state.model?.delete();
        this.state.model = this._getModel(gl);
        this.getAttributeManager().invalidateAll();
      }
    }
    draw({
      uniforms
    }) {
      const {
        radiusUnits,
        radiusScale,
        radiusMinPixels,
        radiusMaxPixels,
        stroked,
        filled,
        billboard,
        antialiasing,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels
      } = this.props;
      this.state.model.setUniforms(uniforms).setUniforms({
        stroked: stroked ? 1 : 0,
        filled,
        billboard,
        antialiasing,
        radiusUnits: UNIT[radiusUnits],
        radiusScale,
        radiusMinPixels,
        radiusMaxPixels,
        lineWidthUnits: UNIT[lineWidthUnits],
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels
      }).draw();
    }
    _getModel(gl) {
      const positions = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new Geometry({
          drawMode: esm_default2.TRIANGLE_FAN,
          vertexCount: 4,
          attributes: {
            positions: {
              size: 3,
              value: new Float32Array(positions)
            }
          }
        }),
        isInstanced: true
      });
    }
  };
  __publicField(ScatterplotLayer, "defaultProps", defaultProps8);
  __publicField(ScatterplotLayer, "layerName", "ScatterplotLayer");

  // ../../node_modules/@math.gl/polygon/dist/esm/polygon-utils.js
  var WINDING = {
    CLOCKWISE: 1,
    COUNTER_CLOCKWISE: -1
  };
  function modifyPolygonWindingDirection(points, direction, options = {}) {
    const windingDirection = getPolygonWindingDirection(points, options);
    if (windingDirection !== direction) {
      reversePolygon(points, options);
      return true;
    }
    return false;
  }
  function getPolygonWindingDirection(points, options = {}) {
    return Math.sign(getPolygonSignedArea(points, options));
  }
  function getPolygonSignedArea(points, options = {}) {
    const {
      start = 0,
      end = points.length
    } = options;
    const dim = options.size || 2;
    let area2 = 0;
    for (let i3 = start, j = end - dim; i3 < end; i3 += dim) {
      area2 += (points[i3] - points[j]) * (points[i3 + 1] + points[j + 1]);
      j = i3;
    }
    return area2 / 2;
  }
  function reversePolygon(points, options) {
    const {
      start = 0,
      end = points.length,
      size = 2
    } = options;
    const numPoints = (end - start) / size;
    const numSwaps = Math.floor(numPoints / 2);
    for (let i3 = 0; i3 < numSwaps; ++i3) {
      const b1 = start + i3 * size;
      const b2 = start + (numPoints - 1 - i3) * size;
      for (let j = 0; j < size; ++j) {
        const tmp = points[b1 + j];
        points[b1 + j] = points[b2 + j];
        points[b2 + j] = tmp;
      }
    }
  }

  // ../../node_modules/@math.gl/polygon/dist/esm/earcut.js
  function earcut(positions, holeIndices, dim = 2, areas) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
    let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0]);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let invSize;
    let maxX;
    let maxY;
    let minX;
    let minY;
    let x2;
    let y2;
    if (hasHoles)
      outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas);
    if (positions.length > 80 * dim) {
      minX = maxX = positions[0];
      minY = maxY = positions[1];
      for (let i3 = dim; i3 < outerLen; i3 += dim) {
        x2 = positions[i3];
        y2 = positions[i3 + 1];
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise, area2) {
    let i3;
    let last;
    if (area2 === void 0) {
      area2 = getPolygonSignedArea(data, {
        start,
        end,
        size: dim
      });
    }
    if (clockwise === area2 < 0) {
      for (i3 = start; i3 < end; i3 += dim)
        last = insertNode(i3, data[i3], data[i3 + 1], last);
    } else {
      for (i3 = end - dim; i3 >= start; i3 -= dim)
        last = insertNode(i3, data[i3], data[i3 + 1], last);
    }
    if (last && equals3(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    let p2 = start;
    let again;
    do {
      again = false;
      if (!p2.steiner && (equals3(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
        removeNode(p2);
        p2 = end = p2.prev;
        if (p2 === p2.next)
          break;
        again = true;
      } else {
        p2 = p2.next;
      }
    } while (again || p2 !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear;
    let prev;
    let next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a2 = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a2, b, c) >= 0)
      return false;
    let p2 = ear.next.next;
    while (p2 !== ear.prev) {
      if (pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a2 = ear.prev;
    const b = ear;
    const c = ear.next;
    if (area(a2, b, c) >= 0)
      return false;
    const minTX = a2.x < b.x ? a2.x < c.x ? a2.x : c.x : b.x < c.x ? b.x : c.x;
    const minTY = a2.y < b.y ? a2.y < c.y ? a2.y : c.y : b.y < c.y ? b.y : c.y;
    const maxTX = a2.x > b.x ? a2.x > c.x ? a2.x : c.x : b.x > c.x ? b.x : c.x;
    const maxTY = a2.y > b.y ? a2.y > c.y ? a2.y : c.y : b.y > c.y ? b.y : c.y;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize);
    const maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p2 = ear.prevZ;
    let n2 = ear.nextZ;
    while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
      if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
      if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
        return false;
      n2 = n2.nextZ;
    }
    while (p2 && p2.z >= minZ) {
      if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
    }
    while (n2 && n2.z <= maxZ) {
      if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b.x, b.y, c.x, c.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
        return false;
      n2 = n2.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    let p2 = start;
    do {
      const a2 = p2.prev;
      const b = p2.next.next;
      if (!equals3(a2, b) && intersects(a2, p2, p2.next, b) && locallyInside(a2, b) && locallyInside(b, a2)) {
        triangles.push(a2.i / dim);
        triangles.push(p2.i / dim);
        triangles.push(b.i / dim);
        removeNode(p2);
        removeNode(p2.next);
        p2 = start = b;
      }
      p2 = p2.next;
    } while (p2 !== start);
    return filterPoints(p2);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a2 = start;
    do {
      let b = a2.next.next;
      while (b !== a2.prev) {
        if (a2.i !== b.i && isValidDiagonal(a2, b)) {
          let c = splitPolygon(a2, b);
          a2 = filterPoints(a2, a2.next);
          c = filterPoints(c, c.next);
          earcutLinked(a2, triangles, dim, minX, minY, invSize);
          earcutLinked(c, triangles, dim, minX, minY, invSize);
          return;
        }
        b = b.next;
      }
      a2 = a2.next;
    } while (a2 !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim, areas) {
    const queue = [];
    let i3;
    let len3;
    let start;
    let end;
    let list;
    for (i3 = 0, len3 = holeIndices.length; i3 < len3; i3++) {
      start = holeIndices[i3] * dim;
      end = i3 < len3 - 1 ? holeIndices[i3 + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false, areas && areas[i3 + 1]);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i3 = 0; i3 < queue.length; i3++) {
      eliminateHole(queue[i3], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
  }
  function compareX(a2, b) {
    return a2.x - b.x;
  }
  function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
      const b = splitPolygon(outerNode, hole);
      filterPoints(outerNode, outerNode.next);
      filterPoints(b, b.next);
    }
  }
  function findHoleBridge(hole, outerNode) {
    let p2 = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m;
    do {
      if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
        const x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
        if (x2 <= hx && x2 > qx) {
          qx = x2;
          if (x2 === hx) {
            if (hy === p2.y)
              return p2;
            if (hy === p2.next.y)
              return p2.next;
          }
          m = p2.x < p2.next.x ? p2 : p2.next;
        }
      }
      p2 = p2.next;
    } while (p2 !== outerNode);
    if (!m)
      return null;
    if (hx === qx)
      return m;
    const stop = m;
    const mx = m.x;
    const my = m.y;
    let tanMin = Infinity;
    let tan2;
    p2 = m;
    do {
      if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
        tan2 = Math.abs(hy - p2.y) / (hx - p2.x);
        if (locallyInside(p2, hole) && (tan2 < tanMin || tan2 === tanMin && (p2.x > m.x || p2.x === m.x && sectorContainsSector(m, p2)))) {
          m = p2;
          tanMin = tan2;
        }
      }
      p2 = p2.next;
    } while (p2 !== stop);
    return m;
  }
  function sectorContainsSector(m, p2) {
    return area(m.prev, m, p2.prev) < 0 && area(p2.next, m, m.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p2 = start;
    do {
      if (p2.z === null)
        p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
      p2.prevZ = p2.prev;
      p2.nextZ = p2.next;
      p2 = p2.next;
    } while (p2 !== start);
    p2.prevZ.nextZ = null;
    p2.prevZ = null;
    sortLinked(p2);
  }
  function sortLinked(list) {
    let e2;
    let i3;
    let inSize = 1;
    let numMerges;
    let p2;
    let pSize;
    let q;
    let qSize;
    let tail;
    do {
      p2 = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p2) {
        numMerges++;
        q = p2;
        pSize = 0;
        for (i3 = 0; i3 < inSize; i3++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
            e2 = p2;
            p2 = p2.nextZ;
            pSize--;
          } else {
            e2 = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e2;
          else
            list = e2;
          e2.prevZ = tail;
          tail = e2;
        }
        p2 = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x2, y2, minX, minY, invSize) {
    x2 = 32767 * (x2 - minX) * invSize;
    y2 = 32767 * (y2 - minY) * invSize;
    x2 = (x2 | x2 << 8) & 16711935;
    x2 = (x2 | x2 << 4) & 252645135;
    x2 = (x2 | x2 << 2) & 858993459;
    x2 = (x2 | x2 << 1) & 1431655765;
    y2 = (y2 | y2 << 8) & 16711935;
    y2 = (y2 | y2 << 4) & 252645135;
    y2 = (y2 | y2 << 2) & 858993459;
    y2 = (y2 | y2 << 1) & 1431655765;
    return x2 | y2 << 1;
  }
  function getLeftmost(start) {
    let p2 = start;
    let leftmost = start;
    do {
      if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
        leftmost = p2;
      p2 = p2.next;
    } while (p2 !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
  }
  function isValidDiagonal(a2, b) {
    return a2.next.i !== b.i && a2.prev.i !== b.i && !intersectsPolygon(a2, b) && (locallyInside(a2, b) && locallyInside(b, a2) && middleInside(a2, b) && (area(a2.prev, a2, b.prev) || area(a2, b.prev, b)) || equals3(a2, b) && area(a2.prev, a2, a2.next) > 0 && area(b.prev, b, b.next) > 0);
  }
  function area(p2, q, r2) {
    return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
  }
  function equals3(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p2, q, r2) {
    return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a2, b) {
    let p2 = a2;
    do {
      if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b.i && p2.next.i !== b.i && intersects(p2, p2.next, a2, b))
        return true;
      p2 = p2.next;
    } while (p2 !== a2);
    return false;
  }
  function locallyInside(a2, b) {
    return area(a2.prev, a2, a2.next) < 0 ? area(a2, b, a2.next) >= 0 && area(a2, a2.prev, b) >= 0 : area(a2, b, a2.prev) < 0 || area(a2, a2.next, b) < 0;
  }
  function middleInside(a2, b) {
    let p2 = a2;
    let inside = false;
    const px = (a2.x + b.x) / 2;
    const py = (a2.y + b.y) / 2;
    do {
      if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
        inside = !inside;
      p2 = p2.next;
    } while (p2 !== a2);
    return inside;
  }
  function splitPolygon(a2, b) {
    const a22 = new Node(a2.i, a2.x, a2.y);
    const b2 = new Node(b.i, b.x, b.y);
    const an = a2.next;
    const bp = b.prev;
    a2.next = b;
    b.prev = a2;
    a22.next = an;
    an.prev = a22;
    b2.next = a22;
    a22.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i3, x2, y2, last) {
    const p2 = new Node(i3, x2, y2);
    if (!last) {
      p2.prev = p2;
      p2.next = p2;
    } else {
      p2.next = last.next;
      p2.prev = last;
      last.next.prev = p2;
      last.next = p2;
    }
    return p2;
  }
  function removeNode(p2) {
    p2.next.prev = p2.prev;
    p2.prev.next = p2.next;
    if (p2.prevZ)
      p2.prevZ.nextZ = p2.nextZ;
    if (p2.nextZ)
      p2.nextZ.prevZ = p2.prevZ;
  }
  function Node(i3, x2, y2) {
    this.i = i3;
    this.x = x2;
    this.y = y2;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }

  // ../../node_modules/@math.gl/polygon/dist/esm/utils.js
  function push(target, source) {
    const size = source.length;
    const startIndex = target.length;
    if (startIndex > 0) {
      let isDuplicate = true;
      for (let i3 = 0; i3 < size; i3++) {
        if (target[startIndex - size + i3] !== source[i3]) {
          isDuplicate = false;
          break;
        }
      }
      if (isDuplicate) {
        return false;
      }
    }
    for (let i3 = 0; i3 < size; i3++) {
      target[startIndex + i3] = source[i3];
    }
    return true;
  }
  function copy2(target, source) {
    const size = source.length;
    for (let i3 = 0; i3 < size; i3++) {
      target[i3] = source[i3];
    }
  }
  function getPointAtIndex(positions, index, size, offset, out = []) {
    const startI = offset + index * size;
    for (let i3 = 0; i3 < size; i3++) {
      out[i3] = positions[startI + i3];
    }
    return out;
  }

  // ../../node_modules/@math.gl/polygon/dist/esm/lineclip.js
  function intersect(a2, b, edge, bbox, out = []) {
    let t2;
    let snap;
    if (edge & 8) {
      t2 = (bbox[3] - a2[1]) / (b[1] - a2[1]);
      snap = 3;
    } else if (edge & 4) {
      t2 = (bbox[1] - a2[1]) / (b[1] - a2[1]);
      snap = 1;
    } else if (edge & 2) {
      t2 = (bbox[2] - a2[0]) / (b[0] - a2[0]);
      snap = 2;
    } else if (edge & 1) {
      t2 = (bbox[0] - a2[0]) / (b[0] - a2[0]);
      snap = 0;
    } else {
      return null;
    }
    for (let i3 = 0; i3 < a2.length; i3++) {
      out[i3] = (snap & 1) === i3 ? bbox[snap] : t2 * (b[i3] - a2[i3]) + a2[i3];
    }
    return out;
  }
  function bitCode(p2, bbox) {
    let code = 0;
    if (p2[0] < bbox[0])
      code |= 1;
    else if (p2[0] > bbox[2])
      code |= 2;
    if (p2[1] < bbox[1])
      code |= 4;
    else if (p2[1] > bbox[3])
      code |= 8;
    return code;
  }

  // ../../node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js
  function cutPolylineByGrid(positions, options) {
    const {
      size = 2,
      broken = false,
      gridResolution = 10,
      gridOffset = [0, 0],
      startIndex = 0,
      endIndex = positions.length
    } = options || {};
    const numPoints = (endIndex - startIndex) / size;
    let part = [];
    const result = [part];
    const a2 = getPointAtIndex(positions, 0, size, startIndex);
    let b;
    let codeB;
    const cell = getGridCell(a2, gridResolution, gridOffset, []);
    const scratchPoint2 = [];
    push(part, a2);
    for (let i3 = 1; i3 < numPoints; i3++) {
      b = getPointAtIndex(positions, i3, size, startIndex, b);
      codeB = bitCode(b, cell);
      while (codeB) {
        intersect(a2, b, codeB, cell, scratchPoint2);
        const codeAlt = bitCode(scratchPoint2, cell);
        if (codeAlt) {
          intersect(a2, scratchPoint2, codeAlt, cell, scratchPoint2);
          codeB = codeAlt;
        }
        push(part, scratchPoint2);
        copy2(a2, scratchPoint2);
        moveToNeighborCell(cell, gridResolution, codeB);
        if (broken && part.length > size) {
          part = [];
          result.push(part);
          push(part, a2);
        }
        codeB = bitCode(b, cell);
      }
      push(part, b);
      copy2(a2, b);
    }
    return broken ? result : result[0];
  }
  var TYPE_INSIDE = 0;
  var TYPE_BORDER = 1;
  function concatInPlace(arr1, arr2) {
    for (let i3 = 0; i3 < arr2.length; i3++) {
      arr1.push(arr2[i3]);
    }
    return arr1;
  }
  function cutPolygonByGrid(positions, holeIndices = null, options) {
    if (!positions.length) {
      return [];
    }
    const {
      size = 2,
      gridResolution = 10,
      gridOffset = [0, 0],
      edgeTypes = false
    } = options || {};
    const result = [];
    const queue = [{
      pos: positions,
      types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
      holes: holeIndices || []
    }];
    const bbox = [[], []];
    let cell = [];
    while (queue.length) {
      const {
        pos,
        types,
        holes
      } = queue.shift();
      getBoundingBox(pos, size, holes[0] || pos.length, bbox);
      cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
      const code = bitCode(bbox[1], cell);
      if (code) {
        let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
        const polygonLow = {
          pos: parts[0].pos,
          types: parts[0].types,
          holes: []
        };
        const polygonHigh = {
          pos: parts[1].pos,
          types: parts[1].types,
          holes: []
        };
        queue.push(polygonLow, polygonHigh);
        for (let i3 = 0; i3 < holes.length; i3++) {
          parts = bisectPolygon(pos, types, size, holes[i3], holes[i3 + 1] || pos.length, cell, code);
          if (parts[0]) {
            polygonLow.holes.push(polygonLow.pos.length);
            polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
            if (edgeTypes) {
              polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
            }
          }
          if (parts[1]) {
            polygonHigh.holes.push(polygonHigh.pos.length);
            polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
            if (edgeTypes) {
              polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
            }
          }
        }
      } else {
        const polygon = {
          positions: pos
        };
        if (edgeTypes) {
          polygon.edgeTypes = types;
        }
        if (holes.length) {
          polygon.holeIndices = holes;
        }
        result.push(polygon);
      }
    }
    return result;
  }
  function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
    const numPoints = (endIndex - startIndex) / size;
    const resultLow = [];
    const resultHigh = [];
    const typesLow = [];
    const typesHigh = [];
    const scratchPoint2 = [];
    let p2;
    let side;
    let type;
    const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);
    let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
    let prevType = edgeTypes && edgeTypes[numPoints - 1];
    let lowPointCount = 0;
    let highPointCount = 0;
    for (let i3 = 0; i3 < numPoints; i3++) {
      p2 = getPointAtIndex(positions, i3, size, startIndex, p2);
      side = Math.sign(edge & 8 ? p2[1] - bbox[3] : p2[0] - bbox[2]);
      type = edgeTypes && edgeTypes[startIndex / size + i3];
      if (side && prevSide && prevSide !== side) {
        intersect(prev, p2, edge, bbox, scratchPoint2);
        push(resultLow, scratchPoint2) && typesLow.push(prevType);
        push(resultHigh, scratchPoint2) && typesHigh.push(prevType);
      }
      if (side <= 0) {
        push(resultLow, p2) && typesLow.push(type);
        lowPointCount -= side;
      } else if (typesLow.length) {
        typesLow[typesLow.length - 1] = TYPE_INSIDE;
      }
      if (side >= 0) {
        push(resultHigh, p2) && typesHigh.push(type);
        highPointCount += side;
      } else if (typesHigh.length) {
        typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
      }
      copy2(prev, p2);
      prevSide = side;
      prevType = type;
    }
    return [lowPointCount ? {
      pos: resultLow,
      types: edgeTypes && typesLow
    } : null, highPointCount ? {
      pos: resultHigh,
      types: edgeTypes && typesHigh
    } : null];
  }
  function getGridCell(p2, gridResolution, gridOffset, out) {
    const left = Math.floor((p2[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
    const bottom = Math.floor((p2[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
    out[0] = left;
    out[1] = bottom;
    out[2] = left + gridResolution;
    out[3] = bottom + gridResolution;
    return out;
  }
  function moveToNeighborCell(cell, gridResolution, edge) {
    if (edge & 8) {
      cell[1] += gridResolution;
      cell[3] += gridResolution;
    } else if (edge & 4) {
      cell[1] -= gridResolution;
      cell[3] -= gridResolution;
    } else if (edge & 2) {
      cell[0] += gridResolution;
      cell[2] += gridResolution;
    } else if (edge & 1) {
      cell[0] -= gridResolution;
      cell[2] -= gridResolution;
    }
  }
  function getBoundingBox(positions, size, endIndex, out) {
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (let i3 = 0; i3 < endIndex; i3 += size) {
      const x2 = positions[i3];
      const y2 = positions[i3 + 1];
      minX = x2 < minX ? x2 : minX;
      maxX = x2 > maxX ? x2 : maxX;
      minY = y2 < minY ? y2 : minY;
      maxY = y2 > maxY ? y2 : maxY;
    }
    out[0][0] = minX;
    out[0][1] = minY;
    out[1][0] = maxX;
    out[1][1] = maxY;
    return out;
  }

  // ../../node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js
  var DEFAULT_MAX_LATITUDE = 85.051129;
  function cutPolylineByMercatorBounds(positions, options) {
    const {
      size = 2,
      startIndex = 0,
      endIndex = positions.length,
      normalize: normalize5 = true
    } = options || {};
    const newPositions = positions.slice(startIndex, endIndex);
    wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
    const parts = cutPolylineByGrid(newPositions, {
      size,
      broken: true,
      gridResolution: 360,
      gridOffset: [-180, -180]
    });
    if (normalize5) {
      for (const part of parts) {
        shiftLongitudesIntoRange(part, size);
      }
    }
    return parts;
  }
  function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
    const {
      size = 2,
      normalize: normalize5 = true,
      edgeTypes = false
    } = options || {};
    holeIndices = holeIndices || [];
    const newPositions = [];
    const newHoleIndices = [];
    let srcStartIndex = 0;
    let targetIndex = 0;
    for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
      const srcEndIndex = holeIndices[ringIndex] || positions.length;
      const targetStartIndex = targetIndex;
      const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
      for (let i3 = splitIndex; i3 < srcEndIndex; i3++) {
        newPositions[targetIndex++] = positions[i3];
      }
      for (let i3 = srcStartIndex; i3 < splitIndex; i3++) {
        newPositions[targetIndex++] = positions[i3];
      }
      wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
      insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options === null || options === void 0 ? void 0 : options.maxLatitude);
      srcStartIndex = srcEndIndex;
      newHoleIndices[ringIndex] = targetIndex;
    }
    newHoleIndices.pop();
    const parts = cutPolygonByGrid(newPositions, newHoleIndices, {
      size,
      gridResolution: 360,
      gridOffset: [-180, -180],
      edgeTypes
    });
    if (normalize5) {
      for (const part of parts) {
        shiftLongitudesIntoRange(part.positions, size);
      }
    }
    return parts;
  }
  function findSplitIndex(positions, size, startIndex, endIndex) {
    let maxLat = -1;
    let pointIndex = -1;
    for (let i3 = startIndex + 1; i3 < endIndex; i3 += size) {
      const lat = Math.abs(positions[i3]);
      if (lat > maxLat) {
        maxLat = lat;
        pointIndex = i3 - 1;
      }
    }
    return pointIndex;
  }
  function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
    const firstLng = positions[startIndex];
    const lastLng = positions[endIndex - size];
    if (Math.abs(firstLng - lastLng) > 180) {
      const p2 = getPointAtIndex(positions, 0, size, startIndex);
      p2[0] += Math.round((lastLng - firstLng) / 360) * 360;
      push(positions, p2);
      p2[1] = Math.sign(p2[1]) * maxLatitude;
      push(positions, p2);
      p2[0] = firstLng;
      push(positions, p2);
    }
  }
  function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
    let prevLng = positions[0];
    let lng;
    for (let i3 = startIndex; i3 < endIndex; i3 += size) {
      lng = positions[i3];
      const delta = lng - prevLng;
      if (delta > 180 || delta < -180) {
        lng -= Math.round(delta / 360) * 360;
      }
      positions[i3] = prevLng = lng;
    }
  }
  function shiftLongitudesIntoRange(positions, size) {
    let refLng;
    const pointCount = positions.length / size;
    for (let i3 = 0; i3 < pointCount; i3++) {
      refLng = positions[i3 * size];
      if ((refLng + 180) % 360 !== 0) {
        break;
      }
    }
    const delta = -Math.round(refLng / 360) * 360;
    if (delta === 0) {
      return;
    }
    for (let i3 = 0; i3 < pointCount; i3++) {
      positions[i3 * size] += delta;
    }
  }

  // ../layers/src/column-layer/column-geometry.ts
  var ColumnGeometry = class extends Geometry {
    constructor(props) {
      const {
        id = uid("column-geometry")
      } = props;
      const {
        indices,
        attributes
      } = tesselateColumn(props);
      super({
        ...props,
        id,
        indices,
        attributes
      });
    }
  };
  function tesselateColumn(props) {
    const {
      radius,
      height = 1,
      nradial = 10
    } = props;
    let {
      vertices
    } = props;
    if (vertices) {
      log_default.assert(vertices.length >= nradial);
      vertices = vertices.flatMap((v) => [v[0], v[1]]);
      modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);
    }
    const isExtruded = height > 0;
    const vertsAroundEdge = nradial + 1;
    const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;
    const stepAngle = Math.PI * 2 / nradial;
    const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);
    const positions = new Float32Array(numVertices * 3);
    const normals = new Float32Array(numVertices * 3);
    let i3 = 0;
    if (isExtruded) {
      for (let j = 0; j < vertsAroundEdge; j++) {
        const a2 = j * stepAngle;
        const vertexIndex = j % nradial;
        const sin2 = Math.sin(a2);
        const cos2 = Math.cos(a2);
        for (let k = 0; k < 2; k++) {
          positions[i3 + 0] = vertices ? vertices[vertexIndex * 2] : cos2 * radius;
          positions[i3 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin2 * radius;
          positions[i3 + 2] = (1 / 2 - k) * height;
          normals[i3 + 0] = vertices ? vertices[vertexIndex * 2] : cos2;
          normals[i3 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin2;
          i3 += 3;
        }
      }
      positions[i3 + 0] = positions[i3 - 3];
      positions[i3 + 1] = positions[i3 - 2];
      positions[i3 + 2] = positions[i3 - 1];
      i3 += 3;
    }
    for (let j = isExtruded ? 0 : 1; j < vertsAroundEdge; j++) {
      const v = Math.floor(j / 2) * Math.sign(0.5 - j % 2);
      const a2 = v * stepAngle;
      const vertexIndex = (v + nradial) % nradial;
      const sin2 = Math.sin(a2);
      const cos2 = Math.cos(a2);
      positions[i3 + 0] = vertices ? vertices[vertexIndex * 2] : cos2 * radius;
      positions[i3 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin2 * radius;
      positions[i3 + 2] = height / 2;
      normals[i3 + 2] = 1;
      i3 += 3;
    }
    if (isExtruded) {
      let index = 0;
      for (let j = 0; j < nradial; j++) {
        indices[index++] = j * 2 + 0;
        indices[index++] = j * 2 + 2;
        indices[index++] = j * 2 + 0;
        indices[index++] = j * 2 + 1;
        indices[index++] = j * 2 + 1;
        indices[index++] = j * 2 + 3;
      }
    }
    return {
      indices,
      attributes: {
        POSITION: {
          size: 3,
          value: positions
        },
        NORMAL: {
          size: 3,
          value: normals
        }
      }
    };
  }

  // ../layers/src/column-layer/column-layer-vertex.glsl.ts
  var column_layer_vertex_glsl_default = `#version 300 es

#define SHADER_NAME column-layer-vertex-shader

in vec3 positions;
in vec3 normals;

in vec3 instancePositions;
in float instanceElevations;
in vec3 instancePositions64Low;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in float instanceStrokeWidths;

in vec3 instancePickingColors;

// Custom uniforms
uniform float opacity;
uniform float radius;
uniform float angle;
uniform vec2 offset;
uniform bool extruded;
uniform bool stroked;
uniform bool isStroke;
uniform float coverage;
uniform float elevationScale;
uniform float edgeDistance;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform int radiusUnits;
uniform int widthUnits;

// Result
out vec4 vColor;
#ifdef FLAT_SHADING
out vec4 position_commonspace;
#endif

void main(void) {
  geometry.worldPosition = instancePositions;

  vec4 color = isStroke ? instanceLineColors : instanceFillColors;
  // rotate primitive position and normal
  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));

  // calculate elevation, if 3d not enabled set to 0
  // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1
  float elevation = 0.0;
  // calculate stroke offset
  float strokeOffsetRatio = 1.0;

  if (extruded) {
    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;
  } else if (stroked) {
    float widthPixels = clamp(
      project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),
      widthMinPixels, widthMaxPixels) / 2.0;
    float halfOffset = project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);
    if (isStroke) {
      strokeOffsetRatio -= sign(positions.z) * halfOffset;
    } else {
      strokeOffsetRatio -= halfOffset;
    }
  }

  // if alpha == 0.0 or z < 0.0, do not render element
  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
  float dotRadius = radius * coverage * shouldRender;

  geometry.pickingColor = instancePickingColors;

  // project center of column
  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
  vec3 centroidPosition64Low = instancePositions64Low;
  vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius;
  if (radiusUnits == UNIT_METERS) {
    offset = project_size(offset);
  }
  vec3 pos = vec3(offset, 0.);
  DECKGL_FILTER_SIZE(pos, geometry);

  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  // Light calculations
  if (extruded && !isStroke) {
#ifdef FLAT_SHADING
    position_commonspace = geometry.position;
    vColor = vec4(color.rgb, color.a * opacity);
#else
    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
    vColor = vec4(lightColor, color.a * opacity);
#endif
  } else {
    vColor = vec4(color.rgb, color.a * opacity);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/column-layer/column-layer-fragment.glsl.ts
  var column_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME column-layer-fragment-shader

precision highp float;

uniform vec3 project_uCameraPosition;
uniform bool extruded;
uniform bool isStroke;

out vec4 fragColor;

in vec4 vColor;
#ifdef FLAT_SHADING
in vec4 position_commonspace;
#endif

void main(void) {
  fragColor = vColor;
#ifdef FLAT_SHADING
  if (extruded && !isStroke && !picking_uActive) {
    vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
    fragColor.rgb = lighting_getLightColor(vColor.rgb, project_uCameraPosition, position_commonspace.xyz, normal);
  }
#endif
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/column-layer/column-layer.ts
  var DEFAULT_COLOR6 = [0, 0, 0, 255];
  var defaultProps9 = {
    diskResolution: {
      type: "number",
      min: 4,
      value: 20
    },
    vertices: null,
    radius: {
      type: "number",
      min: 0,
      value: 1e3
    },
    angle: {
      type: "number",
      value: 0
    },
    offset: {
      type: "array",
      value: [0, 0]
    },
    coverage: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    elevationScale: {
      type: "number",
      min: 0,
      value: 1
    },
    radiusUnits: "meters",
    lineWidthUnits: "meters",
    lineWidthScale: 1,
    lineWidthMinPixels: 0,
    lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
    extruded: true,
    wireframe: false,
    filled: true,
    stroked: false,
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    getFillColor: {
      type: "accessor",
      value: DEFAULT_COLOR6
    },
    getLineColor: {
      type: "accessor",
      value: DEFAULT_COLOR6
    },
    getLineWidth: {
      type: "accessor",
      value: 1
    },
    getElevation: {
      type: "accessor",
      value: 1e3
    },
    material: true,
    getColor: {
      deprecatedFor: ["getFillColor", "getLineColor"]
    }
  };
  var ColumnLayer = class extends Layer {
    getShaders() {
      const {
        gl
      } = this.context;
      const transpileToGLSL100 = !isWebGL2(gl);
      const defines2 = {};
      const useDerivatives = this.props.flatShading && hasFeature(gl, FEATURES.GLSL_DERIVATIVES);
      if (useDerivatives) {
        defines2.FLAT_SHADING = 1;
      }
      return super.getShaders({
        vs: column_layer_vertex_glsl_default,
        fs: column_layer_fragment_glsl_default,
        defines: defines2,
        transpileToGLSL100,
        modules: [project32_default, useDerivatives ? phongLighting : gouraudLighting, picking_default]
      });
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceElevations: {
          size: 1,
          transition: true,
          accessor: "getElevation"
        },
        instanceFillColors: {
          size: this.props.colorFormat.length,
          type: esm_default2.UNSIGNED_BYTE,
          normalized: true,
          transition: true,
          accessor: "getFillColor",
          defaultValue: DEFAULT_COLOR6
        },
        instanceLineColors: {
          size: this.props.colorFormat.length,
          type: esm_default2.UNSIGNED_BYTE,
          normalized: true,
          transition: true,
          accessor: "getLineColor",
          defaultValue: DEFAULT_COLOR6
        },
        instanceStrokeWidths: {
          size: 1,
          accessor: "getLineWidth",
          transition: true
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const {
        props,
        oldProps,
        changeFlags
      } = params;
      const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;
      if (regenerateModels) {
        const {
          gl
        } = this.context;
        this.state.model?.delete();
        this.state.model = this._getModel(gl);
        this.getAttributeManager().invalidateAll();
      }
      if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {
        this._updateGeometry(props);
      }
    }
    getGeometry(diskResolution, vertices, hasThinkness) {
      const geometry = new ColumnGeometry({
        radius: 1,
        height: hasThinkness ? 2 : 0,
        vertices,
        nradial: diskResolution
      });
      let meanVertexDistance = 0;
      if (vertices) {
        for (let i3 = 0; i3 < diskResolution; i3++) {
          const p2 = vertices[i3];
          const d = Math.sqrt(p2[0] * p2[0] + p2[1] * p2[1]);
          meanVertexDistance += d / diskResolution;
        }
      } else {
        meanVertexDistance = 1;
      }
      this.setState({
        edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
      });
      return geometry;
    }
    _getModel(gl) {
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        isInstanced: true
      });
    }
    _updateGeometry({
      diskResolution,
      vertices,
      extruded,
      stroked
    }) {
      const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);
      this.setState({
        fillVertexCount: geometry.attributes.POSITION.value.length / 3,
        wireframeVertexCount: geometry.indices.value.length
      });
      this.state.model.setProps({
        geometry
      });
    }
    draw({
      uniforms
    }) {
      const {
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        radiusUnits,
        elevationScale,
        extruded,
        filled,
        stroked,
        wireframe,
        offset,
        coverage,
        radius,
        angle: angle2
      } = this.props;
      const {
        model,
        fillVertexCount,
        wireframeVertexCount,
        edgeDistance
      } = this.state;
      model.setUniforms(uniforms).setUniforms({
        radius,
        angle: angle2 / 180 * Math.PI,
        offset,
        extruded,
        stroked,
        coverage,
        elevationScale,
        edgeDistance,
        radiusUnits: UNIT[radiusUnits],
        widthUnits: UNIT[lineWidthUnits],
        widthScale: lineWidthScale,
        widthMinPixels: lineWidthMinPixels,
        widthMaxPixels: lineWidthMaxPixels
      });
      if (extruded && wireframe) {
        model.setProps({
          isIndexed: true
        });
        model.setVertexCount(wireframeVertexCount).setDrawMode(esm_default2.LINES).setUniforms({
          isStroke: true
        }).draw();
      }
      if (filled) {
        model.setProps({
          isIndexed: false
        });
        model.setVertexCount(fillVertexCount).setDrawMode(esm_default2.TRIANGLE_STRIP).setUniforms({
          isStroke: false
        }).draw();
      }
      if (!extruded && stroked) {
        model.setProps({
          isIndexed: false
        });
        model.setVertexCount(fillVertexCount * 2 / 3).setDrawMode(esm_default2.TRIANGLE_STRIP).setUniforms({
          isStroke: true
        }).draw();
      }
    }
  };
  __publicField(ColumnLayer, "layerName", "ColumnLayer");
  __publicField(ColumnLayer, "defaultProps", defaultProps9);

  // ../layers/src/column-layer/grid-cell-layer.ts
  var defaultProps10 = {
    cellSize: {
      type: "number",
      min: 0,
      value: 1e3
    },
    offset: {
      type: "array",
      value: [1, 1]
    }
  };
  var GridCellLayer = class extends ColumnLayer {
    getGeometry(diskResolution) {
      return new CubeGeometry();
    }
    draw({
      uniforms
    }) {
      const {
        elevationScale,
        extruded,
        offset,
        coverage,
        cellSize,
        angle: angle2,
        radiusUnits
      } = this.props;
      this.state.model.setUniforms(uniforms).setUniforms({
        radius: cellSize / 2,
        radiusUnits: UNIT[radiusUnits],
        angle: angle2,
        offset,
        extruded,
        coverage,
        elevationScale,
        edgeDistance: 1,
        isWireframe: false
      }).draw();
    }
  };
  __publicField(GridCellLayer, "layerName", "GridCellLayer");
  __publicField(GridCellLayer, "defaultProps", defaultProps10);

  // ../layers/src/path-layer/path.ts
  function normalizePath(path, size, gridResolution, wrapLongitude) {
    let flatPath;
    if (Array.isArray(path[0])) {
      const length7 = path.length * size;
      flatPath = new Array(length7);
      for (let i3 = 0; i3 < path.length; i3++) {
        for (let j = 0; j < size; j++) {
          flatPath[i3 * size + j] = path[i3][j] || 0;
        }
      }
    } else {
      flatPath = path;
    }
    if (gridResolution) {
      return cutPolylineByGrid(flatPath, {
        size,
        gridResolution
      });
    }
    if (wrapLongitude) {
      return cutPolylineByMercatorBounds(flatPath, {
        size
      });
    }
    return flatPath;
  }

  // ../layers/src/path-layer/path-tesselator.ts
  var START_CAP = 1;
  var END_CAP = 2;
  var INVALID = 4;
  var PathTesselator = class extends Tesselator {
    constructor(opts) {
      super({
        ...opts,
        attributes: {
          positions: {
            size: 3,
            padding: 18,
            initialize: true,
            type: opts.fp64 ? Float64Array : Float32Array
          },
          segmentTypes: {
            size: 1,
            type: Uint8ClampedArray
          }
        }
      });
    }
    get(attributeName) {
      return this.attributes[attributeName];
    }
    getGeometryFromBuffer(buffer) {
      if (this.normalize) {
        return super.getGeometryFromBuffer(buffer);
      }
      return null;
    }
    normalizeGeometry(path) {
      if (this.normalize) {
        return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
      }
      return path;
    }
    getGeometrySize(path) {
      if (isCut(path)) {
        let size = 0;
        for (const subPath of path) {
          size += this.getGeometrySize(subPath);
        }
        return size;
      }
      const numPoints = this.getPathLength(path);
      if (numPoints < 2) {
        return 0;
      }
      if (this.isClosed(path)) {
        return numPoints < 3 ? 0 : numPoints + 2;
      }
      return numPoints;
    }
    updateGeometryAttributes(path, context) {
      if (context.geometrySize === 0) {
        return;
      }
      if (path && isCut(path)) {
        for (const subPath of path) {
          const geometrySize = this.getGeometrySize(subPath);
          context.geometrySize = geometrySize;
          this.updateGeometryAttributes(subPath, context);
          context.vertexStart += geometrySize;
        }
      } else {
        this._updateSegmentTypes(path, context);
        this._updatePositions(path, context);
      }
    }
    _updateSegmentTypes(path, context) {
      const segmentTypes = this.attributes.segmentTypes;
      const isPathClosed = path ? this.isClosed(path) : false;
      const {
        vertexStart,
        geometrySize
      } = context;
      segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
      if (isPathClosed) {
        segmentTypes[vertexStart] = INVALID;
        segmentTypes[vertexStart + geometrySize - 2] = INVALID;
      } else {
        segmentTypes[vertexStart] += START_CAP;
        segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
      }
      segmentTypes[vertexStart + geometrySize - 1] = INVALID;
    }
    _updatePositions(path, context) {
      const {
        positions
      } = this.attributes;
      if (!positions || !path) {
        return;
      }
      const {
        vertexStart,
        geometrySize
      } = context;
      const p2 = new Array(3);
      for (let i3 = vertexStart, ptIndex = 0; ptIndex < geometrySize; i3++, ptIndex++) {
        this.getPointOnPath(path, ptIndex, p2);
        positions[i3 * 3] = p2[0];
        positions[i3 * 3 + 1] = p2[1];
        positions[i3 * 3 + 2] = p2[2];
      }
    }
    getPathLength(path) {
      return path.length / this.positionSize;
    }
    getPointOnPath(path, index, target = []) {
      const {
        positionSize
      } = this;
      if (index * positionSize >= path.length) {
        index += 1 - path.length / positionSize;
      }
      const i3 = index * positionSize;
      target[0] = path[i3];
      target[1] = path[i3 + 1];
      target[2] = positionSize === 3 && path[i3 + 2] || 0;
      return target;
    }
    isClosed(path) {
      if (!this.normalize) {
        return Boolean(this.opts.loop);
      }
      const {
        positionSize
      } = this;
      const lastPointIndex = path.length - positionSize;
      return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
    }
  };
  function isCut(path) {
    return Array.isArray(path[0]);
  }

  // ../layers/src/path-layer/path-layer-vertex.glsl.ts
  var path_layer_vertex_glsl_default = `#define SHADER_NAME path-layer-vertex-shader

attribute vec2 positions;

attribute float instanceTypes;
attribute vec3 instanceStartPositions;
attribute vec3 instanceEndPositions;
attribute vec3 instanceLeftPositions;
attribute vec3 instanceRightPositions;
attribute vec3 instanceLeftPositions64Low;
attribute vec3 instanceStartPositions64Low;
attribute vec3 instanceEndPositions64Low;
attribute vec3 instanceRightPositions64Low;
attribute float instanceStrokeWidths;
attribute vec4 instanceColors;
attribute vec3 instancePickingColors;

uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float jointType;
uniform float capType;
uniform float miterLimit;
uniform bool billboard;
uniform int widthUnits;

uniform float opacity;

varying vec4 vColor;
varying vec2 vCornerOffset;
varying float vMiterLength;
varying vec2 vPathPosition;
varying float vPathLength;
varying float vJointType;

const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);

float flipIfTrue(bool flag) {
  return -(float(flag) * 2. - 1.);
}

// calculate line join positions
vec3 getLineJoinOffset(
  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
  vec2 width
) {
  bool isEnd = positions.x > 0.0;
  // side of the segment - -1: left, 0: center, 1: right
  float sideOfPath = positions.y;
  float isJoint = float(sideOfPath == 0.0);

  vec3 deltaA3 = (currPoint - prevPoint);
  vec3 deltaB3 = (nextPoint - currPoint);

  mat3 rotationMatrix;
  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);
  if (needsRotation) {
    deltaA3 = deltaA3 * rotationMatrix;
    deltaB3 = deltaB3 * rotationMatrix;
  }
  vec2 deltaA = deltaA3.xy / width;
  vec2 deltaB = deltaB3.xy / width;

  float lenA = length(deltaA);
  float lenB = length(deltaB);

  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);

  vec2 perpA = vec2(-dirA.y, dirA.x);
  vec2 perpB = vec2(-dirB.y, dirB.x);

  // tangent of the corner
  vec2 tangent = dirA + dirB;
  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
  // direction of the corner
  vec2 miterVec = vec2(-tangent.y, tangent.x);
  // direction of the segment
  vec2 dir = isEnd ? dirA : dirB;
  // direction of the extrusion
  vec2 perp = isEnd ? perpA : perpB;
  // length of the segment
  float L = isEnd ? lenA : lenB;

  // A = angle of the corner
  float sinHalfA = abs(dot(miterVec, perp));
  float cosHalfA = abs(dot(dirA, miterVec));

  // -1: right, 1: left
  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);

  // relative position to the corner:
  // -1: inside (smaller side of the angle)
  // 0: center
  // 1: outside (bigger side of the angle)
  float cornerPosition = sideOfPath * turnDirection;

  float miterSize = 1.0 / max(sinHalfA, EPSILON);
  // trim if inside corner extends further than the line segment
  miterSize = mix(
    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
    miterSize,
    step(0.0, cornerPosition)
  );

  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
    * (sideOfPath + isJoint * turnDirection);

  // special treatment for start cap and end cap
  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
  bool isCap = isStartCap || isEndCap;

  // extend out a triangle to envelope the round cap
  if (isCap) {
    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);
    vJointType = capType;
  } else {
    vJointType = jointType;
  }

  // Generate variables for fragment shader
  vPathLength = L;
  vCornerOffset = offsetVec;
  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
  vMiterLength = isCap ? isJoint : vMiterLength;

  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
  vPathPosition = vec2(
    dot(offsetFromStartOfPath, perp),
    dot(offsetFromStartOfPath, dir)
  );
  geometry.uv = vPathPosition;

  float isValid = step(instanceTypes, 3.5);
  vec3 offset = vec3(offsetVec * width * isValid, 0.0);

  if (needsRotation) {
    offset = rotationMatrix * offset;
  }
  return offset;
}

// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts
void clipLine(inout vec4 position, vec4 refPosition) {
  if (position.w < EPSILON) {
    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
    position = refPosition + (position - refPosition) * r;
  }
}

void main() {
  geometry.pickingColor = instancePickingColors;

  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);

  float isEnd = positions.x;

  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);

  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);

  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);

  geometry.worldPosition = currPosition;
  vec2 widthPixels = vec2(clamp(
    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),
    widthMinPixels, widthMaxPixels) / 2.0);
  vec3 width;

  if (billboard) {
    // Extrude in clipspace
    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);

    clipLine(prevPositionScreen, currPositionScreen);
    clipLine(nextPositionScreen, currPositionScreen);
    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));

    width = vec3(widthPixels, 0.0);
    DECKGL_FILTER_SIZE(width, geometry);

    vec3 offset = getLineJoinOffset(
      prevPositionScreen.xyz / prevPositionScreen.w,
      currPositionScreen.xyz / currPositionScreen.w,
      nextPositionScreen.xyz / nextPositionScreen.w,
      project_pixel_size_to_clipspace(width.xy)
    );

    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);
    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);
  } else {
    // Extrude in commonspace
    prevPosition = project_position(prevPosition, prevPosition64Low);
    currPosition = project_position(currPosition, currPosition64Low);
    nextPosition = project_position(nextPosition, nextPosition64Low);

    width = vec3(project_pixel_size(widthPixels), 0.0);
    DECKGL_FILTER_SIZE(width, geometry);

    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);
    geometry.position = vec4(currPosition + offset, 1.0);
    gl_Position = project_common_position_to_clipspace(geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/path-layer/path-layer-fragment.glsl.ts
  var path_layer_fragment_glsl_default = `#define SHADER_NAME path-layer-fragment-shader

precision highp float;

uniform float miterLimit;

varying vec4 vColor;
varying vec2 vCornerOffset;
varying float vMiterLength;
/*
 * vPathPosition represents the relative coordinates of the current fragment on the path segment.
 * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.
 * vPathPosition.y - position along the length of the path, between [0, L / width].
 */
varying vec2 vPathPosition;
varying float vPathLength;
varying float vJointType;

void main(void) {
  geometry.uv = vPathPosition;

  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
    // if joint is rounded, test distance from the corner
    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
      discard;
    }
    // trim miter
    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {
      discard;
    }
  }
  gl_FragColor = vColor;

  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;

  // ../layers/src/path-layer/path-layer.ts
  var DEFAULT_COLOR7 = [0, 0, 0, 255];
  var defaultProps11 = {
    widthUnits: "meters",
    widthScale: {
      type: "number",
      min: 0,
      value: 1
    },
    widthMinPixels: {
      type: "number",
      min: 0,
      value: 0
    },
    widthMaxPixels: {
      type: "number",
      min: 0,
      value: Number.MAX_SAFE_INTEGER
    },
    jointRounded: false,
    capRounded: false,
    miterLimit: {
      type: "number",
      min: 0,
      value: 4
    },
    billboard: false,
    _pathType: null,
    getPath: {
      type: "accessor",
      value: (object) => object.path
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR7
    },
    getWidth: {
      type: "accessor",
      value: 1
    },
    rounded: {
      deprecatedFor: ["jointRounded", "capRounded"]
    }
  };
  var ATTRIBUTE_TRANSITION = {
    enter: (value, chunk) => {
      return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
    }
  };
  var PathLayer = class extends Layer {
    getShaders() {
      return super.getShaders({
        vs: path_layer_vertex_glsl_default,
        fs: path_layer_fragment_glsl_default,
        modules: [project32_default, picking_default]
      });
    }
    get wrapLongitude() {
      return false;
    }
    initializeState() {
      const noAlloc = true;
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        positions: {
          size: 3,
          vertexOffset: 1,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          transition: ATTRIBUTE_TRANSITION,
          accessor: "getPath",
          update: this.calculatePositions,
          noAlloc,
          shaderAttributes: {
            instanceLeftPositions: {
              vertexOffset: 0
            },
            instanceStartPositions: {
              vertexOffset: 1
            },
            instanceEndPositions: {
              vertexOffset: 2
            },
            instanceRightPositions: {
              vertexOffset: 3
            }
          }
        },
        instanceTypes: {
          size: 1,
          type: esm_default2.UNSIGNED_BYTE,
          update: this.calculateSegmentTypes,
          noAlloc
        },
        instanceStrokeWidths: {
          size: 1,
          accessor: "getWidth",
          transition: ATTRIBUTE_TRANSITION,
          defaultValue: 1
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: esm_default2.UNSIGNED_BYTE,
          normalized: true,
          accessor: "getColor",
          transition: ATTRIBUTE_TRANSITION,
          defaultValue: DEFAULT_COLOR7
        },
        instancePickingColors: {
          size: 3,
          type: esm_default2.UNSIGNED_BYTE,
          accessor: (object, {
            index,
            target: value
          }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
        }
      });
      this.setState({
        pathTesselator: new PathTesselator({
          fp64: this.use64bitPositions()
        })
      });
    }
    updateState(params) {
      super.updateState(params);
      const {
        props,
        changeFlags
      } = params;
      const attributeManager = this.getAttributeManager();
      const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
      if (geometryChanged) {
        const {
          pathTesselator
        } = this.state;
        const buffers = props.data.attributes || {};
        pathTesselator.updateGeometry({
          data: props.data,
          geometryBuffer: buffers.getPath,
          buffers,
          normalize: !props._pathType,
          loop: props._pathType === "loop",
          getGeometry: props.getPath,
          positionFormat: props.positionFormat,
          wrapLongitude: props.wrapLongitude,
          resolution: this.context.viewport.resolution,
          dataChanged: changeFlags.dataChanged
        });
        this.setState({
          numInstances: pathTesselator.instanceCount,
          startIndices: pathTesselator.vertexStarts
        });
        if (!changeFlags.dataChanged) {
          attributeManager.invalidateAll();
        }
      }
      if (changeFlags.extensionsChanged) {
        const {
          gl
        } = this.context;
        this.state.model?.delete();
        this.state.model = this._getModel(gl);
        attributeManager.invalidateAll();
      }
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      const {
        index
      } = info;
      const {
        data
      } = this.props;
      if (data[0] && data[0].__source) {
        info.object = data.find((d) => d.__source.index === index);
      }
      return info;
    }
    disablePickingIndex(objectIndex) {
      const {
        data
      } = this.props;
      if (data[0] && data[0].__source) {
        for (let i3 = 0; i3 < data.length; i3++) {
          if (data[i3].__source.index === objectIndex) {
            this._disablePickingIndex(i3);
          }
        }
      } else {
        super.disablePickingIndex(objectIndex);
      }
    }
    draw({
      uniforms
    }) {
      const {
        jointRounded,
        capRounded,
        billboard,
        miterLimit,
        widthUnits,
        widthScale,
        widthMinPixels,
        widthMaxPixels
      } = this.props;
      this.state.model.setUniforms(uniforms).setUniforms({
        jointType: Number(jointRounded),
        capType: Number(capRounded),
        billboard,
        widthUnits: UNIT[widthUnits],
        widthScale,
        miterLimit,
        widthMinPixels,
        widthMaxPixels
      }).draw();
    }
    _getModel(gl) {
      const SEGMENT_INDICES = [
        0,
        1,
        2,
        1,
        4,
        2,
        1,
        3,
        4,
        3,
        5,
        4
      ];
      const SEGMENT_POSITIONS = [
        0,
        0,
        0,
        -1,
        0,
        1,
        1,
        -1,
        1,
        1,
        1,
        0
      ];
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new Geometry({
          drawMode: esm_default2.TRIANGLES,
          attributes: {
            indices: new Uint16Array(SEGMENT_INDICES),
            positions: {
              value: new Float32Array(SEGMENT_POSITIONS),
              size: 2
            }
          }
        }),
        isInstanced: true
      });
    }
    calculatePositions(attribute) {
      const {
        pathTesselator
      } = this.state;
      attribute.startIndices = pathTesselator.vertexStarts;
      attribute.value = pathTesselator.get("positions");
    }
    calculateSegmentTypes(attribute) {
      const {
        pathTesselator
      } = this.state;
      attribute.startIndices = pathTesselator.vertexStarts;
      attribute.value = pathTesselator.get("segmentTypes");
    }
  };
  __publicField(PathLayer, "defaultProps", defaultProps11);
  __publicField(PathLayer, "layerName", "PathLayer");

  // ../layers/src/solid-polygon-layer/polygon.ts
  var import_earcut2 = __toESM(require_earcut());
  var OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;
  var HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;
  var windingOptions = {
    isClosed: true
  };
  function validate(polygon) {
    polygon = polygon && polygon.positions || polygon;
    if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
      throw new Error("invalid polygon");
    }
  }
  function getPositions(polygon) {
    return "positions" in polygon ? polygon.positions : polygon;
  }
  function getHoleIndices(polygon) {
    return "holeIndices" in polygon ? polygon.holeIndices : null;
  }
  function isNested(polygon) {
    return Array.isArray(polygon[0]);
  }
  function isSimple(polygon) {
    return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
  }
  function isNestedRingClosed(simplePolygon) {
    const p0 = simplePolygon[0];
    const p1 = simplePolygon[simplePolygon.length - 1];
    return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
  }
  function isFlatRingClosed(positions, size, startIndex, endIndex) {
    for (let i3 = 0; i3 < size; i3++) {
      if (positions[startIndex + i3] !== positions[endIndex - size + i3]) {
        return false;
      }
    }
    return true;
  }
  function copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {
    let targetIndex = targetStartIndex;
    const len3 = simplePolygon.length;
    for (let i3 = 0; i3 < len3; i3++) {
      for (let j = 0; j < size; j++) {
        target[targetIndex++] = simplePolygon[i3][j] || 0;
      }
    }
    if (!isNestedRingClosed(simplePolygon)) {
      for (let j = 0; j < size; j++) {
        target[targetIndex++] = simplePolygon[0][j] || 0;
      }
    }
    windingOptions.start = targetStartIndex;
    windingOptions.end = targetIndex;
    windingOptions.size = size;
    modifyPolygonWindingDirection(target, windingDirection, windingOptions);
    return targetIndex;
  }
  function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
    srcEndIndex = srcEndIndex || positions.length;
    const srcLength = srcEndIndex - srcStartIndex;
    if (srcLength <= 0) {
      return targetStartIndex;
    }
    let targetIndex = targetStartIndex;
    for (let i3 = 0; i3 < srcLength; i3++) {
      target[targetIndex++] = positions[srcStartIndex + i3];
    }
    if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
      for (let i3 = 0; i3 < size; i3++) {
        target[targetIndex++] = positions[srcStartIndex + i3];
      }
    }
    windingOptions.start = targetStartIndex;
    windingOptions.end = targetIndex;
    windingOptions.size = size;
    modifyPolygonWindingDirection(target, windingDirection, windingOptions);
    return targetIndex;
  }
  function normalize4(polygon, positionSize) {
    validate(polygon);
    const positions = [];
    const holeIndices = [];
    if ("positions" in polygon) {
      const {
        positions: srcPositions,
        holeIndices: srcHoleIndices
      } = polygon;
      if (srcHoleIndices) {
        let targetIndex = 0;
        for (let i3 = 0; i3 <= srcHoleIndices.length; i3++) {
          targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i3 - 1], srcHoleIndices[i3], i3 === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
          holeIndices.push(targetIndex);
        }
        holeIndices.pop();
        return {
          positions,
          holeIndices
        };
      }
      polygon = srcPositions;
    }
    if (!isNested(polygon)) {
      copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
      return positions;
    }
    if (!isSimple(polygon)) {
      let targetIndex = 0;
      for (const [polygonIndex, simplePolygon] of polygon.entries()) {
        targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return {
        positions,
        holeIndices
      };
    }
    copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
    return positions;
  }
  function getPlaneArea(positions, xIndex, yIndex) {
    const numVerts = positions.length / 3;
    let area2 = 0;
    for (let i3 = 0; i3 < numVerts; i3++) {
      const j = (i3 + 1) % numVerts;
      area2 += positions[i3 * 3 + xIndex] * positions[j * 3 + yIndex];
      area2 -= positions[j * 3 + xIndex] * positions[i3 * 3 + yIndex];
    }
    return Math.abs(area2 / 2);
  }
  function permutePositions(positions, xIndex, yIndex, zIndex) {
    const numVerts = positions.length / 3;
    for (let i3 = 0; i3 < numVerts; i3++) {
      const o2 = i3 * 3;
      const x2 = positions[o2 + 0];
      const y2 = positions[o2 + 1];
      const z = positions[o2 + 2];
      positions[o2 + xIndex] = x2;
      positions[o2 + yIndex] = y2;
      positions[o2 + zIndex] = z;
    }
  }
  function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
    let holeIndices = getHoleIndices(polygon);
    if (holeIndices) {
      holeIndices = holeIndices.map((positionIndex) => positionIndex / positionSize);
    }
    let positions = getPositions(polygon);
    const is3d = full3d && positionSize === 3;
    if (preproject) {
      const n2 = positions.length;
      positions = positions.slice();
      const p2 = [];
      for (let i3 = 0; i3 < n2; i3 += positionSize) {
        p2[0] = positions[i3];
        p2[1] = positions[i3 + 1];
        if (is3d) {
          p2[2] = positions[i3 + 2];
        }
        const xy = preproject(p2);
        positions[i3] = xy[0];
        positions[i3 + 1] = xy[1];
        if (is3d) {
          positions[i3 + 2] = xy[2];
        }
      }
    }
    if (is3d) {
      const xyArea = getPlaneArea(positions, 0, 1);
      const xzArea = getPlaneArea(positions, 0, 2);
      const yzArea = getPlaneArea(positions, 1, 2);
      if (!xyArea && !xzArea && !yzArea) {
        return [];
      }
      if (xyArea > xzArea && xyArea > yzArea) {
      } else if (xzArea > yzArea) {
        if (!preproject) {
          positions = positions.slice();
        }
        permutePositions(positions, 0, 2, 1);
      } else {
        if (!preproject) {
          positions = positions.slice();
        }
        permutePositions(positions, 2, 0, 1);
      }
    }
    return (0, import_earcut2.default)(positions, holeIndices, positionSize);
  }

  // ../layers/src/solid-polygon-layer/polygon-tesselator.ts
  var PolygonTesselator = class extends Tesselator {
    constructor(opts) {
      const {
        fp64: fp642,
        IndexType = Uint32Array
      } = opts;
      super({
        ...opts,
        attributes: {
          positions: {
            size: 3,
            type: fp642 ? Float64Array : Float32Array
          },
          vertexValid: {
            type: Uint8ClampedArray,
            size: 1
          },
          indices: {
            type: IndexType,
            size: 1
          }
        }
      });
    }
    get(attributeName) {
      const {
        attributes
      } = this;
      if (attributeName === "indices") {
        return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
      }
      return attributes[attributeName];
    }
    updateGeometry(opts) {
      super.updateGeometry(opts);
      const externalIndices = this.buffers.indices;
      if (externalIndices) {
        this.vertexCount = (externalIndices.value || externalIndices).length;
      } else if (this.data && !this.getGeometry) {
        throw new Error("missing indices buffer");
      }
    }
    normalizeGeometry(polygon) {
      if (this.normalize) {
        const normalizedPolygon = normalize4(polygon, this.positionSize);
        if (this.opts.resolution) {
          return cutPolygonByGrid(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
            size: this.positionSize,
            gridResolution: this.opts.resolution,
            edgeTypes: true
          });
        }
        if (this.opts.wrapLongitude) {
          return cutPolygonByMercatorBounds(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
            size: this.positionSize,
            maxLatitude: 86,
            edgeTypes: true
          });
        }
        return normalizedPolygon;
      }
      return polygon;
    }
    getGeometrySize(polygon) {
      if (isCut2(polygon)) {
        let size = 0;
        for (const subPolygon of polygon) {
          size += this.getGeometrySize(subPolygon);
        }
        return size;
      }
      return getPositions(polygon).length / this.positionSize;
    }
    getGeometryFromBuffer(buffer) {
      if (this.normalize || !this.buffers.indices) {
        return super.getGeometryFromBuffer(buffer);
      }
      return null;
    }
    updateGeometryAttributes(polygon, context) {
      if (polygon && isCut2(polygon)) {
        for (const subPolygon of polygon) {
          const geometrySize = this.getGeometrySize(subPolygon);
          context.geometrySize = geometrySize;
          this.updateGeometryAttributes(subPolygon, context);
          context.vertexStart += geometrySize;
          context.indexStart = this.indexStarts[context.geometryIndex + 1];
        }
      } else {
        this._updateIndices(polygon, context);
        this._updatePositions(polygon, context);
        this._updateVertexValid(polygon, context);
      }
    }
    _updateIndices(polygon, {
      geometryIndex,
      vertexStart: offset,
      indexStart
    }) {
      const {
        attributes,
        indexStarts,
        typedArrayManager
      } = this;
      let target = attributes.indices;
      if (!target || !polygon) {
        return;
      }
      let i3 = indexStart;
      const indices = getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);
      target = typedArrayManager.allocate(target, indexStart + indices.length, {
        copy: true
      });
      for (let j = 0; j < indices.length; j++) {
        target[i3++] = indices[j] + offset;
      }
      indexStarts[geometryIndex + 1] = indexStart + indices.length;
      attributes.indices = target;
    }
    _updatePositions(polygon, {
      vertexStart,
      geometrySize
    }) {
      const {
        attributes: {
          positions
        },
        positionSize
      } = this;
      if (!positions || !polygon) {
        return;
      }
      const polygonPositions = getPositions(polygon);
      for (let i3 = vertexStart, j = 0; j < geometrySize; i3++, j++) {
        const x2 = polygonPositions[j * positionSize];
        const y2 = polygonPositions[j * positionSize + 1];
        const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;
        positions[i3 * 3] = x2;
        positions[i3 * 3 + 1] = y2;
        positions[i3 * 3 + 2] = z;
      }
    }
    _updateVertexValid(polygon, {
      vertexStart,
      geometrySize
    }) {
      const {
        positionSize
      } = this;
      const vertexValid = this.attributes.vertexValid;
      const holeIndices = polygon && getHoleIndices(polygon);
      if (polygon && polygon.edgeTypes) {
        vertexValid.set(polygon.edgeTypes, vertexStart);
      } else {
        vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
      }
      if (holeIndices) {
        for (let j = 0; j < holeIndices.length; j++) {
          vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;
        }
      }
      vertexValid[vertexStart + geometrySize - 1] = 0;
    }
  };
  function isCut2(polygon) {
    return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
  }

  // ../layers/src/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.ts
  var solid_polygon_layer_vertex_main_glsl_default = `
attribute vec2 vertexPositions;
attribute float vertexValid;

uniform bool extruded;
uniform bool isWireframe;
uniform float elevationScale;
uniform float opacity;

varying vec4 vColor;

struct PolygonProps {
  vec4 fillColors;
  vec4 lineColors;
  vec3 positions;
  vec3 nextPositions;
  vec3 pickingColors;
  vec3 positions64Low;
  vec3 nextPositions64Low;
  float elevations;
};

vec3 project_offset_normal(vec3 vector) {
  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
    // normals generated by the polygon tesselator are in lnglat offsets instead of meters
    return normalize(vector * project_uCommonUnitsPerWorldUnit);
  }
  return project_normal(vector);
}

void calculatePosition(PolygonProps props) {
#ifdef IS_SIDE_VERTEX
  if(vertexValid < 0.5){
    gl_Position = vec4(0.);
    return;
  }
#endif

  vec3 pos;
  vec3 pos64Low;
  vec3 normal;
  vec4 colors = isWireframe ? props.lineColors : props.fillColors;

  geometry.worldPosition = props.positions;
  geometry.worldPositionAlt = props.nextPositions;
  geometry.pickingColor = props.pickingColors;

#ifdef IS_SIDE_VERTEX
  pos = mix(props.positions, props.nextPositions, vertexPositions.x);
  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);
#else
  pos = props.positions;
  pos64Low = props.positions64Low;
#endif

  if (extruded) {
    pos.z += props.elevations * vertexPositions.y * elevationScale;
  }
  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);

  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  if (extruded) {
  #ifdef IS_SIDE_VERTEX
    normal = vec3(
      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),
      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),
      0.0);
    normal = project_offset_normal(normal);
  #else
    normal = project_normal(vec3(0.0, 0.0, 1.0));
  #endif
    geometry.normal = normal;
    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);
    vColor = vec4(lightColor, colors.a * opacity);
  } else {
    vColor = vec4(colors.rgb, colors.a * opacity);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.ts
  var solid_polygon_layer_vertex_top_glsl_default = `#define SHADER_NAME solid-polygon-layer-vertex-shader

attribute vec3 positions;
attribute vec3 positions64Low;
attribute float elevations;
attribute vec4 fillColors;
attribute vec4 lineColors;
attribute vec3 pickingColors;

${solid_polygon_layer_vertex_main_glsl_default}

void main(void) {
  PolygonProps props;

  props.positions = positions;
  props.positions64Low = positions64Low;
  props.elevations = elevations;
  props.fillColors = fillColors;
  props.lineColors = lineColors;
  props.pickingColors = pickingColors;

  calculatePosition(props);
}
`;

  // ../layers/src/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.ts
  var solid_polygon_layer_vertex_side_glsl_default = `#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX


attribute vec3 instancePositions;
attribute vec3 nextPositions;
attribute vec3 instancePositions64Low;
attribute vec3 nextPositions64Low;
attribute float instanceElevations;
attribute vec4 instanceFillColors;
attribute vec4 instanceLineColors;
attribute vec3 instancePickingColors;

${solid_polygon_layer_vertex_main_glsl_default}

void main(void) {
  PolygonProps props;

  #if RING_WINDING_ORDER_CW == 1
    props.positions = instancePositions;
    props.positions64Low = instancePositions64Low;
    props.nextPositions = nextPositions;
    props.nextPositions64Low = nextPositions64Low;
  #else
    props.positions = nextPositions;
    props.positions64Low = nextPositions64Low;
    props.nextPositions = instancePositions;
    props.nextPositions64Low = instancePositions64Low;
  #endif
  props.elevations = instanceElevations;
  props.fillColors = instanceFillColors;
  props.lineColors = instanceLineColors;
  props.pickingColors = instancePickingColors;

  calculatePosition(props);
}
`;

  // ../layers/src/solid-polygon-layer/solid-polygon-layer-fragment.glsl.ts
  var solid_polygon_layer_fragment_glsl_default = `#define SHADER_NAME solid-polygon-layer-fragment-shader

precision highp float;

varying vec4 vColor;

void main(void) {
  gl_FragColor = vColor;

  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;

  // ../layers/src/solid-polygon-layer/solid-polygon-layer.ts
  var DEFAULT_COLOR8 = [0, 0, 0, 255];
  var defaultProps12 = {
    filled: true,
    extruded: false,
    wireframe: false,
    _normalize: true,
    _windingOrder: "CW",
    _full3d: false,
    elevationScale: {
      type: "number",
      min: 0,
      value: 1
    },
    getPolygon: {
      type: "accessor",
      value: (f2) => f2.polygon
    },
    getElevation: {
      type: "accessor",
      value: 1e3
    },
    getFillColor: {
      type: "accessor",
      value: DEFAULT_COLOR8
    },
    getLineColor: {
      type: "accessor",
      value: DEFAULT_COLOR8
    },
    material: true
  };
  var ATTRIBUTE_TRANSITION2 = {
    enter: (value, chunk) => {
      return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
    }
  };
  var SolidPolygonLayer = class extends Layer {
    getShaders(type) {
      return super.getShaders({
        vs: type === "top" ? solid_polygon_layer_vertex_top_glsl_default : solid_polygon_layer_vertex_side_glsl_default,
        fs: solid_polygon_layer_fragment_glsl_default,
        defines: {
          RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
        },
        modules: [project32_default, gouraudLighting, picking_default]
      });
    }
    get wrapLongitude() {
      return false;
    }
    initializeState() {
      const {
        gl,
        viewport
      } = this.context;
      let {
        coordinateSystem
      } = this.props;
      const {
        _full3d
      } = this.props;
      if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
        coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
      }
      let preproject;
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
        if (_full3d) {
          preproject = viewport.projectPosition.bind(viewport);
        } else {
          preproject = viewport.projectFlat.bind(viewport);
        }
      }
      this.setState({
        numInstances: 0,
        polygonTesselator: new PolygonTesselator({
          preproject,
          fp64: this.use64bitPositions(),
          IndexType: !gl || hasFeatures(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array
        })
      });
      const attributeManager = this.getAttributeManager();
      const noAlloc = true;
      attributeManager.remove(["instancePickingColors"]);
      attributeManager.add({
        indices: {
          size: 1,
          isIndexed: true,
          update: this.calculateIndices,
          noAlloc
        },
        positions: {
          size: 3,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          transition: ATTRIBUTE_TRANSITION2,
          accessor: "getPolygon",
          update: this.calculatePositions,
          noAlloc,
          shaderAttributes: {
            positions: {
              vertexOffset: 0,
              divisor: 0
            },
            instancePositions: {
              vertexOffset: 0,
              divisor: 1
            },
            nextPositions: {
              vertexOffset: 1,
              divisor: 1
            }
          }
        },
        vertexValid: {
          size: 1,
          divisor: 1,
          type: esm_default2.UNSIGNED_BYTE,
          update: this.calculateVertexValid,
          noAlloc
        },
        elevations: {
          size: 1,
          transition: ATTRIBUTE_TRANSITION2,
          accessor: "getElevation",
          shaderAttributes: {
            elevations: {
              divisor: 0
            },
            instanceElevations: {
              divisor: 1
            }
          }
        },
        fillColors: {
          size: this.props.colorFormat.length,
          type: esm_default2.UNSIGNED_BYTE,
          normalized: true,
          transition: ATTRIBUTE_TRANSITION2,
          accessor: "getFillColor",
          defaultValue: DEFAULT_COLOR8,
          shaderAttributes: {
            fillColors: {
              divisor: 0
            },
            instanceFillColors: {
              divisor: 1
            }
          }
        },
        lineColors: {
          size: this.props.colorFormat.length,
          type: esm_default2.UNSIGNED_BYTE,
          normalized: true,
          transition: ATTRIBUTE_TRANSITION2,
          accessor: "getLineColor",
          defaultValue: DEFAULT_COLOR8,
          shaderAttributes: {
            lineColors: {
              divisor: 0
            },
            instanceLineColors: {
              divisor: 1
            }
          }
        },
        pickingColors: {
          size: 3,
          type: esm_default2.UNSIGNED_BYTE,
          accessor: (object, {
            index,
            target: value
          }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value),
          shaderAttributes: {
            pickingColors: {
              divisor: 0
            },
            instancePickingColors: {
              divisor: 1
            }
          }
        }
      });
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      const {
        index
      } = info;
      const {
        data
      } = this.props;
      if (data[0] && data[0].__source) {
        info.object = data.find((d) => d.__source.index === index);
      }
      return info;
    }
    disablePickingIndex(objectIndex) {
      const {
        data
      } = this.props;
      if (data[0] && data[0].__source) {
        for (let i3 = 0; i3 < data.length; i3++) {
          if (data[i3].__source.index === objectIndex) {
            this._disablePickingIndex(i3);
          }
        }
      } else {
        super.disablePickingIndex(objectIndex);
      }
    }
    draw({
      uniforms
    }) {
      const {
        extruded,
        filled,
        wireframe,
        elevationScale
      } = this.props;
      const {
        topModel,
        sideModel,
        polygonTesselator
      } = this.state;
      const renderUniforms = {
        ...uniforms,
        extruded: Boolean(extruded),
        elevationScale
      };
      if (sideModel) {
        sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
        sideModel.setUniforms(renderUniforms);
        if (wireframe) {
          sideModel.setDrawMode(esm_default2.LINE_STRIP);
          sideModel.setUniforms({
            isWireframe: true
          }).draw();
        }
        if (filled) {
          sideModel.setDrawMode(esm_default2.TRIANGLE_FAN);
          sideModel.setUniforms({
            isWireframe: false
          }).draw();
        }
      }
      if (topModel) {
        topModel.setVertexCount(polygonTesselator.vertexCount);
        topModel.setUniforms(renderUniforms).draw();
      }
    }
    updateState(updateParams) {
      super.updateState(updateParams);
      this.updateGeometry(updateParams);
      const {
        props,
        oldProps,
        changeFlags
      } = updateParams;
      const attributeManager = this.getAttributeManager();
      const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
      if (regenerateModels) {
        this.state.models?.forEach((model) => model.delete());
        this.setState(this._getModels(this.context.gl));
        attributeManager.invalidateAll();
      }
    }
    updateGeometry({
      props,
      oldProps,
      changeFlags
    }) {
      const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
      if (geometryConfigChanged) {
        const {
          polygonTesselator
        } = this.state;
        const buffers = props.data.attributes || {};
        polygonTesselator.updateGeometry({
          data: props.data,
          normalize: props._normalize,
          geometryBuffer: buffers.getPolygon,
          buffers,
          getGeometry: props.getPolygon,
          positionFormat: props.positionFormat,
          wrapLongitude: props.wrapLongitude,
          resolution: this.context.viewport.resolution,
          fp64: this.use64bitPositions(),
          dataChanged: changeFlags.dataChanged,
          full3d: props._full3d
        });
        this.setState({
          numInstances: polygonTesselator.instanceCount,
          startIndices: polygonTesselator.vertexStarts
        });
        if (!changeFlags.dataChanged) {
          this.getAttributeManager().invalidateAll();
        }
      }
    }
    _getModels(gl) {
      const {
        id,
        filled,
        extruded
      } = this.props;
      let topModel;
      let sideModel;
      if (filled) {
        const shaders = this.getShaders("top");
        shaders.defines.NON_INSTANCED_MODEL = 1;
        topModel = new Model(gl, {
          ...shaders,
          id: `${id}-top`,
          drawMode: esm_default2.TRIANGLES,
          attributes: {
            vertexPositions: new Float32Array([0, 1])
          },
          uniforms: {
            isWireframe: false,
            isSideVertex: false
          },
          vertexCount: 0,
          isIndexed: true
        });
      }
      if (extruded) {
        sideModel = new Model(gl, {
          ...this.getShaders("side"),
          id: `${id}-side`,
          geometry: new Geometry({
            drawMode: esm_default2.LINES,
            vertexCount: 4,
            attributes: {
              vertexPositions: {
                size: 2,
                value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
              }
            }
          }),
          instanceCount: 0,
          isInstanced: 1
        });
        sideModel.userData.excludeAttributes = {
          indices: true
        };
      }
      return {
        models: [sideModel, topModel].filter(Boolean),
        topModel,
        sideModel
      };
    }
    calculateIndices(attribute) {
      const {
        polygonTesselator
      } = this.state;
      attribute.startIndices = polygonTesselator.indexStarts;
      attribute.value = polygonTesselator.get("indices");
    }
    calculatePositions(attribute) {
      const {
        polygonTesselator
      } = this.state;
      attribute.startIndices = polygonTesselator.vertexStarts;
      attribute.value = polygonTesselator.get("positions");
    }
    calculateVertexValid(attribute) {
      attribute.value = this.state.polygonTesselator.get("vertexValid");
    }
  };
  __publicField(SolidPolygonLayer, "defaultProps", defaultProps12);
  __publicField(SolidPolygonLayer, "layerName", "SolidPolygonLayer");

  // ../layers/src/utils.ts
  function replaceInRange({
    data,
    getIndex,
    dataRange,
    replace
  }) {
    const {
      startRow = 0,
      endRow = Infinity
    } = dataRange;
    const count2 = data.length;
    let replaceStart = count2;
    let replaceEnd = count2;
    for (let i3 = 0; i3 < count2; i3++) {
      const row = getIndex(data[i3]);
      if (replaceStart > i3 && row >= startRow) {
        replaceStart = i3;
      }
      if (row >= endRow) {
        replaceEnd = i3;
        break;
      }
    }
    let index = replaceStart;
    const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
    const endChunk = dataLengthChanged ? data.slice(replaceEnd) : void 0;
    for (let i3 = 0; i3 < replace.length; i3++) {
      data[index++] = replace[i3];
    }
    if (endChunk) {
      for (let i3 = 0; i3 < endChunk.length; i3++) {
        data[index++] = endChunk[i3];
      }
      data.length = index;
    }
    return {
      startRow: replaceStart,
      endRow: replaceStart + replace.length
    };
  }

  // ../layers/src/polygon-layer/polygon-layer.ts
  var defaultLineColor = [0, 0, 0, 255];
  var defaultFillColor = [0, 0, 0, 255];
  var defaultProps13 = {
    stroked: true,
    filled: true,
    extruded: false,
    elevationScale: 1,
    wireframe: false,
    _normalize: true,
    _windingOrder: "CW",
    lineWidthUnits: "meters",
    lineWidthScale: 1,
    lineWidthMinPixels: 0,
    lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
    lineJointRounded: false,
    lineMiterLimit: 4,
    getPolygon: {
      type: "accessor",
      value: (f2) => f2.polygon
    },
    getFillColor: {
      type: "accessor",
      value: defaultFillColor
    },
    getLineColor: {
      type: "accessor",
      value: defaultLineColor
    },
    getLineWidth: {
      type: "accessor",
      value: 1
    },
    getElevation: {
      type: "accessor",
      value: 1e3
    },
    material: true
  };
  var PolygonLayer = class extends CompositeLayer {
    initializeState() {
      this.state = {
        paths: []
      };
      if (this.props.getLineDashArray) {
        log_default.removed("getLineDashArray", "PathStyleExtension")();
      }
    }
    updateState({
      changeFlags
    }) {
      const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
      if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
        const paths = this.state.paths.slice();
        const pathsDiff = changeFlags.dataChanged.map((dataRange) => replaceInRange({
          data: paths,
          getIndex: (p2) => p2.__source.index,
          dataRange,
          replace: this._getPaths(dataRange)
        }));
        this.setState({
          paths,
          pathsDiff
        });
      } else if (geometryChanged) {
        this.setState({
          paths: this._getPaths(),
          pathsDiff: null
        });
      }
    }
    _getPaths(dataRange = {}) {
      const {
        data,
        getPolygon,
        positionFormat,
        _normalize
      } = this.props;
      const paths = [];
      const positionSize = positionFormat === "XY" ? 2 : 3;
      const {
        startRow,
        endRow
      } = dataRange;
      const {
        iterable,
        objectInfo
      } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        let polygon = getPolygon(object, objectInfo);
        if (_normalize) {
          polygon = normalize4(polygon, positionSize);
        }
        const {
          holeIndices
        } = polygon;
        const positions = polygon.positions || polygon;
        if (holeIndices) {
          for (let i3 = 0; i3 <= holeIndices.length; i3++) {
            const path = positions.slice(holeIndices[i3 - 1] || 0, holeIndices[i3] || positions.length);
            paths.push(this.getSubLayerRow({
              path
            }, object, objectInfo.index));
          }
        } else {
          paths.push(this.getSubLayerRow({
            path: positions
          }, object, objectInfo.index));
        }
      }
      return paths;
    }
    renderLayers() {
      const {
        data,
        _dataDiff,
        stroked,
        filled,
        extruded,
        wireframe,
        _normalize,
        _windingOrder,
        elevationScale,
        transitions,
        positionFormat
      } = this.props;
      const {
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        lineJointRounded,
        lineMiterLimit,
        lineDashJustified
      } = this.props;
      const {
        getFillColor,
        getLineColor,
        getLineWidth,
        getLineDashArray,
        getElevation,
        getPolygon,
        updateTriggers,
        material
      } = this.props;
      const {
        paths,
        pathsDiff
      } = this.state;
      const FillLayer = this.getSubLayerClass("fill", SolidPolygonLayer);
      const StrokeLayer = this.getSubLayerClass("stroke", PathLayer);
      const polygonLayer = this.shouldRenderSubLayer("fill", paths) && new FillLayer({
        _dataDiff,
        extruded,
        elevationScale,
        filled,
        wireframe,
        _normalize,
        _windingOrder,
        getElevation,
        getFillColor,
        getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
        material,
        transitions
      }, this.getSubLayerProps({
        id: "fill",
        updateTriggers: updateTriggers && {
          getPolygon: updateTriggers.getPolygon,
          getElevation: updateTriggers.getElevation,
          getFillColor: updateTriggers.getFillColor,
          lineColors: extruded && wireframe,
          getLineColor: updateTriggers.getLineColor
        }
      }), {
        data,
        positionFormat,
        getPolygon
      });
      const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("stroke", paths) && new StrokeLayer({
        _dataDiff: pathsDiff && (() => pathsDiff),
        widthUnits: lineWidthUnits,
        widthScale: lineWidthScale,
        widthMinPixels: lineWidthMinPixels,
        widthMaxPixels: lineWidthMaxPixels,
        jointRounded: lineJointRounded,
        miterLimit: lineMiterLimit,
        dashJustified: lineDashJustified,
        _pathType: "loop",
        transitions: transitions && {
          getWidth: transitions.getLineWidth,
          getColor: transitions.getLineColor,
          getPath: transitions.getPolygon
        },
        getColor: this.getSubLayerAccessor(getLineColor),
        getWidth: this.getSubLayerAccessor(getLineWidth),
        getDashArray: this.getSubLayerAccessor(getLineDashArray)
      }, this.getSubLayerProps({
        id: "stroke",
        updateTriggers: updateTriggers && {
          getWidth: updateTriggers.getLineWidth,
          getColor: updateTriggers.getLineColor,
          getDashArray: updateTriggers.getLineDashArray
        }
      }), {
        data: paths,
        positionFormat,
        getPath: (x2) => x2.path
      });
      return [
        !extruded && polygonLayer,
        polygonLineLayer,
        extruded && polygonLayer
      ];
    }
  };
  __publicField(PolygonLayer, "layerName", "PolygonLayer");
  __publicField(PolygonLayer, "defaultProps", defaultProps13);

  // ../layers/src/geojson-layer/geojson-binary.ts
  function binaryToFeatureForAccesor(data, index) {
    if (!data) {
      return null;
    }
    const featureIndex = "startIndices" in data ? data.startIndices[index] : index;
    const geometryIndex = data.featureIds.value[featureIndex];
    if (featureIndex !== -1) {
      return getPropertiesForIndex(data, geometryIndex, featureIndex);
    }
    return null;
  }
  function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
    const feature = {
      properties: {
        ...data.properties[propertiesIndex]
      }
    };
    for (const prop in data.numericProps) {
      feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
    }
    return feature;
  }
  function calculatePickingColors(geojsonBinary, encodePickingColor) {
    const pickingColors = {
      points: null,
      lines: null,
      polygons: null
    };
    for (const key in pickingColors) {
      const featureIds = geojsonBinary[key].globalFeatureIds.value;
      pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);
      const pickingColor = [];
      for (let i3 = 0; i3 < featureIds.length; i3++) {
        encodePickingColor(featureIds[i3], pickingColor);
        pickingColors[key][i3 * 3 + 0] = pickingColor[0];
        pickingColors[key][i3 * 3 + 1] = pickingColor[1];
        pickingColors[key][i3 * 3 + 2] = pickingColor[2];
      }
    }
    return pickingColors;
  }

  // ../layers/src/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.ts
  var multi_icon_layer_fragment_glsl_default = `#define SHADER_NAME multi-icon-layer-fragment-shader

precision highp float;

uniform float opacity;
uniform sampler2D iconsTexture;
uniform float gamma;
uniform bool sdf;
uniform float alphaCutoff;
uniform float sdfBuffer;
uniform float outlineBuffer;
uniform vec4 outlineColor;

varying vec4 vColor;
varying vec2 vTextureCoords;
varying vec2 uv;

void main(void) {
  geometry.uv = uv;

  if (!picking_uActive) {
    float alpha = texture2D(iconsTexture, vTextureCoords).a;
    vec4 color = vColor;

    // if enable sdf (signed distance fields)
    if (sdf) {
      float distance = alpha;
      alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);

      if (outlineBuffer > 0.0) {
        float inFill = alpha;
        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);
        color = mix(outlineColor, vColor, inFill);
        alpha = inBorder;
      }
    }

    // Take the global opacity and the alpha from color into account for the alpha component
    float a = alpha * color.a;
    
    if (a < alphaCutoff) {
      discard;
    }

    gl_FragColor = vec4(color.rgb, a * opacity);
  }

  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;

  // ../layers/src/text-layer/multi-icon-layer/multi-icon-layer.ts
  var DEFAULT_BUFFER2 = 192 / 256;
  var EMPTY_ARRAY3 = [];
  var defaultProps14 = {
    getIconOffsets: {
      type: "accessor",
      value: (x2) => x2.offsets
    },
    alphaCutoff: 1e-3,
    smoothing: 0.1,
    outlineWidth: 0,
    outlineColor: {
      type: "color",
      value: [0, 0, 0, 255]
    }
  };
  var MultiIconLayer = class extends IconLayer {
    getShaders() {
      return {
        ...super.getShaders(),
        fs: multi_icon_layer_fragment_glsl_default
      };
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceOffsets: {
          size: 2,
          accessor: "getIconOffsets"
        },
        instancePickingColors: {
          type: esm_default2.UNSIGNED_BYTE,
          size: 3,
          accessor: (object, {
            index,
            target: value
          }) => this.encodePickingColor(index, value)
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const {
        props,
        oldProps
      } = params;
      let {
        outlineColor
      } = props;
      if (outlineColor !== oldProps.outlineColor) {
        outlineColor = outlineColor.map((x2) => x2 / 255);
        outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
        this.setState({
          outlineColor
        });
      }
      if (!props.sdf && props.outlineWidth) {
        log_default.warn(`${this.id}: fontSettings.sdf is required to render outline`)();
      }
    }
    draw(params) {
      const {
        sdf,
        smoothing,
        outlineWidth
      } = this.props;
      const {
        outlineColor
      } = this.state;
      const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER2 * (1 - outlineWidth)) : -1;
      params.uniforms = {
        ...params.uniforms,
        sdfBuffer: DEFAULT_BUFFER2,
        outlineBuffer,
        gamma: smoothing,
        sdf: Boolean(sdf),
        outlineColor
      };
      super.draw(params);
      if (sdf && outlineWidth) {
        const {
          iconManager
        } = this.state;
        const iconsTexture = iconManager.getTexture();
        if (iconsTexture) {
          this.state.model.draw({
            uniforms: {
              outlineBuffer: DEFAULT_BUFFER2
            }
          });
        }
      }
    }
    getInstanceOffset(icons) {
      return icons ? Array.from(icons).flatMap((icon) => super.getInstanceOffset(icon)) : EMPTY_ARRAY3;
    }
    getInstanceColorMode(icons) {
      return 1;
    }
    getInstanceIconFrame(icons) {
      return icons ? Array.from(icons).flatMap((icon) => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY3;
    }
  };
  __publicField(MultiIconLayer, "defaultProps", defaultProps14);
  __publicField(MultiIconLayer, "layerName", "MultiIconLayer");

  // ../../node_modules/@mapbox/tiny-sdf/index.js
  var INF = 1e20;
  var TinySDF = class {
    constructor({
      fontSize = 24,
      buffer = 3,
      radius = 8,
      cutoff = 0.25,
      fontFamily = "sans-serif",
      fontWeight = "normal",
      fontStyle = "normal"
    } = {}) {
      this.buffer = buffer;
      this.cutoff = cutoff;
      this.radius = radius;
      const size = this.size = fontSize + buffer * 4;
      const canvas = this._createCanvas(size);
      const ctx = this.ctx = canvas.getContext("2d", { willReadFrequently: true });
      ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
      ctx.textBaseline = "alphabetic";
      ctx.textAlign = "left";
      ctx.fillStyle = "black";
      this.gridOuter = new Float64Array(size * size);
      this.gridInner = new Float64Array(size * size);
      this.f = new Float64Array(size);
      this.z = new Float64Array(size + 1);
      this.v = new Uint16Array(size);
    }
    _createCanvas(size) {
      const canvas = document.createElement("canvas");
      canvas.width = canvas.height = size;
      return canvas;
    }
    draw(char) {
      const {
        width: glyphAdvance,
        actualBoundingBoxAscent,
        actualBoundingBoxDescent,
        actualBoundingBoxLeft,
        actualBoundingBoxRight
      } = this.ctx.measureText(char);
      const glyphTop = Math.ceil(actualBoundingBoxAscent);
      const glyphLeft = 0;
      const glyphWidth = Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft));
      const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
      const width = glyphWidth + 2 * this.buffer;
      const height = glyphHeight + 2 * this.buffer;
      const len3 = Math.max(width * height, 0);
      const data = new Uint8ClampedArray(len3);
      const glyph = { data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance };
      if (glyphWidth === 0 || glyphHeight === 0)
        return glyph;
      const { ctx, buffer, gridInner, gridOuter } = this;
      ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
      ctx.fillText(char, buffer, buffer + glyphTop);
      const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);
      gridOuter.fill(INF, 0, len3);
      gridInner.fill(0, 0, len3);
      for (let y2 = 0; y2 < glyphHeight; y2++) {
        for (let x2 = 0; x2 < glyphWidth; x2++) {
          const a2 = imgData.data[4 * (y2 * glyphWidth + x2) + 3] / 255;
          if (a2 === 0)
            continue;
          const j = (y2 + buffer) * width + x2 + buffer;
          if (a2 === 1) {
            gridOuter[j] = 0;
            gridInner[j] = INF;
          } else {
            const d = 0.5 - a2;
            gridOuter[j] = d > 0 ? d * d : 0;
            gridInner[j] = d < 0 ? d * d : 0;
          }
        }
      }
      edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
      edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
      for (let i3 = 0; i3 < len3; i3++) {
        const d = Math.sqrt(gridOuter[i3]) - Math.sqrt(gridInner[i3]);
        data[i3] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
      }
      return glyph;
    }
  };
  function edt(data, x0, y0, width, height, gridSize, f2, v, z) {
    for (let x2 = x0; x2 < x0 + width; x2++)
      edt1d(data, y0 * gridSize + x2, gridSize, height, f2, v, z);
    for (let y2 = y0; y2 < y0 + height; y2++)
      edt1d(data, y2 * gridSize + x0, 1, width, f2, v, z);
  }
  function edt1d(grid, offset, stride, length7, f2, v, z) {
    v[0] = 0;
    z[0] = -INF;
    z[1] = INF;
    f2[0] = grid[offset];
    for (let q = 1, k = 0, s2 = 0; q < length7; q++) {
      f2[q] = grid[offset + q * stride];
      const q2 = q * q;
      do {
        const r2 = v[k];
        s2 = (f2[q] - f2[r2] + q2 - r2 * r2) / (q - r2) / 2;
      } while (s2 <= z[k] && --k > -1);
      k++;
      v[k] = q;
      z[k] = s2;
      z[k + 1] = INF;
    }
    for (let q = 0, k = 0; q < length7; q++) {
      while (z[k + 1] < q)
        k++;
      const r2 = v[k];
      const qr = q - r2;
      grid[offset + q * stride] = f2[r2] + qr * qr;
    }
  }

  // ../layers/src/text-layer/utils.ts
  var MISSING_CHAR_WIDTH = 32;
  var SINGLE_LINE = [];
  function nextPowOfTwo2(number) {
    return Math.pow(2, Math.ceil(Math.log2(number)));
  }
  function buildMapping2({
    characterSet,
    getFontWidth,
    fontHeight,
    buffer,
    maxCanvasWidth,
    mapping = {},
    xOffset = 0,
    yOffset = 0
  }) {
    let row = 0;
    let x2 = xOffset;
    const rowHeight = fontHeight + buffer * 2;
    for (const char of characterSet) {
      if (!mapping[char]) {
        const width = getFontWidth(char);
        if (x2 + width + buffer * 2 > maxCanvasWidth) {
          x2 = 0;
          row++;
        }
        mapping[char] = {
          x: x2 + buffer,
          y: yOffset + row * rowHeight + buffer,
          width,
          height: rowHeight,
          layoutWidth: width,
          layoutHeight: fontHeight
        };
        x2 += width + buffer * 2;
      }
    }
    return {
      mapping,
      xOffset: x2,
      yOffset: yOffset + row * rowHeight,
      canvasHeight: nextPowOfTwo2(yOffset + (row + 1) * rowHeight)
    };
  }
  function getTextWidth(text, startIndex, endIndex, mapping) {
    let width = 0;
    for (let i3 = startIndex; i3 < endIndex; i3++) {
      const character = text[i3];
      width += mapping[character]?.layoutWidth || 0;
    }
    return width;
  }
  function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
    let rowStartCharIndex = startIndex;
    let rowOffsetLeft = 0;
    for (let i3 = startIndex; i3 < endIndex; i3++) {
      const textWidth = getTextWidth(text, i3, i3 + 1, iconMapping);
      if (rowOffsetLeft + textWidth > maxWidth) {
        if (rowStartCharIndex < i3) {
          target.push(i3);
        }
        rowStartCharIndex = i3;
        rowOffsetLeft = 0;
      }
      rowOffsetLeft += textWidth;
    }
    return rowOffsetLeft;
  }
  function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
    let rowStartCharIndex = startIndex;
    let groupStartCharIndex = startIndex;
    let groupEndCharIndex = startIndex;
    let rowOffsetLeft = 0;
    for (let i3 = startIndex; i3 < endIndex; i3++) {
      if (text[i3] === " ") {
        groupEndCharIndex = i3 + 1;
      } else if (text[i3 + 1] === " " || i3 + 1 === endIndex) {
        groupEndCharIndex = i3 + 1;
      }
      if (groupEndCharIndex > groupStartCharIndex) {
        let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
        if (rowOffsetLeft + groupWidth > maxWidth) {
          if (rowStartCharIndex < groupStartCharIndex) {
            target.push(groupStartCharIndex);
            rowStartCharIndex = groupStartCharIndex;
            rowOffsetLeft = 0;
          }
          if (groupWidth > maxWidth) {
            groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);
            rowStartCharIndex = target[target.length - 1];
          }
        }
        groupStartCharIndex = groupEndCharIndex;
        rowOffsetLeft += groupWidth;
      }
    }
    return rowOffsetLeft;
  }
  function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
    if (endIndex === void 0) {
      endIndex = text.length;
    }
    const result = [];
    if (wordBreak === "break-all") {
      breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
    } else {
      breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
    }
    return result;
  }
  function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
    let x2 = 0;
    let rowHeight = 0;
    for (let i3 = startIndex; i3 < endIndex; i3++) {
      const character = line[i3];
      const frame = iconMapping[character];
      if (frame) {
        if (!rowHeight) {
          rowHeight = frame.layoutHeight;
        }
        leftOffsets[i3] = x2 + frame.layoutWidth / 2;
        x2 += frame.layoutWidth;
      } else {
        log_default.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();
        leftOffsets[i3] = x2;
        x2 += MISSING_CHAR_WIDTH;
      }
    }
    rowSize[0] = x2;
    rowSize[1] = rowHeight;
  }
  function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
    const characters = Array.from(paragraph);
    const numCharacters = characters.length;
    const x2 = new Array(numCharacters);
    const y2 = new Array(numCharacters);
    const rowWidth = new Array(numCharacters);
    const autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
    const size = [0, 0];
    const rowSize = [0, 0];
    let rowOffsetTop = 0;
    let lineStartIndex = 0;
    let lineEndIndex = 0;
    for (let i3 = 0; i3 <= numCharacters; i3++) {
      const char = characters[i3];
      if (char === "\n" || i3 === numCharacters) {
        lineEndIndex = i3;
      }
      if (lineEndIndex > lineStartIndex) {
        const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
        for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
          const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
          const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
          transformRow(characters, rowStart, rowEnd, iconMapping, x2, rowSize);
          for (let j = rowStart; j < rowEnd; j++) {
            const char2 = characters[j];
            const layoutOffsetY = iconMapping[char2]?.layoutOffsetY || 0;
            y2[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
            rowWidth[j] = rowSize[0];
          }
          rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
          size[0] = Math.max(size[0], rowSize[0]);
        }
        lineStartIndex = lineEndIndex;
      }
      if (char === "\n") {
        x2[lineStartIndex] = 0;
        y2[lineStartIndex] = 0;
        rowWidth[lineStartIndex] = 0;
        lineStartIndex++;
      }
    }
    size[1] = rowOffsetTop;
    return {
      x: x2,
      y: y2,
      rowWidth,
      size
    };
  }
  function getTextFromBuffer({
    value,
    length: length7,
    stride,
    offset,
    startIndices,
    characterSet
  }) {
    const bytesPerElement = value.BYTES_PER_ELEMENT;
    const elementStride = stride ? stride / bytesPerElement : 1;
    const elementOffset = offset ? offset / bytesPerElement : 0;
    const characterCount = startIndices[length7] || Math.ceil((value.length - elementOffset) / elementStride);
    const autoCharacterSet = characterSet && /* @__PURE__ */ new Set();
    const texts = new Array(length7);
    let codes = value;
    if (elementStride > 1 || elementOffset > 0) {
      const ArrayType = value.constructor;
      codes = new ArrayType(characterCount);
      for (let i3 = 0; i3 < characterCount; i3++) {
        codes[i3] = value[i3 * elementStride + elementOffset];
      }
    }
    for (let index = 0; index < length7; index++) {
      const startIndex = startIndices[index];
      const endIndex = startIndices[index + 1] || characterCount;
      const codesAtIndex = codes.subarray(startIndex, endIndex);
      texts[index] = String.fromCodePoint.apply(null, codesAtIndex);
      if (autoCharacterSet) {
        codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
      }
    }
    if (autoCharacterSet) {
      for (const charCode of autoCharacterSet) {
        characterSet.add(String.fromCodePoint(charCode));
      }
    }
    return {
      texts,
      characterCount
    };
  }

  // ../layers/src/text-layer/lru-cache.ts
  var LRUCache = class {
    _cache = {};
    _order = [];
    constructor(limit = 5) {
      this.limit = limit;
    }
    get(key) {
      const value = this._cache[key];
      if (value) {
        this._deleteOrder(key);
        this._appendOrder(key);
      }
      return value;
    }
    set(key, value) {
      if (!this._cache[key]) {
        if (Object.keys(this._cache).length === this.limit) {
          this.delete(this._order[0]);
        }
        this._cache[key] = value;
        this._appendOrder(key);
      } else {
        this.delete(key);
        this._cache[key] = value;
        this._appendOrder(key);
      }
    }
    delete(key) {
      const value = this._cache[key];
      if (value) {
        delete this._cache[key];
        this._deleteOrder(key);
      }
    }
    _deleteOrder(key) {
      const index = this._order.indexOf(key);
      if (index >= 0) {
        this._order.splice(index, 1);
      }
    }
    _appendOrder(key) {
      this._order.push(key);
    }
  };

  // ../layers/src/text-layer/font-atlas-manager.ts
  function getDefaultCharacterSet() {
    const charSet = [];
    for (let i3 = 32; i3 < 128; i3++) {
      charSet.push(String.fromCharCode(i3));
    }
    return charSet;
  }
  var DEFAULT_FONT_SETTINGS = {
    fontFamily: "Monaco, monospace",
    fontWeight: "normal",
    characterSet: getDefaultCharacterSet(),
    fontSize: 64,
    buffer: 4,
    sdf: false,
    cutoff: 0.25,
    radius: 12,
    smoothing: 0.1
  };
  var MAX_CANVAS_WIDTH = 1024;
  var BASELINE_SCALE = 0.9;
  var HEIGHT_SCALE = 1.2;
  var CACHE_LIMIT = 3;
  var cache3 = new LRUCache(CACHE_LIMIT);
  function getNewChars(cacheKey, characterSet) {
    let newCharSet;
    if (typeof characterSet === "string") {
      newCharSet = new Set(Array.from(characterSet));
    } else {
      newCharSet = new Set(characterSet);
    }
    const cachedFontAtlas = cache3.get(cacheKey);
    if (!cachedFontAtlas) {
      return newCharSet;
    }
    for (const char in cachedFontAtlas.mapping) {
      if (newCharSet.has(char)) {
        newCharSet.delete(char);
      }
    }
    return newCharSet;
  }
  function populateAlphaChannel(alphaChannel, imageData) {
    for (let i3 = 0; i3 < alphaChannel.length; i3++) {
      imageData.data[4 * i3 + 3] = alphaChannel[i3];
    }
  }
  function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
    ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx.fillStyle = "#000";
    ctx.textBaseline = "alphabetic";
    ctx.textAlign = "left";
  }
  function setFontAtlasCacheLimit(limit) {
    log_default.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, "Invalid cache limit");
    cache3 = new LRUCache(limit);
  }
  var FontAtlasManager = class {
    props = {
      ...DEFAULT_FONT_SETTINGS
    };
    get texture() {
      return this._atlas;
    }
    get mapping() {
      return this._atlas && this._atlas.mapping;
    }
    get scale() {
      const {
        fontSize,
        buffer
      } = this.props;
      return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;
    }
    setProps(props = {}) {
      Object.assign(this.props, props);
      this._key = this._getKey();
      const charSet = getNewChars(this._key, this.props.characterSet);
      const cachedFontAtlas = cache3.get(this._key);
      if (cachedFontAtlas && charSet.size === 0) {
        if (this._atlas !== cachedFontAtlas) {
          this._atlas = cachedFontAtlas;
        }
        return;
      }
      const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
      this._atlas = fontAtlas;
      cache3.set(this._key, fontAtlas);
    }
    _generateFontAtlas(characterSet, cachedFontAtlas) {
      const {
        fontFamily,
        fontWeight,
        fontSize,
        buffer,
        sdf,
        radius,
        cutoff
      } = this.props;
      let canvas = cachedFontAtlas && cachedFontAtlas.data;
      if (!canvas) {
        canvas = document.createElement("canvas");
        canvas.width = MAX_CANVAS_WIDTH;
      }
      const ctx = canvas.getContext("2d", {
        willReadFrequently: true
      });
      setTextStyle(ctx, fontFamily, fontSize, fontWeight);
      const {
        mapping,
        canvasHeight,
        xOffset,
        yOffset
      } = buildMapping2({
        getFontWidth: (char) => ctx.measureText(char).width,
        fontHeight: fontSize * HEIGHT_SCALE,
        buffer,
        characterSet,
        maxCanvasWidth: MAX_CANVAS_WIDTH,
        ...cachedFontAtlas && {
          mapping: cachedFontAtlas.mapping,
          xOffset: cachedFontAtlas.xOffset,
          yOffset: cachedFontAtlas.yOffset
        }
      });
      if (canvas.height !== canvasHeight) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        canvas.height = canvasHeight;
        ctx.putImageData(imageData, 0, 0);
      }
      setTextStyle(ctx, fontFamily, fontSize, fontWeight);
      if (sdf) {
        const tinySDF = new TinySDF({
          fontSize,
          buffer,
          radius,
          cutoff,
          fontFamily,
          fontWeight: `${fontWeight}`
        });
        for (const char of characterSet) {
          const {
            data,
            width,
            height,
            glyphTop
          } = tinySDF.draw(char);
          mapping[char].width = width;
          mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
          const imageData = ctx.createImageData(width, height);
          populateAlphaChannel(data, imageData);
          ctx.putImageData(imageData, mapping[char].x, mapping[char].y);
        }
      } else {
        for (const char of characterSet) {
          ctx.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);
        }
      }
      return {
        xOffset,
        yOffset,
        mapping,
        data: canvas,
        width: canvas.width,
        height: canvas.height
      };
    }
    _getKey() {
      const {
        fontFamily,
        fontWeight,
        fontSize,
        buffer,
        sdf,
        radius,
        cutoff
      } = this.props;
      if (sdf) {
        return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;
      }
      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;
    }
  };

  // ../layers/src/text-layer/text-background-layer/text-background-layer-vertex.glsl.ts
  var text_background_layer_vertex_glsl_default = `#define SHADER_NAME text-background-layer-vertex-shader

attribute vec2 positions;

attribute vec3 instancePositions;
attribute vec3 instancePositions64Low;
attribute vec4 instanceRects;
attribute float instanceSizes;
attribute float instanceAngles;
attribute vec2 instancePixelOffsets;
attribute float instanceLineWidths;
attribute vec4 instanceFillColors;
attribute vec4 instanceLineColors;
attribute vec3 instancePickingColors;

uniform bool billboard;
uniform float opacity;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform vec4 padding;
uniform int sizeUnits;

varying vec4 vFillColor;
varying vec4 vLineColor;
varying float vLineWidth;
varying vec2 uv;
varying vec2 dimensions;

vec2 rotate_by_angle(vec2 vertex, float angle) {
  float angle_radian = radians(angle);
  float cos_angle = cos(angle_radian);
  float sin_angle = sin(angle_radian);
  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
  return rotationMatrix * vertex;
}

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = positions;
  geometry.pickingColor = instancePickingColors;
  uv = positions;
  vLineWidth = instanceLineWidths;

  // convert size in meters to pixels, then scaled and clamp

  // project meters to pixels and clamp to limits
  float sizePixels = clamp(
    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),
    sizeMinPixels, sizeMaxPixels
  );

  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;

  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);
  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
  pixelOffset += instancePixelOffsets;
  pixelOffset.y *= -1.0;

  if (billboard)  {
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
    vec3 offset = vec3(pixelOffset, 0.0);
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
  } else {
    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
    DECKGL_FILTER_SIZE(offset_common, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
  DECKGL_FILTER_COLOR(vFillColor, geometry);
  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
  DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;

  // ../layers/src/text-layer/text-background-layer/text-background-layer-fragment.glsl.ts
  var text_background_layer_fragment_glsl_default = `#define SHADER_NAME text-background-layer-fragment-shader

precision highp float;

uniform bool stroked;

varying vec4 vFillColor;
varying vec4 vLineColor;
varying float vLineWidth;
varying vec2 uv;
varying vec2 dimensions;

void main(void) {
  geometry.uv = uv;

  vec2 pixelPosition = uv * dimensions;
  if (stroked) {
    float distToEdge = min(
      min(pixelPosition.x, dimensions.x - pixelPosition.x),
      min(pixelPosition.y, dimensions.y - pixelPosition.y)
    );
    float isBorder = smoothedge(distToEdge, vLineWidth);
    gl_FragColor = mix(vFillColor, vLineColor, isBorder);
  } else {
    gl_FragColor = vFillColor;
  }

  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;

  // ../layers/src/text-layer/text-background-layer/text-background-layer.ts
  var defaultProps15 = {
    billboard: true,
    sizeScale: 1,
    sizeUnits: "pixels",
    sizeMinPixels: 0,
    sizeMaxPixels: Number.MAX_SAFE_INTEGER,
    padding: {
      type: "array",
      value: [0, 0, 0, 0]
    },
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    getSize: {
      type: "accessor",
      value: 1
    },
    getAngle: {
      type: "accessor",
      value: 0
    },
    getPixelOffset: {
      type: "accessor",
      value: [0, 0]
    },
    getBoundingRect: {
      type: "accessor",
      value: [0, 0, 0, 0]
    },
    getFillColor: {
      type: "accessor",
      value: [0, 0, 0, 255]
    },
    getLineColor: {
      type: "accessor",
      value: [0, 0, 0, 255]
    },
    getLineWidth: {
      type: "accessor",
      value: 1
    }
  };
  var TextBackgroundLayer = class extends Layer {
    getShaders() {
      return super.getShaders({
        vs: text_background_layer_vertex_glsl_default,
        fs: text_background_layer_fragment_glsl_default,
        modules: [project32_default, picking_default]
      });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceSizes: {
          size: 1,
          transition: true,
          accessor: "getSize",
          defaultValue: 1
        },
        instanceAngles: {
          size: 1,
          transition: true,
          accessor: "getAngle"
        },
        instanceRects: {
          size: 4,
          accessor: "getBoundingRect"
        },
        instancePixelOffsets: {
          size: 2,
          transition: true,
          accessor: "getPixelOffset"
        },
        instanceFillColors: {
          size: 4,
          transition: true,
          normalized: true,
          type: esm_default2.UNSIGNED_BYTE,
          accessor: "getFillColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineColors: {
          size: 4,
          transition: true,
          normalized: true,
          type: esm_default2.UNSIGNED_BYTE,
          accessor: "getLineColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineWidths: {
          size: 1,
          transition: true,
          accessor: "getLineWidth",
          defaultValue: 1
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const {
        changeFlags
      } = params;
      if (changeFlags.extensionsChanged) {
        const {
          gl
        } = this.context;
        this.state.model?.delete();
        this.state.model = this._getModel(gl);
        this.getAttributeManager().invalidateAll();
      }
    }
    draw({
      uniforms
    }) {
      const {
        billboard,
        sizeScale,
        sizeUnits,
        sizeMinPixels,
        sizeMaxPixels,
        getLineWidth
      } = this.props;
      let {
        padding
      } = this.props;
      if (padding.length < 4) {
        padding = [padding[0], padding[1], padding[0], padding[1]];
      }
      this.state.model.setUniforms(uniforms).setUniforms({
        billboard,
        stroked: Boolean(getLineWidth),
        padding,
        sizeUnits: UNIT[sizeUnits],
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels
      }).draw();
    }
    _getModel(gl) {
      const positions = [0, 0, 1, 0, 1, 1, 0, 1];
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new Geometry({
          drawMode: esm_default2.TRIANGLE_FAN,
          vertexCount: 4,
          attributes: {
            positions: {
              size: 2,
              value: new Float32Array(positions)
            }
          }
        }),
        isInstanced: true
      });
    }
  };
  __publicField(TextBackgroundLayer, "defaultProps", defaultProps15);
  __publicField(TextBackgroundLayer, "layerName", "TextBackgroundLayer");

  // ../layers/src/text-layer/text-layer.ts
  var TEXT_ANCHOR = {
    start: 1,
    middle: 0,
    end: -1
  };
  var ALIGNMENT_BASELINE = {
    top: 1,
    center: 0,
    bottom: -1
  };
  var DEFAULT_COLOR9 = [0, 0, 0, 255];
  var DEFAULT_LINE_HEIGHT = 1;
  var defaultProps16 = {
    billboard: true,
    sizeScale: 1,
    sizeUnits: "pixels",
    sizeMinPixels: 0,
    sizeMaxPixels: Number.MAX_SAFE_INTEGER,
    background: false,
    getBackgroundColor: {
      type: "accessor",
      value: [255, 255, 255, 255]
    },
    getBorderColor: {
      type: "accessor",
      value: DEFAULT_COLOR9
    },
    getBorderWidth: {
      type: "accessor",
      value: 0
    },
    backgroundPadding: {
      type: "array",
      value: [0, 0, 0, 0]
    },
    characterSet: {
      type: "object",
      value: DEFAULT_FONT_SETTINGS.characterSet
    },
    fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,
    fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,
    lineHeight: DEFAULT_LINE_HEIGHT,
    outlineWidth: {
      type: "number",
      value: 0,
      min: 0
    },
    outlineColor: {
      type: "color",
      value: DEFAULT_COLOR9
    },
    fontSettings: {
      type: "object",
      value: {},
      compare: 1
    },
    wordBreak: "break-word",
    maxWidth: {
      type: "number",
      value: -1
    },
    getText: {
      type: "accessor",
      value: (x2) => x2.text
    },
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR9
    },
    getSize: {
      type: "accessor",
      value: 32
    },
    getAngle: {
      type: "accessor",
      value: 0
    },
    getTextAnchor: {
      type: "accessor",
      value: "middle"
    },
    getAlignmentBaseline: {
      type: "accessor",
      value: "center"
    },
    getPixelOffset: {
      type: "accessor",
      value: [0, 0]
    },
    backgroundColor: {
      deprecatedFor: ["background", "getBackgroundColor"]
    }
  };
  var TextLayer = class extends CompositeLayer {
    initializeState() {
      this.state = {
        styleVersion: 0,
        fontAtlasManager: new FontAtlasManager()
      };
      if (this.props.maxWidth > 0) {
        log_default.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")();
      }
    }
    updateState(params) {
      const {
        props,
        oldProps,
        changeFlags
      } = params;
      const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
      if (textChanged) {
        this._updateText();
      }
      const fontChanged = this._updateFontAtlas();
      const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
      if (styleChanged) {
        this.setState({
          styleVersion: this.state.styleVersion + 1
        });
      }
    }
    getPickingInfo({
      info
    }) {
      info.object = info.index >= 0 ? this.props.data[info.index] : null;
      return info;
    }
    _updateFontAtlas() {
      const {
        fontSettings,
        fontFamily,
        fontWeight
      } = this.props;
      const {
        fontAtlasManager,
        characterSet
      } = this.state;
      const fontProps = {
        ...fontSettings,
        characterSet,
        fontFamily,
        fontWeight
      };
      if (!fontAtlasManager.mapping) {
        fontAtlasManager.setProps(fontProps);
        return true;
      }
      for (const key in fontProps) {
        if (fontProps[key] !== fontAtlasManager.props[key]) {
          fontAtlasManager.setProps(fontProps);
          return true;
        }
      }
      return false;
    }
    _updateText() {
      const {
        data,
        characterSet
      } = this.props;
      const textBuffer = data.attributes?.getText;
      let {
        getText
      } = this.props;
      let startIndices = data.startIndices;
      let numInstances;
      const autoCharacterSet = characterSet === "auto" && /* @__PURE__ */ new Set();
      if (textBuffer && startIndices) {
        const {
          texts,
          characterCount
        } = getTextFromBuffer({
          ...ArrayBuffer.isView(textBuffer) ? {
            value: textBuffer
          } : textBuffer,
          length: data.length,
          startIndices,
          characterSet: autoCharacterSet
        });
        numInstances = characterCount;
        getText = (_, {
          index
        }) => texts[index];
      } else {
        const {
          iterable,
          objectInfo
        } = createIterable(data);
        startIndices = [0];
        numInstances = 0;
        for (const object of iterable) {
          objectInfo.index++;
          const text = Array.from(getText(object, objectInfo) || "");
          if (autoCharacterSet) {
            text.forEach(autoCharacterSet.add, autoCharacterSet);
          }
          numInstances += text.length;
          startIndices.push(numInstances);
        }
      }
      this.setState({
        getText,
        startIndices,
        numInstances,
        characterSet: autoCharacterSet || characterSet
      });
    }
    transformParagraph(object, objectInfo) {
      const {
        fontAtlasManager
      } = this.state;
      const iconMapping = fontAtlasManager.mapping;
      const getText = this.state.getText;
      const {
        wordBreak,
        lineHeight,
        maxWidth
      } = this.props;
      const paragraph = getText(object, objectInfo) || "";
      return transformParagraph(paragraph, lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);
    }
    getBoundingRect = (object, objectInfo) => {
      let {
        size: [width, height]
      } = this.transformParagraph(object, objectInfo);
      const {
        fontSize
      } = this.state.fontAtlasManager.props;
      width /= fontSize;
      height /= fontSize;
      const {
        getTextAnchor,
        getAlignmentBaseline
      } = this.props;
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
    };
    getIconOffsets = (object, objectInfo) => {
      const {
        getTextAnchor,
        getAlignmentBaseline
      } = this.props;
      const {
        x: x2,
        y: y2,
        rowWidth,
        size: [width, height]
      } = this.transformParagraph(object, objectInfo);
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      const numCharacters = x2.length;
      const offsets = new Array(numCharacters * 2);
      let index = 0;
      for (let i3 = 0; i3 < numCharacters; i3++) {
        const rowOffset = (1 - anchorX) * (width - rowWidth[i3]) / 2;
        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x2[i3];
        offsets[index++] = (anchorY - 1) * height / 2 + y2[i3];
      }
      return offsets;
    };
    renderLayers() {
      const {
        startIndices,
        numInstances,
        getText,
        fontAtlasManager: {
          scale: scale8,
          texture,
          mapping
        },
        styleVersion
      } = this.state;
      const {
        data,
        _dataDiff,
        getPosition: getPosition2,
        getColor: getColor3,
        getSize,
        getAngle,
        getPixelOffset,
        getBackgroundColor,
        getBorderColor,
        getBorderWidth,
        backgroundPadding,
        background,
        billboard,
        fontSettings,
        outlineWidth,
        outlineColor,
        sizeScale,
        sizeUnits,
        sizeMinPixels,
        sizeMaxPixels,
        transitions,
        updateTriggers
      } = this.props;
      const CharactersLayerClass = this.getSubLayerClass("characters", MultiIconLayer);
      const BackgroundLayerClass = this.getSubLayerClass("background", TextBackgroundLayer);
      return [background && new BackgroundLayerClass({
        getFillColor: getBackgroundColor,
        getLineColor: getBorderColor,
        getLineWidth: getBorderWidth,
        padding: backgroundPadding,
        getPosition: getPosition2,
        getSize,
        getAngle,
        getPixelOffset,
        billboard,
        sizeScale,
        sizeUnits,
        sizeMinPixels,
        sizeMaxPixels,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getSize: transitions.getSize,
          getFillColor: transitions.getBackgroundColor,
          getLineColor: transitions.getBorderColor,
          getLineWidth: transitions.getBorderWidth,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "background",
        updateTriggers: {
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getSize: updateTriggers.getSize,
          getFillColor: updateTriggers.getBackgroundColor,
          getLineColor: updateTriggers.getBorderColor,
          getLineWidth: updateTriggers.getBorderWidth,
          getPixelOffset: updateTriggers.getPixelOffset,
          getBoundingRect: {
            getText: updateTriggers.getText,
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data: data.attributes && data.attributes.background ? {
          length: data.length,
          attributes: data.attributes.background
        } : data,
        _dataDiff,
        autoHighlight: false,
        getBoundingRect: this.getBoundingRect
      }), new CharactersLayerClass({
        sdf: fontSettings.sdf,
        smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,
        outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),
        outlineColor,
        iconAtlas: texture,
        iconMapping: mapping,
        getPosition: getPosition2,
        getColor: getColor3,
        getSize,
        getAngle,
        getPixelOffset,
        billboard,
        sizeScale: sizeScale * scale8,
        sizeUnits,
        sizeMinPixels: sizeMinPixels * scale8,
        sizeMaxPixels: sizeMaxPixels * scale8,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getColor: transitions.getColor,
          getSize: transitions.getSize,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "characters",
        updateTriggers: {
          all: updateTriggers.getText,
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getColor: updateTriggers.getColor,
          getSize: updateTriggers.getSize,
          getPixelOffset: updateTriggers.getPixelOffset,
          getIconOffsets: {
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data,
        _dataDiff,
        startIndices,
        numInstances,
        getIconOffsets: this.getIconOffsets,
        getIcon: getText
      })];
    }
    static set fontAtlasCacheLimit(limit) {
      setFontAtlasCacheLimit(limit);
    }
  };
  __publicField(TextLayer, "defaultProps", defaultProps16);
  __publicField(TextLayer, "layerName", "TextLayer");

  // ../layers/src/geojson-layer/sub-layer-map.ts
  var POINT_LAYER = {
    circle: {
      type: ScatterplotLayer,
      props: {
        filled: "filled",
        stroked: "stroked",
        lineWidthMaxPixels: "lineWidthMaxPixels",
        lineWidthMinPixels: "lineWidthMinPixels",
        lineWidthScale: "lineWidthScale",
        lineWidthUnits: "lineWidthUnits",
        pointRadiusMaxPixels: "radiusMaxPixels",
        pointRadiusMinPixels: "radiusMinPixels",
        pointRadiusScale: "radiusScale",
        pointRadiusUnits: "radiusUnits",
        pointAntialiasing: "antialiasing",
        pointBillboard: "billboard",
        getFillColor: "getFillColor",
        getLineColor: "getLineColor",
        getLineWidth: "getLineWidth",
        getPointRadius: "getRadius"
      }
    },
    icon: {
      type: IconLayer,
      props: {
        iconAtlas: "iconAtlas",
        iconMapping: "iconMapping",
        iconSizeMaxPixels: "sizeMaxPixels",
        iconSizeMinPixels: "sizeMinPixels",
        iconSizeScale: "sizeScale",
        iconSizeUnits: "sizeUnits",
        iconAlphaCutoff: "alphaCutoff",
        iconBillboard: "billboard",
        getIcon: "getIcon",
        getIconAngle: "getAngle",
        getIconColor: "getColor",
        getIconPixelOffset: "getPixelOffset",
        getIconSize: "getSize"
      }
    },
    text: {
      type: TextLayer,
      props: {
        textSizeMaxPixels: "sizeMaxPixels",
        textSizeMinPixels: "sizeMinPixels",
        textSizeScale: "sizeScale",
        textSizeUnits: "sizeUnits",
        textBackground: "background",
        textBackgroundPadding: "backgroundPadding",
        textFontFamily: "fontFamily",
        textFontWeight: "fontWeight",
        textLineHeight: "lineHeight",
        textMaxWidth: "maxWidth",
        textOutlineColor: "outlineColor",
        textOutlineWidth: "outlineWidth",
        textWordBreak: "wordBreak",
        textCharacterSet: "characterSet",
        textBillboard: "billboard",
        textFontSettings: "fontSettings",
        getText: "getText",
        getTextAngle: "getAngle",
        getTextColor: "getColor",
        getTextPixelOffset: "getPixelOffset",
        getTextSize: "getSize",
        getTextAnchor: "getTextAnchor",
        getTextAlignmentBaseline: "getAlignmentBaseline",
        getTextBackgroundColor: "getBackgroundColor",
        getTextBorderColor: "getBorderColor",
        getTextBorderWidth: "getBorderWidth"
      }
    }
  };
  var LINE_LAYER = {
    type: PathLayer,
    props: {
      lineWidthUnits: "widthUnits",
      lineWidthScale: "widthScale",
      lineWidthMinPixels: "widthMinPixels",
      lineWidthMaxPixels: "widthMaxPixels",
      lineJointRounded: "jointRounded",
      lineCapRounded: "capRounded",
      lineMiterLimit: "miterLimit",
      lineBillboard: "billboard",
      getLineColor: "getColor",
      getLineWidth: "getWidth"
    }
  };
  var POLYGON_LAYER = {
    type: SolidPolygonLayer,
    props: {
      extruded: "extruded",
      filled: "filled",
      wireframe: "wireframe",
      elevationScale: "elevationScale",
      material: "material",
      _full3d: "_full3d",
      getElevation: "getElevation",
      getFillColor: "getFillColor",
      getLineColor: "getLineColor"
    }
  };
  function getDefaultProps({
    type,
    props
  }) {
    const result = {};
    for (const key in props) {
      result[key] = type.defaultProps[props[key]];
    }
    return result;
  }
  function forwardProps(layer, mapping) {
    const {
      transitions,
      updateTriggers
    } = layer.props;
    const result = {
      updateTriggers: {},
      transitions: transitions && {
        getPosition: transitions.geometry
      }
    };
    for (const sourceKey in mapping) {
      const targetKey = mapping[sourceKey];
      let value = layer.props[sourceKey];
      if (sourceKey.startsWith("get")) {
        value = layer.getSubLayerAccessor(value);
        result.updateTriggers[targetKey] = updateTriggers[sourceKey];
        if (transitions) {
          result.transitions[targetKey] = transitions[sourceKey];
        }
      }
      result[targetKey] = value;
    }
    return result;
  }

  // ../layers/src/geojson-layer/geojson.ts
  function getGeojsonFeatures(geojson) {
    if (Array.isArray(geojson)) {
      return geojson;
    }
    log_default.assert(geojson.type, "GeoJSON does not have type");
    switch (geojson.type) {
      case "Feature":
        return [geojson];
      case "FeatureCollection":
        log_default.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
        return geojson.features;
      default:
        return [{
          geometry: geojson
        }];
    }
  }
  function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
    const separated = {
      pointFeatures: [],
      lineFeatures: [],
      polygonFeatures: [],
      polygonOutlineFeatures: []
    };
    const {
      startRow = 0,
      endRow = features.length
    } = dataRange;
    for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
      const feature = features[featureIndex];
      const {
        geometry
      } = feature;
      if (!geometry) {
        continue;
      }
      if (geometry.type === "GeometryCollection") {
        log_default.assert(Array.isArray(geometry.geometries), "GeoJSON does not have geometries array");
        const {
          geometries
        } = geometry;
        for (let i3 = 0; i3 < geometries.length; i3++) {
          const subGeometry = geometries[i3];
          separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);
        }
      } else {
        separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);
      }
    }
    return separated;
  }
  function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
    const {
      type,
      coordinates
    } = geometry;
    const {
      pointFeatures,
      lineFeatures,
      polygonFeatures,
      polygonOutlineFeatures
    } = separated;
    if (!validateGeometry(type, coordinates)) {
      log_default.warn(`${type} coordinates are malformed`)();
      return;
    }
    switch (type) {
      case "Point":
        pointFeatures.push(wrapFeature({
          geometry
        }, sourceFeature, sourceFeatureIndex));
        break;
      case "MultiPoint":
        coordinates.forEach((point) => {
          pointFeatures.push(wrapFeature({
            geometry: {
              type: "Point",
              coordinates: point
            }
          }, sourceFeature, sourceFeatureIndex));
        });
        break;
      case "LineString":
        lineFeatures.push(wrapFeature({
          geometry
        }, sourceFeature, sourceFeatureIndex));
        break;
      case "MultiLineString":
        coordinates.forEach((path) => {
          lineFeatures.push(wrapFeature({
            geometry: {
              type: "LineString",
              coordinates: path
            }
          }, sourceFeature, sourceFeatureIndex));
        });
        break;
      case "Polygon":
        polygonFeatures.push(wrapFeature({
          geometry
        }, sourceFeature, sourceFeatureIndex));
        coordinates.forEach((path) => {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: {
              type: "LineString",
              coordinates: path
            }
          }, sourceFeature, sourceFeatureIndex));
        });
        break;
      case "MultiPolygon":
        coordinates.forEach((polygon) => {
          polygonFeatures.push(wrapFeature({
            geometry: {
              type: "Polygon",
              coordinates: polygon
            }
          }, sourceFeature, sourceFeatureIndex));
          polygon.forEach((path) => {
            polygonOutlineFeatures.push(wrapFeature({
              geometry: {
                type: "LineString",
                coordinates: path
              }
            }, sourceFeature, sourceFeatureIndex));
          });
        });
        break;
      default:
    }
  }
  var COORDINATE_NEST_LEVEL = {
    Point: 1,
    MultiPoint: 2,
    LineString: 2,
    MultiLineString: 3,
    Polygon: 3,
    MultiPolygon: 4
  };
  function validateGeometry(type, coordinates) {
    let nestLevel = COORDINATE_NEST_LEVEL[type];
    log_default.assert(nestLevel, `Unknown GeoJSON type ${type}`);
    while (coordinates && --nestLevel > 0) {
      coordinates = coordinates[0];
    }
    return coordinates && Number.isFinite(coordinates[0]);
  }

  // ../layers/src/geojson-layer/geojson-layer-props.ts
  function createEmptyLayerProps() {
    return {
      points: {},
      lines: {},
      polygons: {},
      polygonsOutline: {}
    };
  }
  function getCoordinates(f2) {
    return f2.geometry.coordinates;
  }
  function createLayerPropsFromFeatures(features, featuresDiff) {
    const layerProps = createEmptyLayerProps();
    const {
      pointFeatures,
      lineFeatures,
      polygonFeatures,
      polygonOutlineFeatures
    } = features;
    layerProps.points.data = pointFeatures;
    layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
    layerProps.points.getPosition = getCoordinates;
    layerProps.lines.data = lineFeatures;
    layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
    layerProps.lines.getPath = getCoordinates;
    layerProps.polygons.data = polygonFeatures;
    layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
    layerProps.polygons.getPolygon = getCoordinates;
    layerProps.polygonsOutline.data = polygonOutlineFeatures;
    layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
    layerProps.polygonsOutline.getPath = getCoordinates;
    return layerProps;
  }
  function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
    const layerProps = createEmptyLayerProps();
    const {
      points,
      lines,
      polygons
    } = geojsonBinary;
    const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);
    layerProps.points.data = {
      length: points.positions.value.length / points.positions.size,
      attributes: {
        ...points.attributes,
        getPosition: points.positions,
        instancePickingColors: {
          size: 3,
          value: customPickingColors.points
        }
      },
      properties: points.properties,
      numericProps: points.numericProps,
      featureIds: points.featureIds
    };
    layerProps.lines.data = {
      length: lines.pathIndices.value.length - 1,
      startIndices: lines.pathIndices.value,
      attributes: {
        ...lines.attributes,
        getPath: lines.positions,
        instancePickingColors: {
          size: 3,
          value: customPickingColors.lines
        }
      },
      properties: lines.properties,
      numericProps: lines.numericProps,
      featureIds: lines.featureIds
    };
    layerProps.lines._pathType = "open";
    layerProps.polygons.data = {
      length: polygons.polygonIndices.value.length - 1,
      startIndices: polygons.polygonIndices.value,
      attributes: {
        ...polygons.attributes,
        getPolygon: polygons.positions,
        pickingColors: {
          size: 3,
          value: customPickingColors.polygons
        }
      },
      properties: polygons.properties,
      numericProps: polygons.numericProps,
      featureIds: polygons.featureIds
    };
    layerProps.polygons._normalize = false;
    if (polygons.triangles) {
      layerProps.polygons.data.attributes.indices = polygons.triangles.value;
    }
    layerProps.polygonsOutline.data = {
      length: polygons.primitivePolygonIndices.value.length - 1,
      startIndices: polygons.primitivePolygonIndices.value,
      attributes: {
        ...polygons.attributes,
        getPath: polygons.positions,
        instancePickingColors: {
          size: 3,
          value: customPickingColors.polygons
        }
      },
      properties: polygons.properties,
      numericProps: polygons.numericProps,
      featureIds: polygons.featureIds
    };
    layerProps.polygonsOutline._pathType = "open";
    return layerProps;
  }

  // ../layers/src/geojson-layer/geojson-layer.ts
  var FEATURE_TYPES = ["points", "linestrings", "polygons"];
  var defaultProps17 = {
    ...getDefaultProps(POINT_LAYER.circle),
    ...getDefaultProps(POINT_LAYER.icon),
    ...getDefaultProps(POINT_LAYER.text),
    ...getDefaultProps(LINE_LAYER),
    ...getDefaultProps(POLYGON_LAYER),
    stroked: true,
    filled: true,
    extruded: false,
    wireframe: false,
    _full3d: false,
    iconAtlas: {
      type: "object",
      value: null
    },
    iconMapping: {
      type: "object",
      value: {}
    },
    getIcon: {
      type: "accessor",
      value: (f2) => f2.properties.icon
    },
    getText: {
      type: "accessor",
      value: (f2) => f2.properties.text
    },
    pointType: "circle",
    getRadius: {
      deprecatedFor: "getPointRadius"
    }
  };
  var GeoJsonLayer = class extends CompositeLayer {
    initializeState() {
      this.state = {
        layerProps: {},
        features: {}
      };
    }
    updateState({
      props,
      changeFlags
    }) {
      if (!changeFlags.dataChanged) {
        return;
      }
      const {
        data
      } = this.props;
      const binary = data && "points" in data && "polygons" in data && "lines" in data;
      this.setState({
        binary
      });
      if (binary) {
        this._updateStateBinary({
          props,
          changeFlags
        });
      } else {
        this._updateStateJSON({
          props,
          changeFlags
        });
      }
    }
    _updateStateBinary({
      props,
      changeFlags
    }) {
      const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);
      this.setState({
        layerProps
      });
    }
    _updateStateJSON({
      props,
      changeFlags
    }) {
      const features = getGeojsonFeatures(props.data);
      const wrapFeature = this.getSubLayerRow.bind(this);
      let newFeatures = {};
      const featuresDiff = {};
      if (Array.isArray(changeFlags.dataChanged)) {
        const oldFeatures = this.state.features;
        for (const key in oldFeatures) {
          newFeatures[key] = oldFeatures[key].slice();
          featuresDiff[key] = [];
        }
        for (const dataRange of changeFlags.dataChanged) {
          const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);
          for (const key in oldFeatures) {
            featuresDiff[key].push(replaceInRange({
              data: newFeatures[key],
              getIndex: (f2) => f2.__source.index,
              dataRange,
              replace: partialFeatures[key]
            }));
          }
        }
      } else {
        newFeatures = separateGeojsonFeatures(features, wrapFeature);
      }
      const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);
      this.setState({
        features: newFeatures,
        featuresDiff,
        layerProps
      });
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      const {
        index,
        sourceLayer
      } = info;
      info.featureType = FEATURE_TYPES.find((ft) => sourceLayer.id.startsWith(`${this.id}-${ft}-`));
      if (index >= 0 && sourceLayer.id.startsWith(`${this.id}-points-text`) && this.state.binary) {
        info.index = this.props.data.points.globalFeatureIds.value[index];
      }
      return info;
    }
    _updateAutoHighlight(info) {
      const pointLayerIdPrefix = `${this.id}-points-`;
      const sourceIsPoints = info.featureType === "points";
      for (const layer of this.getSubLayers()) {
        if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
          layer.updateAutoHighlight(info);
        }
      }
    }
    _renderPolygonLayer() {
      const {
        extruded,
        wireframe
      } = this.props;
      const {
        layerProps
      } = this.state;
      const id = "polygons-fill";
      const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);
      if (PolygonFillLayer) {
        const forwardedProps = forwardProps(this, POLYGON_LAYER.props);
        const useLineColor = extruded && wireframe;
        if (!useLineColor) {
          delete forwardedProps.getLineColor;
        }
        forwardedProps.updateTriggers.lineColors = useLineColor;
        return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({
          id,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.polygons);
      }
      return null;
    }
    _renderLineLayers() {
      const {
        extruded,
        stroked
      } = this.props;
      const {
        layerProps
      } = this.state;
      const polygonStrokeLayerId = "polygons-stroke";
      const lineStringsLayerId = "linestrings";
      const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);
      const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);
      if (PolygonStrokeLayer || LineStringsLayer) {
        const forwardedProps = forwardProps(this, LINE_LAYER.props);
        return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({
          id: polygonStrokeLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({
          id: lineStringsLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.lines)];
      }
      return null;
    }
    _renderPointLayers() {
      const {
        pointType
      } = this.props;
      const {
        layerProps,
        binary
      } = this.state;
      let {
        highlightedObjectIndex
      } = this.props;
      if (!binary && Number.isFinite(highlightedObjectIndex)) {
        highlightedObjectIndex = layerProps.points.data.findIndex((d) => d.__source.index === highlightedObjectIndex);
      }
      const types = new Set(pointType.split("+"));
      const pointLayers = [];
      for (const type of types) {
        const id = `points-${type}`;
        const PointLayerMapping = POINT_LAYER[type];
        const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points.data) && this.getSubLayerClass(id, PointLayerMapping.type);
        if (PointsLayer) {
          const forwardedProps = forwardProps(this, PointLayerMapping.props);
          let pointsLayerProps = layerProps.points;
          if (type === "text" && binary) {
            const {
              instancePickingColors,
              ...rest
            } = pointsLayerProps.data.attributes;
            pointsLayerProps = {
              ...pointsLayerProps,
              data: {
                ...pointsLayerProps.data,
                attributes: rest
              }
            };
          }
          pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({
            id,
            updateTriggers: forwardedProps.updateTriggers,
            highlightedObjectIndex
          }), pointsLayerProps));
        }
      }
      return pointLayers;
    }
    renderLayers() {
      const {
        extruded
      } = this.props;
      const polygonFillLayer = this._renderPolygonLayer();
      const lineLayers = this._renderLineLayers();
      const pointLayers = this._renderPointLayers();
      return [
        !extruded && polygonFillLayer,
        lineLayers,
        pointLayers,
        extruded && polygonFillLayer
      ];
    }
    getSubLayerAccessor(accessor) {
      const {
        binary
      } = this.state;
      if (!binary || typeof accessor !== "function") {
        return super.getSubLayerAccessor(accessor);
      }
      return (object, info) => {
        const {
          data,
          index
        } = info;
        const feature = binaryToFeatureForAccesor(data, index);
        return accessor(feature, info);
      };
    }
  };
  __publicField(GeoJsonLayer, "layerName", "GeoJsonLayer");
  __publicField(GeoJsonLayer, "defaultProps", defaultProps17);

  // ../../node_modules/@loaders.gl/xml/dist/esm/lib/parsers/parse-xml.js
  var import_fast_xml_parser = __toESM(require_fxp());
  function fastParseXML(text, options) {
    const parser = new import_fast_xml_parser.XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: "",
      ...options
    });
    const parsedXML = parser.parse(text);
    return parsedXML;
  }

  // ../../node_modules/@loaders.gl/xml/dist/esm/lib/xml-utils/uncapitalize.js
  function uncapitalize(str) {
    return typeof str === "string" ? str.charAt(0).toLowerCase() + str.slice(1) : str;
  }
  function uncapitalizeKeys(object) {
    if (Array.isArray(object)) {
      return object.map((element) => uncapitalizeKeys(element));
    }
    if (object && typeof object === "object") {
      const newObject = {};
      for (const [key, value] of Object.entries(object)) {
        newObject[uncapitalize(key)] = uncapitalizeKeys(value);
      }
      return newObject;
    }
    return object;
  }

  // ../../node_modules/@loaders.gl/xml/dist/esm/xml-loader.js
  var VERSION8 = true ? "3.4.2" : "latest";
  var XMLLoader = {
    name: "XML",
    id: "xml",
    module: "xml",
    version: VERSION8,
    worker: false,
    extensions: ["xml"],
    mimeTypes: ["application/xml", "text/xml"],
    testText: testXMLFile,
    options: {
      xml: {
        parser: "fast-xml-parser",
        uncapitalizeKeys: false,
        removeNSPrefix: false,
        textNodeName: "value",
        arrayPaths: []
      }
    },
    parse: async (arrayBuffer2, options) => parseTextSync(new TextDecoder().decode(arrayBuffer2), options),
    parseTextSync: (text, options) => parseTextSync(text, options)
  };
  function testXMLFile(text) {
    return text.startsWith("<?xml");
  }
  function parseTextSync(text, options) {
    var _options$xml;
    const xmlOptions = {
      ...XMLLoader.options.xml,
      ...options === null || options === void 0 ? void 0 : options.xml
    };
    switch (xmlOptions.parser) {
      case "fast-xml-parser":
        const fastXMLOptions = {
          allowBooleanAttributes: true,
          ignoreDeclaration: true,
          removeNSPrefix: xmlOptions.removeNSPrefix,
          textNodeName: xmlOptions.textNodeName,
          isArray: (name10, jpath, isLeafNode, isAttribute) => {
            var _xmlOptions$arrayPath;
            const array = Boolean(xmlOptions === null || xmlOptions === void 0 ? void 0 : (_xmlOptions$arrayPath = xmlOptions.arrayPaths) === null || _xmlOptions$arrayPath === void 0 ? void 0 : _xmlOptions$arrayPath.some((path) => jpath === path));
            return array;
          },
          ...options === null || options === void 0 ? void 0 : options._fastXML
        };
        const xml = fastParseXML(text, fastXMLOptions);
        return xmlOptions.uncapitalizeKeys ? uncapitalizeKeys(xml) : xml;
      default:
        throw new Error(options === null || options === void 0 ? void 0 : (_options$xml = options.xml) === null || _options$xml === void 0 ? void 0 : _options$xml.parser);
    }
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/parsers/wms/parse-wms-error.js
  function parseWMSError(text, options) {
    var _XMLLoader$parseTextS, _parsedXML$ServiceExc, _parsedXML$ogcServic;
    const parsedXML = (_XMLLoader$parseTextS = XMLLoader.parseTextSync) === null || _XMLLoader$parseTextS === void 0 ? void 0 : _XMLLoader$parseTextS.call(XMLLoader, text, options);
    const serviceExceptionXML = (parsedXML === null || parsedXML === void 0 ? void 0 : (_parsedXML$ServiceExc = parsedXML.ServiceExceptionReport) === null || _parsedXML$ServiceExc === void 0 ? void 0 : _parsedXML$ServiceExc.ServiceException) || (parsedXML === null || parsedXML === void 0 ? void 0 : (_parsedXML$ogcServic = parsedXML["ogc:ServiceExceptionReport"]) === null || _parsedXML$ogcServic === void 0 ? void 0 : _parsedXML$ogcServic["ogc:ServiceException"]);
    const message = typeof serviceExceptionXML === "string" ? serviceExceptionXML : serviceExceptionXML.value || serviceExceptionXML.code || "Unknown error";
    return message;
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/wms-error-loader.js
  var VERSION9 = true ? "3.4.2" : "latest";
  var WMSErrorLoader = {
    id: "wms-error",
    name: "WMS Error",
    module: "wms",
    version: VERSION9,
    worker: false,
    extensions: ["xml"],
    mimeTypes: ["application/vnd.ogc.se_xml", "application/xml", "text/xml"],
    testText: testXMLFile2,
    options: {
      wms: {
        throwOnError: false
      }
    },
    parse: async (arrayBuffer2, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer2), options),
    parseSync: (arrayBuffer2, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer2), options),
    parseTextSync: (text, options) => parseTextSync2(text, options)
  };
  function testXMLFile2(text) {
    return text.startsWith("<?xml");
  }
  function parseTextSync2(text, options) {
    const wmsOptions = {
      ...WMSErrorLoader.options.wms,
      ...options === null || options === void 0 ? void 0 : options.wms
    };
    const error2 = parseWMSError(text, wmsOptions);
    const message = wmsOptions.minimalErrors ? error2 : "WMS Service error: ".concat(error2);
    if (wmsOptions.throwOnError) {
      throw new Error(message);
    }
    return message;
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/parsers/xml/parse-xml-helpers.js
  function getXMLArray(xmlValue) {
    if (Array.isArray(xmlValue)) {
      return xmlValue;
    }
    if (xmlValue) {
      return [xmlValue];
    }
    return [];
  }
  function getXMLStringArray(xmlValue) {
    const xmlArray = getXMLArray(xmlValue);
    if (xmlArray.length > 0 && xmlArray.every((_) => typeof _ === "string")) {
      return xmlArray;
    }
    return [];
  }
  function getXMLFloat(xmlValue) {
    let defaultValue2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    switch (typeof xmlValue) {
      case "number":
        return xmlValue;
      case "string":
        return parseFloat(xmlValue);
      default:
        return void 0;
    }
  }
  function getXMLInteger(xmlValue) {
    let defaultValue2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    switch (typeof xmlValue) {
      case "number":
        return xmlValue;
      case "string":
        return parseInt(xmlValue, 10);
      default:
        return void 0;
    }
  }
  function getXMLBoolean(xmlValue) {
    switch (xmlValue) {
      case "true":
        return true;
      case "false":
        return false;
      case "1":
        return true;
      case "0":
        return false;
      default:
        return false;
    }
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/parsers/wms/parse-wms-capabilities.js
  function parseWMSCapabilities(xmlText, options) {
    const parsedXML = XMLLoader.parseTextSync(xmlText, options);
    const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
    const capabilities = extractCapabilities(xmlCapabilities);
    if (options !== null && options !== void 0 && options.inheritedLayerProps) {
      for (const layer of capabilities.layers) {
        addInheritedLayerProps(layer, null);
      }
    }
    if (options !== null && options !== void 0 && options.includeRawData || options !== null && options !== void 0 && options.raw) {
      capabilities.raw = xmlCapabilities;
    }
    if (options !== null && options !== void 0 && options.includeXMLText) {
      capabilities.xml = xmlText;
    }
    return capabilities;
  }
  function extractCapabilities(xml) {
    var _xml$Service, _xml$Service2, _xml$Service3, _xml$Service4, _xml$Service5, _xml$Service6, _xml$Service6$Keyword, _xml$Service7, _xml$Service8, _xml$Service9, _xml$Service10, _xml$Service11, _xml$Service12, _xml$Service13, _xml$Capability, _xml$Capability2;
    const capabilities = {
      version: String(xml.version || ""),
      name: String(((_xml$Service = xml.Service) === null || _xml$Service === void 0 ? void 0 : _xml$Service.Name) || "unnamed"),
      title: (_xml$Service2 = xml.Service) !== null && _xml$Service2 !== void 0 && _xml$Service2.Title ? String((_xml$Service3 = xml.Service) === null || _xml$Service3 === void 0 ? void 0 : _xml$Service3.Title) : void 0,
      abstract: (_xml$Service4 = xml.Service) !== null && _xml$Service4 !== void 0 && _xml$Service4.Abstract ? String((_xml$Service5 = xml.Service) === null || _xml$Service5 === void 0 ? void 0 : _xml$Service5.Abstract) : void 0,
      keywords: getXMLStringArray((_xml$Service6 = xml.Service) === null || _xml$Service6 === void 0 ? void 0 : (_xml$Service6$Keyword = _xml$Service6.KeywordList) === null || _xml$Service6$Keyword === void 0 ? void 0 : _xml$Service6$Keyword.Keyword),
      fees: (_xml$Service7 = xml.Service) !== null && _xml$Service7 !== void 0 && _xml$Service7.Fees ? JSON.stringify((_xml$Service8 = xml.Service) === null || _xml$Service8 === void 0 ? void 0 : _xml$Service8.Fees) : void 0,
      accessConstraints: (_xml$Service9 = xml.Service) !== null && _xml$Service9 !== void 0 && _xml$Service9.AccessConstraints ? JSON.stringify((_xml$Service10 = xml.Service) === null || _xml$Service10 === void 0 ? void 0 : _xml$Service10.AccessConstraints) : void 0,
      layerLimit: getXMLInteger((_xml$Service11 = xml.Service) === null || _xml$Service11 === void 0 ? void 0 : _xml$Service11.LayerLimit),
      maxWidth: getXMLInteger((_xml$Service12 = xml.Service) === null || _xml$Service12 === void 0 ? void 0 : _xml$Service12.maxWidth),
      maxHeight: getXMLInteger((_xml$Service13 = xml.Service) === null || _xml$Service13 === void 0 ? void 0 : _xml$Service13.maxHeight),
      layers: [],
      requests: extractRequests((_xml$Capability = xml.Capability) === null || _xml$Capability === void 0 ? void 0 : _xml$Capability.Request),
      exceptions: extractExceptions(xml.Exception)
    };
    const xmlLayers = getXMLArray((_xml$Capability2 = xml.Capability) === null || _xml$Capability2 === void 0 ? void 0 : _xml$Capability2.Layer);
    for (const xmlSubLayer of xmlLayers) {
      capabilities.layers.push(extractLayer(xmlSubLayer));
    }
    for (const [key, value] of Object.entries(capabilities)) {
      if (value === void 0) {
        delete capabilities[key];
      }
    }
    return capabilities;
  }
  function extractRequests(xmlRequests) {
    const requests = {};
    for (const [name10, xmlRequest] of Object.entries(xmlRequests || {})) {
      const mimeTypes = getXMLStringArray(xmlRequest === null || xmlRequest === void 0 ? void 0 : xmlRequest.Format);
      requests[name10] = {
        mimeTypes
      };
    }
    return requests;
  }
  function extractExceptions(xmlException) {
    const xmlExceptionFormats = getXMLArray(xmlException === null || xmlException === void 0 ? void 0 : xmlException.Format);
    if (xmlExceptionFormats.length > 0) {
      return {
        mimeTypes: getXMLStringArray(xmlException)
      };
    }
    return void 0;
  }
  function extractLayer(xmlLayer) {
    var _xmlLayer$KeywordList;
    const layer = {
      title: String((xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Title) || ""),
      name: (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name) && String(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name),
      abstract: (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name) && String(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Abstract),
      keywords: getXMLStringArray((_xmlLayer$KeywordList = xmlLayer.KeywordList) === null || _xmlLayer$KeywordList === void 0 ? void 0 : _xmlLayer$KeywordList.Keyword)
    };
    const crs = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.CRS) || (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.SRS);
    if (crs && Array.isArray(crs) && crs.every((_) => typeof _ === "string")) {
      layer.crs = crs;
    }
    let geographicBoundingBox = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.EX_GeographicBoundingBox) && extractEXBoundingBox(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.EX_GeographicBoundingBox);
    if (geographicBoundingBox) {
      layer.geographicBoundingBox = geographicBoundingBox;
    }
    geographicBoundingBox = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.LatLonBoundingBox) && extractLatLonBoundingBox(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.LatLonBoundingBox);
    if (geographicBoundingBox) {
      layer.geographicBoundingBox = geographicBoundingBox;
    }
    const boundingBoxes = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.BoundingBox) && extractWMSBoundingBoxes(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.BoundingBox);
    if (boundingBoxes && boundingBoxes.length > 0) {
      layer.boundingBoxes = boundingBoxes;
    }
    const xmlDimensions = getXMLArray(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Dimension);
    const dimensions = xmlDimensions.map((xml) => extractDimension(xml));
    if (dimensions.length) {
      layer.dimensions = dimensions;
    }
    if (xmlLayer !== null && xmlLayer !== void 0 && xmlLayer.opaque) {
      layer.opaque = getXMLBoolean(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.opaque);
    }
    if (xmlLayer !== null && xmlLayer !== void 0 && xmlLayer.cascaded) {
      layer.cascaded = getXMLBoolean(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.cascaded);
    }
    if (xmlLayer !== null && xmlLayer !== void 0 && xmlLayer.queryable) {
      layer.queryable = getXMLBoolean(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.queryable);
    }
    const xmlLayers = getXMLArray(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Layer);
    const layers = [];
    for (const xmlSubLayer of xmlLayers) {
      layers.push(extractLayer(xmlSubLayer));
    }
    if (layers.length > 0) {
      layer.layers = layers;
    }
    for (const [key, value] of Object.entries(layer)) {
      if (value === void 0) {
        delete layer[key];
      }
    }
    return layer;
  }
  function extractEXBoundingBox(xmlBoundingBox) {
    const {
      westBoundLongitude: w,
      northBoundLatitude: n2,
      eastBoundLongitude: e2,
      southBoundLatitude: s2
    } = xmlBoundingBox;
    return [[w, s2], [e2, n2]];
  }
  function extractLatLonBoundingBox(xmlBoundingBox) {
    const {
      minx,
      miny,
      maxx,
      maxy
    } = xmlBoundingBox;
    return [[minx, miny], [maxx, maxy]];
  }
  function extractWMSBoundingBoxes(xmlBoundingBoxes) {
    const xmlBoxes = getXMLArray(xmlBoundingBoxes);
    return xmlBoxes.map((xmlBox) => extractWMSBoundingBox(xmlBox));
  }
  function extractWMSBoundingBox(xmlBoundingBox) {
    const {
      CRS,
      SRS,
      minx,
      miny,
      maxx,
      maxy,
      resx,
      resy
    } = xmlBoundingBox;
    const boundingBox = {
      crs: CRS || SRS,
      boundingBox: [[getXMLFloat(minx), getXMLFloat(miny)], [getXMLFloat(maxx), getXMLFloat(maxy)]]
    };
    if (resx) {
      boundingBox.xResolution = resx;
    }
    if (resy) {
      boundingBox.yResolution = resy;
    }
    return boundingBox;
  }
  function extractDimension(xmlDimension) {
    const {
      name: name10,
      units,
      value: extent
    } = xmlDimension;
    const dimension = {
      name: name10,
      units,
      extent
    };
    if (xmlDimension.unitSymbol) {
      dimension.unitSymbol = xmlDimension.unitSymbol;
    }
    if (xmlDimension.default) {
      dimension.defaultValue = xmlDimension.default;
    }
    if (xmlDimension.multipleValues) {
      dimension.multipleValues = getXMLBoolean(xmlDimension.multipleValues);
    }
    if (xmlDimension.nearestValue) {
      dimension.nearestValue = getXMLBoolean(xmlDimension.nearestValue);
    }
    if (xmlDimension.current) {
      dimension.current = getXMLBoolean(xmlDimension.current);
    }
    return dimension;
  }
  function addInheritedLayerProps(layer, parent) {
    if (parent !== null && parent !== void 0 && parent.geographicBoundingBox && !layer.geographicBoundingBox) {
      layer.geographicBoundingBox = [...parent.geographicBoundingBox];
    }
    if (parent !== null && parent !== void 0 && parent.crs && !layer.crs) {
      layer.crs = [...parent.crs];
    }
    if (parent !== null && parent !== void 0 && parent.boundingBoxes && !layer.boundingBoxes) {
      layer.boundingBoxes = [...parent.boundingBoxes];
    }
    if (parent !== null && parent !== void 0 && parent.dimensions && !layer.dimensions) {
      layer.dimensions = [...parent.dimensions];
    }
    for (const subLayer of layer.layers || []) {
      addInheritedLayerProps(subLayer, layer);
    }
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/wms-capabilities-loader.js
  var VERSION10 = true ? "3.4.2" : "latest";
  var WMSCapabilitiesLoader = {
    id: "wms-capabilities",
    name: "WMS Capabilities",
    module: "wms",
    version: VERSION10,
    worker: false,
    extensions: ["xml"],
    mimeTypes: ["application/vnd.ogc.wms_xml", "application/xml", "text/xml"],
    testText: testXMLFile3,
    options: {
      wms: {}
    },
    parse: async (arrayBuffer2, options) => parseWMSCapabilities(new TextDecoder().decode(arrayBuffer2), options === null || options === void 0 ? void 0 : options.wms),
    parseTextSync: (text, options) => parseWMSCapabilities(text, options === null || options === void 0 ? void 0 : options.wms)
  };
  function testXMLFile3(text) {
    return text.startsWith("<?xml");
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/parsers/wms/parse-wms-features.js
  function parseWMSFeatureInfo(text, options) {
    var _parsedXML$FeatureInf;
    const parsedXML = XMLLoader.parseTextSync(text, options);
    const xmlFeatureInfo = ((_parsedXML$FeatureInf = parsedXML.FeatureInfoResponse) === null || _parsedXML$FeatureInf === void 0 ? void 0 : _parsedXML$FeatureInf.FIELDS) || [];
    const xmlFeatures = Array.isArray(xmlFeatureInfo) ? xmlFeatureInfo : [xmlFeatureInfo];
    return {
      features: xmlFeatures.map((xmlFeature) => extractFeature(xmlFeature))
    };
  }
  function extractFeature(xmlFeature) {
    const xmlFields = xmlFeature || {};
    return {
      attributes: xmlFields,
      type: "",
      bounds: {
        bottom: 0,
        top: 0,
        left: 0,
        right: 0
      }
    };
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/wip/wms-feature-info-loader.js
  var WMSFeatureInfoLoader = {
    ...WMSCapabilitiesLoader,
    id: "wms-feature-info",
    name: "WMS FeatureInfo",
    parse: async (arrayBuffer2, options) => parseWMSFeatureInfo(new TextDecoder().decode(arrayBuffer2), options),
    parseTextSync: (text, options) => parseWMSFeatureInfo(text, options)
  };

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/parsers/wms/parse-wms-layer-description.js
  function parseWMSLayerDescription(text, options) {
    var _XMLLoader$parseTextS;
    const parsedXML = (_XMLLoader$parseTextS = XMLLoader.parseTextSync) === null || _XMLLoader$parseTextS === void 0 ? void 0 : _XMLLoader$parseTextS.call(XMLLoader, text, options);
    return parsedXML;
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/wip/wms-layer-description-loader.js
  var WMSLayerDescriptionLoader = {
    ...WMSCapabilitiesLoader,
    id: "wms-layer-description",
    name: "WMS DescribeLayer",
    parse: async (arrayBuffer2, options) => parseWMSLayerDescription(new TextDecoder().decode(arrayBuffer2), options),
    parseTextSync: (text, options) => parseWMSLayerDescription(text, options)
  };

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/sources/data-source.js
  var DataSource = class {
    constructor(props) {
      _defineProperty(this, "fetch", void 0);
      _defineProperty(this, "loadOptions", void 0);
      _defineProperty(this, "_needsRefresh", true);
      _defineProperty(this, "props", void 0);
      this.props = {
        ...props
      };
      this.loadOptions = {
        ...props.loadOptions
      };
      this.fetch = getFetchFunction2(this.loadOptions);
    }
    setProps(props) {
      this.props = Object.assign(this.props, props);
      this.setNeedsRefresh();
    }
    setNeedsRefresh() {
      this._needsRefresh = true;
    }
    getNeedsRefresh() {
      let clear2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      const needsRefresh = this._needsRefresh;
      if (clear2) {
        this._needsRefresh = false;
      }
      return needsRefresh;
    }
  };
  function getFetchFunction2(options) {
    const fetchFunction = options === null || options === void 0 ? void 0 : options.fetch;
    if (fetchFunction && typeof fetchFunction === "function") {
      return (url, fetchOptions2) => fetchFunction(url, fetchOptions2);
    }
    const fetchOptions = options === null || options === void 0 ? void 0 : options.fetch;
    if (fetchOptions && typeof fetchOptions !== "function") {
      return (url) => fetch(url, fetchOptions);
    }
    return (url) => fetch(url);
  }

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/sources/image-source.js
  var ImageSource = class extends DataSource {
  };

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/services/generic/image-service.js
  var ImageService = class extends ImageSource {
    constructor(props) {
      super(props);
    }
    async getMetadata() {
      throw new Error("ImageSource.getMetadata not implemented");
    }
    async getImage(parameters2) {
      const granularParameters = this.getGranularParameters(parameters2);
      const url = this.getURLFromTemplate(granularParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      return await ImageLoader.parse(arrayBuffer2);
    }
    getGranularParameters(parameters2) {
      const [east, north, west, south] = parameters2.bbox;
      return {
        ...parameters2,
        east,
        north,
        south,
        west
      };
    }
    getURLFromTemplate(parameters2) {
      let url = this.props.url;
      for (const [key, value] of Object.entries(parameters2)) {
        url = url.replace("${".concat(key, "}"), String(value));
        url = url.replace("{".concat(key, "}"), String(value));
      }
      return url;
    }
  };
  _defineProperty(ImageService, "type", "template");
  _defineProperty(ImageService, "testURL", (url) => url.toLowerCase().includes("{"));

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/services/ogc/wms-service.js
  var WMSService = class extends ImageSource {
    constructor(props) {
      var _props$substituteCRS;
      super(props);
      _defineProperty(this, "url", void 0);
      _defineProperty(this, "substituteCRS84", void 0);
      _defineProperty(this, "flipCRS", void 0);
      _defineProperty(this, "wmsParameters", void 0);
      _defineProperty(this, "vendorParameters", void 0);
      _defineProperty(this, "capabilities", null);
      _defineProperty(this, "loaders", [ImageLoader, WMSErrorLoader, WMSCapabilitiesLoader, WMSFeatureInfoLoader, WMSLayerDescriptionLoader]);
      this.url = props.url;
      this.substituteCRS84 = (_props$substituteCRS = props.substituteCRS84) !== null && _props$substituteCRS !== void 0 ? _props$substituteCRS : false;
      this.flipCRS = ["EPSG:4326"];
      this.wmsParameters = {
        layers: void 0,
        query_layers: void 0,
        styles: void 0,
        version: "1.3.0",
        crs: "EPSG:4326",
        format: "image/png",
        info_format: "text/plain",
        transparent: void 0,
        time: void 0,
        elevation: void 0,
        ...props.wmsParameters
      };
      this.vendorParameters = props.vendorParameters || {};
    }
    async getMetadata() {
      const capabilities = await this.getCapabilities();
      return this.normalizeMetadata(capabilities);
    }
    async getImage(parameters2) {
      return await this.getMap(parameters2);
    }
    normalizeMetadata(capabilities) {
      return capabilities;
    }
    async getCapabilities(wmsParameters, vendorParameters) {
      const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      const capabilities = await WMSCapabilitiesLoader.parse(arrayBuffer2, this.loadOptions);
      this.capabilities = capabilities;
      return capabilities;
    }
    async getMap(wmsParameters, vendorParameters) {
      const url = this.getMapURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      try {
        return await ImageLoader.parse(arrayBuffer2, this.loadOptions);
      } catch {
        throw this._parseError(arrayBuffer2);
      }
    }
    async getFeatureInfo(wmsParameters, vendorParameters) {
      const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      return await WMSFeatureInfoLoader.parse(arrayBuffer2, this.loadOptions);
    }
    async getFeatureInfoText(wmsParameters, vendorParameters) {
      const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      return new TextDecoder().decode(arrayBuffer2);
    }
    async describeLayer(wmsParameters, vendorParameters) {
      const url = this.describeLayerURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      return await WMSLayerDescriptionLoader.parse(arrayBuffer2, this.loadOptions);
    }
    async getLegendGraphic(wmsParameters, vendorParameters) {
      const url = this.getLegendGraphicURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      try {
        return await ImageLoader.parse(arrayBuffer2, this.loadOptions);
      } catch {
        throw this._parseError(arrayBuffer2);
      }
    }
    getCapabilitiesURL(wmsParameters, vendorParameters) {
      const options = {
        version: this.wmsParameters.version,
        ...wmsParameters
      };
      return this._getWMSUrl("GetCapabilities", options, vendorParameters);
    }
    getMapURL(wmsParameters, vendorParameters) {
      wmsParameters = this._getWMS130Parameters(wmsParameters);
      const options = {
        version: this.wmsParameters.version,
        format: this.wmsParameters.format,
        transparent: this.wmsParameters.transparent,
        time: this.wmsParameters.time,
        elevation: this.wmsParameters.elevation,
        layers: this.wmsParameters.layers,
        styles: this.wmsParameters.styles,
        crs: this.wmsParameters.crs,
        ...wmsParameters
      };
      return this._getWMSUrl("GetMap", options, vendorParameters);
    }
    getFeatureInfoURL(wmsParameters, vendorParameters) {
      const options = {
        version: this.wmsParameters.version,
        info_format: this.wmsParameters.info_format,
        layers: this.wmsParameters.layers,
        query_layers: this.wmsParameters.query_layers,
        styles: this.wmsParameters.styles,
        crs: this.wmsParameters.crs,
        ...wmsParameters
      };
      return this._getWMSUrl("GetFeatureInfo", options, vendorParameters);
    }
    describeLayerURL(wmsParameters, vendorParameters) {
      const options = {
        version: this.wmsParameters.version,
        ...wmsParameters
      };
      return this._getWMSUrl("DescribeLayer", options, vendorParameters);
    }
    getLegendGraphicURL(wmsParameters, vendorParameters) {
      const options = {
        version: this.wmsParameters.version,
        ...wmsParameters
      };
      return this._getWMSUrl("GetLegendGraphic", options, vendorParameters);
    }
    _parseWMSUrl(url) {
      const [baseUrl, search] = url.split("?");
      const searchParams = search.split("&");
      const parameters2 = {};
      for (const parameter of searchParams) {
        const [key, value] = parameter.split("=");
        parameters2[key] = value;
      }
      return {
        url: baseUrl,
        parameters: parameters2
      };
    }
    _getWMSUrl(request, wmsParameters, vendorParameters) {
      let url = this.url;
      let first = true;
      const allParameters = {
        service: "WMS",
        version: wmsParameters.version,
        request,
        ...wmsParameters,
        ...this.vendorParameters,
        ...vendorParameters
      };
      const IGNORE_EMPTY_KEYS = ["transparent", "time", "elevation"];
      for (const [key, value] of Object.entries(allParameters)) {
        if (!IGNORE_EMPTY_KEYS.includes(key) || value) {
          url += first ? "?" : "&";
          first = false;
          url += this._getURLParameter(key, value, wmsParameters);
        }
      }
      return encodeURI(url);
    }
    _getWMS130Parameters(wmsParameters) {
      const newParameters = {
        ...wmsParameters
      };
      if (newParameters.srs) {
        newParameters.crs = newParameters.crs || newParameters.srs;
        delete newParameters.srs;
      }
      return newParameters;
    }
    _getURLParameter(key, value, wmsParameters) {
      switch (key) {
        case "crs":
          if (wmsParameters.version !== "1.3.0") {
            key = "srs";
          } else if (this.substituteCRS84 && value === "EPSG:4326") {
            value = "CRS:84";
          }
          break;
        case "srs":
          if (wmsParameters.version === "1.3.0") {
            key = "crs";
          }
          break;
        case "bbox":
          const bbox = this._flipBoundingBox(value, wmsParameters);
          if (bbox) {
            value = bbox;
          }
          break;
        default:
      }
      key = key.toUpperCase();
      return Array.isArray(value) ? "".concat(key, "=").concat(value.join(",")) : "".concat(key, "=").concat(value ? String(value) : "");
    }
    _flipBoundingBox(bboxValue, wmsParameters) {
      if (!Array.isArray(bboxValue) || bboxValue.length !== 4) {
        return null;
      }
      const flipCoordinates = wmsParameters.version === "1.3.0" && this.flipCRS.includes(wmsParameters.crs || "") && !(this.substituteCRS84 && wmsParameters.crs === "EPSG:4326");
      const bbox = bboxValue;
      return flipCoordinates ? [bbox[1], bbox[0], bbox[3], bbox[2]] : bbox;
    }
    async _fetchArrayBuffer(url) {
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      return arrayBuffer2;
    }
    _checkResponse(response, arrayBuffer2) {
      const contentType = response.headers["content-type"];
      if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
        const loadOptions = mergeLoaderOptions(this.loadOptions, {
          wms: {
            throwOnError: true
          }
        });
        const error2 = WMSErrorLoader.parseSync(arrayBuffer2, loadOptions);
        throw new Error(error2);
      }
    }
    _parseError(arrayBuffer2) {
      const error2 = WMSErrorLoader.parseSync(arrayBuffer2, this.loadOptions);
      return new Error(error2);
    }
  };
  _defineProperty(WMSService, "type", "wms");
  _defineProperty(WMSService, "testURL", (url) => url.toLowerCase().includes("wms"));

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/services/arcgis/arcgis-image-service.js
  var ArcGISImageServer = class extends ImageSource {
    constructor(props) {
      super(props);
    }
    async getMetadata() {
      return await this.metadata();
    }
    async getImage(parameters2) {
      throw new Error("not implemented");
    }
    async metadata() {
      throw new Error("not implemented");
    }
    exportImage(options) {
      throw new Error("not implemented");
    }
    metadataURL(options) {
      return "".concat(this.props.url, "?f=pjson");
    }
    exportImageURL(options) {
      const bbox = "bbox=".concat(options.bbox[0], ",").concat(options.bbox[1], ",").concat(options.bbox[2], ",").concat(options.bbox[3]);
      const size = "size=".concat(options.width, ",").concat(options.height);
      const arcgisOptions = {
        ...options,
        bbox,
        size
      };
      delete arcgisOptions.width;
      delete arcgisOptions.height;
      return this.getUrl("exportImage", arcgisOptions);
    }
    getUrl(path, options, extra) {
      let url = "".concat(this.props.url, "/").concat(path);
      let first = true;
      for (const [key, value] of Object.entries(options)) {
        url += first ? "?" : "&";
        first = false;
        if (Array.isArray(value)) {
          url += "".concat(key.toUpperCase(), "=").concat(value.join(","));
        } else {
          url += "".concat(key.toUpperCase(), "=").concat(value ? String(value) : "");
        }
      }
      return url;
    }
    async checkResponse(response) {
      if (!response.ok) {
        throw new Error("error");
      }
    }
  };
  _defineProperty(ArcGISImageServer, "type", "arcgis-image-server");
  _defineProperty(ArcGISImageServer, "testURL", (url) => url.toLowerCase().includes("ImageServer"));

  // ../../node_modules/@loaders.gl/wms/dist/esm/lib/create-image-source.js
  var SERVICES = [WMSService, ArcGISImageServer, ImageService];
  function createImageSource(props) {
    const {
      type = "auto"
    } = props;
    const serviceType = type === "auto" ? guessServiceType(props.url) : type;
    switch (serviceType) {
      case "template":
        return new ImageService(props);
      case "wms":
        return new WMSService(props);
      default:
        throw new Error("Not a valid image source type");
    }
  }
  function guessServiceType(url) {
    for (const Service of SERVICES) {
      if (Service.testURL && Service.testURL(url)) {
        return Service.type;
      }
    }
    return "wms";
  }

  // ../geo-layers/src/wms-layer/utils.ts
  var HALF_EARTH_CIRCUMFERENCE = 6378137 * Math.PI;
  function WGS84ToPseudoMercator(coord) {
    const mercator = lngLatToWorld(coord);
    mercator[0] = (mercator[0] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
    mercator[1] = (mercator[1] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
    return mercator;
  }

  // ../geo-layers/src/wms-layer/wms-layer.ts
  var defaultProps18 = {
    id: "imagery-layer",
    data: "",
    serviceType: "auto",
    srs: "auto",
    layers: {
      type: "array",
      compare: true,
      value: []
    },
    onMetadataLoad: {
      type: "function",
      value: () => {
      }
    },
    onMetadataLoadError: {
      type: "function",
      value: console.error
    },
    onImageLoadStart: {
      type: "function",
      value: () => {
      }
    },
    onImageLoad: {
      type: "function",
      value: () => {
      }
    },
    onImageLoadError: {
      type: "function",
      compare: false,
      value: (requestId, error2) => console.error(error2, requestId)
    }
  };
  var WMSLayer = class extends CompositeLayer {
    get isLoaded() {
      return Boolean(this.state) && this.state.loadCounter === 0 && super.isLoaded;
    }
    shouldUpdateState() {
      return true;
    }
    initializeState() {
      this.state._nextRequestId = 0;
      this.state.lastRequestId = -1;
      this.state.loadCounter = 0;
    }
    updateState({
      changeFlags,
      props,
      oldProps
    }) {
      const {
        viewport
      } = this.context;
      if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {
        this.state.imageSource = this._createImageSource(props);
        this._loadMetadata();
        this.debounce(() => this.loadImage(viewport, "image source changed"), 0);
      } else if (!deepEqual(props.layers, oldProps.layers, 1)) {
        this.debounce(() => this.loadImage(viewport, "layers changed"), 0);
      } else if (changeFlags.viewportChanged) {
        this.debounce(() => this.loadImage(viewport, "viewport changed"));
      }
    }
    finalizeState() {
    }
    renderLayers() {
      const {
        bounds,
        image,
        lastRequestParameters
      } = this.state;
      return image && new BitmapLayer({
        ...this.getSubLayerProps({
          id: "bitmap"
        }),
        _imageCoordinateSystem: lastRequestParameters.srs === "EPSG:4326" ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
        bounds,
        image
      });
    }
    async getFeatureInfoText(x2, y2) {
      const {
        lastRequestParameters
      } = this.state;
      if (lastRequestParameters) {
        const featureInfo = await this.state.imageSource.getFeatureInfoText?.({
          ...lastRequestParameters,
          query_layers: lastRequestParameters.layers,
          x: x2,
          y: y2,
          info_format: "application/vnd.ogc.gml"
        });
        return featureInfo;
      }
      return "";
    }
    _createImageSource(props) {
      if (props.data instanceof ImageSource) {
        return props.data;
      }
      if (typeof props.data === "string") {
        return createImageSource({
          url: props.data,
          loadOptions: props.loadOptions,
          type: props.serviceType
        });
      }
      throw new Error("invalid image source in props.data");
    }
    async _loadMetadata() {
      const {
        imageSource
      } = this.state;
      try {
        this.state.loadCounter++;
        const metadata = await imageSource.getMetadata();
        if (this.state.imageSource === imageSource) {
          this.getCurrentLayer()?.props.onMetadataLoad(metadata);
        }
      } catch (error2) {
        this.getCurrentLayer()?.props.onMetadataLoadError(error2);
      } finally {
        this.state.loadCounter--;
      }
    }
    async loadImage(viewport, reason) {
      const {
        layers,
        serviceType
      } = this.props;
      if (serviceType === "wms" && layers.length === 0) {
        return;
      }
      const bounds = viewport.getBounds();
      const {
        width,
        height
      } = viewport;
      const requestId = this.getRequestId();
      let {
        srs
      } = this.props;
      if (srs === "auto") {
        srs = viewport.resolution ? "EPSG:4326" : "EPSG:3857";
      }
      const requestParams = {
        width,
        height,
        bbox: bounds,
        layers,
        srs
      };
      if (srs === "EPSG:3857") {
        const [minX, minY] = WGS84ToPseudoMercator([bounds[0], bounds[1]]);
        const [maxX, maxY] = WGS84ToPseudoMercator([bounds[2], bounds[3]]);
        requestParams.bbox = [minX, minY, maxX, maxY];
      }
      try {
        this.state.loadCounter++;
        this.props.onImageLoadStart(requestId);
        const image = await this.state.imageSource.getImage(requestParams);
        if (this.state.lastRequestId < requestId) {
          this.getCurrentLayer()?.props.onImageLoad(requestId);
          this.setState({
            image,
            bounds,
            lastRequestParameters: requestParams,
            lastRequestId: requestId
          });
        }
      } catch (error2) {
        this.raiseError(error2, "Load image");
        this.getCurrentLayer()?.props.onImageLoadError(requestId, error2);
      } finally {
        this.state.loadCounter--;
      }
    }
    getRequestId() {
      return this.state._nextRequestId++;
    }
    debounce(fn, ms = 500) {
      clearTimeout(this.state._timeoutId);
      this.state._timeoutId = setTimeout(() => fn(), ms);
    }
  };
  __publicField(WMSLayer, "layerName", "WMSLayer");
  __publicField(WMSLayer, "defaultProps", defaultProps18);

  // ../geo-layers/src/great-circle-layer/great-circle-layer.ts
  var defaultProps19 = {
    getHeight: {
      type: "accessor",
      value: 0
    },
    greatCircle: true
  };
  var GreatCircleLayer = class extends ArcLayer {
  };
  __publicField(GreatCircleLayer, "layerName", "GreatCircleLayer");
  __publicField(GreatCircleLayer, "defaultProps", defaultProps19);

  // ../geo-layers/src/geo-cell-layer/GeoCellLayer.ts
  var defaultProps20 = {
    ...PolygonLayer.defaultProps
  };
  var GeoCellLayer = class extends CompositeLayer {
    indexToBounds() {
      return null;
    }
    renderLayers() {
      const {
        elevationScale,
        extruded,
        wireframe,
        filled,
        stroked,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        lineJointRounded,
        lineMiterLimit,
        lineDashJustified,
        getElevation,
        getFillColor,
        getLineColor,
        getLineWidth
      } = this.props;
      const {
        updateTriggers,
        material,
        transitions
      } = this.props;
      const CellLayer = this.getSubLayerClass("cell", PolygonLayer);
      return new CellLayer({
        filled,
        wireframe,
        extruded,
        elevationScale,
        stroked,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        lineJointRounded,
        lineMiterLimit,
        lineDashJustified,
        material,
        transitions,
        getElevation,
        getFillColor,
        getLineColor,
        getLineWidth
      }, this.getSubLayerProps({
        id: "cell",
        updateTriggers: updateTriggers && {
          getElevation: updateTriggers.getElevation,
          getFillColor: updateTriggers.getFillColor,
          getLineColor: updateTriggers.getLineColor,
          getLineWidth: updateTriggers.getLineWidth
        }
      }), this.indexToBounds());
    }
  };
  __publicField(GeoCellLayer, "layerName", "GeoCellLayer");
  __publicField(GeoCellLayer, "defaultProps", defaultProps20);

  // ../geo-layers/src/s2-layer/s2-geometry.ts
  var import_long = __toESM(require_long());
  var FACE_BITS = 3;
  var MAX_LEVEL = 30;
  var POS_BITS = 2 * MAX_LEVEL + 1;
  var RADIAN_TO_DEGREE = 180 / Math.PI;
  function IJToST(ij, order, offsets) {
    const maxSize = 1 << order;
    return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
  }
  function singleSTtoUV(st) {
    if (st >= 0.5) {
      return 1 / 3 * (4 * st * st - 1);
    }
    return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
  }
  function STToUV(st) {
    return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
  }
  function FaceUVToXYZ(face, [u, v]) {
    switch (face) {
      case 0:
        return [1, u, v];
      case 1:
        return [-u, 1, v];
      case 2:
        return [-u, -v, 1];
      case 3:
        return [-1, -v, -u];
      case 4:
        return [v, -1, -u];
      case 5:
        return [v, u, -1];
      default:
        throw new Error("Invalid face");
    }
  }
  function XYZToLngLat([x2, y2, z]) {
    const lat = Math.atan2(z, Math.sqrt(x2 * x2 + y2 * y2));
    const lng = Math.atan2(y2, x2);
    return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];
  }
  function toHilbertQuadkey(idS) {
    let bin = import_long.default.fromString(idS, true, 10).toString(2);
    while (bin.length < FACE_BITS + POS_BITS) {
      bin = "0" + bin;
    }
    const lsbIndex = bin.lastIndexOf("1");
    const faceB = bin.substring(0, 3);
    const posB = bin.substring(3, lsbIndex);
    const levelN = posB.length / 2;
    const faceS = import_long.default.fromString(faceB, true, 2).toString(10);
    let posS = import_long.default.fromString(posB, true, 2).toString(4);
    while (posS.length < levelN) {
      posS = "0" + posS;
    }
    return `${faceS}/${posS}`;
  }
  function rotateAndFlipQuadrant(n2, point, rx, ry) {
    if (ry === 0) {
      if (rx === 1) {
        point[0] = n2 - 1 - point[0];
        point[1] = n2 - 1 - point[1];
      }
      const x2 = point[0];
      point[0] = point[1];
      point[1] = x2;
    }
  }
  function FromHilbertQuadKey(hilbertQuadkey) {
    const parts = hilbertQuadkey.split("/");
    const face = parseInt(parts[0], 10);
    const position = parts[1];
    const maxLevel = position.length;
    const point = [0, 0];
    let level;
    for (let i3 = maxLevel - 1; i3 >= 0; i3--) {
      level = maxLevel - i3;
      const bit = position[i3];
      let rx = 0;
      let ry = 0;
      if (bit === "1") {
        ry = 1;
      } else if (bit === "2") {
        rx = 1;
        ry = 1;
      } else if (bit === "3") {
        rx = 1;
      }
      const val2 = Math.pow(2, level - 1);
      rotateAndFlipQuadrant(val2, point, rx, ry);
      point[0] += val2 * rx;
      point[1] += val2 * ry;
    }
    if (face % 2 === 1) {
      const t2 = point[0];
      point[0] = point[1];
      point[1] = t2;
    }
    return {
      face,
      ij: point,
      level
    };
  }

  // ../geo-layers/src/s2-layer/s2-utils.ts
  var import_long2 = __toESM(require_long());
  function getIdFromToken(token) {
    const paddedToken = token.padEnd(16, "0");
    return import_long2.default.fromString(paddedToken, 16);
  }
  var MAX_RESOLUTION = 100;
  function getGeoBounds({
    face,
    ij,
    level
  }) {
    const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];
    const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));
    const result = new Float64Array(4 * resolution * 2 + 2);
    let ptIndex = 0;
    let prevLng = 0;
    for (let i3 = 0; i3 < 4; i3++) {
      const offset = offsets[i3].slice(0);
      const nextOffset = offsets[i3 + 1];
      const stepI = (nextOffset[0] - offset[0]) / resolution;
      const stepJ = (nextOffset[1] - offset[1]) / resolution;
      for (let j = 0; j < resolution; j++) {
        offset[0] += stepI;
        offset[1] += stepJ;
        const st = IJToST(ij, level, offset);
        const uv = STToUV(st);
        const xyz = FaceUVToXYZ(face, uv);
        const lngLat = XYZToLngLat(xyz);
        if (Math.abs(lngLat[1]) > 89.999) {
          lngLat[0] = prevLng;
        }
        const deltaLng = lngLat[0] - prevLng;
        lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
        result[ptIndex++] = lngLat[0];
        result[ptIndex++] = lngLat[1];
        prevLng = lngLat[0];
      }
    }
    result[ptIndex++] = result[0];
    result[ptIndex++] = result[1];
    return result;
  }
  function getS2QuadKey(token) {
    if (typeof token === "string") {
      if (token.indexOf("/") > 0) {
        return token;
      }
      token = getIdFromToken(token);
    }
    return toHilbertQuadkey(token.toString());
  }
  function getS2Polygon(token) {
    const key = getS2QuadKey(token);
    const s2cell = FromHilbertQuadKey(key);
    return getGeoBounds(s2cell);
  }

  // ../geo-layers/src/s2-layer/s2-layer.ts
  var defaultProps21 = {
    getS2Token: {
      type: "accessor",
      value: (d) => d.token
    }
  };
  var S2Layer = class extends GeoCellLayer {
    indexToBounds() {
      const {
        data,
        getS2Token
      } = this.props;
      return {
        data,
        _normalize: false,
        positionFormat: "XY",
        getPolygon: (x2, objectInfo) => getS2Polygon(getS2Token(x2, objectInfo))
      };
    }
  };
  __publicField(S2Layer, "layerName", "S2Layer");
  __publicField(S2Layer, "defaultProps", defaultProps21);

  // ../geo-layers/src/quadkey-layer/quadkey-utils.ts
  var TILE_SIZE3 = 512;
  function quadkeyToWorldBounds(quadkey) {
    let x2 = 0;
    let y2 = 0;
    let mask = 1 << quadkey.length;
    const scale8 = mask / TILE_SIZE3;
    for (let i3 = 0; i3 < quadkey.length; i3++) {
      mask >>= 1;
      const q = parseInt(quadkey[i3]);
      if (q % 2)
        x2 |= mask;
      if (q > 1)
        y2 |= mask;
    }
    return [[x2 / scale8, TILE_SIZE3 - y2 / scale8], [(x2 + 0.99) / scale8, TILE_SIZE3 - (y2 + 0.99) / scale8]];
  }
  function getQuadkeyPolygon(quadkey) {
    const [topLeft, bottomRight] = quadkeyToWorldBounds(quadkey);
    const [w, n2] = worldToLngLat(topLeft);
    const [e2, s2] = worldToLngLat(bottomRight);
    return [e2, n2, e2, s2, w, s2, w, n2, e2, n2];
  }

  // ../geo-layers/src/quadkey-layer/quadkey-layer.ts
  var defaultProps22 = {
    getQuadkey: {
      type: "accessor",
      value: (d) => d.quadkey
    }
  };
  var QuadkeyLayer = class extends GeoCellLayer {
    indexToBounds() {
      const {
        data,
        getQuadkey
      } = this.props;
      return {
        data,
        _normalize: false,
        positionFormat: "XY",
        getPolygon: (x2, objectInfo) => getQuadkeyPolygon(getQuadkey(x2, objectInfo))
      };
    }
  };
  __publicField(QuadkeyLayer, "layerName", "QuadkeyLayer");
  __publicField(QuadkeyLayer, "defaultProps", defaultProps22);

  // ../geo-layers/src/tileset-2d/tile-2d-header.ts
  var Tile2DHeader = class {
    constructor(index) {
      this.index = index;
      this.isVisible = false;
      this.isSelected = false;
      this.parent = null;
      this.children = [];
      this.content = null;
      this._loader = void 0;
      this._abortController = null;
      this._loaderId = 0;
      this._isLoaded = false;
      this._isCancelled = false;
      this._needsReload = false;
    }
    get bbox() {
      return this._bbox;
    }
    set bbox(value) {
      if (this._bbox)
        return;
      this._bbox = value;
      if ("west" in value) {
        this.boundingBox = [[value.west, value.south], [value.east, value.north]];
      } else {
        this.boundingBox = [[value.left, value.top], [value.right, value.bottom]];
      }
    }
    get data() {
      return this.isLoading && this._loader ? this._loader.then(() => this.data) : this.content;
    }
    get isLoaded() {
      return this._isLoaded && !this._needsReload;
    }
    get isLoading() {
      return Boolean(this._loader) && !this._isCancelled;
    }
    get needsReload() {
      return this._needsReload || this._isCancelled;
    }
    get byteLength() {
      const result = this.content ? this.content.byteLength : 0;
      if (!Number.isFinite(result)) {
        console.error("byteLength not defined in tile data");
      }
      return result;
    }
    async _loadData({
      getData,
      requestScheduler,
      onLoad,
      onError
    }) {
      const {
        index,
        id,
        bbox,
        userData,
        zoom
      } = this;
      const loaderId = this._loaderId;
      this._abortController = new AbortController();
      const {
        signal
      } = this._abortController;
      const requestToken = await requestScheduler.scheduleRequest(this, (tile) => {
        return tile.isSelected ? 1 : -1;
      });
      if (!requestToken) {
        this._isCancelled = true;
        return;
      }
      if (this._isCancelled) {
        requestToken.done();
        return;
      }
      let tileData = null;
      let error2;
      try {
        tileData = await getData({
          index,
          id,
          bbox,
          userData,
          zoom,
          signal
        });
      } catch (err) {
        error2 = err || true;
      } finally {
        requestToken.done();
      }
      if (loaderId !== this._loaderId) {
        return;
      }
      this._loader = void 0;
      this.content = tileData;
      if (this._isCancelled && !tileData) {
        this._isLoaded = false;
        return;
      }
      this._isLoaded = true;
      this._isCancelled = false;
      if (error2) {
        onError(error2, this);
      } else {
        onLoad(this);
      }
    }
    loadData(opts) {
      this._isLoaded = false;
      this._isCancelled = false;
      this._needsReload = false;
      this._loaderId++;
      this._loader = this._loadData(opts);
      return this._loader;
    }
    setNeedsReload() {
      if (this.isLoading) {
        this.abort();
        this._loader = void 0;
      }
      this._needsReload = true;
    }
    abort() {
      if (this.isLoaded) {
        return;
      }
      this._isCancelled = true;
      this._abortController?.abort();
    }
  };

  // ../../node_modules/@math.gl/culling/dist/esm/constants.js
  var INTERSECTION = {
    OUTSIDE: -1,
    INTERSECTING: 0,
    INSIDE: 1
  };

  // ../../node_modules/@math.gl/culling/node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty4(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // ../../node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/axis-aligned-bounding-box.js
  var scratchVector2 = new Vector3();
  var scratchNormal = new Vector3();
  var AxisAlignedBoundingBox = class {
    constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center) {
      _defineProperty4(this, "center", void 0);
      _defineProperty4(this, "halfDiagonal", void 0);
      _defineProperty4(this, "minimum", void 0);
      _defineProperty4(this, "maximum", void 0);
      center = center || scratchVector2.copy(minimum).add(maximum).scale(0.5);
      this.center = new Vector3(center);
      this.halfDiagonal = new Vector3(maximum).subtract(this.center);
      this.minimum = new Vector3(minimum);
      this.maximum = new Vector3(maximum);
    }
    clone() {
      return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
    }
    equals(right) {
      return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
    }
    transform(transform3) {
      this.center.transformAsPoint(transform3);
      this.halfDiagonal.transform(transform3);
      this.minimum.transform(transform3);
      this.maximum.transform(transform3);
      return this;
    }
    intersectPlane(plane) {
      const {
        halfDiagonal
      } = this;
      const normal = scratchNormal.from(plane.normal);
      const e2 = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);
      const s2 = this.center.dot(normal) + plane.distance;
      if (s2 - e2 > 0) {
        return INTERSECTION.INSIDE;
      }
      if (s2 + e2 < 0) {
        return INTERSECTION.OUTSIDE;
      }
      return INTERSECTION.INTERSECTING;
    }
    distanceTo(point) {
      return Math.sqrt(this.distanceSquaredTo(point));
    }
    distanceSquaredTo(point) {
      const offset = scratchVector2.from(point).subtract(this.center);
      const {
        halfDiagonal
      } = this;
      let distanceSquared = 0;
      let d;
      d = Math.abs(offset.x) - halfDiagonal.x;
      if (d > 0) {
        distanceSquared += d * d;
      }
      d = Math.abs(offset.y) - halfDiagonal.y;
      if (d > 0) {
        distanceSquared += d * d;
      }
      d = Math.abs(offset.z) - halfDiagonal.z;
      if (d > 0) {
        distanceSquared += d * d;
      }
      return distanceSquared;
    }
  };

  // ../../node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/bounding-sphere.js
  var scratchVector3 = new Vector3();
  var scratchVector22 = new Vector3();
  var BoundingSphere = class {
    constructor(center = [0, 0, 0], radius = 0) {
      _defineProperty4(this, "center", void 0);
      _defineProperty4(this, "radius", void 0);
      this.radius = -0;
      this.center = new Vector3();
      this.fromCenterRadius(center, radius);
    }
    fromCenterRadius(center, radius) {
      this.center.from(center);
      this.radius = radius;
      return this;
    }
    fromCornerPoints(corner, oppositeCorner) {
      oppositeCorner = scratchVector3.from(oppositeCorner);
      this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);
      this.radius = this.center.distance(oppositeCorner);
      return this;
    }
    equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;
    }
    clone() {
      return new BoundingSphere(this.center, this.radius);
    }
    union(boundingSphere) {
      const leftCenter = this.center;
      const leftRadius = this.radius;
      const rightCenter = boundingSphere.center;
      const rightRadius = boundingSphere.radius;
      const toRightCenter = scratchVector3.copy(rightCenter).subtract(leftCenter);
      const centerSeparation = toRightCenter.magnitude();
      if (leftRadius >= centerSeparation + rightRadius) {
        return this.clone();
      }
      if (rightRadius >= centerSeparation + leftRadius) {
        return boundingSphere.clone();
      }
      const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
      scratchVector22.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);
      this.center.copy(scratchVector22);
      this.radius = halfDistanceBetweenTangentPoints;
      return this;
    }
    expand(point) {
      const scratchPoint2 = scratchVector3.from(point);
      const radius = scratchPoint2.subtract(this.center).magnitude();
      if (radius > this.radius) {
        this.radius = radius;
      }
      return this;
    }
    transform(transform3) {
      this.center.transform(transform3);
      const scale8 = getScaling(scratchVector3, transform3);
      this.radius = Math.max(scale8[0], Math.max(scale8[1], scale8[2])) * this.radius;
      return this;
    }
    distanceSquaredTo(point) {
      const d = this.distanceTo(point);
      return d * d;
    }
    distanceTo(point) {
      const scratchPoint2 = scratchVector3.from(point);
      const delta = scratchPoint2.subtract(this.center);
      return Math.max(0, delta.len() - this.radius);
    }
    intersectPlane(plane) {
      const center = this.center;
      const radius = this.radius;
      const normal = plane.normal;
      const distanceToPlane = normal.dot(center) + plane.distance;
      if (distanceToPlane < -radius) {
        return INTERSECTION.OUTSIDE;
      }
      if (distanceToPlane < radius) {
        return INTERSECTION.INTERSECTING;
      }
      return INTERSECTION.INSIDE;
    }
  };

  // ../../node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/oriented-bounding-box.js
  var scratchVector32 = new Vector3();
  var scratchOffset = new Vector3();
  var scratchVectorU = new Vector3();
  var scratchVectorV = new Vector3();
  var scratchVectorW = new Vector3();
  var scratchCorner = new Vector3();
  var scratchToCenter = new Vector3();
  var MATRIX3 = {
    COLUMN0ROW0: 0,
    COLUMN0ROW1: 1,
    COLUMN0ROW2: 2,
    COLUMN1ROW0: 3,
    COLUMN1ROW1: 4,
    COLUMN1ROW2: 5,
    COLUMN2ROW0: 6,
    COLUMN2ROW1: 7,
    COLUMN2ROW2: 8
  };
  var OrientedBoundingBox = class {
    constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
      _defineProperty4(this, "center", void 0);
      _defineProperty4(this, "halfAxes", void 0);
      this.center = new Vector3().from(center);
      this.halfAxes = new Matrix3(halfAxes);
    }
    get halfSize() {
      const xAxis = this.halfAxes.getColumn(0);
      const yAxis = this.halfAxes.getColumn(1);
      const zAxis = this.halfAxes.getColumn(2);
      return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];
    }
    get quaternion() {
      const xAxis = this.halfAxes.getColumn(0);
      const yAxis = this.halfAxes.getColumn(1);
      const zAxis = this.halfAxes.getColumn(2);
      const normXAxis = new Vector3(xAxis).normalize();
      const normYAxis = new Vector3(yAxis).normalize();
      const normZAxis = new Vector3(zAxis).normalize();
      return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));
    }
    fromCenterHalfSizeQuaternion(center, halfSize, quaternion2) {
      const quaternionObject = new Quaternion(quaternion2);
      const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);
      directionsMatrix[0] = directionsMatrix[0] * halfSize[0];
      directionsMatrix[1] = directionsMatrix[1] * halfSize[0];
      directionsMatrix[2] = directionsMatrix[2] * halfSize[0];
      directionsMatrix[3] = directionsMatrix[3] * halfSize[1];
      directionsMatrix[4] = directionsMatrix[4] * halfSize[1];
      directionsMatrix[5] = directionsMatrix[5] * halfSize[1];
      directionsMatrix[6] = directionsMatrix[6] * halfSize[2];
      directionsMatrix[7] = directionsMatrix[7] * halfSize[2];
      directionsMatrix[8] = directionsMatrix[8] * halfSize[2];
      this.center = new Vector3().from(center);
      this.halfAxes = directionsMatrix;
      return this;
    }
    clone() {
      return new OrientedBoundingBox(this.center, this.halfAxes);
    }
    equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
    }
    getBoundingSphere(result = new BoundingSphere()) {
      const halfAxes = this.halfAxes;
      const u = halfAxes.getColumn(0, scratchVectorU);
      const v = halfAxes.getColumn(1, scratchVectorV);
      const w = halfAxes.getColumn(2, scratchVectorW);
      const cornerVector = scratchVector32.copy(u).add(v).add(w);
      result.center.copy(this.center);
      result.radius = cornerVector.magnitude();
      return result;
    }
    intersectPlane(plane) {
      const center = this.center;
      const normal = plane.normal;
      const halfAxes = this.halfAxes;
      const normalX = normal.x;
      const normalY = normal.y;
      const normalZ = normal.z;
      const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);
      const distanceToPlane = normal.dot(center) + plane.distance;
      if (distanceToPlane <= -radEffective) {
        return INTERSECTION.OUTSIDE;
      } else if (distanceToPlane >= radEffective) {
        return INTERSECTION.INSIDE;
      }
      return INTERSECTION.INTERSECTING;
    }
    distanceTo(point) {
      return Math.sqrt(this.distanceSquaredTo(point));
    }
    distanceSquaredTo(point) {
      const offset = scratchOffset.from(point).subtract(this.center);
      const halfAxes = this.halfAxes;
      const u = halfAxes.getColumn(0, scratchVectorU);
      const v = halfAxes.getColumn(1, scratchVectorV);
      const w = halfAxes.getColumn(2, scratchVectorW);
      const uHalf = u.magnitude();
      const vHalf = v.magnitude();
      const wHalf = w.magnitude();
      u.normalize();
      v.normalize();
      w.normalize();
      let distanceSquared = 0;
      let d;
      d = Math.abs(offset.dot(u)) - uHalf;
      if (d > 0) {
        distanceSquared += d * d;
      }
      d = Math.abs(offset.dot(v)) - vHalf;
      if (d > 0) {
        distanceSquared += d * d;
      }
      d = Math.abs(offset.dot(w)) - wHalf;
      if (d > 0) {
        distanceSquared += d * d;
      }
      return distanceSquared;
    }
    computePlaneDistances(position, direction, result = [-0, -0]) {
      let minDist = Number.POSITIVE_INFINITY;
      let maxDist = Number.NEGATIVE_INFINITY;
      const center = this.center;
      const halfAxes = this.halfAxes;
      const u = halfAxes.getColumn(0, scratchVectorU);
      const v = halfAxes.getColumn(1, scratchVectorV);
      const w = halfAxes.getColumn(2, scratchVectorW);
      const corner = scratchCorner.copy(u).add(v).add(w).add(center);
      const toCenter = scratchToCenter.copy(corner).subtract(position);
      let mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u).add(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u).subtract(v).add(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u).subtract(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).add(v).add(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).add(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).subtract(v).add(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u).subtract(v).subtract(w);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      result[0] = minDist;
      result[1] = maxDist;
      return result;
    }
    transform(transformation) {
      this.center.transformAsPoint(transformation);
      const xAxis = this.halfAxes.getColumn(0, scratchVectorU);
      xAxis.transformAsPoint(transformation);
      const yAxis = this.halfAxes.getColumn(1, scratchVectorV);
      yAxis.transformAsPoint(transformation);
      const zAxis = this.halfAxes.getColumn(2, scratchVectorW);
      zAxis.transformAsPoint(transformation);
      this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);
      return this;
    }
    getTransform() {
      throw new Error("not implemented");
    }
  };

  // ../../node_modules/@math.gl/culling/dist/esm/lib/plane.js
  var scratchPosition = new Vector3();
  var scratchNormal2 = new Vector3();
  var Plane = class {
    constructor(normal = [0, 0, 1], distance3 = 0) {
      _defineProperty4(this, "normal", void 0);
      _defineProperty4(this, "distance", void 0);
      this.normal = new Vector3();
      this.distance = -0;
      this.fromNormalDistance(normal, distance3);
    }
    fromNormalDistance(normal, distance3) {
      assert9(Number.isFinite(distance3));
      this.normal.from(normal).normalize();
      this.distance = distance3;
      return this;
    }
    fromPointNormal(point, normal) {
      point = scratchPosition.from(point);
      this.normal.from(normal).normalize();
      const distance3 = -this.normal.dot(point);
      this.distance = distance3;
      return this;
    }
    fromCoefficients(a2, b, c, d) {
      this.normal.set(a2, b, c);
      assert9(equals(this.normal.len(), 1));
      this.distance = d;
      return this;
    }
    clone() {
      return new Plane(this.normal, this.distance);
    }
    equals(right) {
      return equals(this.distance, right.distance) && equals(this.normal, right.normal);
    }
    getPointDistance(point) {
      return this.normal.dot(point) + this.distance;
    }
    transform(matrix4) {
      const normal = scratchNormal2.copy(this.normal).transformAsVector(matrix4).normalize();
      const point = this.normal.scale(-this.distance).transform(matrix4);
      return this.fromPointNormal(point, normal);
    }
    projectPointOntoPlane(point, result = [0, 0, 0]) {
      point = scratchPosition.from(point);
      const pointDistance = this.getPointDistance(point);
      const scaledNormal = scratchNormal2.copy(this.normal).scale(pointDistance);
      return point.subtract(scaledNormal).to(result);
    }
  };

  // ../../node_modules/@math.gl/culling/dist/esm/lib/culling-volume.js
  var faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];
  var scratchPlaneCenter = new Vector3();
  var scratchPlaneNormal = new Vector3();
  var scratchPlane = new Plane(new Vector3(1, 0, 0), 0);
  var CullingVolume = class {
    constructor(planes = []) {
      _defineProperty4(this, "planes", void 0);
      this.planes = planes;
    }
    fromBoundingSphere(boundingSphere) {
      this.planes.length = 2 * faces.length;
      const center = boundingSphere.center;
      const radius = boundingSphere.radius;
      let planeIndex = 0;
      for (const faceNormal of faces) {
        let plane0 = this.planes[planeIndex];
        let plane1 = this.planes[planeIndex + 1];
        if (!plane0) {
          plane0 = this.planes[planeIndex] = new Plane();
        }
        if (!plane1) {
          plane1 = this.planes[planeIndex + 1] = new Plane();
        }
        const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);
        const plane0Distance = -faceNormal.dot(plane0Center);
        plane0.fromPointNormal(plane0Center, faceNormal);
        const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);
        const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();
        const plane1Distance = -negatedFaceNormal.dot(plane1Center);
        plane1.fromPointNormal(plane1Center, negatedFaceNormal);
        planeIndex += 2;
      }
      return this;
    }
    computeVisibility(boundingVolume) {
      let intersect3 = INTERSECTION.INSIDE;
      for (const plane of this.planes) {
        const result = boundingVolume.intersectPlane(plane);
        switch (result) {
          case INTERSECTION.OUTSIDE:
            return INTERSECTION.OUTSIDE;
          case INTERSECTION.INTERSECTING:
            intersect3 = INTERSECTION.INTERSECTING;
            break;
          default:
        }
      }
      return intersect3;
    }
    computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
      assert9(Number.isFinite(parentPlaneMask), "parentPlaneMask is required.");
      if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {
        return parentPlaneMask;
      }
      let mask = CullingVolume.MASK_INSIDE;
      const planes = this.planes;
      for (let k = 0; k < this.planes.length; ++k) {
        const flag = k < 31 ? 1 << k : 0;
        if (k < 31 && (parentPlaneMask & flag) === 0) {
          continue;
        }
        const plane = planes[k];
        const result = boundingVolume.intersectPlane(plane);
        if (result === INTERSECTION.OUTSIDE) {
          return CullingVolume.MASK_OUTSIDE;
        } else if (result === INTERSECTION.INTERSECTING) {
          mask |= flag;
        }
      }
      return mask;
    }
  };
  _defineProperty4(CullingVolume, "MASK_OUTSIDE", 4294967295);
  _defineProperty4(CullingVolume, "MASK_INSIDE", 0);
  _defineProperty4(CullingVolume, "MASK_INDETERMINATE", 2147483647);

  // ../../node_modules/@math.gl/culling/dist/esm/lib/perspective-off-center-frustum.js
  var scratchPlaneUpVector = new Vector3();
  var scratchPlaneRightVector = new Vector3();
  var scratchPlaneNearCenter = new Vector3();
  var scratchPlaneFarCenter = new Vector3();
  var scratchPlaneNormal2 = new Vector3();

  // ../../node_modules/@math.gl/culling/dist/esm/lib/algorithms/bounding-sphere-from-points.js
  var fromPointsXMin = new Vector3();
  var fromPointsYMin = new Vector3();
  var fromPointsZMin = new Vector3();
  var fromPointsXMax = new Vector3();
  var fromPointsYMax = new Vector3();
  var fromPointsZMax = new Vector3();
  var fromPointsCurrentPos = new Vector3();
  var fromPointsScratch = new Vector3();
  var fromPointsRitterCenter = new Vector3();
  var fromPointsMinBoxPt = new Vector3();
  var fromPointsMaxBoxPt = new Vector3();
  var fromPointsNaiveCenterScratch = new Vector3();
  var volumeConstant = 4 / 3 * Math.PI;

  // ../../node_modules/@math.gl/culling/dist/esm/lib/algorithms/compute-eigen-decomposition.js
  var scratchMatrix = new Matrix3();
  var scratchUnitary = new Matrix3();
  var scratchDiagonal = new Matrix3();
  var jMatrix = new Matrix3();
  var jMatrixTranspose = new Matrix3();
  function computeEigenDecomposition(matrix, result = {}) {
    const EIGEN_TOLERANCE = math_utils_default.EPSILON20;
    const EIGEN_MAX_SWEEPS = 10;
    let count2 = 0;
    let sweep = 0;
    const unitaryMatrix = scratchUnitary;
    const diagonalMatrix = scratchDiagonal;
    unitaryMatrix.identity();
    diagonalMatrix.copy(matrix);
    const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);
    while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {
      shurDecomposition(diagonalMatrix, jMatrix);
      jMatrixTranspose.copy(jMatrix).transpose();
      diagonalMatrix.multiplyRight(jMatrix);
      diagonalMatrix.multiplyLeft(jMatrixTranspose);
      unitaryMatrix.multiplyRight(jMatrix);
      if (++count2 > 2) {
        ++sweep;
        count2 = 0;
      }
    }
    result.unitary = unitaryMatrix.toTarget(result.unitary);
    result.diagonal = diagonalMatrix.toTarget(result.diagonal);
    return result;
  }
  function computeFrobeniusNorm(matrix) {
    let norm = 0;
    for (let i3 = 0; i3 < 9; ++i3) {
      const temp = matrix[i3];
      norm += temp * temp;
    }
    return Math.sqrt(norm);
  }
  var rowVal = [1, 0, 0];
  var colVal = [2, 2, 1];
  function offDiagonalFrobeniusNorm(matrix) {
    let norm = 0;
    for (let i3 = 0; i3 < 3; ++i3) {
      const temp = matrix[scratchMatrix.getElementIndex(colVal[i3], rowVal[i3])];
      norm += 2 * temp * temp;
    }
    return Math.sqrt(norm);
  }
  function shurDecomposition(matrix, result) {
    const tolerance = math_utils_default.EPSILON15;
    let maxDiagonal = 0;
    let rotAxis = 1;
    for (let i3 = 0; i3 < 3; ++i3) {
      const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i3], rowVal[i3])]);
      if (temp > maxDiagonal) {
        rotAxis = i3;
        maxDiagonal = temp;
      }
    }
    const p2 = rowVal[rotAxis];
    const q = colVal[rotAxis];
    let c = 1;
    let s2 = 0;
    if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p2)]) > tolerance) {
      const qq = matrix[scratchMatrix.getElementIndex(q, q)];
      const pp = matrix[scratchMatrix.getElementIndex(p2, p2)];
      const qp = matrix[scratchMatrix.getElementIndex(q, p2)];
      const tau = (qq - pp) / 2 / qp;
      let t2;
      if (tau < 0) {
        t2 = -1 / (-tau + Math.sqrt(1 + tau * tau));
      } else {
        t2 = 1 / (tau + Math.sqrt(1 + tau * tau));
      }
      c = 1 / Math.sqrt(1 + t2 * t2);
      s2 = t2 * c;
    }
    Matrix3.IDENTITY.to(result);
    result[scratchMatrix.getElementIndex(p2, p2)] = result[scratchMatrix.getElementIndex(q, q)] = c;
    result[scratchMatrix.getElementIndex(q, p2)] = s2;
    result[scratchMatrix.getElementIndex(p2, q)] = -s2;
    return result;
  }

  // ../../node_modules/@math.gl/culling/dist/esm/lib/algorithms/bounding-box-from-points.js
  var scratchVector23 = new Vector3();
  var scratchVector33 = new Vector3();
  var scratchVector4 = new Vector3();
  var scratchVector5 = new Vector3();
  var scratchVector6 = new Vector3();
  var scratchCovarianceResult = new Matrix3();
  var scratchEigenResult = {
    diagonal: new Matrix3(),
    unitary: new Matrix3()
  };
  function makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {
    if (!positions || positions.length === 0) {
      result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      result.center = new Vector3();
      return result;
    }
    const length7 = positions.length;
    const meanPoint = new Vector3(0, 0, 0);
    for (const position of positions) {
      meanPoint.add(position);
    }
    const invLength = 1 / length7;
    meanPoint.multiplyByScalar(invLength);
    let exx = 0;
    let exy = 0;
    let exz = 0;
    let eyy = 0;
    let eyz = 0;
    let ezz = 0;
    for (const position of positions) {
      const p2 = scratchVector23.copy(position).subtract(meanPoint);
      exx += p2.x * p2.x;
      exy += p2.x * p2.y;
      exz += p2.x * p2.z;
      eyy += p2.y * p2.y;
      eyz += p2.y * p2.z;
      ezz += p2.z * p2.z;
    }
    exx *= invLength;
    exy *= invLength;
    exz *= invLength;
    eyy *= invLength;
    eyz *= invLength;
    ezz *= invLength;
    const covarianceMatrix = scratchCovarianceResult;
    covarianceMatrix[0] = exx;
    covarianceMatrix[1] = exy;
    covarianceMatrix[2] = exz;
    covarianceMatrix[3] = exy;
    covarianceMatrix[4] = eyy;
    covarianceMatrix[5] = eyz;
    covarianceMatrix[6] = exz;
    covarianceMatrix[7] = eyz;
    covarianceMatrix[8] = ezz;
    const {
      unitary
    } = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);
    const rotation = result.halfAxes.copy(unitary);
    let v1 = rotation.getColumn(0, scratchVector4);
    let v2 = rotation.getColumn(1, scratchVector5);
    let v3 = rotation.getColumn(2, scratchVector6);
    let u1 = -Number.MAX_VALUE;
    let u2 = -Number.MAX_VALUE;
    let u3 = -Number.MAX_VALUE;
    let l1 = Number.MAX_VALUE;
    let l2 = Number.MAX_VALUE;
    let l3 = Number.MAX_VALUE;
    for (const position of positions) {
      scratchVector23.copy(position);
      u1 = Math.max(scratchVector23.dot(v1), u1);
      u2 = Math.max(scratchVector23.dot(v2), u2);
      u3 = Math.max(scratchVector23.dot(v3), u3);
      l1 = Math.min(scratchVector23.dot(v1), l1);
      l2 = Math.min(scratchVector23.dot(v2), l2);
      l3 = Math.min(scratchVector23.dot(v3), l3);
    }
    v1 = v1.multiplyByScalar(0.5 * (l1 + u1));
    v2 = v2.multiplyByScalar(0.5 * (l2 + u2));
    v3 = v3.multiplyByScalar(0.5 * (l3 + u3));
    result.center.copy(v1).add(v2).add(v3);
    const scale8 = scratchVector33.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);
    const scaleMatrix = new Matrix3([scale8[0], 0, 0, 0, scale8[1], 0, 0, 0, scale8[2]]);
    result.halfAxes.multiplyRight(scaleMatrix);
    return result;
  }

  // ../geo-layers/src/tileset-2d/tile-2d-traversal.ts
  var TILE_SIZE4 = 512;
  var MAX_MAPS = 3;
  var REF_POINTS_5 = [[0.5, 0.5], [0, 0], [0, 1], [1, 0], [1, 1]];
  var REF_POINTS_9 = REF_POINTS_5.concat([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]]);
  var REF_POINTS_11 = REF_POINTS_9.concat([[0.25, 0.5], [0.75, 0.5]]);
  var OSMNode = class {
    constructor(x2, y2, z) {
      this.x = x2;
      this.y = y2;
      this.z = z;
    }
    get children() {
      if (!this._children) {
        const x2 = this.x * 2;
        const y2 = this.y * 2;
        const z = this.z + 1;
        this._children = [new OSMNode(x2, y2, z), new OSMNode(x2, y2 + 1, z), new OSMNode(x2 + 1, y2, z), new OSMNode(x2 + 1, y2 + 1, z)];
      }
      return this._children;
    }
    update(params) {
      const {
        viewport,
        cullingVolume: cullingVolume2,
        elevationBounds,
        minZ,
        maxZ,
        bounds,
        offset,
        project: project3
      } = params;
      const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project3);
      if (bounds && !this.insideBounds(bounds)) {
        return false;
      }
      const isInside = cullingVolume2.computeVisibility(boundingVolume);
      if (isInside < 0) {
        return false;
      }
      if (!this.childVisible) {
        let {
          z
        } = this;
        if (z < maxZ && z >= minZ) {
          const distance3 = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;
          z += Math.floor(Math.log2(distance3));
        }
        if (z >= maxZ) {
          this.selected = true;
          return true;
        }
      }
      this.selected = false;
      this.childVisible = true;
      for (const child of this.children) {
        child.update(params);
      }
      return true;
    }
    getSelected(result = []) {
      if (this.selected) {
        result.push(this);
      }
      if (this._children) {
        for (const node2 of this._children) {
          node2.getSelected(result);
        }
      }
      return result;
    }
    insideBounds([minX, minY, maxX, maxY]) {
      const scale8 = Math.pow(2, this.z);
      const extent = TILE_SIZE4 / scale8;
      return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;
    }
    getBoundingVolume(zRange, worldOffset, project3) {
      if (project3) {
        const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;
        const refPointPositions = [];
        for (const p2 of refPoints) {
          const lngLat = osmTile2lngLat(this.x + p2[0], this.y + p2[1], this.z);
          lngLat[2] = zRange[0];
          refPointPositions.push(project3(lngLat));
          if (zRange[0] !== zRange[1]) {
            lngLat[2] = zRange[1];
            refPointPositions.push(project3(lngLat));
          }
        }
        return makeOrientedBoundingBoxFromPoints(refPointPositions);
      }
      const scale8 = Math.pow(2, this.z);
      const extent = TILE_SIZE4 / scale8;
      const originX = this.x * extent + worldOffset * TILE_SIZE4;
      const originY = TILE_SIZE4 - (this.y + 1) * extent;
      return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);
    }
  };
  function getOSMTileIndices(viewport, maxZ, zRange, bounds) {
    const project3 = viewport instanceof GlobeViewport && viewport.resolution ? viewport.projectPosition : null;
    const planes = Object.values(viewport.getFrustumPlanes()).map(({
      normal,
      distance: distance3
    }) => new Plane(normal.clone().negate(), distance3));
    const cullingVolume2 = new CullingVolume(planes);
    const unitsPerMeter2 = viewport.distanceScales.unitsPerMeter[2];
    const elevationMin = zRange && zRange[0] * unitsPerMeter2 || 0;
    const elevationMax = zRange && zRange[1] * unitsPerMeter2 || 0;
    const minZ = viewport instanceof WebMercatorViewport2 && viewport.pitch <= 60 ? maxZ : 0;
    if (bounds) {
      const [minLng, minLat, maxLng, maxLat] = bounds;
      const topLeft = lngLatToWorld([minLng, maxLat]);
      const bottomRight = lngLatToWorld([maxLng, minLat]);
      bounds = [topLeft[0], TILE_SIZE4 - topLeft[1], bottomRight[0], TILE_SIZE4 - bottomRight[1]];
    }
    const root = new OSMNode(0, 0, 0);
    const traversalParams = {
      viewport,
      project: project3,
      cullingVolume: cullingVolume2,
      elevationBounds: [elevationMin, elevationMax],
      minZ,
      maxZ,
      bounds,
      offset: 0
    };
    root.update(traversalParams);
    if (viewport instanceof WebMercatorViewport2 && viewport.subViewports && viewport.subViewports.length > 1) {
      traversalParams.offset = -1;
      while (root.update(traversalParams)) {
        if (--traversalParams.offset < -MAX_MAPS) {
          break;
        }
      }
      traversalParams.offset = 1;
      while (root.update(traversalParams)) {
        if (++traversalParams.offset > MAX_MAPS) {
          break;
        }
      }
    }
    return root.getSelected();
  }

  // ../geo-layers/src/tileset-2d/utils.ts
  var TILE_SIZE5 = 512;
  var DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];
  var urlType = {
    type: "object",
    value: null,
    validate: (value, propType) => propType.optional && value === null || typeof value === "string" || Array.isArray(value) && value.every((url) => typeof url === "string"),
    equal: (value1, value2) => {
      if (value1 === value2) {
        return true;
      }
      if (!Array.isArray(value1) || !Array.isArray(value2)) {
        return false;
      }
      const len3 = value1.length;
      if (len3 !== value2.length) {
        return false;
      }
      for (let i3 = 0; i3 < len3; i3++) {
        if (value1[i3] !== value2[i3]) {
          return false;
        }
      }
      return true;
    }
  };
  function transformBox(bbox, modelMatrix2) {
    const transformedCoords = [
      modelMatrix2.transformAsPoint([bbox[0], bbox[1]]),
      modelMatrix2.transformAsPoint([bbox[2], bbox[1]]),
      modelMatrix2.transformAsPoint([bbox[0], bbox[3]]),
      modelMatrix2.transformAsPoint([bbox[2], bbox[3]])
    ];
    const transformedBox = [
      Math.min(...transformedCoords.map((i3) => i3[0])),
      Math.min(...transformedCoords.map((i3) => i3[1])),
      Math.max(...transformedCoords.map((i3) => i3[0])),
      Math.max(...transformedCoords.map((i3) => i3[1]))
    ];
    return transformedBox;
  }
  function stringHash(s2) {
    return Math.abs(s2.split("").reduce((a2, b) => (a2 << 5) - a2 + b.charCodeAt(0) | 0, 0));
  }
  function getURLFromTemplate(template, tile) {
    if (!template || !template.length) {
      return null;
    }
    const {
      index,
      id
    } = tile;
    if (Array.isArray(template)) {
      const i3 = stringHash(id) % template.length;
      template = template[i3];
    }
    let url = template;
    for (const key of Object.keys(index)) {
      const regex = new RegExp(`{${key}}`, "g");
      url = url.replace(regex, String(index[key]));
    }
    if (Number.isInteger(index.y) && Number.isInteger(index.z)) {
      url = url.replace(/\{-y\}/g, String(Math.pow(2, index.z) - index.y - 1));
    }
    return url;
  }
  function getBoundingBox2(viewport, zRange, extent) {
    let bounds;
    if (zRange && zRange.length === 2) {
      const [minZ, maxZ] = zRange;
      const bounds0 = viewport.getBounds({
        z: minZ
      });
      const bounds1 = viewport.getBounds({
        z: maxZ
      });
      bounds = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
    } else {
      bounds = viewport.getBounds();
    }
    if (!viewport.isGeospatial) {
      return [
        Math.max(Math.min(bounds[0], extent[2]), extent[0]),
        Math.max(Math.min(bounds[1], extent[3]), extent[1]),
        Math.min(Math.max(bounds[2], extent[0]), extent[2]),
        Math.min(Math.max(bounds[3], extent[1]), extent[3])
      ];
    }
    return [Math.max(bounds[0], extent[0]), Math.max(bounds[1], extent[1]), Math.min(bounds[2], extent[2]), Math.min(bounds[3], extent[3])];
  }
  function getCullBounds({
    viewport,
    z = 0,
    cullRect
  }) {
    const subViewports = viewport.subViewports || [viewport];
    return subViewports.map((v) => getCullBoundsInViewport(v, z, cullRect));
  }
  function getCullBoundsInViewport(viewport, z, cullRect) {
    if (!Array.isArray(z)) {
      const x2 = cullRect.x - viewport.x;
      const y2 = cullRect.y - viewport.y;
      const {
        width,
        height
      } = cullRect;
      const unprojectOption = {
        targetZ: z
      };
      const topLeft = viewport.unproject([x2, y2], unprojectOption);
      const topRight = viewport.unproject([x2 + width, y2], unprojectOption);
      const bottomLeft = viewport.unproject([x2, y2 + height], unprojectOption);
      const bottomRight = viewport.unproject([x2 + width, y2 + height], unprojectOption);
      return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
    }
    const bounds0 = getCullBoundsInViewport(viewport, z[0], cullRect);
    const bounds1 = getCullBoundsInViewport(viewport, z[1], cullRect);
    return [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
  }
  function getIndexingCoords(bbox, scale8, modelMatrixInverse) {
    if (modelMatrixInverse) {
      const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map((i3) => i3 * scale8 / TILE_SIZE5);
      return transformedTileIndex;
    }
    return bbox.map((i3) => i3 * scale8 / TILE_SIZE5);
  }
  function getScale(z, tileSize) {
    return Math.pow(2, z) * TILE_SIZE5 / tileSize;
  }
  function osmTile2lngLat(x2, y2, z) {
    const scale8 = getScale(z, TILE_SIZE5);
    const lng = x2 / scale8 * 360 - 180;
    const n2 = Math.PI - 2 * Math.PI * y2 / scale8;
    const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n2) - Math.exp(-n2)));
    return [lng, lat];
  }
  function tile2XY(x2, y2, z, tileSize) {
    const scale8 = getScale(z, tileSize);
    return [x2 / scale8 * TILE_SIZE5, y2 / scale8 * TILE_SIZE5];
  }
  function tileToBoundingBox(viewport, x2, y2, z, tileSize = TILE_SIZE5) {
    if (viewport.isGeospatial) {
      const [west, north] = osmTile2lngLat(x2, y2, z);
      const [east, south] = osmTile2lngLat(x2 + 1, y2 + 1, z);
      return {
        west,
        north,
        east,
        south
      };
    }
    const [left, top] = tile2XY(x2, y2, z, tileSize);
    const [right, bottom] = tile2XY(x2 + 1, y2 + 1, z, tileSize);
    return {
      left,
      top,
      right,
      bottom
    };
  }
  function getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {
    const bbox = getBoundingBox2(viewport, null, extent);
    const scale8 = getScale(z, tileSize);
    const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale8, modelMatrixInverse);
    const indices = [];
    for (let x2 = Math.floor(minX); x2 < maxX; x2++) {
      for (let y2 = Math.floor(minY); y2 < maxY; y2++) {
        indices.push({
          x: x2,
          y: y2,
          z
        });
      }
    }
    return indices;
  }
  function getTileIndices({
    viewport,
    maxZoom,
    minZoom,
    zRange,
    extent,
    tileSize = TILE_SIZE5,
    modelMatrix: modelMatrix2,
    modelMatrixInverse,
    zoomOffset = 0
  }) {
    let z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE5 / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;
    if (typeof minZoom === "number" && Number.isFinite(minZoom) && z < minZoom) {
      if (!extent) {
        return [];
      }
      z = minZoom;
    }
    if (typeof maxZoom === "number" && Number.isFinite(maxZoom) && z > maxZoom) {
      z = maxZoom;
    }
    let transformedExtent = extent;
    if (modelMatrix2 && modelMatrixInverse && extent && !viewport.isGeospatial) {
      transformedExtent = transformBox(extent, modelMatrix2);
    }
    return viewport.isGeospatial ? getOSMTileIndices(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);
  }
  function isURLTemplate(s2) {
    return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s2);
  }
  function isGeoBoundingBox(v) {
    return Number.isFinite(v.west) && Number.isFinite(v.north) && Number.isFinite(v.east) && Number.isFinite(v.south);
  }

  // ../geo-layers/src/tileset-2d/memoize.ts
  function memoize2(compute) {
    let cachedArgs = {};
    let cachedResult;
    return (args) => {
      for (const key in args) {
        if (!isEqual2(args[key], cachedArgs[key])) {
          cachedResult = compute(args);
          cachedArgs = args;
          break;
        }
      }
      return cachedResult;
    };
  }
  function isEqual2(a2, b) {
    if (a2 === b) {
      return true;
    }
    if (Array.isArray(a2)) {
      const len3 = a2.length;
      if (!b || b.length !== len3) {
        return false;
      }
      for (let i3 = 0; i3 < len3; i3++) {
        if (a2[i3] !== b[i3]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../geo-layers/src/tileset-2d/tileset-2d.ts
  var TILE_STATE_VISITED = 1;
  var TILE_STATE_VISIBLE = 2;
  var STRATEGY_NEVER = "never";
  var STRATEGY_REPLACE = "no-overlap";
  var STRATEGY_DEFAULT = "best-available";
  var DEFAULT_CACHE_SCALE = 5;
  var STRATEGIES = {
    [STRATEGY_DEFAULT]: updateTileStateDefault,
    [STRATEGY_REPLACE]: updateTileStateReplace,
    [STRATEGY_NEVER]: () => {
    }
  };
  var DEFAULT_TILESET2D_PROPS = {
    extent: null,
    tileSize: 512,
    maxZoom: null,
    minZoom: null,
    maxCacheSize: null,
    maxCacheByteSize: null,
    refinementStrategy: "best-available",
    zRange: null,
    maxRequests: 6,
    zoomOffset: 0,
    onTileLoad: () => {
    },
    onTileUnload: () => {
    },
    onTileError: () => {
    }
  };
  var Tileset2D = class {
    constructor(opts) {
      this.opts = {
        ...DEFAULT_TILESET2D_PROPS,
        ...opts
      };
      this.onTileLoad = (tile) => {
        this.opts.onTileLoad?.(tile);
        if (this.opts.maxCacheByteSize) {
          this._cacheByteSize += tile.byteLength;
          this._resizeCache();
        }
      };
      this._requestScheduler = new RequestScheduler({
        maxRequests: opts.maxRequests,
        throttleRequests: Boolean(opts.maxRequests && opts.maxRequests > 0)
      });
      this._cache = /* @__PURE__ */ new Map();
      this._tiles = [];
      this._dirty = false;
      this._cacheByteSize = 0;
      this._viewport = null;
      this._selectedTiles = null;
      this._frameNumber = 0;
      this._modelMatrix = new Matrix4();
      this._modelMatrixInverse = new Matrix4();
      this.setOptions(opts);
    }
    get tiles() {
      return this._tiles;
    }
    get selectedTiles() {
      return this._selectedTiles;
    }
    get isLoaded() {
      return this._selectedTiles !== null && this._selectedTiles.every((tile) => tile.isLoaded);
    }
    get needsReload() {
      return this._selectedTiles !== null && this._selectedTiles.some((tile) => tile.needsReload);
    }
    setOptions(opts) {
      Object.assign(this.opts, opts);
      if (Number.isFinite(opts.maxZoom)) {
        this._maxZoom = Math.floor(opts.maxZoom);
      }
      if (Number.isFinite(opts.minZoom)) {
        this._minZoom = Math.ceil(opts.minZoom);
      }
    }
    finalize() {
      for (const tile of this._cache.values()) {
        if (tile.isLoading) {
          tile.abort();
        }
      }
      this._cache.clear();
      this._tiles = [];
      this._selectedTiles = null;
    }
    reloadAll() {
      for (const id of this._cache.keys()) {
        const tile = this._cache.get(id);
        if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {
          this._cache.delete(id);
        } else {
          tile.setNeedsReload();
        }
      }
    }
    update(viewport, {
      zRange,
      modelMatrix: modelMatrix2
    } = {}) {
      const modelMatrixAsMatrix4 = new Matrix4(modelMatrix2);
      const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
      if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {
        if (isModelMatrixNew) {
          this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();
          this._modelMatrix = modelMatrixAsMatrix4;
        }
        this._viewport = viewport;
        this._zRange = zRange;
        const tileIndices = this.getTileIndices({
          viewport,
          maxZoom: this._maxZoom,
          minZoom: this._minZoom,
          zRange,
          modelMatrix: this._modelMatrix,
          modelMatrixInverse: this._modelMatrixInverse
        });
        this._selectedTiles = tileIndices.map((index) => this._getTile(index, true));
        if (this._dirty) {
          this._rebuildTree();
        }
      } else if (this.needsReload) {
        this._selectedTiles = this._selectedTiles.map((tile) => this._getTile(tile.index, true));
      }
      const changed = this.updateTileStates();
      this._pruneRequests();
      if (this._dirty) {
        this._resizeCache();
      }
      if (changed) {
        this._frameNumber++;
      }
      return this._frameNumber;
    }
    isTileVisible(tile, cullRect) {
      if (!tile.isVisible) {
        return false;
      }
      if (cullRect && this._viewport) {
        const boundsArr = this._getCullBounds({
          viewport: this._viewport,
          z: this._zRange,
          cullRect
        });
        const {
          bbox
        } = tile;
        for (const [minX, minY, maxX, maxY] of boundsArr) {
          let overlaps;
          if ("west" in bbox) {
            overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;
          } else {
            const y0 = Math.min(bbox.top, bbox.bottom);
            const y1 = Math.max(bbox.top, bbox.bottom);
            overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;
          }
          if (overlaps) {
            return true;
          }
        }
        return false;
      }
      return true;
    }
    getTileIndices({
      viewport,
      maxZoom,
      minZoom,
      zRange,
      modelMatrix: modelMatrix2,
      modelMatrixInverse
    }) {
      const {
        tileSize,
        extent,
        zoomOffset
      } = this.opts;
      return getTileIndices({
        viewport,
        maxZoom,
        minZoom,
        zRange,
        tileSize,
        extent,
        modelMatrix: modelMatrix2,
        modelMatrixInverse,
        zoomOffset
      });
    }
    getTileId(index) {
      return `${index.x}-${index.y}-${index.z}`;
    }
    getTileZoom(index) {
      return index.z;
    }
    getTileMetadata(index) {
      const {
        tileSize
      } = this.opts;
      return {
        bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize)
      };
    }
    getParentIndex(index) {
      const x2 = Math.floor(index.x / 2);
      const y2 = Math.floor(index.y / 2);
      const z = index.z - 1;
      return {
        x: x2,
        y: y2,
        z
      };
    }
    updateTileStates() {
      const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
      const visibilities = new Array(this._cache.size);
      let i3 = 0;
      for (const tile of this._cache.values()) {
        visibilities[i3++] = tile.isVisible;
        tile.isSelected = false;
        tile.isVisible = false;
      }
      for (const tile of this._selectedTiles) {
        tile.isSelected = true;
        tile.isVisible = true;
      }
      (typeof refinementStrategy === "function" ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));
      i3 = 0;
      for (const tile of this._cache.values()) {
        if (visibilities[i3++] !== tile.isVisible) {
          return true;
        }
      }
      return false;
    }
    _getCullBounds = memoize2(getCullBounds);
    _pruneRequests() {
      const {
        maxRequests = 0
      } = this.opts;
      const abortCandidates = [];
      let ongoingRequestCount = 0;
      for (const tile of this._cache.values()) {
        if (tile.isLoading) {
          ongoingRequestCount++;
          if (!tile.isSelected && !tile.isVisible) {
            abortCandidates.push(tile);
          }
        }
      }
      while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {
        const tile = abortCandidates.shift();
        tile.abort();
        ongoingRequestCount--;
      }
    }
    _rebuildTree() {
      const {
        _cache
      } = this;
      for (const tile of _cache.values()) {
        tile.parent = null;
        if (tile.children) {
          tile.children.length = 0;
        }
      }
      for (const tile of _cache.values()) {
        const parent = this._getNearestAncestor(tile);
        tile.parent = parent;
        if (parent?.children) {
          parent.children.push(tile);
        }
      }
    }
    _resizeCache() {
      const {
        _cache,
        opts
      } = this;
      const maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
      const maxCacheByteSize = opts.maxCacheByteSize || Infinity;
      const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
      if (overflown) {
        for (const [id, tile] of _cache) {
          if (!tile.isVisible && !tile.isSelected) {
            this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;
            _cache.delete(id);
            this.opts.onTileUnload?.(tile);
          }
          if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
            break;
          }
        }
        this._rebuildTree();
        this._dirty = true;
      }
      if (this._dirty) {
        this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);
        this._dirty = false;
      }
    }
    _getTile(index, create9) {
      const id = this.getTileId(index);
      let tile = this._cache.get(id);
      let needsReload = false;
      if (!tile && create9) {
        tile = new Tile2DHeader(index);
        Object.assign(tile, this.getTileMetadata(tile.index));
        Object.assign(tile, {
          id,
          zoom: this.getTileZoom(tile.index)
        });
        needsReload = true;
        this._cache.set(id, tile);
        this._dirty = true;
      } else if (tile && tile.needsReload) {
        needsReload = true;
      }
      if (tile && needsReload) {
        tile.loadData({
          getData: this.opts.getTileData,
          requestScheduler: this._requestScheduler,
          onLoad: this.onTileLoad,
          onError: this.opts.onTileError
        });
      }
      return tile;
    }
    _getNearestAncestor(tile) {
      const {
        _minZoom = 0
      } = this;
      let index = tile.index;
      while (this.getTileZoom(index) > _minZoom) {
        index = this.getParentIndex(index);
        const parent = this._getTile(index);
        if (parent) {
          return parent;
        }
      }
      return null;
    }
  };
  function updateTileStateDefault(allTiles) {
    for (const tile of allTiles) {
      tile.state = 0;
    }
    for (const tile of allTiles) {
      if (tile.isSelected && !getPlaceholderInAncestors(tile)) {
        getPlaceholderInChildren(tile);
      }
    }
    for (const tile of allTiles) {
      tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
    }
  }
  function updateTileStateReplace(allTiles) {
    for (const tile of allTiles) {
      tile.state = 0;
    }
    for (const tile of allTiles) {
      if (tile.isSelected) {
        getPlaceholderInAncestors(tile);
      }
    }
    const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);
    for (const tile of sortedTiles) {
      tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
      if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {
        for (const child of tile.children) {
          child.state = TILE_STATE_VISITED;
        }
      } else if (tile.isSelected) {
        getPlaceholderInChildren(tile);
      }
    }
  }
  function getPlaceholderInAncestors(startTile) {
    let tile = startTile;
    while (tile) {
      if (tile.isLoaded || tile.content) {
        tile.state |= TILE_STATE_VISIBLE;
        return true;
      }
      tile = tile.parent;
    }
    return false;
  }
  function getPlaceholderInChildren(tile) {
    for (const child of tile.children) {
      if (child.isLoaded || child.content) {
        child.state |= TILE_STATE_VISIBLE;
      } else {
        getPlaceholderInChildren(child);
      }
    }
  }

  // ../geo-layers/src/tile-layer/tile-layer.ts
  var defaultProps23 = {
    TilesetClass: Tileset2D,
    data: {
      type: "data",
      value: []
    },
    dataComparator: urlType.equal,
    renderSubLayers: {
      type: "function",
      value: (props) => new GeoJsonLayer(props)
    },
    getTileData: {
      type: "function",
      optional: true,
      value: null
    },
    onViewportLoad: {
      type: "function",
      optional: true,
      value: null
    },
    onTileLoad: {
      type: "function",
      value: (tile) => {
      }
    },
    onTileUnload: {
      type: "function",
      value: (tile) => {
      }
    },
    onTileError: {
      type: "function",
      value: (err) => console.error(err)
    },
    extent: {
      type: "array",
      optional: true,
      value: null,
      compare: true
    },
    tileSize: 512,
    maxZoom: null,
    minZoom: 0,
    maxCacheSize: null,
    maxCacheByteSize: null,
    refinementStrategy: STRATEGY_DEFAULT,
    zRange: null,
    maxRequests: 6,
    zoomOffset: 0
  };
  var TileLayer = class extends CompositeLayer {
    initializeState() {
      this.state = {
        tileset: null,
        isLoaded: false
      };
    }
    finalizeState() {
      this.state?.tileset?.finalize();
    }
    get isLoaded() {
      return this.state?.tileset?.selectedTiles.every((tile) => tile.isLoaded && tile.layers && tile.layers.every((layer) => layer.isLoaded));
    }
    shouldUpdateState({
      changeFlags
    }) {
      return changeFlags.somethingChanged;
    }
    updateState({
      changeFlags
    }) {
      let {
        tileset
      } = this.state;
      const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;
      const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
      if (!tileset) {
        tileset = new this.props.TilesetClass(this._getTilesetOptions());
        this.setState({
          tileset
        });
      } else if (propsChanged) {
        tileset.setOptions(this._getTilesetOptions());
        if (dataChanged) {
          tileset.reloadAll();
        } else {
          this.state.tileset.tiles.forEach((tile) => {
            tile.layers = null;
          });
        }
      }
      this._updateTileset();
    }
    _getTilesetOptions() {
      const {
        tileSize,
        maxCacheSize,
        maxCacheByteSize,
        refinementStrategy,
        extent,
        maxZoom,
        minZoom,
        maxRequests,
        zoomOffset
      } = this.props;
      return {
        maxCacheSize,
        maxCacheByteSize,
        maxZoom,
        minZoom,
        tileSize,
        refinementStrategy,
        extent,
        maxRequests,
        zoomOffset,
        getTileData: this.getTileData.bind(this),
        onTileLoad: this._onTileLoad.bind(this),
        onTileError: this._onTileError.bind(this),
        onTileUnload: this._onTileUnload.bind(this)
      };
    }
    _updateTileset() {
      const {
        tileset
      } = this.state;
      const {
        zRange,
        modelMatrix: modelMatrix2
      } = this.props;
      const frameNumber = tileset.update(this.context.viewport, {
        zRange,
        modelMatrix: modelMatrix2
      });
      const {
        isLoaded
      } = tileset;
      const loadingStateChanged = this.state.isLoaded !== isLoaded;
      const tilesetChanged = this.state.frameNumber !== frameNumber;
      if (isLoaded && (loadingStateChanged || tilesetChanged)) {
        this._onViewportLoad();
      }
      if (tilesetChanged) {
        this.setState({
          frameNumber
        });
      }
      this.state.isLoaded = isLoaded;
    }
    _onViewportLoad() {
      const {
        tileset
      } = this.state;
      const {
        onViewportLoad
      } = this.props;
      if (onViewportLoad) {
        onViewportLoad(tileset.selectedTiles);
      }
    }
    _onTileLoad(tile) {
      this.props.onTileLoad(tile);
      tile.layers = null;
      this.setNeedsUpdate();
    }
    _onTileError(error2, tile) {
      this.props.onTileError(error2);
      tile.layers = null;
      this.setNeedsUpdate();
    }
    _onTileUnload(tile) {
      this.props.onTileUnload(tile);
    }
    getTileData(tile) {
      const {
        data,
        getTileData,
        fetch: fetch2
      } = this.props;
      const {
        signal
      } = tile;
      tile.url = typeof data === "string" || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;
      if (getTileData) {
        return getTileData(tile);
      }
      if (fetch2 && tile.url) {
        return fetch2(tile.url, {
          propName: "data",
          layer: this,
          signal
        });
      }
      return null;
    }
    renderSubLayers(props) {
      return this.props.renderSubLayers(props);
    }
    getSubLayerPropsByTile(tile) {
      return null;
    }
    getPickingInfo({
      info,
      sourceLayer
    }) {
      const sourceTile = sourceLayer.props.tile;
      if (info.picked) {
        info.tile = sourceTile;
      }
      info.sourceTile = sourceTile;
      return info;
    }
    _updateAutoHighlight(info) {
      const sourceTile = info.sourceTile;
      if (sourceTile && sourceTile.layers) {
        for (const layer of sourceTile.layers) {
          layer.updateAutoHighlight(info);
        }
      }
    }
    renderLayers() {
      return this.state.tileset.tiles.map((tile) => {
        const subLayerProps = this.getSubLayerPropsByTile(tile);
        if (!tile.isLoaded && !tile.content) {
        } else if (!tile.layers) {
          const layers = this.renderSubLayers({
            ...this.props,
            id: `${this.id}-${tile.id}`,
            data: tile.content,
            _offset: 0,
            tile
          });
          tile.layers = flatten(layers, Boolean).map((layer) => layer.clone({
            tile,
            ...subLayerProps
          }));
        } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some((propName) => tile.layers[0].props[propName] !== subLayerProps[propName])) {
          tile.layers = tile.layers.map((layer) => layer.clone(subLayerProps));
        }
        return tile.layers;
      });
    }
    filterSubLayer({
      layer,
      cullRect
    }) {
      const {
        tile
      } = layer.props;
      return this.state.tileset.isTileVisible(tile, cullRect);
    }
  };
  __publicField(TileLayer, "defaultProps", defaultProps23);
  __publicField(TileLayer, "layerName", "TileLayer");

  // ../geo-layers/src/trips-layer/trips-layer.ts
  var defaultProps24 = {
    fadeTrail: true,
    trailLength: {
      type: "number",
      value: 120,
      min: 0
    },
    currentTime: {
      type: "number",
      value: 0,
      min: 0
    },
    getTimestamps: {
      type: "accessor",
      value: (d) => d.timestamps
    }
  };
  var TripsLayer = class extends PathLayer {
    getShaders() {
      const shaders = super.getShaders();
      shaders.inject = {
        "vs:#decl": `uniform float trailLength;
attribute float instanceTimestamps;
attribute float instanceNextTimestamps;
varying float vTime;
`,
        "vs:#main-end": `vTime = instanceTimestamps + (instanceNextTimestamps - instanceTimestamps) * vPathPosition.y / vPathLength;
`,
        "fs:#decl": `uniform bool fadeTrail;
uniform float trailLength;
uniform float currentTime;
varying float vTime;
`,
        "fs:#main-start": `if(vTime > currentTime || (fadeTrail && (vTime < currentTime - trailLength))) {
  discard;
}
`,
        "fs:DECKGL_FILTER_COLOR": `if(fadeTrail) {
  color.a *= 1.0 - (currentTime - vTime) / trailLength;
}
`
      };
      return shaders;
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        timestamps: {
          size: 1,
          accessor: "getTimestamps",
          shaderAttributes: {
            instanceTimestamps: {
              vertexOffset: 0
            },
            instanceNextTimestamps: {
              vertexOffset: 1
            }
          }
        }
      });
    }
    draw(params) {
      const {
        fadeTrail,
        trailLength,
        currentTime
      } = this.props;
      params.uniforms = {
        ...params.uniforms,
        fadeTrail,
        trailLength,
        currentTime
      };
      super.draw(params);
    }
  };
  __publicField(TripsLayer, "layerName", "TripsLayer");
  __publicField(TripsLayer, "defaultProps", defaultProps24);

  // ../geo-layers/src/h3-layers/h3-cluster-layer.ts
  var import_h3_js2 = __toESM(require_h3_js());

  // ../geo-layers/src/h3-layers/h3-hexagon-layer.ts
  var import_h3_js = __toESM(require_h3_js());
  var UPDATE_THRESHOLD_KM = 10;
  function normalizeLongitudes(vertices, refLng) {
    refLng = refLng === void 0 ? vertices[0][0] : refLng;
    for (const pt of vertices) {
      const deltaLng = pt[0] - refLng;
      if (deltaLng > 180) {
        pt[0] -= 360;
      } else if (deltaLng < -180) {
        pt[0] += 360;
      }
    }
  }
  function scalePolygon(hexId, vertices, factor) {
    const [lat, lng] = (0, import_h3_js.h3ToGeo)(hexId);
    const actualCount = vertices.length;
    normalizeLongitudes(vertices, lng);
    const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;
    for (let i3 = 0; i3 < vertexCount; i3++) {
      vertices[i3][0] = lerp(lng, vertices[i3][0], factor);
      vertices[i3][1] = lerp(lat, vertices[i3][1], factor);
    }
  }
  function getHexagonCentroid(getHexagon, object, objectInfo) {
    const hexagonId = getHexagon(object, objectInfo);
    const [lat, lng] = (0, import_h3_js.h3ToGeo)(hexagonId);
    return [lng, lat];
  }
  function h3ToPolygon(hexId, coverage = 1) {
    const vertices = (0, import_h3_js.h3ToGeoBoundary)(hexId, true);
    if (coverage !== 1) {
      scalePolygon(hexId, vertices, coverage);
    } else {
      normalizeLongitudes(vertices);
    }
    return vertices;
  }
  function flattenPolygon(vertices) {
    const positions = new Float64Array(vertices.length * 2);
    let i3 = 0;
    for (const pt of vertices) {
      positions[i3++] = pt[0];
      positions[i3++] = pt[1];
    }
    return positions;
  }
  function mergeTriggers(getHexagon, coverage) {
    let trigger;
    if (getHexagon === void 0 || getHexagon === null) {
      trigger = coverage;
    } else if (typeof getHexagon === "object") {
      trigger = {
        ...getHexagon,
        coverage
      };
    } else {
      trigger = {
        getHexagon,
        coverage
      };
    }
    return trigger;
  }
  var defaultProps25 = {
    ...PolygonLayer.defaultProps,
    highPrecision: "auto",
    coverage: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    centerHexagon: null,
    getHexagon: {
      type: "accessor",
      value: (x2) => x2.hexagon
    },
    extruded: true
  };
  var _H3HexagonLayer = class extends CompositeLayer {
    initializeState() {
      _H3HexagonLayer._checkH3Lib();
      this.state = {
        edgeLengthKM: 0,
        resolution: -1
      };
    }
    shouldUpdateState({
      changeFlags
    }) {
      return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;
    }
    updateState({
      props,
      changeFlags
    }) {
      if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {
        const dataProps = this._calculateH3DataProps();
        this.setState(dataProps);
      }
      this._updateVertices(this.context.viewport);
    }
    _calculateH3DataProps() {
      let resolution = -1;
      let hasPentagon = false;
      let hasMultipleRes = false;
      const {
        iterable,
        objectInfo
      } = createIterable(this.props.data);
      for (const object of iterable) {
        objectInfo.index++;
        const hexId = this.props.getHexagon(object, objectInfo);
        const hexResolution = (0, import_h3_js.h3GetResolution)(hexId);
        if (resolution < 0) {
          resolution = hexResolution;
          if (!this.props.highPrecision)
            break;
        } else if (resolution !== hexResolution) {
          hasMultipleRes = true;
          break;
        }
        if ((0, import_h3_js.h3IsPentagon)(hexId)) {
          hasPentagon = true;
          break;
        }
      }
      return {
        resolution,
        edgeLengthKM: resolution >= 0 ? (0, import_h3_js.edgeLength)(resolution, "km") : 0,
        hasMultipleRes,
        hasPentagon
      };
    }
    _shouldUseHighPrecision() {
      if (this.props.highPrecision === "auto") {
        const {
          resolution,
          hasPentagon,
          hasMultipleRes
        } = this.state;
        const {
          viewport
        } = this.context;
        return Boolean(viewport?.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;
      }
      return this.props.highPrecision;
    }
    _updateVertices(viewport) {
      if (this._shouldUseHighPrecision()) {
        return;
      }
      const {
        resolution,
        edgeLengthKM,
        centerHex
      } = this.state;
      if (resolution < 0) {
        return;
      }
      const hex = this.props.centerHexagon || (0, import_h3_js.geoToH3)(viewport.latitude, viewport.longitude, resolution);
      if (centerHex === hex) {
        return;
      }
      if (centerHex) {
        const distance3 = (0, import_h3_js.h3Distance)(centerHex, hex);
        if (distance3 >= 0 && distance3 * edgeLengthKM < UPDATE_THRESHOLD_KM) {
          return;
        }
      }
      const {
        unitsPerMeter: unitsPerMeter2
      } = viewport.distanceScales;
      let vertices = h3ToPolygon(hex);
      const [centerLat, centerLng] = (0, import_h3_js.h3ToGeo)(hex);
      const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);
      vertices = vertices.map((p2) => {
        const worldPosition = viewport.projectFlat(p2);
        return [(worldPosition[0] - centerX) / unitsPerMeter2[0], (worldPosition[1] - centerY) / unitsPerMeter2[1]];
      });
      this.setState({
        centerHex: hex,
        vertices
      });
    }
    renderLayers() {
      return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();
    }
    _getForwardProps() {
      const {
        elevationScale,
        material,
        coverage,
        extruded,
        wireframe,
        stroked,
        filled,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        getFillColor,
        getElevation,
        getLineColor,
        getLineWidth,
        transitions,
        updateTriggers
      } = this.props;
      return {
        elevationScale,
        extruded,
        coverage,
        wireframe,
        stroked,
        filled,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        material,
        getElevation,
        getFillColor,
        getLineColor,
        getLineWidth,
        transitions,
        updateTriggers: {
          getFillColor: updateTriggers.getFillColor,
          getElevation: updateTriggers.getElevation,
          getLineColor: updateTriggers.getLineColor,
          getLineWidth: updateTriggers.getLineWidth
        }
      };
    }
    _renderPolygonLayer() {
      const {
        data,
        getHexagon,
        updateTriggers,
        coverage
      } = this.props;
      const SubLayerClass = this.getSubLayerClass("hexagon-cell-hifi", PolygonLayer);
      const forwardProps2 = this._getForwardProps();
      forwardProps2.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);
      return new SubLayerClass(forwardProps2, this.getSubLayerProps({
        id: "hexagon-cell-hifi",
        updateTriggers: forwardProps2.updateTriggers
      }), {
        data,
        _normalize: false,
        _windingOrder: "CCW",
        positionFormat: "XY",
        getPolygon: (object, objectInfo) => {
          const hexagonId = getHexagon(object, objectInfo);
          return flattenPolygon(h3ToPolygon(hexagonId, coverage));
        }
      });
    }
    _renderColumnLayer() {
      const {
        data,
        getHexagon,
        updateTriggers
      } = this.props;
      const SubLayerClass = this.getSubLayerClass("hexagon-cell", ColumnLayer);
      const forwardProps2 = this._getForwardProps();
      forwardProps2.updateTriggers.getPosition = updateTriggers.getHexagon;
      return new SubLayerClass(forwardProps2, this.getSubLayerProps({
        id: "hexagon-cell",
        flatShading: true,
        updateTriggers: forwardProps2.updateTriggers
      }), {
        data,
        diskResolution: 6,
        radius: 1,
        vertices: this.state.vertices,
        getPosition: getHexagonCentroid.bind(null, getHexagon)
      });
    }
  };
  var H3HexagonLayer = _H3HexagonLayer;
  __publicField(H3HexagonLayer, "defaultProps", defaultProps25);
  __publicField(H3HexagonLayer, "layerName", "H3HexagonLayer");
  __publicField(H3HexagonLayer, "_checkH3Lib", () => {
  });

  // ../geo-layers/src/h3-layers/h3-cluster-layer.ts
  var defaultProps26 = {
    getHexagons: {
      type: "accessor",
      value: (d) => d.hexagons
    }
  };
  var H3ClusterLayer = class extends GeoCellLayer {
    initializeState() {
      H3HexagonLayer._checkH3Lib();
    }
    updateState({
      props,
      changeFlags
    }) {
      if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagons) {
        const {
          data,
          getHexagons
        } = props;
        const polygons = [];
        const {
          iterable,
          objectInfo
        } = createIterable(data);
        for (const object of iterable) {
          objectInfo.index++;
          const hexagons = getHexagons(object, objectInfo);
          const multiPolygon = (0, import_h3_js2.h3SetToMultiPolygon)(hexagons, true);
          for (const polygon of multiPolygon) {
            polygons.push(this.getSubLayerRow({
              polygon
            }, object, objectInfo.index));
          }
        }
        this.setState({
          polygons
        });
      }
    }
    indexToBounds() {
      const {
        getElevation,
        getFillColor,
        getLineColor,
        getLineWidth
      } = this.props;
      return {
        data: this.state.polygons,
        getPolygon: (d) => d.polygon,
        getElevation: this.getSubLayerAccessor(getElevation),
        getFillColor: this.getSubLayerAccessor(getFillColor),
        getLineColor: this.getSubLayerAccessor(getLineColor),
        getLineWidth: this.getSubLayerAccessor(getLineWidth)
      };
    }
  };
  __publicField(H3ClusterLayer, "layerName", "H3ClusterLayer");
  __publicField(H3ClusterLayer, "defaultProps", defaultProps26);

  // ../mesh-layers/src/utils/matrix.ts
  var RADIAN_PER_DEGREE = Math.PI / 180;
  var modelMatrix = new Float32Array(16);
  var valueArray = new Float32Array(12);
  function calculateTransformMatrix(targetMatrix, orientation, scale8) {
    const pitch = orientation[0] * RADIAN_PER_DEGREE;
    const yaw = orientation[1] * RADIAN_PER_DEGREE;
    const roll = orientation[2] * RADIAN_PER_DEGREE;
    const sr = Math.sin(roll);
    const sp = Math.sin(pitch);
    const sw = Math.sin(yaw);
    const cr = Math.cos(roll);
    const cp = Math.cos(pitch);
    const cw = Math.cos(yaw);
    const scx = scale8[0];
    const scy = scale8[1];
    const scz = scale8[2];
    targetMatrix[0] = scx * cw * cp;
    targetMatrix[1] = scx * sw * cp;
    targetMatrix[2] = scx * -sp;
    targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);
    targetMatrix[4] = scy * (cw * cr + sw * sp * sr);
    targetMatrix[5] = scy * cp * sr;
    targetMatrix[6] = scz * (sw * sr + cw * sp * cr);
    targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);
    targetMatrix[8] = scz * cp * cr;
  }
  function getExtendedMat3FromMat4(mat4) {
    mat4[0] = mat4[0];
    mat4[1] = mat4[1];
    mat4[2] = mat4[2];
    mat4[3] = mat4[4];
    mat4[4] = mat4[5];
    mat4[5] = mat4[6];
    mat4[6] = mat4[8];
    mat4[7] = mat4[9];
    mat4[8] = mat4[10];
    mat4[9] = mat4[12];
    mat4[10] = mat4[13];
    mat4[11] = mat4[14];
    return mat4.subarray(0, 12);
  }
  var MATRIX_ATTRIBUTES = {
    size: 12,
    accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
    shaderAttributes: {
      instanceModelMatrix__LOCATION_0: {
        size: 3,
        elementOffset: 0
      },
      instanceModelMatrix__LOCATION_1: {
        size: 3,
        elementOffset: 3
      },
      instanceModelMatrix__LOCATION_2: {
        size: 3,
        elementOffset: 6
      },
      instanceTranslation: {
        size: 3,
        elementOffset: 9
      }
    },
    update(attribute, {
      startRow,
      endRow
    }) {
      const {
        data,
        getOrientation,
        getScale: getScale3,
        getTranslation: getTranslation2,
        getTransformMatrix
      } = this.props;
      const arrayMatrix = Array.isArray(getTransformMatrix);
      const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;
      const constantScale = Array.isArray(getScale3);
      const constantOrientation = Array.isArray(getOrientation);
      const constantTranslation = Array.isArray(getTranslation2);
      const hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));
      if (hasMatrix) {
        attribute.constant = constantMatrix;
      } else {
        attribute.constant = constantOrientation && constantScale && constantTranslation;
      }
      const instanceModelMatrixData = attribute.value;
      if (attribute.constant) {
        let matrix;
        if (hasMatrix) {
          modelMatrix.set(getTransformMatrix);
          matrix = getExtendedMat3FromMat4(modelMatrix);
        } else {
          matrix = valueArray;
          const orientation = getOrientation;
          const scale8 = getScale3;
          calculateTransformMatrix(matrix, orientation, scale8);
          matrix.set(getTranslation2, 9);
        }
        attribute.value = new Float32Array(matrix);
      } else {
        let i3 = startRow * attribute.size;
        const {
          iterable,
          objectInfo
        } = createIterable(data, startRow, endRow);
        for (const object of iterable) {
          objectInfo.index++;
          let matrix;
          if (hasMatrix) {
            modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));
            matrix = getExtendedMat3FromMat4(modelMatrix);
          } else {
            matrix = valueArray;
            const orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);
            const scale8 = constantScale ? getScale3 : getScale3(object, objectInfo);
            calculateTransformMatrix(matrix, orientation, scale8);
            matrix.set(constantTranslation ? getTranslation2 : getTranslation2(object, objectInfo), 9);
          }
          instanceModelMatrixData[i3++] = matrix[0];
          instanceModelMatrixData[i3++] = matrix[1];
          instanceModelMatrixData[i3++] = matrix[2];
          instanceModelMatrixData[i3++] = matrix[3];
          instanceModelMatrixData[i3++] = matrix[4];
          instanceModelMatrixData[i3++] = matrix[5];
          instanceModelMatrixData[i3++] = matrix[6];
          instanceModelMatrixData[i3++] = matrix[7];
          instanceModelMatrixData[i3++] = matrix[8];
          instanceModelMatrixData[i3++] = matrix[9];
          instanceModelMatrixData[i3++] = matrix[10];
          instanceModelMatrixData[i3++] = matrix[11];
        }
      }
    }
  };
  function shouldComposeModelMatrix(viewport, coordinateSystem) {
    return coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial;
  }

  // ../mesh-layers/src/simple-mesh-layer/simple-mesh-layer-vertex.glsl.ts
  var simple_mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs

// Scale the model
uniform float sizeScale;
uniform bool composeModelMatrix;

// Primitive attributes
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;

// Instance attributes
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
in vec3 instanceTranslation;

// Outputs to fragment shader
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = texCoords;
  geometry.pickingColor = instancePickingColors;

  vTexCoord = texCoords;
  cameraPosition = project_uCameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;

  if (composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    // using instancePositions as world coordinates
    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth
    // call project_normal before setting position to avoid rotation
    normals_commonspace = project_normal(instanceModelMatrix * normals);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
    geometry.position = position_commonspace;
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
    geometry.position = position_commonspace;
    normals_commonspace = project_normal(instanceModelMatrix * normals);
  }

  geometry.normal = normals_commonspace;
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../mesh-layers/src/simple-mesh-layer/simple-mesh-layer-fragment.glsl.ts
  var simple_mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  geometry.uv = vTexCoord;

  vec3 normal;
  if (flatShading) {

// NOTE(Tarek): This is necessary because
// headless.gl reports the extension as
// available but does not support it in
// the shader.
#ifdef DERIVATIVES_AVAILABLE
    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
#else
    normal = vec3(0.0, 0.0, 1.0);
#endif
  } else {
    normal = normals_commonspace;
  }

  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
  DECKGL_FILTER_COLOR(color, geometry);

  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * opacity);
}
`;

  // ../../node_modules/@loaders.gl/schema/dist/esm/category/mesh/mesh-utils.js
  function getMeshBoundingBox(attributes) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    const positions = attributes.POSITION ? attributes.POSITION.value : [];
    const len3 = positions && positions.length;
    for (let i3 = 0; i3 < len3; i3 += 3) {
      const x2 = positions[i3];
      const y2 = positions[i3 + 1];
      const z = positions[i3 + 2];
      minX = x2 < minX ? x2 : minX;
      minY = y2 < minY ? y2 : minY;
      minZ = z < minZ ? z : minZ;
      maxX = x2 > maxX ? x2 : maxX;
      maxY = y2 > maxY ? y2 : maxY;
      maxZ = z > maxZ ? z : maxZ;
    }
    return [[minX, minY, minZ], [maxX, maxY, maxZ]];
  }

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/utils/assert.js
  function assert12(condition, message) {
    if (!condition) {
      throw new Error(message || "loader assertion failed.");
    }
  }

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/schema.js
  var Schema = class {
    constructor(fields, metadata) {
      _defineProperty(this, "fields", void 0);
      _defineProperty(this, "metadata", void 0);
      assert12(Array.isArray(fields));
      checkNames(fields);
      this.fields = fields;
      this.metadata = metadata || /* @__PURE__ */ new Map();
    }
    compareTo(other) {
      if (this.metadata !== other.metadata) {
        return false;
      }
      if (this.fields.length !== other.fields.length) {
        return false;
      }
      for (let i3 = 0; i3 < this.fields.length; ++i3) {
        if (!this.fields[i3].compareTo(other.fields[i3])) {
          return false;
        }
      }
      return true;
    }
    select() {
      const nameMap = /* @__PURE__ */ Object.create(null);
      for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {
        columnNames[_key] = arguments[_key];
      }
      for (const name10 of columnNames) {
        nameMap[name10] = true;
      }
      const selectedFields = this.fields.filter((field) => nameMap[field.name]);
      return new Schema(selectedFields, this.metadata);
    }
    selectAt() {
      for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        columnIndices[_key2] = arguments[_key2];
      }
      const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);
      return new Schema(selectedFields, this.metadata);
    }
    assign(schemaOrFields) {
      let fields;
      let metadata = this.metadata;
      if (schemaOrFields instanceof Schema) {
        const otherSchema = schemaOrFields;
        fields = otherSchema.fields;
        metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), otherSchema.metadata);
      } else {
        fields = schemaOrFields;
      }
      const fieldMap = /* @__PURE__ */ Object.create(null);
      for (const field of this.fields) {
        fieldMap[field.name] = field;
      }
      for (const field of fields) {
        fieldMap[field.name] = field;
      }
      const mergedFields = Object.values(fieldMap);
      return new Schema(mergedFields, metadata);
    }
  };
  function checkNames(fields) {
    const usedNames = {};
    for (const field of fields) {
      if (usedNames[field.name]) {
        console.warn("Schema: duplicated field name", field.name, field);
      }
      usedNames[field.name] = true;
    }
  }
  function mergeMaps(m1, m2) {
    return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
  }

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/field.js
  var Field = class {
    constructor(name10, type) {
      let nullable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      let metadata = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : /* @__PURE__ */ new Map();
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "nullable", void 0);
      _defineProperty(this, "metadata", void 0);
      this.name = name10;
      this.type = type;
      this.nullable = nullable;
      this.metadata = metadata;
    }
    get typeId() {
      return this.type && this.type.typeId;
    }
    clone() {
      return new Field(this.name, this.type, this.nullable, this.metadata);
    }
    compareTo(other) {
      return this.name === other.name && this.type === other.type && this.nullable === other.nullable && this.metadata === other.metadata;
    }
    toString() {
      return "".concat(this.type).concat(this.nullable ? ", nullable" : "").concat(this.metadata ? ", metadata: ".concat(this.metadata) : "");
    }
  };

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/enum.js
  var Type = function(Type2) {
    Type2[Type2["NONE"] = 0] = "NONE";
    Type2[Type2["Null"] = 1] = "Null";
    Type2[Type2["Int"] = 2] = "Int";
    Type2[Type2["Float"] = 3] = "Float";
    Type2[Type2["Binary"] = 4] = "Binary";
    Type2[Type2["Utf8"] = 5] = "Utf8";
    Type2[Type2["Bool"] = 6] = "Bool";
    Type2[Type2["Decimal"] = 7] = "Decimal";
    Type2[Type2["Date"] = 8] = "Date";
    Type2[Type2["Time"] = 9] = "Time";
    Type2[Type2["Timestamp"] = 10] = "Timestamp";
    Type2[Type2["Interval"] = 11] = "Interval";
    Type2[Type2["List"] = 12] = "List";
    Type2[Type2["Struct"] = 13] = "Struct";
    Type2[Type2["Union"] = 14] = "Union";
    Type2[Type2["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type2[Type2["FixedSizeList"] = 16] = "FixedSizeList";
    Type2[Type2["Map"] = 17] = "Map";
    Type2[Type2["Dictionary"] = -1] = "Dictionary";
    Type2[Type2["Int8"] = -2] = "Int8";
    Type2[Type2["Int16"] = -3] = "Int16";
    Type2[Type2["Int32"] = -4] = "Int32";
    Type2[Type2["Int64"] = -5] = "Int64";
    Type2[Type2["Uint8"] = -6] = "Uint8";
    Type2[Type2["Uint16"] = -7] = "Uint16";
    Type2[Type2["Uint32"] = -8] = "Uint32";
    Type2[Type2["Uint64"] = -9] = "Uint64";
    Type2[Type2["Float16"] = -10] = "Float16";
    Type2[Type2["Float32"] = -11] = "Float32";
    Type2[Type2["Float64"] = -12] = "Float64";
    Type2[Type2["DateDay"] = -13] = "DateDay";
    Type2[Type2["DateMillisecond"] = -14] = "DateMillisecond";
    Type2[Type2["TimestampSecond"] = -15] = "TimestampSecond";
    Type2[Type2["TimestampMillisecond"] = -16] = "TimestampMillisecond";
    Type2[Type2["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
    Type2[Type2["TimestampNanosecond"] = -18] = "TimestampNanosecond";
    Type2[Type2["TimeSecond"] = -19] = "TimeSecond";
    Type2[Type2["TimeMillisecond"] = -20] = "TimeMillisecond";
    Type2[Type2["TimeMicrosecond"] = -21] = "TimeMicrosecond";
    Type2[Type2["TimeNanosecond"] = -22] = "TimeNanosecond";
    Type2[Type2["DenseUnion"] = -23] = "DenseUnion";
    Type2[Type2["SparseUnion"] = -24] = "SparseUnion";
    Type2[Type2["IntervalDayTime"] = -25] = "IntervalDayTime";
    Type2[Type2["IntervalYearMonth"] = -26] = "IntervalYearMonth";
    return Type2;
  }({});

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/type.js
  var _Symbol$toStringTag;
  var _Symbol$toStringTag2;
  var _Symbol$toStringTag3;
  var _Symbol$toStringTag4;
  var _Symbol$toStringTag5;
  var _Symbol$toStringTag6;
  var _Symbol$toStringTag7;
  var _Symbol$toStringTag8;
  var DataType = class {
    static isNull(x2) {
      return x2 && x2.typeId === Type.Null;
    }
    static isInt(x2) {
      return x2 && x2.typeId === Type.Int;
    }
    static isFloat(x2) {
      return x2 && x2.typeId === Type.Float;
    }
    static isBinary(x2) {
      return x2 && x2.typeId === Type.Binary;
    }
    static isUtf8(x2) {
      return x2 && x2.typeId === Type.Utf8;
    }
    static isBool(x2) {
      return x2 && x2.typeId === Type.Bool;
    }
    static isDecimal(x2) {
      return x2 && x2.typeId === Type.Decimal;
    }
    static isDate(x2) {
      return x2 && x2.typeId === Type.Date;
    }
    static isTime(x2) {
      return x2 && x2.typeId === Type.Time;
    }
    static isTimestamp(x2) {
      return x2 && x2.typeId === Type.Timestamp;
    }
    static isInterval(x2) {
      return x2 && x2.typeId === Type.Interval;
    }
    static isList(x2) {
      return x2 && x2.typeId === Type.List;
    }
    static isStruct(x2) {
      return x2 && x2.typeId === Type.Struct;
    }
    static isUnion(x2) {
      return x2 && x2.typeId === Type.Union;
    }
    static isFixedSizeBinary(x2) {
      return x2 && x2.typeId === Type.FixedSizeBinary;
    }
    static isFixedSizeList(x2) {
      return x2 && x2.typeId === Type.FixedSizeList;
    }
    static isMap(x2) {
      return x2 && x2.typeId === Type.Map;
    }
    static isDictionary(x2) {
      return x2 && x2.typeId === Type.Dictionary;
    }
    get typeId() {
      return Type.NONE;
    }
    compareTo(other) {
      return this === other;
    }
  };
  var Null = class extends DataType {
    get typeId() {
      return Type.Null;
    }
    get [Symbol.toStringTag]() {
      return "Null";
    }
    toString() {
      return "Null";
    }
  };
  var Bool = class extends DataType {
    get typeId() {
      return Type.Bool;
    }
    get [Symbol.toStringTag]() {
      return "Bool";
    }
    toString() {
      return "Bool";
    }
  };
  _Symbol$toStringTag = Symbol.toStringTag;
  var Int = class extends DataType {
    constructor(isSigned, bitWidth) {
      super();
      _defineProperty(this, "isSigned", void 0);
      _defineProperty(this, "bitWidth", void 0);
      this.isSigned = isSigned;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Int;
    }
    get [_Symbol$toStringTag]() {
      return "Int";
    }
    toString() {
      return "".concat(this.isSigned ? "I" : "Ui", "nt").concat(this.bitWidth);
    }
  };
  var Int8 = class extends Int {
    constructor() {
      super(true, 8);
    }
  };
  var Int16 = class extends Int {
    constructor() {
      super(true, 16);
    }
  };
  var Int32 = class extends Int {
    constructor() {
      super(true, 32);
    }
  };
  var Uint8 = class extends Int {
    constructor() {
      super(false, 8);
    }
  };
  var Uint16 = class extends Int {
    constructor() {
      super(false, 16);
    }
  };
  var Uint32 = class extends Int {
    constructor() {
      super(false, 32);
    }
  };
  var Precision = {
    HALF: 16,
    SINGLE: 32,
    DOUBLE: 64
  };
  _Symbol$toStringTag2 = Symbol.toStringTag;
  var Float = class extends DataType {
    constructor(precision) {
      super();
      _defineProperty(this, "precision", void 0);
      this.precision = precision;
    }
    get typeId() {
      return Type.Float;
    }
    get [_Symbol$toStringTag2]() {
      return "Float";
    }
    toString() {
      return "Float".concat(this.precision);
    }
  };
  var Float32 = class extends Float {
    constructor() {
      super(Precision.SINGLE);
    }
  };
  var Float64 = class extends Float {
    constructor() {
      super(Precision.DOUBLE);
    }
  };
  var Binary = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Binary;
    }
    toString() {
      return "Binary";
    }
    get [Symbol.toStringTag]() {
      return "Binary";
    }
  };
  var Utf8 = class extends DataType {
    get typeId() {
      return Type.Utf8;
    }
    get [Symbol.toStringTag]() {
      return "Utf8";
    }
    toString() {
      return "Utf8";
    }
  };
  var DateUnit = {
    DAY: 0,
    MILLISECOND: 1
  };
  _Symbol$toStringTag3 = Symbol.toStringTag;
  var Date2 = class extends DataType {
    constructor(unit) {
      super();
      _defineProperty(this, "unit", void 0);
      this.unit = unit;
    }
    get typeId() {
      return Type.Date;
    }
    get [_Symbol$toStringTag3]() {
      return "Date";
    }
    toString() {
      return "Date".concat((this.unit + 1) * 32, "<").concat(DateUnit[this.unit], ">");
    }
  };
  var TimeUnit = {
    SECOND: 1,
    MILLISECOND: 1e3,
    MICROSECOND: 1e6,
    NANOSECOND: 1e9
  };
  _Symbol$toStringTag4 = Symbol.toStringTag;
  var Time = class extends DataType {
    constructor(unit, bitWidth) {
      super();
      _defineProperty(this, "unit", void 0);
      _defineProperty(this, "bitWidth", void 0);
      this.unit = unit;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Time;
    }
    toString() {
      return "Time".concat(this.bitWidth, "<").concat(TimeUnit[this.unit], ">");
    }
    get [_Symbol$toStringTag4]() {
      return "Time";
    }
  };
  _Symbol$toStringTag5 = Symbol.toStringTag;
  var Timestamp = class extends DataType {
    constructor(unit) {
      let timezone = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      super();
      _defineProperty(this, "unit", void 0);
      _defineProperty(this, "timezone", void 0);
      this.unit = unit;
      this.timezone = timezone;
    }
    get typeId() {
      return Type.Timestamp;
    }
    get [_Symbol$toStringTag5]() {
      return "Timestamp";
    }
    toString() {
      return "Timestamp<".concat(TimeUnit[this.unit]).concat(this.timezone ? ", ".concat(this.timezone) : "", ">");
    }
  };
  var IntervalUnit = {
    DAY_TIME: 0,
    YEAR_MONTH: 1
  };
  _Symbol$toStringTag6 = Symbol.toStringTag;
  var Interval = class extends DataType {
    constructor(unit) {
      super();
      _defineProperty(this, "unit", void 0);
      this.unit = unit;
    }
    get typeId() {
      return Type.Interval;
    }
    get [_Symbol$toStringTag6]() {
      return "Interval";
    }
    toString() {
      return "Interval<".concat(IntervalUnit[this.unit], ">");
    }
  };
  _Symbol$toStringTag7 = Symbol.toStringTag;
  var FixedSizeList = class extends DataType {
    constructor(listSize, child) {
      super();
      _defineProperty(this, "listSize", void 0);
      _defineProperty(this, "children", void 0);
      this.listSize = listSize;
      this.children = [child];
    }
    get typeId() {
      return Type.FixedSizeList;
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get [_Symbol$toStringTag7]() {
      return "FixedSizeList";
    }
    toString() {
      return "FixedSizeList[".concat(this.listSize, "]<").concat(this.valueType, ">");
    }
  };
  _Symbol$toStringTag8 = Symbol.toStringTag;
  var Struct = class extends DataType {
    constructor(children) {
      super();
      _defineProperty(this, "children", void 0);
      this.children = children;
    }
    get typeId() {
      return Type.Struct;
    }
    toString() {
      return "Struct<{".concat(this.children.map((f2) => "".concat(f2.name, ":").concat(f2.type)).join(", "), "}>");
    }
    get [_Symbol$toStringTag8]() {
      return "Struct";
    }
  };

  // ../../node_modules/@loaders.gl/schema/dist/esm/lib/arrow/arrow-like-type-utils.js
  function getArrowTypeFromTypedArray(array) {
    switch (array.constructor) {
      case Int8Array:
        return new Int8();
      case Uint8Array:
        return new Uint8();
      case Int16Array:
        return new Int16();
      case Uint16Array:
        return new Uint16();
      case Int32Array:
        return new Int32();
      case Uint32Array:
        return new Uint32();
      case Float32Array:
        return new Float32();
      case Float64Array:
        return new Float64();
      default:
        throw new Error("array type not supported");
    }
  }

  // ../../node_modules/@loaders.gl/schema/dist/esm/category/mesh/deduce-mesh-schema.js
  function deduceMeshField(attributeName, attribute, optionalMetadata) {
    const type = getArrowTypeFromTypedArray(attribute.value);
    const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);
    const field = new Field(attributeName, new FixedSizeList(attribute.size, new Field("value", type)), false, metadata);
    return field;
  }
  function makeMeshAttributeMetadata(attribute) {
    const result = /* @__PURE__ */ new Map();
    if ("byteOffset" in attribute) {
      result.set("byteOffset", attribute.byteOffset.toString(10));
    }
    if ("byteStride" in attribute) {
      result.set("byteStride", attribute.byteStride.toString(10));
    }
    if ("normalized" in attribute) {
      result.set("normalized", attribute.normalized.toString());
    }
    return result;
  }

  // ../mesh-layers/src/simple-mesh-layer/simple-mesh-layer.ts
  function validateGeometryAttributes(attributes, useMeshColors) {
    const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
    const useColorAttribute = hasColorAttribute && useMeshColors;
    if (!useColorAttribute) {
      attributes.colors = {
        constant: true,
        value: new Float32Array([1, 1, 1])
      };
    }
    log_default.assert(attributes.positions || attributes.POSITION, 'no "postions" or "POSITION" attribute in mesh');
  }
  function getGeometry(data, useMeshColors) {
    if (data.attributes) {
      validateGeometryAttributes(data.attributes, useMeshColors);
      if (data instanceof Geometry) {
        return data;
      } else {
        return new Geometry(data);
      }
    } else if (data.positions || data.POSITION) {
      validateGeometryAttributes(data, useMeshColors);
      return new Geometry({
        attributes: data
      });
    }
    throw Error("Invalid mesh");
  }
  var DEFAULT_COLOR10 = [0, 0, 0, 255];
  var defaultProps27 = {
    mesh: {
      type: "object",
      value: null,
      async: true
    },
    texture: {
      type: "image",
      value: null,
      async: true
    },
    sizeScale: {
      type: "number",
      value: 1,
      min: 0
    },
    _useMeshColors: {
      type: "boolean",
      value: false
    },
    _instanced: true,
    wireframe: false,
    material: true,
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR10
    },
    getOrientation: {
      type: "accessor",
      value: [0, 0, 0]
    },
    getScale: {
      type: "accessor",
      value: [1, 1, 1]
    },
    getTranslation: {
      type: "accessor",
      value: [0, 0, 0]
    },
    getTransformMatrix: {
      type: "accessor",
      value: []
    },
    textureParameters: {
      type: "object",
      ignore: true
    }
  };
  var SimpleMeshLayer = class extends Layer {
    getShaders() {
      const transpileToGLSL100 = !isWebGL2(this.context.gl);
      const defines2 = {};
      if (hasFeature(this.context.gl, FEATURES.GLSL_DERIVATIVES)) {
        defines2.DERIVATIVES_AVAILABLE = 1;
      }
      return super.getShaders({
        vs: simple_mesh_layer_vertex_glsl_default,
        fs: simple_mesh_layer_fragment_glsl_default,
        modules: [project32_default, phongLighting, picking_default],
        transpileToGLSL100,
        defines: defines2
      });
    }
    getBounds() {
      if (this.props._instanced) {
        return super.getBounds();
      }
      let result = this.state.positionBounds;
      if (result) {
        return result;
      }
      const {
        mesh
      } = this.props;
      if (!mesh) {
        return null;
      }
      result = mesh.header?.boundingBox;
      if (!result) {
        const {
          attributes
        } = getGeometry(mesh, this.props._useMeshColors);
        attributes.POSITION = attributes.POSITION || attributes.positions;
        result = getMeshBoundingBox(attributes);
      }
      this.state.positionBounds = result;
      return result;
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          transition: true,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          size: 3,
          accessor: "getPosition"
        },
        instanceColors: {
          type: esm_default2.UNSIGNED_BYTE,
          transition: true,
          size: this.props.colorFormat.length,
          normalized: true,
          accessor: "getColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceModelMatrix: MATRIX_ATTRIBUTES
      });
      this.setState({
        emptyTexture: new Texture2D(this.context.gl, {
          data: new Uint8Array(4),
          width: 1,
          height: 1
        })
      });
    }
    updateState(params) {
      super.updateState(params);
      const {
        props,
        oldProps,
        changeFlags
      } = params;
      if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
        this.state.positionBounds = null;
        this.state.model?.delete();
        if (props.mesh) {
          this.state.model = this.getModel(props.mesh);
          const attributes = props.mesh.attributes || props.mesh;
          this.setState({
            hasNormals: Boolean(attributes.NORMAL || attributes.normals)
          });
        }
        this.getAttributeManager().invalidateAll();
      }
      if (props.texture !== oldProps.texture) {
        this.setTexture(props.texture);
      }
      if (this.state.model) {
        this.state.model.setDrawMode(this.props.wireframe ? esm_default2.LINE_STRIP : esm_default2.TRIANGLES);
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.emptyTexture.delete();
    }
    draw({
      uniforms
    }) {
      if (!this.state.model) {
        return;
      }
      const {
        viewport
      } = this.context;
      const {
        sizeScale,
        coordinateSystem,
        _instanced
      } = this.props;
      this.state.model.setUniforms(uniforms).setUniforms({
        sizeScale,
        composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),
        flatShading: !this.state.hasNormals
      }).draw();
    }
    getModel(mesh) {
      const model = new Model(this.context.gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: getGeometry(mesh, this.props._useMeshColors),
        isInstanced: true
      });
      const {
        texture
      } = this.props;
      const {
        emptyTexture
      } = this.state;
      model.setUniforms({
        sampler: texture || emptyTexture,
        hasTexture: Boolean(texture)
      });
      return model;
    }
    setTexture(texture) {
      const {
        emptyTexture,
        model
      } = this.state;
      if (model) {
        model.setUniforms({
          sampler: texture || emptyTexture,
          hasTexture: Boolean(texture)
        });
      }
    }
  };
  __publicField(SimpleMeshLayer, "defaultProps", defaultProps27);
  __publicField(SimpleMeshLayer, "layerName", "SimpleMeshLayer");

  // ../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/scenegraph-node.js
  var ScenegraphNode = class {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        id
      } = props;
      this.id = id || uid(this.constructor.name);
      this.display = true;
      this.position = new Vector3();
      this.rotation = new Vector3();
      this.scale = new Vector3(1, 1, 1);
      this.matrix = new Matrix4();
      this.userData = {};
      this.props = {};
      this._setScenegraphNodeProps(props);
    }
    delete() {
    }
    setProps(props) {
      this._setScenegraphNodeProps(props);
      return this;
    }
    toString() {
      return "{type: ScenegraphNode, id: ".concat(this.id, ")}");
    }
    getBounds() {
      return null;
    }
    setPosition(position) {
      assert7(position.length === 3, "setPosition requires vector argument");
      this.position = position;
      return this;
    }
    setRotation(rotation) {
      assert7(rotation.length === 3, "setRotation requires vector argument");
      this.rotation = rotation;
      return this;
    }
    setScale(scale8) {
      assert7(scale8.length === 3, "setScale requires vector argument");
      this.scale = scale8;
      return this;
    }
    setMatrix(matrix) {
      let copyMatrix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (copyMatrix) {
        this.matrix.copy(matrix);
      } else {
        this.matrix = matrix;
      }
    }
    setMatrixComponents(_ref) {
      let {
        position,
        rotation,
        scale: scale8,
        update = true
      } = _ref;
      if (position) {
        this.setPosition(position);
      }
      if (rotation) {
        this.setRotation(rotation);
      }
      if (scale8) {
        this.setScale(scale8);
      }
      if (update) {
        this.updateMatrix();
      }
      return this;
    }
    updateMatrix() {
      const pos = this.position;
      const rot = this.rotation;
      const scale8 = this.scale;
      this.matrix.identity();
      this.matrix.translate(pos);
      this.matrix.rotateXYZ(rot);
      this.matrix.scale(scale8);
      return this;
    }
    update() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        position,
        rotation,
        scale: scale8
      } = options;
      if (position) {
        this.setPosition(position);
      }
      if (rotation) {
        this.setRotation(rotation);
      }
      if (scale8) {
        this.setScale(scale8);
      }
      this.updateMatrix();
      return this;
    }
    getCoordinateUniforms(viewMatrix2, modelMatrix2) {
      assert7(viewMatrix2);
      modelMatrix2 = modelMatrix2 || this.matrix;
      const worldMatrix = new Matrix4(viewMatrix2).multiplyRight(modelMatrix2);
      const worldInverse = worldMatrix.invert();
      const worldInverseTranspose = worldInverse.transpose();
      return {
        viewMatrix: viewMatrix2,
        modelMatrix: modelMatrix2,
        objectMatrix: modelMatrix2,
        worldMatrix,
        worldInverseMatrix: worldInverse,
        worldInverseTransposeMatrix: worldInverseTranspose
      };
    }
    _setScenegraphNodeProps(props) {
      if ("display" in props) {
        this.display = props.display;
      }
      if ("position" in props) {
        this.setPosition(props.position);
      }
      if ("rotation" in props) {
        this.setRotation(props.rotation);
      }
      if ("scale" in props) {
        this.setScale(props.scale);
      }
      if ("matrix" in props) {
        this.setMatrix(props.matrix);
      }
      Object.assign(this.props, props);
    }
  };

  // ../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/group-node.js
  var GroupNode = class extends ScenegraphNode {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      props = Array.isArray(props) ? {
        children: props
      } : props;
      const {
        children = []
      } = props;
      log2.assert(children.every((child) => child instanceof ScenegraphNode), "every child must an instance of ScenegraphNode");
      super(props);
      this.children = children;
    }
    add() {
      for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
        children[_key] = arguments[_key];
      }
      for (const child of children) {
        if (Array.isArray(child)) {
          this.add(...child);
        } else {
          this.children.push(child);
        }
      }
      return this;
    }
    remove(child) {
      const children = this.children;
      const indexOf = children.indexOf(child);
      if (indexOf > -1) {
        children.splice(indexOf, 1);
      }
      return this;
    }
    removeAll() {
      this.children = [];
      return this;
    }
    delete() {
      this.children.forEach((child) => child.delete());
      this.removeAll();
      super.delete();
    }
    getBounds() {
      const result = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
      this.traverse((node2, _ref) => {
        let {
          worldMatrix
        } = _ref;
        const bounds = node2.getBounds();
        if (!bounds) {
          return;
        }
        const [min, max] = bounds;
        const center = new Vector3(min).add(max).divide([2, 2, 2]);
        worldMatrix.transformAsPoint(center, center);
        const halfSize = new Vector3(max).subtract(min).divide([2, 2, 2]);
        worldMatrix.transformAsVector(halfSize, halfSize);
        for (let v = 0; v < 8; v++) {
          const position = new Vector3(v & 1 ? -1 : 1, v & 2 ? -1 : 1, v & 4 ? -1 : 1).multiply(halfSize).add(center);
          for (let i3 = 0; i3 < 3; i3++) {
            result[0][i3] = Math.min(result[0][i3], position[i3]);
            result[1][i3] = Math.max(result[1][i3], position[i3]);
          }
        }
      });
      if (!Number.isFinite(result[0][0])) {
        return null;
      }
      return result;
    }
    traverse(visitor) {
      let {
        worldMatrix = new Matrix4()
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const modelMatrix2 = new Matrix4(worldMatrix).multiplyRight(this.matrix);
      for (const child of this.children) {
        if (child instanceof GroupNode) {
          child.traverse(visitor, {
            worldMatrix: modelMatrix2
          });
        } else {
          visitor(child, {
            worldMatrix: modelMatrix2
          });
        }
      }
    }
  };

  // ../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-animator.js
  var ATTRIBUTE_TYPE_TO_COMPONENTS = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  function accessorToJsArray(accessor) {
    if (!accessor._animation) {
      const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
      const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
      const length7 = components * accessor.count;
      const {
        buffer,
        byteOffset
      } = accessor.bufferView.data;
      const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length7);
      if (components === 1) {
        accessor._animation = Array.from(array);
      } else {
        const slicedArray = [];
        for (let i3 = 0; i3 < array.length; i3 += components) {
          slicedArray.push(Array.from(array.slice(i3, i3 + components)));
        }
        accessor._animation = slicedArray;
      }
    }
    return accessor._animation;
  }
  var helperMatrix = new Matrix4();
  function applyTranslationRotationScale(gltfNode, node2) {
    node2.matrix.identity();
    if (gltfNode.translation) {
      node2.matrix.translate(gltfNode.translation);
    }
    if (gltfNode.rotation) {
      const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);
      node2.matrix.multiplyRight(rotationMatrix);
    }
    if (gltfNode.scale) {
      node2.matrix.scale(gltfNode.scale);
    }
  }
  var quaternion = new Quaternion();
  function linearInterpolate(target, path, start, stop, ratio) {
    if (path === "rotation") {
      quaternion.slerp({
        start,
        target: stop,
        ratio
      });
      for (let i3 = 0; i3 < quaternion.length; i3++) {
        target[path][i3] = quaternion[i3];
      }
    } else {
      for (let i3 = 0; i3 < start.length; i3++) {
        target[path][i3] = ratio * stop[i3] + (1 - ratio) * start[i3];
      }
    }
  }
  function cubicsplineInterpolate(target, path, _ref) {
    let {
      p0,
      outTangent0,
      inTangent1,
      p1,
      tDiff,
      ratio: t2
    } = _ref;
    for (let i3 = 0; i3 < target[path].length; i3++) {
      const m0 = outTangent0[i3] * tDiff;
      const m1 = inTangent1[i3] * tDiff;
      target[path][i3] = (2 * Math.pow(t2, 3) - 3 * Math.pow(t2, 2) + 1) * p0[i3] + (Math.pow(t2, 3) - 2 * Math.pow(t2, 2) + t2) * m0 + (-2 * Math.pow(t2, 3) + 3 * Math.pow(t2, 2)) * p1[i3] + (Math.pow(t2, 3) - Math.pow(t2, 2)) * m1;
    }
  }
  function stepInterpolate(target, path, value) {
    for (let i3 = 0; i3 < value.length; i3++) {
      target[path][i3] = value[i3];
    }
  }
  function interpolate(time, _ref2, target, path) {
    let {
      input,
      interpolation,
      output
    } = _ref2;
    const maxTime = input[input.length - 1];
    const animationTime = time % maxTime;
    const nextIndex = input.findIndex((t2) => t2 >= animationTime);
    const previousIndex = Math.max(0, nextIndex - 1);
    if (!Array.isArray(target[path])) {
      switch (path) {
        case "translation":
          target[path] = [0, 0, 0];
          break;
        case "rotation":
          target[path] = [0, 0, 0, 1];
          break;
        case "scale":
          target[path] = [1, 1, 1];
          break;
        default:
          log2.warn("Bad animation path ".concat(path))();
      }
    }
    assert7(target[path].length === output[previousIndex].length);
    const previousTime = input[previousIndex];
    const nextTime = input[nextIndex];
    switch (interpolation) {
      case "STEP":
        stepInterpolate(target, path, output[previousIndex]);
        break;
      case "LINEAR":
        if (nextTime > previousTime) {
          const ratio = (animationTime - previousTime) / (nextTime - previousTime);
          linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);
        }
        break;
      case "CUBICSPLINE":
        if (nextTime > previousTime) {
          const ratio = (animationTime - previousTime) / (nextTime - previousTime);
          const tDiff = nextTime - previousTime;
          const p0 = output[3 * previousIndex + 1];
          const outTangent0 = output[3 * previousIndex + 2];
          const inTangent1 = output[3 * nextIndex + 0];
          const p1 = output[3 * nextIndex + 1];
          cubicsplineInterpolate(target, path, {
            p0,
            outTangent0,
            inTangent1,
            p1,
            tDiff,
            ratio
          });
        }
        break;
      default:
        log2.warn("Interpolation ".concat(interpolation, " not supported"))();
        break;
    }
  }
  var GLTFAnimation = class {
    constructor(props) {
      this.startTime = 0;
      this.playing = true;
      this.speed = 1;
      this.channels = [];
      Object.assign(this, props);
    }
    animate(timeMs) {
      if (!this.playing) {
        return;
      }
      const absTime = timeMs / 1e3;
      const time = (absTime - this.startTime) * this.speed;
      this.channels.forEach((_ref3) => {
        let {
          sampler,
          target,
          path
        } = _ref3;
        interpolate(time, sampler, target, path);
        applyTranslationRotationScale(target, target._node);
      });
    }
  };
  var GLTFAnimator = class {
    constructor(gltf) {
      this.animations = gltf.animations.map((animation, index) => {
        const name10 = animation.name || "Animation-".concat(index);
        const samplers = animation.samplers.map((_ref4) => {
          let {
            input,
            interpolation = "LINEAR",
            output
          } = _ref4;
          return {
            input: accessorToJsArray(gltf.accessors[input]),
            interpolation,
            output: accessorToJsArray(gltf.accessors[output])
          };
        });
        const channels = animation.channels.map((_ref5) => {
          let {
            sampler,
            target
          } = _ref5;
          return {
            sampler: samplers[sampler],
            target: gltf.nodes[target.node],
            path: target.path
          };
        });
        return new GLTFAnimation({
          name: name10,
          channels
        });
      });
    }
    animate(time) {
      this.setTime(time);
    }
    setTime(time) {
      this.animations.forEach((animation) => animation.animate(time));
    }
    getAnimations() {
      return this.animations;
    }
  };

  // ../../node_modules/@luma.gl/experimental/dist/esm/scenegraph/model-node.js
  var ModelNode = class extends ScenegraphNode {
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(props);
      this.onBeforeRender = null;
      this.AfterRender = null;
      if (gl instanceof Model) {
        this.model = gl;
        this._setModelNodeProps(props);
      } else {
        this.model = new Model(gl, props);
      }
      this.bounds = null;
      this.managedResources = props.managedResources || [];
    }
    setProps(props) {
      super.setProps(props);
      this._setModelNodeProps(props);
      return this;
    }
    getBounds() {
      return this.bounds;
    }
    delete() {
      if (this.model) {
        this.model.delete();
        this.model = null;
      }
      this.managedResources.forEach((resource) => resource.delete());
      this.managedResources = [];
    }
    draw() {
      return this.model.draw(...arguments);
    }
    setUniforms() {
      this.model.setUniforms(...arguments);
      return this;
    }
    setAttributes() {
      this.model.setAttributes(...arguments);
      return this;
    }
    updateModuleSettings() {
      this.model.updateModuleSettings(...arguments);
      return this;
    }
    _setModelNodeProps(props) {
      this.model.setProps(props);
    }
  };

  // ../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-material-parser.js
  var GLTFMaterialParser = class {
    constructor(gl, _ref) {
      let {
        attributes,
        material,
        pbrDebug,
        imageBasedLightingEnvironment,
        lights: lights2,
        useTangents
      } = _ref;
      this.gl = gl;
      this.defines = {
        MANUAL_SRGB: 1,
        SRGB_FAST_APPROXIMATION: 1
      };
      if (hasFeature(gl, FEATURES.GLSL_TEXTURE_LOD)) {
        this.defines.USE_TEX_LOD = 1;
      }
      this.uniforms = {
        u_Camera: [0, 0, 0],
        u_MetallicRoughnessValues: [1, 1]
      };
      this.parameters = {};
      this.generatedTextures = [];
      if (imageBasedLightingEnvironment) {
        this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();
        this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();
        this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();
        this.uniforms.u_ScaleIBLAmbient = [1, 1];
      }
      if (pbrDebug) {
        this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];
        this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];
      }
      this.defineIfPresent(attributes.NORMAL, "HAS_NORMALS");
      this.defineIfPresent(attributes.TANGENT && useTangents, "HAS_TANGENTS");
      this.defineIfPresent(attributes.TEXCOORD_0, "HAS_UV");
      this.defineIfPresent(imageBasedLightingEnvironment, "USE_IBL");
      this.defineIfPresent(lights2, "USE_LIGHTS");
      this.defineIfPresent(pbrDebug, "PBR_DEBUG");
      if (material) {
        this.parseMaterial(material);
      }
    }
    defineIfPresent(value, name10) {
      if (value) {
        this.defines[name10] = 1;
      }
    }
    parseTexture(gltfTexture, name10) {
      let define2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      const parameters2 = gltfTexture.texture && gltfTexture.texture.sampler && gltfTexture.texture.sampler.parameters || {};
      const image = gltfTexture.texture.source.image;
      let textureOptions;
      let specialTextureParameters = {};
      if (image.compressed) {
        textureOptions = image;
        specialTextureParameters = {
          [this.gl.TEXTURE_MIN_FILTER]: image.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR
        };
      } else {
        textureOptions = {
          data: image
        };
      }
      const texture = new Texture2D(this.gl, {
        id: gltfTexture.name || gltfTexture.id,
        parameters: {
          ...parameters2,
          ...specialTextureParameters
        },
        pixelStore: {
          [this.gl.UNPACK_FLIP_Y_WEBGL]: false
        },
        ...textureOptions
      });
      this.uniforms[name10] = texture;
      this.defineIfPresent(define2, define2);
      this.generatedTextures.push(texture);
    }
    parsePbrMetallicRoughness(pbrMetallicRoughness) {
      if (pbrMetallicRoughness.baseColorTexture) {
        this.parseTexture(pbrMetallicRoughness.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP");
      }
      this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];
      if (pbrMetallicRoughness.metallicRoughnessTexture) {
        this.parseTexture(pbrMetallicRoughness.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP");
      }
      const {
        metallicFactor = 1,
        roughnessFactor = 1
      } = pbrMetallicRoughness;
      this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];
    }
    parseMaterial(material) {
      this.uniforms.pbr_uUnlit = Boolean(material.unlit);
      if (material.pbrMetallicRoughness) {
        this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);
      }
      if (material.normalTexture) {
        this.parseTexture(material.normalTexture, "u_NormalSampler", "HAS_NORMALMAP");
        const {
          scale: scale8 = 1
        } = material.normalTexture;
        this.uniforms.u_NormalScale = scale8;
      }
      if (material.occlusionTexture) {
        this.parseTexture(material.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP");
        const {
          strength = 1
        } = material.occlusionTexture;
        this.uniforms.u_OcclusionStrength = strength;
      }
      if (material.emissiveTexture) {
        this.parseTexture(material.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP");
        this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];
      }
      if (material.alphaMode === "MASK") {
        const {
          alphaCutoff = 0.5
        } = material;
        this.defines.ALPHA_CUTOFF = 1;
        this.uniforms.u_AlphaCutoff = alphaCutoff;
      } else if (material.alphaMode === "BLEND") {
        log2.warn("BLEND alphaMode might not work well because it requires mesh sorting")();
        Object.assign(this.parameters, {
          blend: true,
          blendEquation: this.gl.FUNC_ADD,
          blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]
        });
      }
    }
    delete() {
      this.generatedTextures.forEach((texture) => texture.delete());
    }
  };

  // ../../node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-model.js
  var vs7 = "\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * POSITION;\n  }\n";
  var fs4 = "\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor = pbr_filterColor(vec4(0));\n  }\n";
  function addVersionToShader(gl, source) {
    if (isWebGL2(gl)) {
      return "#version 300 es\n".concat(source);
    }
    return source;
  }
  function createGLTFModel(gl, options) {
    const {
      id,
      drawMode,
      vertexCount,
      attributes,
      modelOptions
    } = options;
    const materialParser = new GLTFMaterialParser(gl, options);
    log2.info(4, "createGLTFModel defines: ", materialParser.defines)();
    const managedResources = [];
    managedResources.push(...materialParser.generatedTextures);
    managedResources.push(...Object.values(attributes).map((attribute) => attribute.buffer));
    const model = new ModelNode(gl, Object.assign({
      id,
      drawMode,
      vertexCount,
      modules: [pbr],
      defines: materialParser.defines,
      parameters: materialParser.parameters,
      vs: addVersionToShader(gl, vs7),
      fs: addVersionToShader(gl, fs4),
      managedResources
    }, modelOptions));
    model.setProps({
      attributes
    });
    model.setUniforms(materialParser.uniforms);
    return model;
  }

  // ../../node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-instantiator.js
  var ATTRIBUTE_TYPE_TO_COMPONENTS2 = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var DEFAULT_OPTIONS3 = {
    modelOptions: {},
    pbrDebug: false,
    imageBasedLightingEnvironment: null,
    lights: true,
    useTangents: false
  };
  var GLTFInstantiator = class {
    constructor(gl) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.options = Object.assign({}, DEFAULT_OPTIONS3, options);
    }
    instantiate(gltf) {
      this.gltf = gltf;
      const scenes = (gltf.scenes || []).map((scene) => this.createScene(scene));
      return scenes;
    }
    createAnimator() {
      if (Array.isArray(this.gltf.animations)) {
        return new GLTFAnimator(this.gltf);
      }
      return null;
    }
    createScene(gltfScene) {
      const gltfNodes = gltfScene.nodes || [];
      const nodes = gltfNodes.map((node2) => this.createNode(node2));
      const scene = new GroupNode({
        id: gltfScene.name || gltfScene.id,
        children: nodes
      });
      return scene;
    }
    createNode(gltfNode) {
      if (!gltfNode._node) {
        const gltfChildren = gltfNode.children || [];
        const children = gltfChildren.map((child) => this.createNode(child));
        if (gltfNode.mesh) {
          children.push(this.createMesh(gltfNode.mesh));
        }
        const node2 = new GroupNode({
          id: gltfNode.name || gltfNode.id,
          children
        });
        if (gltfNode.matrix) {
          node2.setMatrix(gltfNode.matrix);
        } else {
          node2.matrix.identity();
          if (gltfNode.translation) {
            node2.matrix.translate(gltfNode.translation);
          }
          if (gltfNode.rotation) {
            const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);
            node2.matrix.multiplyRight(rotationMatrix);
          }
          if (gltfNode.scale) {
            node2.matrix.scale(gltfNode.scale);
          }
        }
        gltfNode._node = node2;
      }
      return gltfNode._node;
    }
    createMesh(gltfMesh) {
      if (!gltfMesh._mesh) {
        const gltfPrimitives = gltfMesh.primitives || [];
        const primitives = gltfPrimitives.map((gltfPrimitive, i3) => this.createPrimitive(gltfPrimitive, i3, gltfMesh));
        const mesh = new GroupNode({
          id: gltfMesh.name || gltfMesh.id,
          children: primitives
        });
        gltfMesh._mesh = mesh;
      }
      return gltfMesh._mesh;
    }
    getVertexCount(attributes) {
      log2.warn("getVertexCount() not found")();
    }
    createPrimitive(gltfPrimitive, i3, gltfMesh) {
      const model = createGLTFModel(this.gl, Object.assign({
        id: gltfPrimitive.name || "".concat(gltfMesh.name || gltfMesh.id, "-primitive-").concat(i3),
        drawMode: gltfPrimitive.mode || 4,
        vertexCount: gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes),
        attributes: this.createAttributes(gltfPrimitive.attributes, gltfPrimitive.indices),
        material: gltfPrimitive.material
      }, this.options));
      model.bounds = [gltfPrimitive.attributes.POSITION.min, gltfPrimitive.attributes.POSITION.max];
      return model;
    }
    createAttributes(attributes, indices) {
      const loadedAttributes = {};
      Object.keys(attributes).forEach((attrName) => {
        loadedAttributes[attrName] = this.createAccessor(attributes[attrName], this.createBuffer(attributes[attrName], this.gl.ARRAY_BUFFER));
      });
      if (indices) {
        loadedAttributes.indices = this.createAccessor(indices, this.createBuffer(indices, this.gl.ELEMENT_ARRAY_BUFFER));
      }
      log2.info(4, "glTF Attributes", {
        attributes,
        indices,
        generated: loadedAttributes
      })();
      return loadedAttributes;
    }
    createBuffer(attribute, target) {
      if (!attribute.bufferView) {
        attribute.bufferView = {};
      }
      const {
        bufferView
      } = attribute;
      if (!bufferView.lumaBuffers) {
        bufferView.lumaBuffers = {};
      }
      if (!bufferView.lumaBuffers[target]) {
        bufferView.lumaBuffers[target] = new Buffer2(this.gl, {
          id: "from-".concat(bufferView.id),
          data: bufferView.data || attribute.value,
          target
        });
      }
      return bufferView.lumaBuffers[target];
    }
    createAccessor(accessor, buffer) {
      return new Accessor({
        buffer,
        offset: accessor.byteOffset || 0,
        stride: accessor.bufferView.byteStride || 0,
        type: accessor.componentType,
        size: ATTRIBUTE_TYPE_TO_COMPONENTS2[accessor.type]
      });
    }
    createSampler(gltfSampler) {
      return gltfSampler;
    }
    needsPOT() {
      return false;
    }
  };

  // ../../node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-objects.js
  function createGLTFObjects(gl, gltf, options) {
    const instantiator = new GLTFInstantiator(gl, options);
    const scenes = instantiator.instantiate(gltf);
    const animator = instantiator.createAnimator();
    return {
      scenes,
      animator
    };
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/version.js
  var VERSION11 = true ? "3.4.2" : "latest";

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/utils/version.js
  var VERSION12 = true ? "3.4.2" : "latest";

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/parsers/basis-module-loader.js
  var VERSION13 = true ? "3.4.2" : "latest";
  var BASIS_CDN_ENCODER_WASM = "https://unpkg.com/@loaders.gl/textures@".concat(VERSION13, "/dist/libs/basis_encoder.wasm");
  var BASIS_CDN_ENCODER_JS = "https://unpkg.com/@loaders.gl/textures@".concat(VERSION13, "/dist/libs/basis_encoder.js");
  var loadBasisTranscoderPromise;
  async function loadBasisTrascoderModule(options) {
    const modules = options.modules || {};
    if (modules.basis) {
      return modules.basis;
    }
    loadBasisTranscoderPromise = loadBasisTranscoderPromise || loadBasisTrascoder(options);
    return await loadBasisTranscoderPromise;
  }
  async function loadBasisTrascoder(options) {
    let BASIS = null;
    let wasmBinary = null;
    [BASIS, wasmBinary] = await Promise.all([await loadLibrary("basis_transcoder.js", "textures", options), await loadLibrary("basis_transcoder.wasm", "textures", options)]);
    BASIS = BASIS || globalThis.BASIS;
    return await initializeBasisTrascoderModule(BASIS, wasmBinary);
  }
  function initializeBasisTrascoderModule(BasisModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve2) => {
      BasisModule(options).then((module2) => {
        const {
          BasisFile,
          initializeBasis
        } = module2;
        initializeBasis();
        resolve2({
          BasisFile
        });
      });
    });
  }
  var loadBasisEncoderPromise;
  async function loadBasisEncoderModule(options) {
    const modules = options.modules || {};
    if (modules.basisEncoder) {
      return modules.basisEncoder;
    }
    loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);
    return await loadBasisEncoderPromise;
  }
  async function loadBasisEncoder(options) {
    let BASIS_ENCODER = null;
    let wasmBinary = null;
    [BASIS_ENCODER, wasmBinary] = await Promise.all([await loadLibrary(BASIS_CDN_ENCODER_JS, "textures", options), await loadLibrary(BASIS_CDN_ENCODER_WASM, "textures", options)]);
    BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;
    return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);
  }
  function initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve2) => {
      BasisEncoderModule(options).then((module2) => {
        const {
          BasisFile,
          KTX2File,
          initializeBasis,
          BasisEncoder
        } = module2;
        initializeBasis();
        resolve2({
          BasisFile,
          KTX2File,
          BasisEncoder
        });
      });
    });
  }

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/gl-extensions.js
  var GL_EXTENSIONS_CONSTANTS = {
    COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
    COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
    COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
    COMPRESSED_R11_EAC: 37488,
    COMPRESSED_SIGNED_R11_EAC: 37489,
    COMPRESSED_RG11_EAC: 37490,
    COMPRESSED_SIGNED_RG11_EAC: 37491,
    COMPRESSED_RGB8_ETC2: 37492,
    COMPRESSED_RGBA8_ETC2_EAC: 37493,
    COMPRESSED_SRGB8_ETC2: 37494,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
    COMPRESSED_RGB_ETC1_WEBGL: 36196,
    COMPRESSED_RGB_ATC_WEBGL: 35986,
    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
    COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
    COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
    COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
    COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
    COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
    COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
    COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
    COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
    COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
    COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
    COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
    COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
    COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
    COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
    COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
    COMPRESSED_RED_RGTC1_EXT: 36283,
    COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
    COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
    COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
    COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
  };

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/utils/texture-formats.js
  var BROWSER_PREFIXES = ["", "WEBKIT_", "MOZ_"];
  var WEBGL_EXTENSIONS = {
    WEBGL_compressed_texture_s3tc: "dxt",
    WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
    WEBGL_compressed_texture_etc1: "etc1",
    WEBGL_compressed_texture_etc: "etc2",
    WEBGL_compressed_texture_pvrtc: "pvrtc",
    WEBGL_compressed_texture_atc: "atc",
    WEBGL_compressed_texture_astc: "astc",
    EXT_texture_compression_rgtc: "rgtc"
  };
  var formats = null;
  function getSupportedGPUTextureFormats(gl) {
    if (!formats) {
      gl = gl || getWebGLContext() || void 0;
      formats = /* @__PURE__ */ new Set();
      for (const prefix of BROWSER_PREFIXES) {
        for (const extension in WEBGL_EXTENSIONS) {
          if (gl && gl.getExtension("".concat(prefix).concat(extension))) {
            const gpuTextureFormat = WEBGL_EXTENSIONS[extension];
            formats.add(gpuTextureFormat);
          }
        }
      }
    }
    return formats;
  }
  function getWebGLContext() {
    try {
      const canvas = document.createElement("canvas");
      return canvas.getContext("webgl");
    } catch (error2) {
      return null;
    }
  }

  // ../../node_modules/ktx-parse/dist/ktx-parse.modern.js
  var t = new Uint8Array([0]);
  var n;
  var i;
  var s;
  var a;
  var r;
  var o;
  var l;
  var f;
  !function(t2) {
    t2[t2.NONE = 0] = "NONE", t2[t2.BASISLZ = 1] = "BASISLZ", t2[t2.ZSTD = 2] = "ZSTD", t2[t2.ZLIB = 3] = "ZLIB";
  }(n || (n = {})), function(t2) {
    t2[t2.BASICFORMAT = 0] = "BASICFORMAT";
  }(i || (i = {})), function(t2) {
    t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.ETC1S = 163] = "ETC1S", t2[t2.UASTC = 166] = "UASTC";
  }(s || (s = {})), function(t2) {
    t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.SRGB = 1] = "SRGB";
  }(a || (a = {})), function(t2) {
    t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.LINEAR = 1] = "LINEAR", t2[t2.SRGB = 2] = "SRGB", t2[t2.ITU = 3] = "ITU", t2[t2.NTSC = 4] = "NTSC", t2[t2.SLOG = 5] = "SLOG", t2[t2.SLOG2 = 6] = "SLOG2";
  }(r || (r = {})), function(t2) {
    t2[t2.ALPHA_STRAIGHT = 0] = "ALPHA_STRAIGHT", t2[t2.ALPHA_PREMULTIPLIED = 1] = "ALPHA_PREMULTIPLIED";
  }(o || (o = {})), function(t2) {
    t2[t2.RGB = 0] = "RGB", t2[t2.RRR = 3] = "RRR", t2[t2.GGG = 4] = "GGG", t2[t2.AAA = 15] = "AAA";
  }(l || (l = {})), function(t2) {
    t2[t2.RGB = 0] = "RGB", t2[t2.RGBA = 3] = "RGBA", t2[t2.RRR = 4] = "RRR", t2[t2.RRRG = 5] = "RRRG";
  }(f || (f = {}));

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-ktx.js
  var KTX2_ID = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
  function isKTX(data) {
    const id = new Uint8Array(data);
    const notKTX = id.byteLength < KTX2_ID.length || id[0] !== KTX2_ID[0] || id[1] !== KTX2_ID[1] || id[2] !== KTX2_ID[2] || id[3] !== KTX2_ID[3] || id[4] !== KTX2_ID[4] || id[5] !== KTX2_ID[5] || id[6] !== KTX2_ID[6] || id[7] !== KTX2_ID[7] || id[8] !== KTX2_ID[8] || id[9] !== KTX2_ID[9] || id[10] !== KTX2_ID[10] || id[11] !== KTX2_ID[11];
    return !notKTX;
  }

  // ../../node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-basis.js
  var OutputFormat = {
    etc1: {
      basisFormat: 0,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL
    },
    etc2: {
      basisFormat: 1,
      compressed: true
    },
    bc1: {
      basisFormat: 2,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT
    },
    bc3: {
      basisFormat: 3,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT
    },
    bc4: {
      basisFormat: 4,
      compressed: true
    },
    bc5: {
      basisFormat: 5,
      compressed: true
    },
    "bc7-m6-opaque-only": {
      basisFormat: 6,
      compressed: true
    },
    "bc7-m5": {
      basisFormat: 7,
      compressed: true
    },
    "pvrtc1-4-rgb": {
      basisFormat: 8,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
    },
    "pvrtc1-4-rgba": {
      basisFormat: 9,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
    },
    "astc-4x4": {
      basisFormat: 10,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR
    },
    "atc-rgb": {
      basisFormat: 11,
      compressed: true
    },
    "atc-rgba-interpolated-alpha": {
      basisFormat: 12,
      compressed: true
    },
    rgba32: {
      basisFormat: 13,
      compressed: false
    },
    rgb565: {
      basisFormat: 14,
      compressed: false
    },
    bgr565: {
      basisFormat: 15,
      compressed: false
    },
    rgba4444: {
      basisFormat: 16,
      compressed: false
    }
  };
  async function parseBasis(data, options) {
    if (options.basis.containerFormat === "auto") {
      if (isKTX(data)) {
        const fileConstructors = await loadBasisEncoderModule(options);
        return parseKTX2File(fileConstructors.KTX2File, data, options);
      }
      const {
        BasisFile
      } = await loadBasisTrascoderModule(options);
      return parseBasisFile(BasisFile, data, options);
    }
    switch (options.basis.module) {
      case "encoder":
        const fileConstructors = await loadBasisEncoderModule(options);
        switch (options.basis.containerFormat) {
          case "ktx2":
            return parseKTX2File(fileConstructors.KTX2File, data, options);
          case "basis":
          default:
            return parseBasisFile(fileConstructors.BasisFile, data, options);
        }
      case "transcoder":
      default:
        const {
          BasisFile
        } = await loadBasisTrascoderModule(options);
        return parseBasisFile(BasisFile, data, options);
    }
  }
  function parseBasisFile(BasisFile, data, options) {
    const basisFile = new BasisFile(new Uint8Array(data));
    try {
      if (!basisFile.startTranscoding()) {
        throw new Error("Failed to start basis transcoding");
      }
      const imageCount = basisFile.getNumImages();
      const images = [];
      for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {
        const levelsCount = basisFile.getNumLevels(imageIndex);
        const levels = [];
        for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
          levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));
        }
        images.push(levels);
      }
      return images;
    } finally {
      basisFile.close();
      basisFile.delete();
    }
  }
  function transcodeImage(basisFile, imageIndex, levelIndex, options) {
    const width = basisFile.getImageWidth(imageIndex, levelIndex);
    const height = basisFile.getImageHeight(imageIndex, levelIndex);
    const hasAlpha = basisFile.getHasAlpha();
    const {
      compressed,
      format,
      basisFormat
    } = getBasisOptions(options, hasAlpha);
    const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);
    const decodedData = new Uint8Array(decodedSize);
    if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {
      throw new Error("failed to start Basis transcoding");
    }
    return {
      width,
      height,
      data: decodedData,
      compressed,
      format,
      hasAlpha
    };
  }
  function parseKTX2File(KTX2File, data, options) {
    const ktx2File = new KTX2File(new Uint8Array(data));
    try {
      if (!ktx2File.startTranscoding()) {
        throw new Error("failed to start KTX2 transcoding");
      }
      const levelsCount = ktx2File.getLevels();
      const levels = [];
      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
        levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));
        break;
      }
      return [levels];
    } finally {
      ktx2File.close();
      ktx2File.delete();
    }
  }
  function transcodeKTX2Image(ktx2File, levelIndex, options) {
    const {
      alphaFlag,
      height,
      width
    } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);
    const {
      compressed,
      format,
      basisFormat
    } = getBasisOptions(options, alphaFlag);
    const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0, 0, basisFormat);
    const decodedData = new Uint8Array(decodedSize);
    if (!ktx2File.transcodeImage(decodedData, levelIndex, 0, 0, basisFormat, 0, -1, -1)) {
      throw new Error("Failed to transcode KTX2 image");
    }
    return {
      width,
      height,
      data: decodedData,
      compressed,
      levelSize: decodedSize,
      hasAlpha: alphaFlag,
      format
    };
  }
  function getBasisOptions(options, hasAlpha) {
    let format = options && options.basis && options.basis.format;
    if (format === "auto") {
      format = selectSupportedBasisFormat();
    }
    if (typeof format === "object") {
      format = hasAlpha ? format.alpha : format.noAlpha;
    }
    format = format.toLowerCase();
    return OutputFormat[format];
  }
  function selectSupportedBasisFormat() {
    const supportedFormats = getSupportedGPUTextureFormats();
    if (supportedFormats.has("astc")) {
      return "astc-4x4";
    } else if (supportedFormats.has("dxt")) {
      return {
        alpha: "bc3",
        noAlpha: "bc1"
      };
    } else if (supportedFormats.has("pvrtc")) {
      return {
        alpha: "pvrtc1-4-rgba",
        noAlpha: "pvrtc1-4-rgb"
      };
    } else if (supportedFormats.has("etc1")) {
      return "etc1";
    } else if (supportedFormats.has("etc2")) {
      return "etc2";
    }
    return "rgb565";
  }

  // ../../node_modules/@loaders.gl/textures/dist/esm/basis-loader.js
  var BasisWorkerLoader = {
    name: "Basis",
    id: isBrowser2 ? "basis" : "basis-nodejs",
    module: "textures",
    version: VERSION12,
    worker: true,
    extensions: ["basis", "ktx2"],
    mimeTypes: ["application/octet-stream", "image/ktx2"],
    tests: ["sB"],
    binary: true,
    options: {
      basis: {
        format: "auto",
        libraryPath: "libs/",
        containerFormat: "auto",
        module: "transcoder"
      }
    }
  };
  var BasisLoader = {
    ...BasisWorkerLoader,
    parse: parseBasis
  };

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js
  function assert13(condition, message) {
    if (!condition) {
      throw new Error(message || "assert failed: gltf");
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/resolve-url.js
  function resolveUrl(url, options) {
    const absolute = url.startsWith("data:") || url.startsWith("http:") || url.startsWith("https:");
    if (absolute) {
      return url;
    }
    const baseUrl = options.baseUri || options.uri;
    if (!baseUrl) {
      throw new Error("'baseUri' must be provided to resolve relative url ".concat(url));
    }
    return baseUrl.substr(0, baseUrl.lastIndexOf("/") + 1) + url;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/get-typed-array.js
  function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {
    const bufferView = json.bufferViews[bufferViewIndex];
    assert13(bufferView);
    const bufferIndex = bufferView.buffer;
    const binChunk = buffers[bufferIndex];
    assert13(binChunk);
    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_meshopt_compression.js
  var EXT_meshopt_compression_exports = {};
  __export(EXT_meshopt_compression_exports, {
    decode: () => decode2,
    name: () => name
  });

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-utils.js
  var TYPES = ["SCALAR", "VEC2", "VEC3", "VEC4"];
  var ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]];
  var ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);
  var ATTRIBUTE_TYPE_TO_COMPONENTS3 = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
    5120: 1,
    5121: 1,
    5122: 2,
    5123: 2,
    5125: 4,
    5126: 4
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2 = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  function getAccessorTypeFromSize(size) {
    const type = TYPES[size - 1];
    return type || TYPES[0];
  }
  function getComponentTypeFromArray(typedArray) {
    const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);
    if (!componentType) {
      throw new Error("Illegal typed array");
    }
    return componentType;
  }
  function getAccessorArrayTypeAndLength(accessor, bufferView) {
    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2[accessor.componentType];
    const components = ATTRIBUTE_TYPE_TO_COMPONENTS3[accessor.type];
    const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
    const length7 = accessor.count * components;
    const byteLength = accessor.count * components * bytesPerComponent;
    assert13(byteLength >= 0 && byteLength <= bufferView.byteLength);
    return {
      ArrayType,
      length: length7,
      byteLength
    };
  }
  function getMemoryUsageGLTF(gltf) {
    let {
      images,
      bufferViews
    } = gltf;
    images = images || [];
    bufferViews = bufferViews || [];
    const imageBufferViews = images.map((i3) => i3.bufferView);
    bufferViews = bufferViews.filter((view) => !imageBufferViews.includes(view));
    const bufferMemory = bufferViews.reduce((acc, view) => acc + view.byteLength, 0);
    const pixelCount = images.reduce((acc, image) => {
      const {
        width,
        height
      } = image.image;
      return acc + width * height;
    }, 0);
    return bufferMemory + Math.ceil(4 * pixelCount * 1.33);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js
  var DEFAULT_GLTF_JSON = {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: []
  };
  var GLTFScenegraph = class {
    constructor(gltf) {
      _defineProperty(this, "gltf", void 0);
      _defineProperty(this, "sourceBuffers", void 0);
      _defineProperty(this, "byteLength", void 0);
      this.gltf = gltf || {
        json: {
          ...DEFAULT_GLTF_JSON
        },
        buffers: []
      };
      this.sourceBuffers = [];
      this.byteLength = 0;
      if (this.gltf.buffers && this.gltf.buffers[0]) {
        this.byteLength = this.gltf.buffers[0].byteLength;
        this.sourceBuffers = [this.gltf.buffers[0]];
      }
    }
    get json() {
      return this.gltf.json;
    }
    getApplicationData(key) {
      const data = this.json[key];
      return data;
    }
    getExtraData(key) {
      const extras = this.json.extras || {};
      return extras[key];
    }
    getExtension(extensionName) {
      const isExtension = this.getUsedExtensions().find((name10) => name10 === extensionName);
      const extensions = this.json.extensions || {};
      return isExtension ? extensions[extensionName] || true : null;
    }
    getRequiredExtension(extensionName) {
      const isRequired = this.getRequiredExtensions().find((name10) => name10 === extensionName);
      return isRequired ? this.getExtension(extensionName) : null;
    }
    getRequiredExtensions() {
      return this.json.extensionsRequired || [];
    }
    getUsedExtensions() {
      return this.json.extensionsUsed || [];
    }
    getRemovedExtensions() {
      return this.json.extensionsRemoved || [];
    }
    getObjectExtension(object, extensionName) {
      const extensions = object.extensions || {};
      return extensions[extensionName];
    }
    getScene(index) {
      return this.getObject("scenes", index);
    }
    getNode(index) {
      return this.getObject("nodes", index);
    }
    getSkin(index) {
      return this.getObject("skins", index);
    }
    getMesh(index) {
      return this.getObject("meshes", index);
    }
    getMaterial(index) {
      return this.getObject("materials", index);
    }
    getAccessor(index) {
      return this.getObject("accessors", index);
    }
    getTexture(index) {
      return this.getObject("textures", index);
    }
    getSampler(index) {
      return this.getObject("samplers", index);
    }
    getImage(index) {
      return this.getObject("images", index);
    }
    getBufferView(index) {
      return this.getObject("bufferViews", index);
    }
    getBuffer(index) {
      return this.getObject("buffers", index);
    }
    getObject(array, index) {
      if (typeof index === "object") {
        return index;
      }
      const object = this.json[array] && this.json[array][index];
      if (!object) {
        throw new Error("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
      }
      return object;
    }
    getTypedArrayForBufferView(bufferView) {
      bufferView = this.getBufferView(bufferView);
      const bufferIndex = bufferView.buffer;
      const binChunk = this.gltf.buffers[bufferIndex];
      assert13(binChunk);
      const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
      return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
    }
    getTypedArrayForAccessor(accessor) {
      accessor = this.getAccessor(accessor);
      const bufferView = this.getBufferView(accessor.bufferView);
      const buffer = this.getBuffer(bufferView.buffer);
      const arrayBuffer2 = buffer.data;
      const {
        ArrayType,
        length: length7
      } = getAccessorArrayTypeAndLength(accessor, bufferView);
      const byteOffset = bufferView.byteOffset + accessor.byteOffset;
      return new ArrayType(arrayBuffer2, byteOffset, length7);
    }
    getTypedArrayForImageData(image) {
      image = this.getAccessor(image);
      const bufferView = this.getBufferView(image.bufferView);
      const buffer = this.getBuffer(bufferView.buffer);
      const arrayBuffer2 = buffer.data;
      const byteOffset = bufferView.byteOffset || 0;
      return new Uint8Array(arrayBuffer2, byteOffset, bufferView.byteLength);
    }
    addApplicationData(key, data) {
      this.json[key] = data;
      return this;
    }
    addExtraData(key, data) {
      this.json.extras = this.json.extras || {};
      this.json.extras[key] = data;
      return this;
    }
    addObjectExtension(object, extensionName, data) {
      object.extensions = object.extensions || {};
      object.extensions[extensionName] = data;
      this.registerUsedExtension(extensionName);
      return this;
    }
    setObjectExtension(object, extensionName, data) {
      const extensions = object.extensions || {};
      extensions[extensionName] = data;
    }
    removeObjectExtension(object, extensionName) {
      const extensions = object.extensions || {};
      const extension = extensions[extensionName];
      delete extensions[extensionName];
      return extension;
    }
    addExtension(extensionName) {
      let extensionData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assert13(extensionData);
      this.json.extensions = this.json.extensions || {};
      this.json.extensions[extensionName] = extensionData;
      this.registerUsedExtension(extensionName);
      return extensionData;
    }
    addRequiredExtension(extensionName) {
      let extensionData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assert13(extensionData);
      this.addExtension(extensionName, extensionData);
      this.registerRequiredExtension(extensionName);
      return extensionData;
    }
    registerUsedExtension(extensionName) {
      this.json.extensionsUsed = this.json.extensionsUsed || [];
      if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {
        this.json.extensionsUsed.push(extensionName);
      }
    }
    registerRequiredExtension(extensionName) {
      this.registerUsedExtension(extensionName);
      this.json.extensionsRequired = this.json.extensionsRequired || [];
      if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {
        this.json.extensionsRequired.push(extensionName);
      }
    }
    removeExtension(extensionName) {
      if (!this.getExtension(extensionName)) {
        return;
      }
      if (this.json.extensionsRequired) {
        this._removeStringFromArray(this.json.extensionsRequired, extensionName);
      }
      if (this.json.extensionsUsed) {
        this._removeStringFromArray(this.json.extensionsUsed, extensionName);
      }
      if (this.json.extensions) {
        delete this.json.extensions[extensionName];
      }
      if (!Array.isArray(this.json.extensionsRemoved)) {
        this.json.extensionsRemoved = [];
      }
      const extensionsRemoved = this.json.extensionsRemoved;
      if (!extensionsRemoved.includes(extensionName)) {
        extensionsRemoved.push(extensionName);
      }
    }
    setDefaultScene(sceneIndex) {
      this.json.scene = sceneIndex;
    }
    addScene(scene) {
      const {
        nodeIndices
      } = scene;
      this.json.scenes = this.json.scenes || [];
      this.json.scenes.push({
        nodes: nodeIndices
      });
      return this.json.scenes.length - 1;
    }
    addNode(node2) {
      const {
        meshIndex,
        matrix
      } = node2;
      this.json.nodes = this.json.nodes || [];
      const nodeData = {
        mesh: meshIndex
      };
      if (matrix) {
        nodeData.matrix = matrix;
      }
      this.json.nodes.push(nodeData);
      return this.json.nodes.length - 1;
    }
    addMesh(mesh) {
      const {
        attributes,
        indices,
        material,
        mode = 4
      } = mesh;
      const accessors = this._addAttributes(attributes);
      const glTFMesh = {
        primitives: [{
          attributes: accessors,
          mode
        }]
      };
      if (indices) {
        const indicesAccessor = this._addIndices(indices);
        glTFMesh.primitives[0].indices = indicesAccessor;
      }
      if (Number.isFinite(material)) {
        glTFMesh.primitives[0].material = material;
      }
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
    addPointCloud(attributes) {
      const accessorIndices = this._addAttributes(attributes);
      const glTFMesh = {
        primitives: [{
          attributes: accessorIndices,
          mode: 0
        }]
      };
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
    addImage(imageData, mimeTypeOpt) {
      const metadata = getBinaryImageMetadata(imageData);
      const mimeType = mimeTypeOpt || (metadata === null || metadata === void 0 ? void 0 : metadata.mimeType);
      const bufferViewIndex = this.addBufferView(imageData);
      const glTFImage = {
        bufferView: bufferViewIndex,
        mimeType
      };
      this.json.images = this.json.images || [];
      this.json.images.push(glTFImage);
      return this.json.images.length - 1;
    }
    addBufferView(buffer) {
      const byteLength = buffer.byteLength;
      assert13(Number.isFinite(byteLength));
      this.sourceBuffers = this.sourceBuffers || [];
      this.sourceBuffers.push(buffer);
      const glTFBufferView = {
        buffer: 0,
        byteOffset: this.byteLength,
        byteLength
      };
      this.byteLength += padToNBytes(byteLength, 4);
      this.json.bufferViews = this.json.bufferViews || [];
      this.json.bufferViews.push(glTFBufferView);
      return this.json.bufferViews.length - 1;
    }
    addAccessor(bufferViewIndex, accessor) {
      const glTFAccessor = {
        bufferView: bufferViewIndex,
        type: getAccessorTypeFromSize(accessor.size),
        componentType: accessor.componentType,
        count: accessor.count,
        max: accessor.max,
        min: accessor.min
      };
      this.json.accessors = this.json.accessors || [];
      this.json.accessors.push(glTFAccessor);
      return this.json.accessors.length - 1;
    }
    addBinaryBuffer(sourceBuffer) {
      let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        size: 3
      };
      const bufferViewIndex = this.addBufferView(sourceBuffer);
      let minMax = {
        min: accessor.min,
        max: accessor.max
      };
      if (!minMax.min || !minMax.max) {
        minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);
      }
      const accessorDefaults = {
        size: accessor.size,
        componentType: getComponentTypeFromArray(sourceBuffer),
        count: Math.round(sourceBuffer.length / accessor.size),
        min: minMax.min,
        max: minMax.max
      };
      return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
    }
    addTexture(texture) {
      const {
        imageIndex
      } = texture;
      const glTFTexture = {
        source: imageIndex
      };
      this.json.textures = this.json.textures || [];
      this.json.textures.push(glTFTexture);
      return this.json.textures.length - 1;
    }
    addMaterial(pbrMaterialInfo) {
      this.json.materials = this.json.materials || [];
      this.json.materials.push(pbrMaterialInfo);
      return this.json.materials.length - 1;
    }
    createBinaryChunk() {
      var _this$json, _this$json$buffers;
      this.gltf.buffers = [];
      const totalByteLength = this.byteLength;
      const arrayBuffer2 = new ArrayBuffer(totalByteLength);
      const targetArray = new Uint8Array(arrayBuffer2);
      let dstByteOffset = 0;
      for (const sourceBuffer of this.sourceBuffers || []) {
        dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);
      }
      if ((_this$json = this.json) !== null && _this$json !== void 0 && (_this$json$buffers = _this$json.buffers) !== null && _this$json$buffers !== void 0 && _this$json$buffers[0]) {
        this.json.buffers[0].byteLength = totalByteLength;
      } else {
        this.json.buffers = [{
          byteLength: totalByteLength
        }];
      }
      this.gltf.binary = arrayBuffer2;
      this.sourceBuffers = [arrayBuffer2];
    }
    _removeStringFromArray(array, string) {
      let found = true;
      while (found) {
        const index = array.indexOf(string);
        if (index > -1) {
          array.splice(index, 1);
        } else {
          found = false;
        }
      }
    }
    _addAttributes() {
      let attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const result = {};
      for (const attributeKey in attributes) {
        const attributeData = attributes[attributeKey];
        const attrName = this._getGltfAttributeName(attributeKey);
        const accessor = this.addBinaryBuffer(attributeData.value, attributeData);
        result[attrName] = accessor;
      }
      return result;
    }
    _addIndices(indices) {
      return this.addBinaryBuffer(indices, {
        size: 1
      });
    }
    _getGltfAttributeName(attributeName) {
      switch (attributeName.toLowerCase()) {
        case "position":
        case "positions":
        case "vertices":
          return "POSITION";
        case "normal":
        case "normals":
          return "NORMAL";
        case "color":
        case "colors":
          return "COLOR_0";
        case "texcoord":
        case "texcoords":
          return "TEXCOORD_0";
        default:
          return attributeName;
      }
    }
    _getAccessorMinMax(buffer, size) {
      const result = {
        min: null,
        max: null
      };
      if (buffer.length < size) {
        return result;
      }
      result.min = [];
      result.max = [];
      const initValues = buffer.subarray(0, size);
      for (const value of initValues) {
        result.min.push(value);
        result.max.push(value);
      }
      for (let index = size; index < buffer.length; index += size) {
        for (let componentIndex = 0; componentIndex < size; componentIndex++) {
          result.min[0 + componentIndex] = Math.min(result.min[0 + componentIndex], buffer[index + componentIndex]);
          result.max[0 + componentIndex] = Math.max(result.max[0 + componentIndex], buffer[index + componentIndex]);
        }
      }
      return result;
    }
  };

  // ../../node_modules/@loaders.gl/gltf/dist/esm/meshopt/meshopt-decoder.js
  var wasm_base = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
  var wasm_simd = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB";
  var detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
  var wasmpack = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
  var FILTERS = {
    0: "",
    1: "meshopt_decodeFilterOct",
    2: "meshopt_decodeFilterQuat",
    3: "meshopt_decodeFilterExp",
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  };
  var DECODERS = {
    0: "meshopt_decodeVertexBuffer",
    1: "meshopt_decodeIndexBuffer",
    2: "meshopt_decodeIndexSequence",
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  async function meshoptDecodeGltfBuffer(target, count2, size, source, mode) {
    let filter = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "NONE";
    const instance = await loadWasmInstance();
    decode(instance, instance.exports[DECODERS[mode]], target, count2, size, source, instance.exports[FILTERS[filter || "NONE"]]);
  }
  var wasmPromise;
  async function loadWasmInstance() {
    if (!wasmPromise) {
      wasmPromise = loadWasmModule();
    }
    return wasmPromise;
  }
  async function loadWasmModule() {
    let wasm2 = wasm_base;
    if (WebAssembly.validate(detector)) {
      wasm2 = wasm_simd;
      console.log("Warning: meshopt_decoder is using experimental SIMD support");
    }
    const result = await WebAssembly.instantiate(unpack(wasm2), {});
    await result.instance.exports.__wasm_call_ctors();
    return result.instance;
  }
  function unpack(data) {
    const result = new Uint8Array(data.length);
    for (let i3 = 0; i3 < data.length; ++i3) {
      const ch = data.charCodeAt(i3);
      result[i3] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;
    }
    let write = 0;
    for (let i3 = 0; i3 < data.length; ++i3) {
      result[write++] = result[i3] < 60 ? wasmpack[result[i3]] : (result[i3] - 60) * 64 + result[++i3];
    }
    return result.buffer.slice(0, write);
  }
  function decode(instance, fun, target, count2, size, source, filter) {
    const sbrk = instance.exports.sbrk;
    const count4 = count2 + 3 & ~3;
    const tp = sbrk(count4 * size);
    const sp = sbrk(source.length);
    const heap = new Uint8Array(instance.exports.memory.buffer);
    heap.set(source, sp);
    const res = fun(tp, count2, size, sp, source.length);
    if (res === 0 && filter) {
      filter(tp, count4, size);
    }
    target.set(heap.subarray(tp, tp + count2 * size));
    sbrk(tp - sbrk(0));
    if (res !== 0) {
      throw new Error("Malformed buffer data: ".concat(res));
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_meshopt_compression.js
  var EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression";
  var name = EXT_MESHOPT_COMPRESSION;
  async function decode2(gltfData, options) {
    var _options$gltf;
    const scenegraph = new GLTFScenegraph(gltfData);
    if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {
      return;
    }
    const promises = [];
    for (const bufferViewIndex of gltfData.json.bufferViews || []) {
      promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));
    }
    await Promise.all(promises);
    scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);
  }
  async function decodeMeshoptBufferView(scenegraph, bufferView) {
    const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
    if (meshoptExtension) {
      const {
        byteOffset = 0,
        byteLength = 0,
        byteStride,
        count: count2,
        mode,
        filter = "NONE",
        buffer: bufferIndex
      } = meshoptExtension;
      const buffer = scenegraph.gltf.buffers[bufferIndex];
      const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);
      const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
      await meshoptDecodeGltfBuffer(result, count2, byteStride, source, mode, filter);
      return result;
    }
    return null;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_texture_webp.js
  var EXT_texture_webp_exports = {};
  __export(EXT_texture_webp_exports, {
    name: () => name2,
    preprocess: () => preprocess
  });
  var EXT_TEXTURE_WEBP = "EXT_texture_webp";
  var name2 = EXT_TEXTURE_WEBP;
  function preprocess(gltfData, options) {
    const scenegraph = new GLTFScenegraph(gltfData);
    if (!isImageFormatSupported("image/webp")) {
      if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {
        throw new Error("gltf: Required extension ".concat(EXT_TEXTURE_WEBP, " not supported by browser"));
      }
      return;
    }
    const {
      json
    } = scenegraph;
    for (const texture of json.textures || []) {
      const extension = scenegraph.getObjectExtension(texture, EXT_TEXTURE_WEBP);
      if (extension) {
        texture.source = extension.source;
      }
      scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);
    }
    scenegraph.removeExtension(EXT_TEXTURE_WEBP);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_basisu.js
  var KHR_texture_basisu_exports = {};
  __export(KHR_texture_basisu_exports, {
    name: () => name3,
    preprocess: () => preprocess2
  });
  var KHR_TEXTURE_BASISU = "KHR_texture_basisu";
  var name3 = KHR_TEXTURE_BASISU;
  function preprocess2(gltfData, options) {
    const scene = new GLTFScenegraph(gltfData);
    const {
      json
    } = scene;
    for (const texture of json.textures || []) {
      const extension = scene.getObjectExtension(texture, KHR_TEXTURE_BASISU);
      if (extension) {
        texture.source = extension.source;
      }
      scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);
    }
    scene.removeExtension(KHR_TEXTURE_BASISU);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_draco_mesh_compression.js
  var KHR_draco_mesh_compression_exports = {};
  __export(KHR_draco_mesh_compression_exports, {
    decode: () => decode3,
    encode: () => encode,
    name: () => name4,
    preprocess: () => preprocess3
  });

  // ../../node_modules/@loaders.gl/draco/dist/esm/lib/utils/version.js
  var VERSION14 = true ? "3.4.2" : "latest";

  // ../../node_modules/@loaders.gl/draco/dist/esm/draco-loader.js
  var DEFAULT_DRACO_OPTIONS = {
    draco: {
      decoderType: typeof WebAssembly === "object" ? "wasm" : "js",
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: void 0
    }
  };
  var DracoLoader = {
    name: "Draco",
    id: isBrowser2 ? "draco" : "draco-nodejs",
    module: "draco",
    shapes: ["mesh"],
    version: VERSION14,
    worker: true,
    extensions: ["drc"],
    mimeTypes: ["application/octet-stream"],
    binary: true,
    tests: ["DRACO"],
    options: DEFAULT_DRACO_OPTIONS
  };

  // ../../node_modules/@loaders.gl/draco/dist/esm/lib/utils/get-draco-schema.js
  function getDracoSchema(attributes, loaderData, indices) {
    const metadataMap = makeMetadata(loaderData.metadata);
    const fields = [];
    const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);
      fields.push(field);
    }
    if (indices) {
      const indicesField = getArrowFieldFromAttribute("indices", indices);
      fields.push(indicesField);
    }
    return new Schema(fields, metadataMap);
  }
  function transformAttributesLoaderData(loaderData) {
    const result = {};
    for (const key in loaderData) {
      const dracoAttribute = loaderData[key];
      result[dracoAttribute.name || "undefined"] = dracoAttribute;
    }
    return result;
  }
  function getArrowFieldFromAttribute(attributeName, attribute, loaderData) {
    const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : void 0;
    const field = deduceMeshField(attributeName, attribute, metadataMap);
    return field;
  }
  function makeMetadata(metadata) {
    const metadataMap = /* @__PURE__ */ new Map();
    for (const key in metadata) {
      metadataMap.set("".concat(key, ".string"), JSON.stringify(metadata[key]));
    }
    return metadataMap;
  }

  // ../../node_modules/@loaders.gl/draco/dist/esm/lib/draco-parser.js
  var DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {
    POSITION: "POSITION",
    NORMAL: "NORMAL",
    COLOR: "COLOR_0",
    TEX_COORD: "TEXCOORD_0"
  };
  var DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {
    1: Int8Array,
    2: Uint8Array,
    3: Int16Array,
    4: Uint16Array,
    5: Int32Array,
    6: Uint32Array,
    9: Float32Array
  };
  var INDEX_ITEM_SIZE = 4;
  var DracoParser = class {
    constructor(draco) {
      _defineProperty(this, "draco", void 0);
      _defineProperty(this, "decoder", void 0);
      _defineProperty(this, "metadataQuerier", void 0);
      this.draco = draco;
      this.decoder = new this.draco.Decoder();
      this.metadataQuerier = new this.draco.MetadataQuerier();
    }
    destroy() {
      this.draco.destroy(this.decoder);
      this.draco.destroy(this.metadataQuerier);
    }
    parseSync(arrayBuffer2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const buffer = new this.draco.DecoderBuffer();
      buffer.Init(new Int8Array(arrayBuffer2), arrayBuffer2.byteLength);
      this._disableAttributeTransforms(options);
      const geometry_type = this.decoder.GetEncodedGeometryType(buffer);
      const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
      try {
        let dracoStatus;
        switch (geometry_type) {
          case this.draco.TRIANGULAR_MESH:
            dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);
            break;
          case this.draco.POINT_CLOUD:
            dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
            break;
          default:
            throw new Error("DRACO: Unknown geometry type.");
        }
        if (!dracoStatus.ok() || !dracoGeometry.ptr) {
          const message = "DRACO decompression failed: ".concat(dracoStatus.error_msg());
          throw new Error(message);
        }
        const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);
        const geometry = this._getMeshData(dracoGeometry, loaderData, options);
        const boundingBox = getMeshBoundingBox(geometry.attributes);
        const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);
        const data = {
          loader: "draco",
          loaderData,
          header: {
            vertexCount: dracoGeometry.num_points(),
            boundingBox
          },
          ...geometry,
          schema
        };
        return data;
      } finally {
        this.draco.destroy(buffer);
        if (dracoGeometry) {
          this.draco.destroy(dracoGeometry);
        }
      }
    }
    _getDracoLoaderData(dracoGeometry, geometry_type, options) {
      const metadata = this._getTopLevelMetadata(dracoGeometry);
      const attributes = this._getDracoAttributes(dracoGeometry, options);
      return {
        geometry_type,
        num_attributes: dracoGeometry.num_attributes(),
        num_points: dracoGeometry.num_points(),
        num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,
        metadata,
        attributes
      };
    }
    _getDracoAttributes(dracoGeometry, options) {
      const dracoAttributes = {};
      for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
        const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);
        dracoAttributes[dracoAttribute.unique_id()] = {
          unique_id: dracoAttribute.unique_id(),
          attribute_type: dracoAttribute.attribute_type(),
          data_type: dracoAttribute.data_type(),
          num_components: dracoAttribute.num_components(),
          byte_offset: dracoAttribute.byte_offset(),
          byte_stride: dracoAttribute.byte_stride(),
          normalized: dracoAttribute.normalized(),
          attribute_index: attributeId,
          metadata
        };
        const quantization = this._getQuantizationTransform(dracoAttribute, options);
        if (quantization) {
          dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;
        }
        const octahedron = this._getOctahedronTransform(dracoAttribute, options);
        if (octahedron) {
          dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;
        }
      }
      return dracoAttributes;
    }
    _getMeshData(dracoGeometry, loaderData, options) {
      const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);
      const positionAttribute = attributes.POSITION;
      if (!positionAttribute) {
        throw new Error("DRACO: No position attribute found.");
      }
      if (dracoGeometry instanceof this.draco.Mesh) {
        switch (options.topology) {
          case "triangle-strip":
            return {
              topology: "triangle-strip",
              mode: 4,
              attributes,
              indices: {
                value: this._getTriangleStripIndices(dracoGeometry),
                size: 1
              }
            };
          case "triangle-list":
          default:
            return {
              topology: "triangle-list",
              mode: 5,
              attributes,
              indices: {
                value: this._getTriangleListIndices(dracoGeometry),
                size: 1
              }
            };
        }
      }
      return {
        topology: "point-list",
        mode: 0,
        attributes
      };
    }
    _getMeshAttributes(loaderData, dracoGeometry, options) {
      const attributes = {};
      for (const loaderAttribute of Object.values(loaderData.attributes)) {
        const attributeName = this._deduceAttributeName(loaderAttribute, options);
        loaderAttribute.name = attributeName;
        const {
          value,
          size
        } = this._getAttributeValues(dracoGeometry, loaderAttribute);
        attributes[attributeName] = {
          value,
          size,
          byteOffset: loaderAttribute.byte_offset,
          byteStride: loaderAttribute.byte_stride,
          normalized: loaderAttribute.normalized
        };
      }
      return attributes;
    }
    _getTriangleListIndices(dracoGeometry) {
      const numFaces = dracoGeometry.num_faces();
      const numIndices = numFaces * 3;
      const byteLength = numIndices * INDEX_ITEM_SIZE;
      const ptr = this.draco._malloc(byteLength);
      try {
        this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
        return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();
      } finally {
        this.draco._free(ptr);
      }
    }
    _getTriangleStripIndices(dracoGeometry) {
      const dracoArray = new this.draco.DracoInt32Array();
      try {
        this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);
        return getUint32Array(dracoArray);
      } finally {
        this.draco.destroy(dracoArray);
      }
    }
    _getAttributeValues(dracoGeometry, attribute) {
      const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];
      const numComponents = attribute.num_components;
      const numPoints = dracoGeometry.num_points();
      const numValues = numPoints * numComponents;
      const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;
      const dataType = getDracoDataType(this.draco, TypedArrayCtor);
      let value;
      const ptr = this.draco._malloc(byteLength);
      try {
        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);
        this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);
        value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();
      } finally {
        this.draco._free(ptr);
      }
      return {
        value,
        size: numComponents
      };
    }
    _deduceAttributeName(attribute, options) {
      const uniqueId = attribute.unique_id;
      for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {
        if (attributeUniqueId === uniqueId) {
          return attributeName;
        }
      }
      const thisAttributeType = attribute.attribute_type;
      for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {
        const attributeType = this.draco[dracoAttributeConstant];
        if (attributeType === thisAttributeType) {
          return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];
        }
      }
      const entryName = options.attributeNameEntry || "name";
      if (attribute.metadata[entryName]) {
        return attribute.metadata[entryName].string;
      }
      return "CUSTOM_ATTRIBUTE_".concat(uniqueId);
    }
    _getTopLevelMetadata(dracoGeometry) {
      const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);
      return this._getDracoMetadata(dracoMetadata);
    }
    _getAttributeMetadata(dracoGeometry, attributeId) {
      const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);
      return this._getDracoMetadata(dracoMetadata);
    }
    _getDracoMetadata(dracoMetadata) {
      if (!dracoMetadata || !dracoMetadata.ptr) {
        return {};
      }
      const result = {};
      const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);
      for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {
        const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);
        result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);
      }
      return result;
    }
    _getDracoMetadataField(dracoMetadata, entryName) {
      const dracoArray = new this.draco.DracoInt32Array();
      try {
        this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);
        const intArray = getInt32Array(dracoArray);
        return {
          int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),
          string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),
          double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),
          intArray
        };
      } finally {
        this.draco.destroy(dracoArray);
      }
    }
    _disableAttributeTransforms(options) {
      const {
        quantizedAttributes = [],
        octahedronAttributes = []
      } = options;
      const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];
      for (const dracoAttributeName of skipAttributes) {
        this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);
      }
    }
    _getQuantizationTransform(dracoAttribute, options) {
      const {
        quantizedAttributes = []
      } = options;
      const attribute_type = dracoAttribute.attribute_type();
      const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);
      if (skip) {
        const transform3 = new this.draco.AttributeQuantizationTransform();
        try {
          if (transform3.InitFromAttribute(dracoAttribute)) {
            return {
              quantization_bits: transform3.quantization_bits(),
              range: transform3.range(),
              min_values: new Float32Array([1, 2, 3]).map((i3) => transform3.min_value(i3))
            };
          }
        } finally {
          this.draco.destroy(transform3);
        }
      }
      return null;
    }
    _getOctahedronTransform(dracoAttribute, options) {
      const {
        octahedronAttributes = []
      } = options;
      const attribute_type = dracoAttribute.attribute_type();
      const octahedron = octahedronAttributes.map((type) => this.decoder[type]).includes(attribute_type);
      if (octahedron) {
        const transform3 = new this.draco.AttributeQuantizationTransform();
        try {
          if (transform3.InitFromAttribute(dracoAttribute)) {
            return {
              quantization_bits: transform3.quantization_bits()
            };
          }
        } finally {
          this.draco.destroy(transform3);
        }
      }
      return null;
    }
  };
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
      default:
        return draco.DT_INVALID;
    }
  }
  function getInt32Array(dracoArray) {
    const numValues = dracoArray.size();
    const intArray = new Int32Array(numValues);
    for (let i3 = 0; i3 < numValues; i3++) {
      intArray[i3] = dracoArray.GetValue(i3);
    }
    return intArray;
  }
  function getUint32Array(dracoArray) {
    const numValues = dracoArray.size();
    const intArray = new Int32Array(numValues);
    for (let i3 = 0; i3 < numValues; i3++) {
      intArray[i3] = dracoArray.GetValue(i3);
    }
    return intArray;
  }

  // ../../node_modules/@loaders.gl/draco/dist/esm/lib/draco-module-loader.js
  var DRACO_DECODER_VERSION = "1.5.5";
  var DRACO_ENCODER_VERSION = "1.4.1";
  var STATIC_DECODER_URL = "https://www.gstatic.com/draco/versioned/decoders/".concat(DRACO_DECODER_VERSION);
  var DRACO_JS_DECODER_URL = "".concat(STATIC_DECODER_URL, "/draco_decoder.js");
  var DRACO_WASM_WRAPPER_URL = "".concat(STATIC_DECODER_URL, "/draco_wasm_wrapper.js");
  var DRACO_WASM_DECODER_URL = "".concat(STATIC_DECODER_URL, "/draco_decoder.wasm");
  var DRACO_ENCODER_URL = "https://raw.githubusercontent.com/google/draco/".concat(DRACO_ENCODER_VERSION, "/javascript/draco_encoder.js");
  var loadDecoderPromise;
  async function loadDracoDecoderModule(options) {
    const modules = options.modules || {};
    if (modules.draco3d) {
      loadDecoderPromise = loadDecoderPromise || modules.draco3d.createDecoderModule({}).then((draco) => {
        return {
          draco
        };
      });
    } else {
      loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);
    }
    return await loadDecoderPromise;
  }
  async function loadDracoDecoder(options) {
    let DracoDecoderModule;
    let wasmBinary;
    switch (options.draco && options.draco.decoderType) {
      case "js":
        DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, "draco", options);
        break;
      case "wasm":
      default:
        [DracoDecoderModule, wasmBinary] = await Promise.all([await loadLibrary(DRACO_WASM_WRAPPER_URL, "draco", options), await loadLibrary(DRACO_WASM_DECODER_URL, "draco", options)]);
    }
    DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;
    return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);
  }
  function initializeDracoDecoder(DracoDecoderModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve2) => {
      DracoDecoderModule({
        ...options,
        onModuleLoaded: (draco) => resolve2({
          draco
        })
      });
    });
  }

  // ../../node_modules/@loaders.gl/draco/dist/esm/index.js
  var DracoLoader2 = {
    ...DracoLoader,
    parse: parse2
  };
  async function parse2(arrayBuffer2, options) {
    const {
      draco
    } = await loadDracoDecoderModule(options);
    const dracoParser = new DracoParser(draco);
    try {
      return dracoParser.parseSync(arrayBuffer2, options === null || options === void 0 ? void 0 : options.draco);
    } finally {
      dracoParser.destroy();
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-attribute-utils.js
  function getGLTFAccessors(attributes) {
    const accessors = {};
    for (const name10 in attributes) {
      const attribute = attributes[name10];
      if (name10 !== "indices") {
        const glTFAccessor = getGLTFAccessor(attribute);
        accessors[name10] = glTFAccessor;
      }
    }
    return accessors;
  }
  function getGLTFAccessor(attribute) {
    const {
      buffer,
      size,
      count: count2
    } = getAccessorData(attribute);
    const glTFAccessor = {
      value: buffer,
      size,
      byteOffset: 0,
      count: count2,
      type: getAccessorTypeFromSize(size),
      componentType: getComponentTypeFromArray(buffer)
    };
    return glTFAccessor;
  }
  function getAccessorData(attribute) {
    let buffer = attribute;
    let size = 1;
    let count2 = 0;
    if (attribute && attribute.value) {
      buffer = attribute.value;
      size = attribute.size || 1;
    }
    if (buffer) {
      if (!ArrayBuffer.isView(buffer)) {
        buffer = toTypedArray2(buffer, Float32Array);
      }
      count2 = buffer.length / size;
    }
    return {
      buffer,
      size,
      count: count2
    };
  }
  function toTypedArray2(array, ArrayType) {
    let convertTypedArrays = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!array) {
      return null;
    }
    if (Array.isArray(array)) {
      return new ArrayType(array);
    }
    if (convertTypedArrays && !(array instanceof ArrayType)) {
      return new ArrayType(array);
    }
    return array;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_draco_mesh_compression.js
  var KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression";
  var name4 = KHR_DRACO_MESH_COMPRESSION;
  function preprocess3(gltfData, options, context) {
    const scenegraph = new GLTFScenegraph(gltfData);
    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
      if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
      }
    }
  }
  async function decode3(gltfData, options, context) {
    var _options$gltf;
    if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {
      return;
    }
    const scenegraph = new GLTFScenegraph(gltfData);
    const promises = [];
    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
      if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
        promises.push(decompressPrimitive(scenegraph, primitive, options, context));
      }
    }
    await Promise.all(promises);
    scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);
  }
  function encode(gltfData) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const scenegraph = new GLTFScenegraph(gltfData);
    for (const mesh of scenegraph.json.meshes || []) {
      compressMesh(mesh, options);
      scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);
    }
  }
  async function decompressPrimitive(scenegraph, primitive, options, context) {
    const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
    if (!dracoExtension) {
      return;
    }
    const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);
    const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);
    const {
      parse: parse5
    } = context;
    const dracoOptions = {
      ...options
    };
    delete dracoOptions["3d-tiles"];
    const decodedData = await parse5(bufferCopy, DracoLoader2, dracoOptions, context);
    const decodedAttributes = getGLTFAccessors(decodedData.attributes);
    for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {
      if (attributeName in primitive.attributes) {
        const accessorIndex = primitive.attributes[attributeName];
        const accessor = scenegraph.getAccessor(accessorIndex);
        if (accessor !== null && accessor !== void 0 && accessor.min && accessor !== null && accessor !== void 0 && accessor.max) {
          decodedAttribute.min = accessor.min;
          decodedAttribute.max = accessor.max;
        }
      }
    }
    primitive.attributes = decodedAttributes;
    if (decodedData.indices) {
      primitive.indices = getGLTFAccessor(decodedData.indices);
    }
    checkPrimitive(primitive);
  }
  function compressMesh(attributes, indices) {
    var _context$parseSync;
    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4;
    let options = arguments.length > 3 ? arguments[3] : void 0;
    let context = arguments.length > 4 ? arguments[4] : void 0;
    if (!options.DracoWriter) {
      throw new Error("options.gltf.DracoWriter not provided");
    }
    const compressedData = options.DracoWriter.encodeSync({
      attributes
    });
    const decodedData = context === null || context === void 0 ? void 0 : (_context$parseSync = context.parseSync) === null || _context$parseSync === void 0 ? void 0 : _context$parseSync.call(context, {
      attributes
    });
    const fauxAccessors = options._addFauxAttributes(decodedData.attributes);
    const bufferViewIndex = options.addBufferView(compressedData);
    const glTFMesh = {
      primitives: [{
        attributes: fauxAccessors,
        mode,
        extensions: {
          [KHR_DRACO_MESH_COMPRESSION]: {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors
          }
        }
      }]
    };
    return glTFMesh;
  }
  function checkPrimitive(primitive) {
    if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
      throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
    }
  }
  function* makeMeshPrimitiveIterator(scenegraph) {
    for (const mesh of scenegraph.json.meshes || []) {
      for (const primitive of mesh.primitives) {
        yield primitive;
      }
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_transform.js
  var KHR_texture_transform_exports = {};
  __export(KHR_texture_transform_exports, {
    decode: () => decode4,
    name: () => name5
  });

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js
  var COMPONENTS = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var BYTES = {
    5120: 1,
    5121: 1,
    5122: 2,
    5123: 2,
    5125: 4,
    5126: 4
  };

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_transform.js
  var EXT_MESHOPT_TRANSFORM = "KHR_texture_transform";
  var name5 = EXT_MESHOPT_TRANSFORM;
  var scratchVector7 = new Vector3();
  var scratchRotationMatrix = new Matrix3();
  var scratchScaleMatrix = new Matrix3();
  async function decode4(gltfData, options) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const extension = gltfScenegraph.getExtension(EXT_MESHOPT_TRANSFORM);
    if (!extension) {
      return;
    }
    const materials = gltfData.json.materials || [];
    for (let i3 = 0; i3 < materials.length; i3++) {
      transformTexCoords(i3, gltfData);
    }
  }
  function transformTexCoords(materialIndex, gltfData) {
    var _gltfData$json$materi, _material$pbrMetallic, _material$pbrMetallic2;
    const processedTexCoords = [];
    const material = (_gltfData$json$materi = gltfData.json.materials) === null || _gltfData$json$materi === void 0 ? void 0 : _gltfData$json$materi[materialIndex];
    const baseColorTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic = material.pbrMetallicRoughness) === null || _material$pbrMetallic === void 0 ? void 0 : _material$pbrMetallic.baseColorTexture;
    if (baseColorTexture) {
      transformPrimitives(gltfData, materialIndex, baseColorTexture, processedTexCoords);
    }
    const emisiveTexture = material === null || material === void 0 ? void 0 : material.emissiveTexture;
    if (emisiveTexture) {
      transformPrimitives(gltfData, materialIndex, emisiveTexture, processedTexCoords);
    }
    const normalTexture = material === null || material === void 0 ? void 0 : material.normalTexture;
    if (normalTexture) {
      transformPrimitives(gltfData, materialIndex, normalTexture, processedTexCoords);
    }
    const occlusionTexture = material === null || material === void 0 ? void 0 : material.occlusionTexture;
    if (occlusionTexture) {
      transformPrimitives(gltfData, materialIndex, occlusionTexture, processedTexCoords);
    }
    const metallicRoughnessTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic2 = material.pbrMetallicRoughness) === null || _material$pbrMetallic2 === void 0 ? void 0 : _material$pbrMetallic2.metallicRoughnessTexture;
    if (metallicRoughnessTexture) {
      transformPrimitives(gltfData, materialIndex, metallicRoughnessTexture, processedTexCoords);
    }
  }
  function transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {
    const transformParameters = getTransformParameters(texture, processedTexCoords);
    if (!transformParameters) {
      return;
    }
    const meshes = gltfData.json.meshes || [];
    for (const mesh of meshes) {
      for (const primitive of mesh.primitives) {
        const material = primitive.material;
        if (Number.isFinite(material) && materialIndex === material) {
          transformPrimitive(gltfData, primitive, transformParameters);
        }
      }
    }
  }
  function getTransformParameters(texture, processedTexCoords) {
    var _texture$extensions;
    const textureInfo = (_texture$extensions = texture.extensions) === null || _texture$extensions === void 0 ? void 0 : _texture$extensions[EXT_MESHOPT_TRANSFORM];
    const {
      texCoord: originalTexCoord = 0
    } = texture;
    const {
      texCoord = originalTexCoord
    } = textureInfo;
    const isProcessed = processedTexCoords.findIndex((_ref) => {
      let [original, newTexCoord] = _ref;
      return original === originalTexCoord && newTexCoord === texCoord;
    }) !== -1;
    if (!isProcessed) {
      const matrix = makeTransformationMatrix(textureInfo);
      if (originalTexCoord !== texCoord) {
        texture.texCoord = texCoord;
      }
      processedTexCoords.push([originalTexCoord, texCoord]);
      return {
        originalTexCoord,
        texCoord,
        matrix
      };
    }
    return null;
  }
  function transformPrimitive(gltfData, primitive, transformParameters) {
    const {
      originalTexCoord,
      texCoord,
      matrix
    } = transformParameters;
    const texCoordAccessor = primitive.attributes["TEXCOORD_".concat(originalTexCoord)];
    if (Number.isFinite(texCoordAccessor)) {
      var _gltfData$json$access;
      const accessor = (_gltfData$json$access = gltfData.json.accessors) === null || _gltfData$json$access === void 0 ? void 0 : _gltfData$json$access[texCoordAccessor];
      if (accessor && accessor.bufferView) {
        var _gltfData$json$buffer;
        const bufferView = (_gltfData$json$buffer = gltfData.json.bufferViews) === null || _gltfData$json$buffer === void 0 ? void 0 : _gltfData$json$buffer[accessor.bufferView];
        if (bufferView) {
          const {
            arrayBuffer: arrayBuffer2,
            byteOffset: bufferByteOffset
          } = gltfData.buffers[bufferView.buffer];
          const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);
          const {
            ArrayType,
            length: length7
          } = getAccessorArrayTypeAndLength(accessor, bufferView);
          const bytes = BYTES[accessor.componentType];
          const components = COMPONENTS[accessor.type];
          const elementAddressScale = bufferView.byteStride || bytes * components;
          const result = new Float32Array(length7);
          for (let i3 = 0; i3 < accessor.count; i3++) {
            const uv = new ArrayType(arrayBuffer2, byteOffset + i3 * elementAddressScale, 2);
            scratchVector7.set(uv[0], uv[1], 1);
            scratchVector7.transformByMatrix3(matrix);
            result.set([scratchVector7[0], scratchVector7[1]], i3 * components);
          }
          if (originalTexCoord === texCoord) {
            updateGltf(accessor, bufferView, gltfData.buffers, result);
          } else {
            createAttribute(texCoord, accessor, primitive, gltfData, result);
          }
        }
      }
    }
  }
  function updateGltf(accessor, bufferView, buffers, newTexCoordArray) {
    accessor.componentType = 5126;
    buffers.push({
      arrayBuffer: newTexCoordArray.buffer,
      byteOffset: 0,
      byteLength: newTexCoordArray.buffer.byteLength
    });
    bufferView.buffer = buffers.length - 1;
    bufferView.byteLength = newTexCoordArray.buffer.byteLength;
    bufferView.byteOffset = 0;
    delete bufferView.byteStride;
  }
  function createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {
    gltfData.buffers.push({
      arrayBuffer: newTexCoordArray.buffer,
      byteOffset: 0,
      byteLength: newTexCoordArray.buffer.byteLength
    });
    const bufferViews = gltfData.json.bufferViews;
    if (!bufferViews) {
      return;
    }
    bufferViews.push({
      buffer: gltfData.buffers.length - 1,
      byteLength: newTexCoordArray.buffer.byteLength,
      byteOffset: 0
    });
    const accessors = gltfData.json.accessors;
    if (!accessors) {
      return;
    }
    accessors.push({
      bufferView: (bufferViews === null || bufferViews === void 0 ? void 0 : bufferViews.length) - 1,
      byteOffset: 0,
      componentType: 5126,
      count: originalAccessor.count,
      type: "VEC2"
    });
    primitive.attributes["TEXCOORD_".concat(newTexCoord)] = accessors.length - 1;
  }
  function makeTransformationMatrix(extensionData) {
    const {
      offset = [0, 0],
      rotation = 0,
      scale: scale8 = [1, 1]
    } = extensionData;
    const translationMatirx = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);
    const rotationMatirx = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);
    const scaleMatrix = scratchScaleMatrix.set(scale8[0], 0, 0, 0, scale8[1], 0, 0, 0, 1);
    return translationMatirx.multiplyRight(rotationMatirx).multiplyRight(scaleMatrix);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_lights_punctual.js
  var KHR_lights_punctual_exports = {};
  __export(KHR_lights_punctual_exports, {
    decode: () => decode5,
    encode: () => encode2,
    name: () => name6
  });
  var KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual";
  var name6 = KHR_LIGHTS_PUNCTUAL;
  async function decode5(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);
    if (extension) {
      gltfScenegraph.json.lights = extension.lights;
      gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);
    }
    for (const node2 of json.nodes || []) {
      const nodeExtension = gltfScenegraph.getObjectExtension(node2, KHR_LIGHTS_PUNCTUAL);
      if (nodeExtension) {
        node2.light = nodeExtension.light;
      }
      gltfScenegraph.removeObjectExtension(node2, KHR_LIGHTS_PUNCTUAL);
    }
  }
  async function encode2(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    if (json.lights) {
      const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);
      assert13(!extension.lights);
      extension.lights = json.lights;
      delete json.lights;
    }
    if (gltfScenegraph.json.lights) {
      for (const light of gltfScenegraph.json.lights) {
        const node2 = light.node;
        gltfScenegraph.addObjectExtension(node2, KHR_LIGHTS_PUNCTUAL, light);
      }
      delete gltfScenegraph.json.lights;
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_materials_unlit.js
  var KHR_materials_unlit_exports = {};
  __export(KHR_materials_unlit_exports, {
    decode: () => decode6,
    encode: () => encode3,
    name: () => name7
  });
  var KHR_MATERIALS_UNLIT = "KHR_materials_unlit";
  var name7 = KHR_MATERIALS_UNLIT;
  async function decode6(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    for (const material of json.materials || []) {
      const extension = material.extensions && material.extensions.KHR_materials_unlit;
      if (extension) {
        material.unlit = true;
      }
      gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);
    }
    gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);
  }
  function encode3(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    if (gltfScenegraph.materials) {
      for (const material of json.materials || []) {
        if (material.unlit) {
          delete material.unlit;
          gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});
          gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_techniques_webgl.js
  var KHR_techniques_webgl_exports = {};
  __export(KHR_techniques_webgl_exports, {
    decode: () => decode7,
    encode: () => encode4,
    name: () => name8
  });
  var KHR_TECHNIQUES_WEBGL = "KHR_techniques_webgl";
  var name8 = KHR_TECHNIQUES_WEBGL;
  async function decode7(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);
    if (extension) {
      const techniques = resolveTechniques(extension, gltfScenegraph);
      for (const material of json.materials || []) {
        const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);
        if (materialExtension) {
          material.technique = Object.assign({}, materialExtension, techniques[materialExtension.technique]);
          material.technique.values = resolveValues(material.technique, gltfScenegraph);
        }
        gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);
      }
      gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);
    }
  }
  async function encode4(gltfData, options) {
  }
  function resolveTechniques(techniquesExtension, gltfScenegraph) {
    const {
      programs = [],
      shaders = [],
      techniques = []
    } = techniquesExtension;
    const textDecoder = new TextDecoder();
    shaders.forEach((shader) => {
      if (Number.isFinite(shader.bufferView)) {
        shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));
      } else {
        throw new Error("KHR_techniques_webgl: no shader code");
      }
    });
    programs.forEach((program) => {
      program.fragmentShader = shaders[program.fragmentShader];
      program.vertexShader = shaders[program.vertexShader];
    });
    techniques.forEach((technique) => {
      technique.program = programs[technique.program];
    });
    return techniques;
  }
  function resolveValues(technique, gltfScenegraph) {
    const values = Object.assign({}, technique.values);
    Object.keys(technique.uniforms || {}).forEach((uniform) => {
      if (technique.uniforms[uniform].value && !(uniform in values)) {
        values[uniform] = technique.uniforms[uniform].value;
      }
    });
    Object.keys(values).forEach((uniform) => {
      if (typeof values[uniform] === "object" && values[uniform].index !== void 0) {
        values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);
      }
    });
    return values;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/EXT_feature_metadata.js
  var EXT_feature_metadata_exports = {};
  __export(EXT_feature_metadata_exports, {
    decode: () => decode8,
    name: () => name9
  });
  var EXT_FEATURE_METADATA = "EXT_feature_metadata";
  var name9 = EXT_FEATURE_METADATA;
  async function decode8(gltfData) {
    const scenegraph = new GLTFScenegraph(gltfData);
    decodeExtFeatureMetadata(scenegraph);
  }
  function decodeExtFeatureMetadata(scenegraph) {
    var _extension$schema;
    const extension = scenegraph.getExtension(EXT_FEATURE_METADATA);
    const schemaClasses = extension === null || extension === void 0 ? void 0 : (_extension$schema = extension.schema) === null || _extension$schema === void 0 ? void 0 : _extension$schema.classes;
    const featureTables = extension === null || extension === void 0 ? void 0 : extension.featureTables;
    const featureTextures = extension === null || extension === void 0 ? void 0 : extension.featureTextures;
    if (featureTextures) {
      console.warn('featureTextures is not yet supported in the "EXT_feature_metadata" extension.');
    }
    if (schemaClasses && featureTables) {
      for (const schemaName in schemaClasses) {
        const schemaClass = schemaClasses[schemaName];
        const featureTable = findFeatureTableByName(featureTables, schemaName);
        if (featureTable) {
          handleFeatureTableProperties(scenegraph, featureTable, schemaClass);
        }
      }
    }
  }
  function handleFeatureTableProperties(scenegraph, featureTable, schemaClass) {
    for (const propertyName in schemaClass.properties) {
      var _featureTable$propert;
      const schemaProperty = schemaClass.properties[propertyName];
      const featureTableProperty = featureTable === null || featureTable === void 0 ? void 0 : (_featureTable$propert = featureTable.properties) === null || _featureTable$propert === void 0 ? void 0 : _featureTable$propert[propertyName];
      const numberOfFeatures = featureTable.count;
      if (featureTableProperty) {
        const data = getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty);
        featureTableProperty.data = data;
      }
    }
  }
  function getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty) {
    const bufferView = featureTableProperty.bufferView;
    let data = scenegraph.getTypedArrayForBufferView(bufferView);
    switch (schemaProperty.type) {
      case "STRING": {
        const stringOffsetBufferView = featureTableProperty.stringOffsetBufferView;
        const offsetsData = scenegraph.getTypedArrayForBufferView(stringOffsetBufferView);
        data = getStringAttributes(data, offsetsData, numberOfFeatures);
        break;
      }
      default:
    }
    return data;
  }
  function findFeatureTableByName(featureTables, schemaClassName) {
    for (const featureTableName in featureTables) {
      const featureTable = featureTables[featureTableName];
      if (featureTable.class === schemaClassName) {
        return featureTable;
      }
    }
    return null;
  }
  function getStringAttributes(data, offsetsData, stringsCount) {
    const stringsArray = [];
    const textDecoder = new TextDecoder("utf8");
    let stringOffset = 0;
    const bytesPerStringSize = 4;
    for (let index = 0; index < stringsCount; index++) {
      const stringByteSize = offsetsData[(index + 1) * bytesPerStringSize] - offsetsData[index * bytesPerStringSize];
      const stringData = data.subarray(stringOffset, stringByteSize + stringOffset);
      const stringAttribute = textDecoder.decode(stringData);
      stringsArray.push(stringAttribute);
      stringOffset += stringByteSize;
    }
    return stringsArray;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-extensions.js
  var EXTENSIONS2 = [EXT_meshopt_compression_exports, EXT_texture_webp_exports, KHR_texture_basisu_exports, KHR_draco_mesh_compression_exports, KHR_lights_punctual_exports, KHR_materials_unlit_exports, KHR_techniques_webgl_exports, KHR_texture_transform_exports, EXT_feature_metadata_exports];
  function preprocessExtensions(gltf) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let context = arguments.length > 2 ? arguments[2] : void 0;
    const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
    for (const extension of extensions) {
      var _extension$preprocess;
      (_extension$preprocess = extension.preprocess) === null || _extension$preprocess === void 0 ? void 0 : _extension$preprocess.call(extension, gltf, options, context);
    }
  }
  async function decodeExtensions(gltf) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let context = arguments.length > 2 ? arguments[2] : void 0;
    const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
    for (const extension of extensions) {
      var _extension$decode;
      await ((_extension$decode = extension.decode) === null || _extension$decode === void 0 ? void 0 : _extension$decode.call(extension, gltf, options, context));
    }
  }
  function useExtension(extensionName, options) {
    var _options$gltf;
    const excludes = (options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.excludeExtensions) || {};
    const exclude = extensionName in excludes && !excludes[extensionName];
    return !exclude;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_binary_gltf.js
  var KHR_BINARY_GLTF = "KHR_binary_glTF";
  function preprocess4(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    for (const image of json.images || []) {
      const extension = gltfScenegraph.getObjectExtension(image, KHR_BINARY_GLTF);
      if (extension) {
        Object.assign(image, extension);
      }
      gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);
    }
    if (json.buffers && json.buffers[0]) {
      delete json.buffers[0].uri;
    }
    gltfScenegraph.removeExtension(KHR_BINARY_GLTF);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/normalize-gltf-v1.js
  var GLTF_ARRAYS = {
    accessors: "accessor",
    animations: "animation",
    buffers: "buffer",
    bufferViews: "bufferView",
    images: "image",
    materials: "material",
    meshes: "mesh",
    nodes: "node",
    samplers: "sampler",
    scenes: "scene",
    skins: "skin",
    textures: "texture"
  };
  var GLTF_KEYS = {
    accessor: "accessors",
    animations: "animation",
    buffer: "buffers",
    bufferView: "bufferViews",
    image: "images",
    material: "materials",
    mesh: "meshes",
    node: "nodes",
    sampler: "samplers",
    scene: "scenes",
    skin: "skins",
    texture: "textures"
  };
  var GLTFV1Normalizer = class {
    constructor() {
      _defineProperty(this, "idToIndexMap", {
        animations: {},
        accessors: {},
        buffers: {},
        bufferViews: {},
        images: {},
        materials: {},
        meshes: {},
        nodes: {},
        samplers: {},
        scenes: {},
        skins: {},
        textures: {}
      });
      _defineProperty(this, "json", void 0);
    }
    normalize(gltf, options) {
      this.json = gltf.json;
      const json = gltf.json;
      switch (json.asset && json.asset.version) {
        case "2.0":
          return;
        case void 0:
        case "1.0":
          break;
        default:
          console.warn("glTF: Unknown version ".concat(json.asset.version));
          return;
      }
      if (!options.normalize) {
        throw new Error("glTF v1 is not supported.");
      }
      console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail.");
      this._addAsset(json);
      this._convertTopLevelObjectsToArrays(json);
      preprocess4(gltf);
      this._convertObjectIdsToArrayIndices(json);
      this._updateObjects(json);
      this._updateMaterial(json);
    }
    _addAsset(json) {
      json.asset = json.asset || {};
      json.asset.version = "2.0";
      json.asset.generator = json.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
    }
    _convertTopLevelObjectsToArrays(json) {
      for (const arrayName in GLTF_ARRAYS) {
        this._convertTopLevelObjectToArray(json, arrayName);
      }
    }
    _convertTopLevelObjectToArray(json, mapName) {
      const objectMap = json[mapName];
      if (!objectMap || Array.isArray(objectMap)) {
        return;
      }
      json[mapName] = [];
      for (const id in objectMap) {
        const object = objectMap[id];
        object.id = object.id || id;
        const index = json[mapName].length;
        json[mapName].push(object);
        this.idToIndexMap[mapName][id] = index;
      }
    }
    _convertObjectIdsToArrayIndices(json) {
      for (const arrayName in GLTF_ARRAYS) {
        this._convertIdsToIndices(json, arrayName);
      }
      if ("scene" in json) {
        json.scene = this._convertIdToIndex(json.scene, "scene");
      }
      for (const texture of json.textures) {
        this._convertTextureIds(texture);
      }
      for (const mesh of json.meshes) {
        this._convertMeshIds(mesh);
      }
      for (const node2 of json.nodes) {
        this._convertNodeIds(node2);
      }
      for (const node2 of json.scenes) {
        this._convertSceneIds(node2);
      }
    }
    _convertTextureIds(texture) {
      if (texture.source) {
        texture.source = this._convertIdToIndex(texture.source, "image");
      }
    }
    _convertMeshIds(mesh) {
      for (const primitive of mesh.primitives) {
        const {
          attributes,
          indices,
          material
        } = primitive;
        for (const attributeName in attributes) {
          attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], "accessor");
        }
        if (indices) {
          primitive.indices = this._convertIdToIndex(indices, "accessor");
        }
        if (material) {
          primitive.material = this._convertIdToIndex(material, "material");
        }
      }
    }
    _convertNodeIds(node2) {
      if (node2.children) {
        node2.children = node2.children.map((child) => this._convertIdToIndex(child, "node"));
      }
      if (node2.meshes) {
        node2.meshes = node2.meshes.map((mesh) => this._convertIdToIndex(mesh, "mesh"));
      }
    }
    _convertSceneIds(scene) {
      if (scene.nodes) {
        scene.nodes = scene.nodes.map((node2) => this._convertIdToIndex(node2, "node"));
      }
    }
    _convertIdsToIndices(json, topLevelArrayName) {
      if (!json[topLevelArrayName]) {
        console.warn("gltf v1: json doesn't contain attribute ".concat(topLevelArrayName));
        json[topLevelArrayName] = [];
      }
      for (const object of json[topLevelArrayName]) {
        for (const key in object) {
          const id = object[key];
          const index = this._convertIdToIndex(id, key);
          object[key] = index;
        }
      }
    }
    _convertIdToIndex(id, key) {
      const arrayName = GLTF_KEYS[key];
      if (arrayName in this.idToIndexMap) {
        const index = this.idToIndexMap[arrayName][id];
        if (!Number.isFinite(index)) {
          throw new Error("gltf v1: failed to resolve ".concat(key, " with id ").concat(id));
        }
        return index;
      }
      return id;
    }
    _updateObjects(json) {
      for (const buffer of this.json.buffers) {
        delete buffer.type;
      }
    }
    _updateMaterial(json) {
      for (const material of json.materials) {
        var _material$values, _material$values2, _material$values3;
        material.pbrMetallicRoughness = {
          baseColorFactor: [1, 1, 1, 1],
          metallicFactor: 1,
          roughnessFactor: 1
        };
        const textureId = ((_material$values = material.values) === null || _material$values === void 0 ? void 0 : _material$values.tex) || ((_material$values2 = material.values) === null || _material$values2 === void 0 ? void 0 : _material$values2.texture2d_0) || ((_material$values3 = material.values) === null || _material$values3 === void 0 ? void 0 : _material$values3.diffuseTex);
        const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);
        if (textureIndex !== -1) {
          material.pbrMetallicRoughness.baseColorTexture = {
            index: textureIndex
          };
        }
      }
    }
  };
  function normalizeGLTFV1(gltf) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return new GLTFV1Normalizer().normalize(gltf, options);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/api/post-process-gltf.js
  var COMPONENTS2 = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var BYTES2 = {
    5120: 1,
    5121: 1,
    5122: 2,
    5123: 2,
    5125: 4,
    5126: 4
  };
  var GL_SAMPLER = {
    TEXTURE_MAG_FILTER: 10240,
    TEXTURE_MIN_FILTER: 10241,
    TEXTURE_WRAP_S: 10242,
    TEXTURE_WRAP_T: 10243,
    REPEAT: 10497,
    LINEAR: 9729,
    NEAREST_MIPMAP_LINEAR: 9986
  };
  var SAMPLER_PARAMETER_GLTF_TO_GL = {
    magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
    minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
    wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
    wrapT: GL_SAMPLER.TEXTURE_WRAP_T
  };
  var DEFAULT_SAMPLER = {
    [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
    [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
    [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
    [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT
  };
  function getBytesFromComponentType(componentType) {
    return BYTES2[componentType];
  }
  function getSizeFromAccessorType(type) {
    return COMPONENTS2[type];
  }
  var GLTFPostProcessor = class {
    constructor() {
      _defineProperty(this, "baseUri", "");
      _defineProperty(this, "json", {});
      _defineProperty(this, "buffers", []);
      _defineProperty(this, "images", []);
    }
    postProcess(gltf) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        json,
        buffers = [],
        images = [],
        baseUri = ""
      } = gltf;
      assert13(json);
      this.baseUri = baseUri;
      this.json = json;
      this.buffers = buffers;
      this.images = images;
      this._resolveTree(this.json, options);
      return this.json;
    }
    _resolveTree(json) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (json.bufferViews) {
        json.bufferViews = json.bufferViews.map((bufView, i3) => this._resolveBufferView(bufView, i3));
      }
      if (json.images) {
        json.images = json.images.map((image, i3) => this._resolveImage(image, i3));
      }
      if (json.samplers) {
        json.samplers = json.samplers.map((sampler, i3) => this._resolveSampler(sampler, i3));
      }
      if (json.textures) {
        json.textures = json.textures.map((texture, i3) => this._resolveTexture(texture, i3));
      }
      if (json.accessors) {
        json.accessors = json.accessors.map((accessor, i3) => this._resolveAccessor(accessor, i3));
      }
      if (json.materials) {
        json.materials = json.materials.map((material, i3) => this._resolveMaterial(material, i3));
      }
      if (json.meshes) {
        json.meshes = json.meshes.map((mesh, i3) => this._resolveMesh(mesh, i3));
      }
      if (json.nodes) {
        json.nodes = json.nodes.map((node2, i3) => this._resolveNode(node2, i3));
      }
      if (json.skins) {
        json.skins = json.skins.map((skin, i3) => this._resolveSkin(skin, i3));
      }
      if (json.scenes) {
        json.scenes = json.scenes.map((scene, i3) => this._resolveScene(scene, i3));
      }
      if (json.scene !== void 0) {
        json.scene = json.scenes[this.json.scene];
      }
    }
    getScene(index) {
      return this._get("scenes", index);
    }
    getNode(index) {
      return this._get("nodes", index);
    }
    getSkin(index) {
      return this._get("skins", index);
    }
    getMesh(index) {
      return this._get("meshes", index);
    }
    getMaterial(index) {
      return this._get("materials", index);
    }
    getAccessor(index) {
      return this._get("accessors", index);
    }
    getCamera(index) {
      return null;
    }
    getTexture(index) {
      return this._get("textures", index);
    }
    getSampler(index) {
      return this._get("samplers", index);
    }
    getImage(index) {
      return this._get("images", index);
    }
    getBufferView(index) {
      return this._get("bufferViews", index);
    }
    getBuffer(index) {
      return this._get("buffers", index);
    }
    _get(array, index) {
      if (typeof index === "object") {
        return index;
      }
      const object = this.json[array] && this.json[array][index];
      if (!object) {
        console.warn("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
      }
      return object;
    }
    _resolveScene(scene, index) {
      scene.id = scene.id || "scene-".concat(index);
      scene.nodes = (scene.nodes || []).map((node2) => this.getNode(node2));
      return scene;
    }
    _resolveNode(node2, index) {
      node2.id = node2.id || "node-".concat(index);
      if (node2.children) {
        node2.children = node2.children.map((child) => this.getNode(child));
      }
      if (node2.mesh !== void 0) {
        node2.mesh = this.getMesh(node2.mesh);
      } else if (node2.meshes !== void 0 && node2.meshes.length) {
        node2.mesh = node2.meshes.reduce((accum, meshIndex) => {
          const mesh = this.getMesh(meshIndex);
          accum.id = mesh.id;
          accum.primitives = accum.primitives.concat(mesh.primitives);
          return accum;
        }, {
          primitives: []
        });
      }
      if (node2.camera !== void 0) {
        node2.camera = this.getCamera(node2.camera);
      }
      if (node2.skin !== void 0) {
        node2.skin = this.getSkin(node2.skin);
      }
      return node2;
    }
    _resolveSkin(skin, index) {
      skin.id = skin.id || "skin-".concat(index);
      skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);
      return skin;
    }
    _resolveMesh(mesh, index) {
      mesh.id = mesh.id || "mesh-".concat(index);
      if (mesh.primitives) {
        mesh.primitives = mesh.primitives.map((primitive) => {
          primitive = {
            ...primitive
          };
          const attributes = primitive.attributes;
          primitive.attributes = {};
          for (const attribute in attributes) {
            primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);
          }
          if (primitive.indices !== void 0) {
            primitive.indices = this.getAccessor(primitive.indices);
          }
          if (primitive.material !== void 0) {
            primitive.material = this.getMaterial(primitive.material);
          }
          return primitive;
        });
      }
      return mesh;
    }
    _resolveMaterial(material, index) {
      material.id = material.id || "material-".concat(index);
      if (material.normalTexture) {
        material.normalTexture = {
          ...material.normalTexture
        };
        material.normalTexture.texture = this.getTexture(material.normalTexture.index);
      }
      if (material.occlusionTexture) {
        material.occlustionTexture = {
          ...material.occlustionTexture
        };
        material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
      }
      if (material.emissiveTexture) {
        material.emmisiveTexture = {
          ...material.emmisiveTexture
        };
        material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
      }
      if (!material.emissiveFactor) {
        material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];
      }
      if (material.pbrMetallicRoughness) {
        material.pbrMetallicRoughness = {
          ...material.pbrMetallicRoughness
        };
        const mr = material.pbrMetallicRoughness;
        if (mr.baseColorTexture) {
          mr.baseColorTexture = {
            ...mr.baseColorTexture
          };
          mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
        }
        if (mr.metallicRoughnessTexture) {
          mr.metallicRoughnessTexture = {
            ...mr.metallicRoughnessTexture
          };
          mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
        }
      }
      return material;
    }
    _resolveAccessor(accessor, index) {
      accessor.id = accessor.id || "accessor-".concat(index);
      if (accessor.bufferView !== void 0) {
        accessor.bufferView = this.getBufferView(accessor.bufferView);
      }
      accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);
      accessor.components = getSizeFromAccessorType(accessor.type);
      accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;
      if (accessor.bufferView) {
        const buffer = accessor.bufferView.buffer;
        const {
          ArrayType,
          byteLength
        } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);
        const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;
        let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);
        if (accessor.bufferView.byteStride) {
          cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);
        }
        accessor.value = new ArrayType(cutBuffer);
      }
      return accessor;
    }
    _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count2) {
      const result = new Uint8Array(count2 * bytesPerElement);
      for (let i3 = 0; i3 < count2; i3++) {
        const elementOffset = byteOffset + i3 * byteStride;
        result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i3 * bytesPerElement);
      }
      return result.buffer;
    }
    _resolveTexture(texture, index) {
      texture.id = texture.id || "texture-".concat(index);
      texture.sampler = "sampler" in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;
      texture.source = this.getImage(texture.source);
      return texture;
    }
    _resolveSampler(sampler, index) {
      sampler.id = sampler.id || "sampler-".concat(index);
      sampler.parameters = {};
      for (const key in sampler) {
        const glEnum = this._enumSamplerParameter(key);
        if (glEnum !== void 0) {
          sampler.parameters[glEnum] = sampler[key];
        }
      }
      return sampler;
    }
    _enumSamplerParameter(key) {
      return SAMPLER_PARAMETER_GLTF_TO_GL[key];
    }
    _resolveImage(image, index) {
      image.id = image.id || "image-".concat(index);
      if (image.bufferView !== void 0) {
        image.bufferView = this.getBufferView(image.bufferView);
      }
      const preloadedImage = this.images[index];
      if (preloadedImage) {
        image.image = preloadedImage;
      }
      return image;
    }
    _resolveBufferView(bufferView, index) {
      const bufferIndex = bufferView.buffer;
      const result = {
        id: "bufferView-".concat(index),
        ...bufferView,
        buffer: this.buffers[bufferIndex]
      };
      const arrayBuffer2 = this.buffers[bufferIndex].arrayBuffer;
      let byteOffset = this.buffers[bufferIndex].byteOffset || 0;
      if ("byteOffset" in bufferView) {
        byteOffset += bufferView.byteOffset;
      }
      result.data = new Uint8Array(arrayBuffer2, byteOffset, bufferView.byteLength);
      return result;
    }
    _resolveCamera(camera, index) {
      camera.id = camera.id || "camera-".concat(index);
      if (camera.perspective) {
      }
      if (camera.orthographic) {
      }
      return camera;
    }
  };
  function postProcessGLTF(gltf, options) {
    return new GLTFPostProcessor().postProcess(gltf, options);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-glb.js
  var MAGIC_glTF = 1735152710;
  var GLB_FILE_HEADER_SIZE = 12;
  var GLB_CHUNK_HEADER_SIZE = 8;
  var GLB_CHUNK_TYPE_JSON = 1313821514;
  var GLB_CHUNK_TYPE_BIN = 5130562;
  var GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;
  var GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;
  var GLB_V1_CONTENT_FORMAT_JSON = 0;
  var LE = true;
  function getMagicString3(dataView) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return "".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));
  }
  function isGLB(arrayBuffer2) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const dataView = new DataView(arrayBuffer2);
    const {
      magic = MAGIC_glTF
    } = options;
    const magic1 = dataView.getUint32(byteOffset, false);
    return magic1 === magic || magic1 === MAGIC_glTF;
  }
  function parseGLBSync(glb, arrayBuffer2) {
    let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const dataView = new DataView(arrayBuffer2);
    const type = getMagicString3(dataView, byteOffset + 0);
    const version = dataView.getUint32(byteOffset + 4, LE);
    const byteLength = dataView.getUint32(byteOffset + 8, LE);
    Object.assign(glb, {
      header: {
        byteOffset,
        byteLength,
        hasBinChunk: false
      },
      type,
      version,
      json: {},
      binChunks: []
    });
    byteOffset += GLB_FILE_HEADER_SIZE;
    switch (glb.version) {
      case 1:
        return parseGLBV1(glb, dataView, byteOffset);
      case 2:
        return parseGLBV2(glb, dataView, byteOffset, options = {});
      default:
        throw new Error("Invalid GLB version ".concat(glb.version, ". Only supports v1 and v2."));
    }
  }
  function parseGLBV1(glb, dataView, byteOffset) {
    assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
    const contentLength = dataView.getUint32(byteOffset + 0, LE);
    const contentFormat = dataView.getUint32(byteOffset + 4, LE);
    byteOffset += GLB_CHUNK_HEADER_SIZE;
    assert2(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);
    parseJSONChunk(glb, dataView, byteOffset, contentLength);
    byteOffset += contentLength;
    byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);
    return byteOffset;
  }
  function parseGLBV2(glb, dataView, byteOffset, options) {
    assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
    parseGLBChunksSync(glb, dataView, byteOffset, options);
    return byteOffset + glb.header.byteLength;
  }
  function parseGLBChunksSync(glb, dataView, byteOffset, options) {
    while (byteOffset + 8 <= glb.header.byteLength) {
      const chunkLength = dataView.getUint32(byteOffset + 0, LE);
      const chunkFormat = dataView.getUint32(byteOffset + 4, LE);
      byteOffset += GLB_CHUNK_HEADER_SIZE;
      switch (chunkFormat) {
        case GLB_CHUNK_TYPE_JSON:
          parseJSONChunk(glb, dataView, byteOffset, chunkLength);
          break;
        case GLB_CHUNK_TYPE_BIN:
          parseBINChunk(glb, dataView, byteOffset, chunkLength);
          break;
        case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
          if (!options.strict) {
            parseJSONChunk(glb, dataView, byteOffset, chunkLength);
          }
          break;
        case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
          if (!options.strict) {
            parseBINChunk(glb, dataView, byteOffset, chunkLength);
          }
          break;
        default:
          break;
      }
      byteOffset += padToNBytes(chunkLength, 4);
    }
    return byteOffset;
  }
  function parseJSONChunk(glb, dataView, byteOffset, chunkLength) {
    const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);
    const textDecoder = new TextDecoder("utf8");
    const jsonText = textDecoder.decode(jsonChunk);
    glb.json = JSON.parse(jsonText);
    return padToNBytes(chunkLength, 4);
  }
  function parseBINChunk(glb, dataView, byteOffset, chunkLength) {
    glb.header.hasBinChunk = true;
    glb.binChunks.push({
      byteOffset,
      byteLength: chunkLength,
      arrayBuffer: dataView.buffer
    });
    return padToNBytes(chunkLength, 4);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-gltf.js
  async function parseGLTF(gltf, arrayBufferOrString) {
    var _options$gltf, _options$gltf2, _options$gltf3, _options$gltf4;
    let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let options = arguments.length > 3 ? arguments[3] : void 0;
    let context = arguments.length > 4 ? arguments[4] : void 0;
    parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
    normalizeGLTFV1(gltf, {
      normalize: options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.normalize
    });
    preprocessExtensions(gltf, options, context);
    const promises = [];
    if (options !== null && options !== void 0 && (_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadBuffers && gltf.json.buffers) {
      await loadBuffers(gltf, options, context);
    }
    if (options !== null && options !== void 0 && (_options$gltf3 = options.gltf) !== null && _options$gltf3 !== void 0 && _options$gltf3.loadImages) {
      const promise2 = loadImages(gltf, options, context);
      promises.push(promise2);
    }
    const promise = decodeExtensions(gltf, options, context);
    promises.push(promise);
    await Promise.all(promises);
    return options !== null && options !== void 0 && (_options$gltf4 = options.gltf) !== null && _options$gltf4 !== void 0 && _options$gltf4.postProcess ? postProcessGLTF(gltf, options) : gltf;
  }
  function parseGLTFContainerSync(gltf, data, byteOffset, options) {
    if (options.uri) {
      gltf.baseUri = options.uri;
    }
    if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {
      const textDecoder = new TextDecoder();
      data = textDecoder.decode(data);
    }
    if (typeof data === "string") {
      gltf.json = parseJSON(data);
    } else if (data instanceof ArrayBuffer) {
      const glb = {};
      byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);
      assert13(glb.type === "glTF", "Invalid GLB magic string ".concat(glb.type));
      gltf._glb = glb;
      gltf.json = glb.json;
    } else {
      assert13(false, "GLTF: must be ArrayBuffer or string");
    }
    const buffers = gltf.json.buffers || [];
    gltf.buffers = new Array(buffers.length).fill(null);
    if (gltf._glb && gltf._glb.header.hasBinChunk) {
      const {
        binChunks
      } = gltf._glb;
      gltf.buffers[0] = {
        arrayBuffer: binChunks[0].arrayBuffer,
        byteOffset: binChunks[0].byteOffset,
        byteLength: binChunks[0].byteLength
      };
    }
    const images = gltf.json.images || [];
    gltf.images = new Array(images.length).fill({});
  }
  async function loadBuffers(gltf, options, context) {
    const buffers = gltf.json.buffers || [];
    for (let i3 = 0; i3 < buffers.length; ++i3) {
      const buffer = buffers[i3];
      if (buffer.uri) {
        var _context$fetch, _response$arrayBuffer;
        const {
          fetch: fetch2
        } = context;
        assert13(fetch2);
        const uri = resolveUrl(buffer.uri, options);
        const response = await (context === null || context === void 0 ? void 0 : (_context$fetch = context.fetch) === null || _context$fetch === void 0 ? void 0 : _context$fetch.call(context, uri));
        const arrayBuffer2 = await (response === null || response === void 0 ? void 0 : (_response$arrayBuffer = response.arrayBuffer) === null || _response$arrayBuffer === void 0 ? void 0 : _response$arrayBuffer.call(response));
        gltf.buffers[i3] = {
          arrayBuffer: arrayBuffer2,
          byteOffset: 0,
          byteLength: arrayBuffer2.byteLength
        };
        delete buffer.uri;
      } else if (gltf.buffers[i3] === null) {
        gltf.buffers[i3] = {
          arrayBuffer: new ArrayBuffer(buffer.byteLength),
          byteOffset: 0,
          byteLength: buffer.byteLength
        };
      }
    }
  }
  async function loadImages(gltf, options, context) {
    const imageIndices = getReferencesImageIndices(gltf);
    const images = gltf.json.images || [];
    const promises = [];
    for (const imageIndex of imageIndices) {
      promises.push(loadImage2(gltf, images[imageIndex], imageIndex, options, context));
    }
    return await Promise.all(promises);
  }
  function getReferencesImageIndices(gltf) {
    const imageIndices = /* @__PURE__ */ new Set();
    const textures = gltf.json.textures || [];
    for (const texture of textures) {
      if (texture.source !== void 0) {
        imageIndices.add(texture.source);
      }
    }
    return Array.from(imageIndices).sort();
  }
  async function loadImage2(gltf, image, index, options, context) {
    const {
      fetch: fetch2,
      parse: parse5
    } = context;
    let arrayBuffer2;
    if (image.uri && !image.hasOwnProperty("bufferView")) {
      const uri = resolveUrl(image.uri, options);
      const response = await fetch2(uri);
      arrayBuffer2 = await response.arrayBuffer();
      image.bufferView = {
        data: arrayBuffer2
      };
    }
    if (Number.isFinite(image.bufferView)) {
      const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);
      arrayBuffer2 = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);
    }
    assert13(arrayBuffer2, "glTF image has no data");
    let parsedImage = await parse5(arrayBuffer2, [ImageLoader, BasisLoader], {
      mimeType: image.mimeType,
      basis: options.basis || {
        format: selectSupportedBasisFormat()
      }
    }, context);
    if (parsedImage && parsedImage[0]) {
      parsedImage = {
        compressed: true,
        mipmaps: false,
        width: parsedImage[0].width,
        height: parsedImage[0].height,
        data: parsedImage[0]
      };
    }
    gltf.images = gltf.images || [];
    gltf.images[index] = parsedImage;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/esm/gltf-loader.js
  var GLTFLoader = {
    name: "glTF",
    id: "gltf",
    module: "gltf",
    version: VERSION11,
    extensions: ["gltf", "glb"],
    mimeTypes: ["model/gltf+json", "model/gltf-binary"],
    text: true,
    binary: true,
    tests: ["glTF"],
    parse: parse3,
    options: {
      gltf: {
        normalize: true,
        loadBuffers: true,
        loadImages: true,
        decompressMeshes: true,
        postProcess: true
      },
      log: console
    },
    deprecatedOptions: {
      fetchImages: "gltf.loadImages",
      createImages: "gltf.loadImages",
      decompress: "gltf.decompressMeshes",
      postProcess: "gltf.postProcess",
      gltf: {
        decompress: "gltf.decompressMeshes"
      }
    }
  };
  async function parse3(arrayBuffer2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let context = arguments.length > 2 ? arguments[2] : void 0;
    options = {
      ...GLTFLoader.options,
      ...options
    };
    options.gltf = {
      ...GLTFLoader.options.gltf,
      ...options.gltf
    };
    const {
      byteOffset = 0
    } = options;
    const gltf = {};
    return await parseGLTF(gltf, arrayBuffer2, byteOffset, options, context);
  }

  // ../mesh-layers/src/scenegraph-layer/gltf-utils.ts
  async function waitForGLTFAssets(gltfObjects) {
    const remaining = [];
    gltfObjects.scenes.forEach((scene) => {
      scene.traverse((model) => {
        Object.values(model.model.getUniforms()).forEach((uniform) => {
          if (uniform.loaded === false) {
            remaining.push(uniform);
          }
        });
      });
    });
    return await waitWhileCondition(() => remaining.some((uniform) => !uniform.loaded));
  }
  async function waitWhileCondition(condition) {
    while (condition()) {
      await new Promise((resolve2) => requestAnimationFrame(resolve2));
    }
  }

  // ../mesh-layers/src/scenegraph-layer/scenegraph-layer-vertex.glsl.ts
  var scenegraph_layer_vertex_glsl_default = `#version 300 es

// Instance attributes
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
in vec3 instanceTranslation;

// Uniforms
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform mat4 sceneModelMatrix;
uniform bool composeModelMatrix;

// Attributes
in vec4 POSITION;

#ifdef HAS_UV
  in vec2 TEXCOORD_0;
#endif

#ifdef MODULE_PBR
  #ifdef HAS_NORMALS
    in vec4 NORMAL;
  #endif
#endif

// Varying
out vec4 vColor;

// MODULE_PBR contains all the varying definitions needed
#ifndef MODULE_PBR
  #ifdef HAS_UV
    out vec2 vTEXCOORD_0;
  #endif
#endif

// Main
void main(void) {
  #if defined(HAS_UV) && !defined(MODULE_PBR)
    vTEXCOORD_0 = TEXCOORD_0;
    geometry.uv = vTEXCOORD_0;
  #endif

  geometry.worldPosition = instancePositions;
  geometry.pickingColor = instancePickingColors;

  vec3 normal = vec3(0.0, 0.0, 1.0);
  #ifdef MODULE_PBR
    #ifdef HAS_NORMALS
      normal = instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz;
    #endif
  #endif

  float originalSize = project_size_to_pixel(sizeScale);
  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);

  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;
  if(composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    // using instancePositions as world coordinates
    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth
    // call project_normal before setting position to avoid rotation
    geometry.normal = project_normal(normal);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
    geometry.normal = project_normal(normal);
  }
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBR
    // set PBR data
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = TEXCOORD_0;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  vColor = instanceColors;
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../mesh-layers/src/scenegraph-layer/scenegraph-layer-fragment.glsl.ts
  var scenegraph_layer_fragment_glsl_default = `#version 300 es

// Uniforms
uniform float opacity;

// Varying
in vec4 vColor;

out vec4 fragmentColor;

// MODULE_PBR contains all the varying definitions needed
#ifndef MODULE_PBR
  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
    in vec2 vTEXCOORD_0;
    uniform sampler2D u_BaseColorSampler;
  #endif
#endif

void main(void) {
  #ifdef MODULE_PBR
    fragmentColor = vColor * pbr_filterColor(vec4(0));
    geometry.uv = pbr_vUV;
  #else
    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);
      geometry.uv = vTEXCOORD_0;
    #else
      fragmentColor = vColor;
    #endif
  #endif

  fragmentColor.a *= opacity;
  DECKGL_FILTER_COLOR(fragmentColor, geometry);
}
`;

  // ../mesh-layers/src/scenegraph-layer/scenegraph-layer.ts
  var DEFAULT_COLOR11 = [255, 255, 255, 255];
  var defaultProps28 = {
    scenegraph: {
      type: "object",
      value: null,
      async: true
    },
    getScene: (gltf) => {
      if (gltf && gltf.scenes) {
        return typeof gltf.scene === "object" ? gltf.scene : gltf.scenes[gltf.scene || 0];
      }
      return gltf;
    },
    getAnimator: (scenegraph) => scenegraph && scenegraph.animator,
    _animations: null,
    sizeScale: {
      type: "number",
      value: 1,
      min: 0
    },
    sizeMinPixels: {
      type: "number",
      min: 0,
      value: 0
    },
    sizeMaxPixels: {
      type: "number",
      min: 0,
      value: Number.MAX_SAFE_INTEGER
    },
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR11
    },
    _lighting: "flat",
    _imageBasedLightingEnvironment: null,
    getOrientation: {
      type: "accessor",
      value: [0, 0, 0]
    },
    getScale: {
      type: "accessor",
      value: [1, 1, 1]
    },
    getTranslation: {
      type: "accessor",
      value: [0, 0, 0]
    },
    getTransformMatrix: {
      type: "accessor",
      value: []
    },
    loaders: [GLTFLoader]
  };
  var ScenegraphLayer = class extends Layer {
    getShaders() {
      const modules = [project32_default, picking_default];
      if (this.props._lighting === "pbr") {
        modules.push(pbr);
      }
      return {
        vs: scenegraph_layer_vertex_glsl_default,
        fs: scenegraph_layer_fragment_glsl_default,
        modules
      };
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions(),
          accessor: "getPosition",
          transition: true
        },
        instanceColors: {
          type: esm_default2.UNSIGNED_BYTE,
          size: this.props.colorFormat.length,
          accessor: "getColor",
          normalized: true,
          defaultValue: DEFAULT_COLOR11,
          transition: true
        },
        instanceModelMatrix: MATRIX_ATTRIBUTES
      });
    }
    updateState(params) {
      super.updateState(params);
      const {
        props,
        oldProps
      } = params;
      if (props.scenegraph !== oldProps.scenegraph) {
        this._updateScenegraph();
      } else if (props._animations !== oldProps._animations) {
        this._applyAnimationsProp(this.state.scenegraph, this.state.animator, props._animations);
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this._deleteScenegraph();
    }
    _updateScenegraph() {
      const props = this.props;
      const {
        gl
      } = this.context;
      let scenegraphData = null;
      if (props.scenegraph instanceof ScenegraphNode) {
        scenegraphData = {
          scenes: [props.scenegraph]
        };
      } else if (props.scenegraph && !props.scenegraph.gltf) {
        const gltf = props.scenegraph;
        const gltfObjects = createGLTFObjects(gl, gltf, this._getModelOptions());
        scenegraphData = {
          gltf,
          ...gltfObjects
        };
        waitForGLTFAssets(gltfObjects).then(() => this.setNeedsRedraw());
      } else if (props.scenegraph) {
        log_default.deprecated("ScenegraphLayer.props.scenegraph", "Use GLTFLoader instead of GLTFScenegraphLoader")();
        scenegraphData = props.scenegraph;
      }
      const options = {
        layer: this,
        gl
      };
      const scenegraph = props.getScene(scenegraphData, options);
      const animator = props.getAnimator(scenegraphData, options);
      if (scenegraph instanceof ScenegraphNode) {
        this._deleteScenegraph();
        this._applyAllAttributes(scenegraph);
        this._applyAnimationsProp(scenegraph, animator, props._animations);
        this.setState({
          scenegraph,
          animator
        });
      } else if (scenegraph !== null) {
        log_default.warn("invalid scenegraph:", scenegraph)();
      }
    }
    _applyAllAttributes(scenegraph) {
      if (this.state.attributesAvailable) {
        const allAttributes = this.getAttributeManager().getAttributes();
        scenegraph.traverse((model) => {
          this._setModelAttributes(model.model, allAttributes);
        });
      }
    }
    _applyAnimationsProp(scenegraph, animator, animationsProp) {
      if (!scenegraph || !animator || !animationsProp) {
        return;
      }
      const animations = animator.getAnimations();
      Object.keys(animationsProp).sort().forEach((key) => {
        const value = animationsProp[key];
        if (key === "*") {
          animations.forEach((animation) => {
            Object.assign(animation, value);
          });
        } else if (Number.isFinite(Number(key))) {
          const number = Number(key);
          if (number >= 0 && number < animations.length) {
            Object.assign(animations[number], value);
          } else {
            log_default.warn(`animation ${key} not found`)();
          }
        } else {
          const findResult = animations.find(({
            name: name10
          }) => name10 === key);
          if (findResult) {
            Object.assign(findResult, value);
          } else {
            log_default.warn(`animation ${key} not found`)();
          }
        }
      });
    }
    _deleteScenegraph() {
      const {
        scenegraph
      } = this.state;
      if (scenegraph instanceof ScenegraphNode) {
        scenegraph.delete();
      }
    }
    _getModelOptions() {
      const {
        _imageBasedLightingEnvironment
      } = this.props;
      let env = null;
      if (_imageBasedLightingEnvironment) {
        if (typeof _imageBasedLightingEnvironment === "function") {
          env = _imageBasedLightingEnvironment({
            gl: this.context.gl,
            layer: this
          });
        } else {
          env = _imageBasedLightingEnvironment;
        }
      }
      return {
        gl: this.context.gl,
        waitForFullLoad: true,
        imageBasedLightingEnvironment: env,
        modelOptions: {
          isInstanced: true,
          transpileToGLSL100: !isWebGL2(this.context.gl),
          ...this.getShaders()
        },
        useTangents: false
      };
    }
    updateAttributes(changedAttributes) {
      this.setState({
        attributesAvailable: true
      });
      if (!this.state.scenegraph)
        return;
      this.state.scenegraph.traverse((model) => {
        this._setModelAttributes(model.model, changedAttributes);
      });
    }
    draw({
      moduleParameters = null,
      parameters: parameters2 = {},
      context
    }) {
      if (!this.state.scenegraph)
        return;
      if (this.props._animations && this.state.animator) {
        this.state.animator.animate(context.timeline.getTime());
        this.setNeedsRedraw();
      }
      const {
        viewport
      } = this.context;
      const {
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels,
        opacity,
        coordinateSystem
      } = this.props;
      const numInstances = this.getNumInstances();
      this.state.scenegraph.traverse((model, {
        worldMatrix
      }) => {
        model.model.setInstanceCount(numInstances);
        model.updateModuleSettings(moduleParameters);
        model.draw({
          parameters: parameters2,
          uniforms: {
            sizeScale,
            opacity,
            sizeMinPixels,
            sizeMaxPixels,
            composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),
            sceneModelMatrix: worldMatrix,
            u_Camera: model.model.getUniforms().project_uCameraPosition
          }
        });
      });
    }
  };
  __publicField(ScenegraphLayer, "defaultProps", defaultProps28);
  __publicField(ScenegraphLayer, "layerName", "ScenegraphLayer");

  // ../geo-layers/src/mesh-layer/mesh-layer-vertex.glsl.ts
  var mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs

// Scale the model
uniform float sizeScale;
uniform bool composeModelMatrix;
uniform bool pickFeatureIds;

// Primitive attributes
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;

// Instance attributes
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;

// Outputs to fragment shader
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

vec2 applyUVRegion(vec2 uv) {
  #ifdef HAS_UV_REGIONS
    // https://github.com/Esri/i3s-spec/blob/master/docs/1.7/geometryUVRegion.cmn.md
    return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
  #else
    return uv;
  #endif
}

void main(void) {
  vec2 uv = applyUVRegion(texCoords);
  geometry.uv = uv;

  if (pickFeatureIds) {
    geometry.pickingColor = featureIdsPickingColors;
  } else {
    geometry.pickingColor = instancePickingColors;
  }

  vTexCoord = uv;
  cameraPosition = project_uCameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  vec3 pos = (instanceModelMatrix * positions) * sizeScale;
  vec3 projectedPosition = project_position(positions);
  position_commonspace = vec4(projectedPosition, 1.0);
  gl_Position = project_common_position_to_clipspace(position_commonspace);

  geometry.position = position_commonspace;
  normals_commonspace = project_normal(instanceModelMatrix * normals);
  geometry.normal = normals_commonspace;

  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBR
    // set PBR data
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = uv;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../geo-layers/src/mesh-layer/mesh-layer-fragment.glsl.ts
  var mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  
#ifdef MODULE_PBR

  fragColor = vColor * pbr_filterColor(vec4(0));
  geometry.uv = pbr_vUV;
  fragColor.a *= opacity;

#else

  geometry.uv = vTexCoord;

  vec3 normal;
  if (flatShading) {

// NOTE(Tarek): This is necessary because
// headless.gl reports the extension as
// available but does not support it in
// the shader.
#ifdef DERIVATIVES_AVAILABLE
    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
#else
    normal = vec3(0.0, 0.0, 1.0);
#endif
  } else {
    normal = normals_commonspace;
  }

  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * opacity);

#endif

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../geo-layers/src/mesh-layer/mesh-layer.ts
  function validateGeometryAttributes2(attributes) {
    const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
    if (!hasColorAttribute) {
      attributes.colors = {
        constant: true,
        value: new Float32Array([1, 1, 1])
      };
    }
  }
  var defaultProps29 = {
    pbrMaterial: {
      type: "object",
      value: null
    },
    featureIds: {
      type: "array",
      value: null,
      optional: true
    }
  };
  var MeshLayer = class extends SimpleMeshLayer {
    getShaders() {
      const shaders = super.getShaders();
      const modules = shaders.modules;
      modules.push(pbr);
      return {
        ...shaders,
        vs: mesh_layer_vertex_glsl_default,
        fs: mesh_layer_fragment_glsl_default
      };
    }
    initializeState() {
      const {
        featureIds
      } = this.props;
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      if (featureIds) {
        attributeManager.add({
          featureIdsPickingColors: {
            type: esm_default2.UNSIGNED_BYTE,
            size: 3,
            noAlloc: true,
            update: this.calculateFeatureIdsPickingColors
          }
        });
      }
    }
    updateState(params) {
      super.updateState(params);
      const {
        props,
        oldProps
      } = params;
      if (props.pbrMaterial !== oldProps.pbrMaterial) {
        this.updatePbrMaterialUniforms(props.pbrMaterial);
      }
    }
    draw(opts) {
      const {
        featureIds
      } = this.props;
      if (!this.state.model) {
        return;
      }
      this.state.model.setUniforms({
        u_Camera: this.state.model.getUniforms().project_uCameraPosition,
        pickFeatureIds: Boolean(featureIds)
      });
      super.draw(opts);
    }
    getModel(mesh) {
      const {
        id,
        pbrMaterial
      } = this.props;
      const materialParser = this.parseMaterial(pbrMaterial, mesh);
      this.setState({
        materialParser
      });
      const shaders = this.getShaders();
      validateGeometryAttributes2(mesh.attributes);
      const model = new Model(this.context.gl, {
        ...this.getShaders(),
        id,
        geometry: mesh,
        defines: {
          ...shaders.defines,
          ...materialParser?.defines,
          HAS_UV_REGIONS: mesh.attributes.uvRegions
        },
        parameters: materialParser?.parameters,
        isInstanced: true
      });
      return model;
    }
    updatePbrMaterialUniforms(pbrMaterial) {
      const {
        model
      } = this.state;
      if (model) {
        const {
          mesh
        } = this.props;
        const materialParser = this.parseMaterial(pbrMaterial, mesh);
        this.setState({
          materialParser
        });
        model.setUniforms(materialParser.uniforms);
      }
    }
    parseMaterial(pbrMaterial, mesh) {
      const unlit = Boolean(pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture);
      this.state.materialParser?.delete();
      return new GLTFMaterialParser(this.context.gl, {
        attributes: {
          NORMAL: mesh.attributes.normals,
          TEXCOORD_0: mesh.attributes.texCoords
        },
        material: {
          unlit,
          ...pbrMaterial
        },
        pbrDebug: false,
        imageBasedLightingEnvironment: null,
        lights: true,
        useTangents: false
      });
    }
    calculateFeatureIdsPickingColors(attribute) {
      const featureIds = this.props.featureIds;
      const value = new Uint8ClampedArray(featureIds.length * attribute.size);
      const pickingColor = [];
      for (let index = 0; index < featureIds.length; index++) {
        this.encodePickingColor(featureIds[index], pickingColor);
        value[index * 3] = pickingColor[0];
        value[index * 3 + 1] = pickingColor[1];
        value[index * 3 + 2] = pickingColor[2];
      }
      attribute.value = value;
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.materialParser?.delete();
      this.setState({
        materialParser: null
      });
    }
  };
  __publicField(MeshLayer, "layerName", "MeshLayer");
  __publicField(MeshLayer, "defaultProps", defaultProps29);

  // ../../node_modules/@math.gl/geospatial/node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty5(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // ../../node_modules/@math.gl/geospatial/dist/esm/constants.js
  var WGS84_RADIUS_X = 6378137;
  var WGS84_RADIUS_Y = 6378137;
  var WGS84_RADIUS_Z = 6356752314245179e-9;
  var WGS84_CONSTANTS = {
    radii: [WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z],
    radiiSquared: [WGS84_RADIUS_X * WGS84_RADIUS_X, WGS84_RADIUS_Y * WGS84_RADIUS_Y, WGS84_RADIUS_Z * WGS84_RADIUS_Z],
    oneOverRadii: [1 / WGS84_RADIUS_X, 1 / WGS84_RADIUS_Y, 1 / WGS84_RADIUS_Z],
    oneOverRadiiSquared: [1 / (WGS84_RADIUS_X * WGS84_RADIUS_X), 1 / (WGS84_RADIUS_Y * WGS84_RADIUS_Y), 1 / (WGS84_RADIUS_Z * WGS84_RADIUS_Z)],
    maximumRadius: Math.max(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z),
    centerToleranceSquared: 0.1
  };

  // ../../node_modules/@math.gl/geospatial/dist/esm/type-utils.js
  function identity3(x2) {
    return x2;
  }
  var scratchVector8 = new Vector3();
  function fromCartographic(cartographic, result = [], map2 = identity3) {
    if ("longitude" in cartographic) {
      result[0] = map2(cartographic.longitude);
      result[1] = map2(cartographic.latitude);
      result[2] = cartographic.height;
    } else if ("x" in cartographic) {
      result[0] = map2(cartographic.x);
      result[1] = map2(cartographic.y);
      result[2] = cartographic.z;
    } else {
      result[0] = map2(cartographic[0]);
      result[1] = map2(cartographic[1]);
      result[2] = cartographic[2];
    }
    return result;
  }
  function fromCartographicToRadians(cartographic, vector = []) {
    return fromCartographic(cartographic, vector, config._cartographicRadians ? identity3 : toRadians);
  }
  function toCartographic(vector, cartographic, map2 = identity3) {
    if ("longitude" in cartographic) {
      cartographic.longitude = map2(vector[0]);
      cartographic.latitude = map2(vector[1]);
      cartographic.height = vector[2];
    } else if ("x" in cartographic) {
      cartographic.x = map2(vector[0]);
      cartographic.y = map2(vector[1]);
      cartographic.z = vector[2];
    } else {
      cartographic[0] = map2(vector[0]);
      cartographic[1] = map2(vector[1]);
      cartographic[2] = vector[2];
    }
    return cartographic;
  }
  function toCartographicFromRadians(vector, cartographic) {
    return toCartographic(vector, cartographic, config._cartographicRadians ? identity3 : toDegrees);
  }

  // ../../node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/scale-to-geodetic-surface.js
  var scratchVector9 = new Vector3();
  var scaleToGeodeticSurfaceIntersection = new Vector3();
  var scaleToGeodeticSurfaceGradient = new Vector3();
  function scaleToGeodeticSurface(cartesian, ellipsoid, result = []) {
    const {
      oneOverRadii,
      oneOverRadiiSquared,
      centerToleranceSquared
    } = ellipsoid;
    scratchVector9.from(cartesian);
    const positionX = scratchVector9.x;
    const positionY = scratchVector9.y;
    const positionZ = scratchVector9.z;
    const oneOverRadiiX = oneOverRadii.x;
    const oneOverRadiiY = oneOverRadii.y;
    const oneOverRadiiZ = oneOverRadii.z;
    const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
    const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
    const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;
    const squaredNorm = x2 + y2 + z2;
    const ratio = Math.sqrt(1 / squaredNorm);
    if (!Number.isFinite(ratio)) {
      return void 0;
    }
    const intersection = scaleToGeodeticSurfaceIntersection;
    intersection.copy(cartesian).scale(ratio);
    if (squaredNorm < centerToleranceSquared) {
      return intersection.to(result);
    }
    const oneOverRadiiSquaredX = oneOverRadiiSquared.x;
    const oneOverRadiiSquaredY = oneOverRadiiSquared.y;
    const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;
    const gradient = scaleToGeodeticSurfaceGradient;
    gradient.set(intersection.x * oneOverRadiiSquaredX * 2, intersection.y * oneOverRadiiSquaredY * 2, intersection.z * oneOverRadiiSquaredZ * 2);
    let lambda = (1 - ratio) * scratchVector9.len() / (0.5 * gradient.len());
    let correction = 0;
    let xMultiplier;
    let yMultiplier;
    let zMultiplier;
    let func;
    do {
      lambda -= correction;
      xMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredX);
      yMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredY);
      zMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredZ);
      const xMultiplier2 = xMultiplier * xMultiplier;
      const yMultiplier2 = yMultiplier * yMultiplier;
      const zMultiplier2 = zMultiplier * zMultiplier;
      const xMultiplier3 = xMultiplier2 * xMultiplier;
      const yMultiplier3 = yMultiplier2 * yMultiplier;
      const zMultiplier3 = zMultiplier2 * zMultiplier;
      func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1;
      const denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
      const derivative = -2 * denominator;
      correction = func / derivative;
    } while (Math.abs(func) > math_utils_default.EPSILON12);
    return scratchVector9.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);
  }

  // ../../node_modules/@math.gl/geospatial/dist/esm/ellipsoid/helpers/ellipsoid-transform.js
  var EPSILON14 = 1e-14;
  var scratchOrigin = new Vector3();
  var VECTOR_PRODUCT_LOCAL_FRAME = {
    up: {
      south: "east",
      north: "west",
      west: "south",
      east: "north"
    },
    down: {
      south: "west",
      north: "east",
      west: "north",
      east: "south"
    },
    south: {
      up: "west",
      down: "east",
      west: "down",
      east: "up"
    },
    north: {
      up: "east",
      down: "west",
      west: "up",
      east: "down"
    },
    west: {
      up: "north",
      down: "south",
      north: "down",
      south: "up"
    },
    east: {
      up: "south",
      down: "north",
      north: "up",
      south: "down"
    }
  };
  var degeneratePositionLocalFrame = {
    north: [-1, 0, 0],
    east: [0, 1, 0],
    up: [0, 0, 1],
    south: [1, 0, 0],
    west: [0, -1, 0],
    down: [0, 0, -1]
  };
  var scratchAxisVectors = {
    east: new Vector3(),
    north: new Vector3(),
    up: new Vector3(),
    west: new Vector3(),
    south: new Vector3(),
    down: new Vector3()
  };
  var scratchVector1 = new Vector3();
  var scratchVector24 = new Vector3();
  var scratchVector34 = new Vector3();
  function localFrameToFixedFrame(ellipsoid, firstAxis, secondAxis, thirdAxis, cartesianOrigin, result) {
    const thirdAxisInferred = VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];
    assert9(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));
    let firstAxisVector;
    let secondAxisVector;
    let thirdAxisVector;
    const origin = scratchOrigin.copy(cartesianOrigin);
    const atPole = equals(origin.x, 0, EPSILON14) && equals(origin.y, 0, EPSILON14);
    if (atPole) {
      const sign2 = Math.sign(origin.z);
      firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);
      if (firstAxis !== "east" && firstAxis !== "west") {
        firstAxisVector.scale(sign2);
      }
      secondAxisVector = scratchVector24.fromArray(degeneratePositionLocalFrame[secondAxis]);
      if (secondAxis !== "east" && secondAxis !== "west") {
        secondAxisVector.scale(sign2);
      }
      thirdAxisVector = scratchVector34.fromArray(degeneratePositionLocalFrame[thirdAxis]);
      if (thirdAxis !== "east" && thirdAxis !== "west") {
        thirdAxisVector.scale(sign2);
      }
    } else {
      const {
        up,
        east,
        north
      } = scratchAxisVectors;
      east.set(-origin.y, origin.x, 0).normalize();
      ellipsoid.geodeticSurfaceNormal(origin, up);
      north.copy(up).cross(east);
      const {
        down,
        west,
        south
      } = scratchAxisVectors;
      down.copy(up).scale(-1);
      west.copy(east).scale(-1);
      south.copy(north).scale(-1);
      firstAxisVector = scratchAxisVectors[firstAxis];
      secondAxisVector = scratchAxisVectors[secondAxis];
      thirdAxisVector = scratchAxisVectors[thirdAxis];
    }
    result[0] = firstAxisVector.x;
    result[1] = firstAxisVector.y;
    result[2] = firstAxisVector.z;
    result[3] = 0;
    result[4] = secondAxisVector.x;
    result[5] = secondAxisVector.y;
    result[6] = secondAxisVector.z;
    result[7] = 0;
    result[8] = thirdAxisVector.x;
    result[9] = thirdAxisVector.y;
    result[10] = thirdAxisVector.z;
    result[11] = 0;
    result[12] = origin.x;
    result[13] = origin.y;
    result[14] = origin.z;
    result[15] = 1;
    return result;
  }

  // ../../node_modules/@math.gl/geospatial/dist/esm/ellipsoid/ellipsoid.js
  var scratchVector10 = new Vector3();
  var scratchNormal3 = new Vector3();
  var scratchK = new Vector3();
  var scratchPosition2 = new Vector3();
  var scratchHeight = new Vector3();
  var scratchCartesian = new Vector3();
  var Ellipsoid = class {
    constructor(x2 = 0, y2 = 0, z = 0) {
      _defineProperty5(this, "radii", void 0);
      _defineProperty5(this, "radiiSquared", void 0);
      _defineProperty5(this, "radiiToTheFourth", void 0);
      _defineProperty5(this, "oneOverRadii", void 0);
      _defineProperty5(this, "oneOverRadiiSquared", void 0);
      _defineProperty5(this, "minimumRadius", void 0);
      _defineProperty5(this, "maximumRadius", void 0);
      _defineProperty5(this, "centerToleranceSquared", math_utils_default.EPSILON1);
      _defineProperty5(this, "squaredXOverSquaredZ", void 0);
      assert9(x2 >= 0);
      assert9(y2 >= 0);
      assert9(z >= 0);
      this.radii = new Vector3(x2, y2, z);
      this.radiiSquared = new Vector3(x2 * x2, y2 * y2, z * z);
      this.radiiToTheFourth = new Vector3(x2 * x2 * x2 * x2, y2 * y2 * y2 * y2, z * z * z * z);
      this.oneOverRadii = new Vector3(x2 === 0 ? 0 : 1 / x2, y2 === 0 ? 0 : 1 / y2, z === 0 ? 0 : 1 / z);
      this.oneOverRadiiSquared = new Vector3(x2 === 0 ? 0 : 1 / (x2 * x2), y2 === 0 ? 0 : 1 / (y2 * y2), z === 0 ? 0 : 1 / (z * z));
      this.minimumRadius = Math.min(x2, y2, z);
      this.maximumRadius = Math.max(x2, y2, z);
      if (this.radiiSquared.z !== 0) {
        this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;
      }
      Object.freeze(this);
    }
    equals(right) {
      return this === right || Boolean(right && this.radii.equals(right.radii));
    }
    toString() {
      return this.radii.toString();
    }
    cartographicToCartesian(cartographic, result = [0, 0, 0]) {
      const normal = scratchNormal3;
      const k = scratchK;
      const [, , height] = cartographic;
      this.geodeticSurfaceNormalCartographic(cartographic, normal);
      k.copy(this.radiiSquared).scale(normal);
      const gamma = Math.sqrt(normal.dot(k));
      k.scale(1 / gamma);
      normal.scale(height);
      k.add(normal);
      return k.to(result);
    }
    cartesianToCartographic(cartesian, result = [0, 0, 0]) {
      scratchCartesian.from(cartesian);
      const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition2);
      if (!point) {
        return void 0;
      }
      const normal = this.geodeticSurfaceNormal(point, scratchNormal3);
      const h = scratchHeight;
      h.copy(scratchCartesian).subtract(point);
      const longitude = Math.atan2(normal.y, normal.x);
      const latitude = Math.asin(normal.z);
      const height = Math.sign(dot(h, scratchCartesian)) * length2(h);
      return toCartographicFromRadians([longitude, latitude, height], result);
    }
    eastNorthUpToFixedFrame(origin, result = new Matrix4()) {
      return localFrameToFixedFrame(this, "east", "north", "up", origin, result);
    }
    localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {
      return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);
    }
    geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {
      return scratchVector10.from(cartesian).normalize().to(result);
    }
    geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {
      const cartographicVectorRadians = fromCartographicToRadians(cartographic);
      const longitude = cartographicVectorRadians[0];
      const latitude = cartographicVectorRadians[1];
      const cosLatitude = Math.cos(latitude);
      scratchVector10.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();
      return scratchVector10.to(result);
    }
    geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {
      return scratchVector10.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);
    }
    scaleToGeodeticSurface(cartesian, result) {
      return scaleToGeodeticSurface(cartesian, this, result);
    }
    scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {
      scratchPosition2.from(cartesian);
      const positionX = scratchPosition2.x;
      const positionY = scratchPosition2.y;
      const positionZ = scratchPosition2.z;
      const oneOverRadiiSquared = this.oneOverRadiiSquared;
      const beta = 1 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);
      return scratchPosition2.multiplyScalar(beta).to(result);
    }
    transformPositionToScaledSpace(position, result = [0, 0, 0]) {
      return scratchPosition2.from(position).scale(this.oneOverRadii).to(result);
    }
    transformPositionFromScaledSpace(position, result = [0, 0, 0]) {
      return scratchPosition2.from(position).scale(this.radii).to(result);
    }
    getSurfaceNormalIntersectionWithZAxis(position, buffer = 0, result = [0, 0, 0]) {
      assert9(equals(this.radii.x, this.radii.y, math_utils_default.EPSILON15));
      assert9(this.radii.z > 0);
      scratchPosition2.from(position);
      const z = scratchPosition2.z * (1 - this.squaredXOverSquaredZ);
      if (Math.abs(z) >= this.radii.z - buffer) {
        return void 0;
      }
      return scratchPosition2.set(0, 0, z).to(result);
    }
  };
  _defineProperty5(Ellipsoid, "WGS84", new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z));

  // ../../node_modules/@loaders.gl/tiles/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp5() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) {
      timestamp = window.performance.now();
    } else if (typeof process !== "undefined" && process.hrtime) {
      const timeParts = process.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@loaders.gl/tiles/node_modules/@probe.gl/stats/dist/lib/stat.js
  var Stat3 = class {
    constructor(name10, type) {
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "sampleSize", 1);
      _defineProperty(this, "time", 0);
      _defineProperty(this, "count", 0);
      _defineProperty(this, "samples", 0);
      _defineProperty(this, "lastTiming", 0);
      _defineProperty(this, "lastSampleTime", 0);
      _defineProperty(this, "lastSampleCount", 0);
      _defineProperty(this, "_count", 0);
      _defineProperty(this, "_time", 0);
      _defineProperty(this, "_samples", 0);
      _defineProperty(this, "_startTime", 0);
      _defineProperty(this, "_timerPending", false);
      this.name = name10;
      this.type = type;
      this.reset();
    }
    reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
    setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
    incrementCount() {
      this.addCount(1);
      return this;
    }
    decrementCount() {
      this.subtractCount(1);
      return this;
    }
    addCount(value) {
      this._count += value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    subtractCount(value) {
      this._count -= value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;
      this._checkSampling();
      return this;
    }
    timeStart() {
      this._startTime = getHiResTimestamp5();
      this._timerPending = true;
      return this;
    }
    timeEnd() {
      if (!this._timerPending) {
        return this;
      }
      this.addTime(getHiResTimestamp5() - this._startTime);
      this._timerPending = false;
      this._checkSampling();
      return this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  };

  // ../../node_modules/@loaders.gl/tiles/node_modules/@probe.gl/stats/dist/lib/stats.js
  var Stats3 = class {
    constructor(options) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "stats", {});
      this.id = options.id;
      this.stats = {};
      this._initializeStats(options.stats);
      Object.seal(this);
    }
    get(name10) {
      let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
      return this._getOrCreate({
        name: name10,
        type
      });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    reset() {
      for (const stat of Object.values(this.stats)) {
        stat.reset();
      }
      return this;
    }
    forEach(fn) {
      for (const stat of Object.values(this.stats)) {
        fn(stat);
      }
    }
    getTable() {
      const table = {};
      this.forEach((stat) => {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
    _initializeStats() {
      let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      stats.forEach((stat) => this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
      const {
        name: name10,
        type
      } = stat;
      let result = this.stats[name10];
      if (!result) {
        if (stat instanceof Stat3) {
          result = stat;
        } else {
          result = new Stat3(name10, type);
        }
        this.stats[name10] = result;
      }
      return result;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/utils/doubly-linked-list-node.js
  var DoublyLinkedListNode = class {
    constructor(item, previous, next) {
      _defineProperty(this, "item", void 0);
      _defineProperty(this, "previous", void 0);
      _defineProperty(this, "next", void 0);
      this.item = item;
      this.previous = previous;
      this.next = next;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/utils/doubly-linked-list.js
  var DoublyLinkedList = class {
    constructor() {
      _defineProperty(this, "head", null);
      _defineProperty(this, "tail", null);
      _defineProperty(this, "_length", 0);
    }
    get length() {
      return this._length;
    }
    add(item) {
      const node2 = new DoublyLinkedListNode(item, this.tail, null);
      if (this.tail) {
        this.tail.next = node2;
        this.tail = node2;
      } else {
        this.head = node2;
        this.tail = node2;
      }
      ++this._length;
      return node2;
    }
    remove(node2) {
      if (!node2) {
        return;
      }
      if (node2.previous && node2.next) {
        node2.previous.next = node2.next;
        node2.next.previous = node2.previous;
      } else if (node2.previous) {
        node2.previous.next = null;
        this.tail = node2.previous;
      } else if (node2.next) {
        node2.next.previous = null;
        this.head = node2.next;
      } else {
        this.head = null;
        this.tail = null;
      }
      node2.next = null;
      node2.previous = null;
      --this._length;
    }
    splice(node2, nextNode) {
      if (node2 === nextNode) {
        return;
      }
      this.remove(nextNode);
      this._insert(node2, nextNode);
    }
    _insert(node2, nextNode) {
      const oldNodeNext = node2.next;
      node2.next = nextNode;
      if (this.tail === node2) {
        this.tail = nextNode;
      } else {
        oldNodeNext.previous = nextNode;
      }
      nextNode.next = oldNodeNext;
      nextNode.previous = node2;
      ++this._length;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/tileset-cache.js
  var TilesetCache = class {
    constructor() {
      _defineProperty(this, "_list", void 0);
      _defineProperty(this, "_sentinel", void 0);
      _defineProperty(this, "_trimTiles", void 0);
      this._list = new DoublyLinkedList();
      this._sentinel = this._list.add("sentinel");
      this._trimTiles = false;
    }
    reset() {
      this._list.splice(this._list.tail, this._sentinel);
    }
    touch(tile) {
      const node2 = tile._cacheNode;
      if (node2) {
        this._list.splice(this._sentinel, node2);
      }
    }
    add(tileset, tile, addCallback) {
      if (!tile._cacheNode) {
        tile._cacheNode = this._list.add(tile);
        if (addCallback) {
          addCallback(tileset, tile);
        }
      }
    }
    unloadTile(tileset, tile, unloadCallback) {
      const node2 = tile._cacheNode;
      if (!node2) {
        return;
      }
      this._list.remove(node2);
      tile._cacheNode = null;
      if (unloadCallback) {
        unloadCallback(tileset, tile);
      }
    }
    unloadTiles(tileset, unloadCallback) {
      const trimTiles = this._trimTiles;
      this._trimTiles = false;
      const list = this._list;
      const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;
      const sentinel = this._sentinel;
      let node2 = list.head;
      while (node2 !== sentinel && (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)) {
        const tile = node2.item;
        node2 = node2.next;
        this.unloadTile(tileset, tile, unloadCallback);
      }
    }
    trim() {
      this._trimTiles = true;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/transform-utils.js
  function calculateTransformProps(tileHeader, tile) {
    assert2(tileHeader);
    assert2(tile);
    const {
      rtcCenter,
      gltfUpAxis
    } = tile;
    const {
      computedTransform,
      boundingVolume: {
        center
      }
    } = tileHeader;
    let modelMatrix2 = new Matrix4(computedTransform);
    if (rtcCenter) {
      modelMatrix2.translate(rtcCenter);
    }
    switch (gltfUpAxis) {
      case "Z":
        break;
      case "Y":
        const rotationY = new Matrix4().rotateX(Math.PI / 2);
        modelMatrix2 = modelMatrix2.multiplyRight(rotationY);
        break;
      case "X":
        const rotationX = new Matrix4().rotateY(-Math.PI / 2);
        modelMatrix2 = modelMatrix2.multiplyRight(rotationX);
        break;
      default:
        break;
    }
    if (tile.isQuantized) {
      modelMatrix2.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);
    }
    const cartesianOrigin = new Vector3(center);
    tile.cartesianModelMatrix = modelMatrix2;
    tile.cartesianOrigin = cartesianOrigin;
    const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(cartesianOrigin, new Vector3());
    const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);
    const toFixedFrameMatrix = fromFixedFrameMatrix.invert();
    tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix2);
    tile.cartographicOrigin = cartographicOrigin;
    if (!tile.coordinateSystem) {
      tile.modelMatrix = tile.cartographicModelMatrix;
    }
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/frame-state.js
  var scratchVector11 = new Vector3();
  var scratchPosition3 = new Vector3();
  var cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);
  function getFrameState(viewport, frameNumber) {
    const {
      cameraDirection,
      cameraUp,
      height
    } = viewport;
    const {
      metersPerUnit
    } = viewport.distanceScales;
    const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);
    const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);
    const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
    const cameraPositionCartesian2 = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());
    const cameraDirectionCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))).normalize();
    const cameraUpCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))).normalize();
    commonSpacePlanesToWGS84(viewport);
    const ViewportClass = viewport.constructor;
    const {
      longitude,
      latitude,
      width,
      bearing,
      zoom
    } = viewport;
    const topDownViewport = new ViewportClass({
      longitude,
      latitude,
      height,
      width,
      bearing,
      zoom,
      pitch: 0
    });
    return {
      camera: {
        position: cameraPositionCartesian2,
        direction: cameraDirectionCartesian,
        up: cameraUpCartesian
      },
      viewport,
      topDownViewport,
      height,
      cullingVolume,
      frameNumber,
      sseDenominator: 1.15
    };
  }
  function limitSelectedTiles(tiles, frameState, maximumTilesSelected) {
    if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {
      return [tiles, []];
    }
    const tuples = [];
    const {
      longitude: viewportLongitude,
      latitude: viewportLatitude
    } = frameState.viewport;
    for (const [index, tile] of tiles.entries()) {
      const [longitude, latitude] = tile.header.mbs;
      const deltaLon = Math.abs(viewportLongitude - longitude);
      const deltaLat = Math.abs(viewportLatitude - latitude);
      const distance3 = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);
      tuples.push([index, distance3]);
    }
    const tuplesSorted = tuples.sort((a2, b) => a2[1] - b[1]);
    const selectedTiles = [];
    for (let i3 = 0; i3 < maximumTilesSelected; i3++) {
      selectedTiles.push(tiles[tuplesSorted[i3][0]]);
    }
    const unselectedTiles = [];
    for (let i3 = maximumTilesSelected; i3 < tuplesSorted.length; i3++) {
      unselectedTiles.push(tiles[tuplesSorted[i3][0]]);
    }
    return [selectedTiles, unselectedTiles];
  }
  function commonSpacePlanesToWGS84(viewport) {
    const frustumPlanes = viewport.getFrustumPlanes();
    const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);
    const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);
    const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition3);
    let i3 = 0;
    cullingVolume.planes[i3++].fromPointNormal(nearCenterCartesian, scratchVector11.copy(nearCenterCartesian).subtract(cameraCartesian));
    for (const dir in frustumPlanes) {
      if (dir === "near") {
        continue;
      }
      const plane = frustumPlanes[dir];
      const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition3);
      const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition3);
      cullingVolume.planes[i3++].fromPointNormal(cartesianPos, scratchVector11.copy(nearCenterCartesian).subtract(cartesianPos));
    }
  }
  function closestPointOnPlane(plane, refPoint) {
    let out = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Vector3();
    const distanceToRef = plane.normal.dot(refPoint);
    out.copy(plane.normal).scale(plane.distance - distanceToRef).add(refPoint);
    return out;
  }
  function worldToCartesian(viewport, point) {
    let out = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Vector3();
    const cartographicPos = viewport.unprojectPosition(point);
    return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/zoom.js
  var WGS84_RADIUS_X2 = 6378137;
  var WGS84_RADIUS_Y2 = 6378137;
  var WGS84_RADIUS_Z2 = 6356752314245179e-9;
  var scratchVector12 = new Vector3();
  function getZoomFromBoundingVolume(boundingVolume, cartorgraphicCenter) {
    if (boundingVolume instanceof OrientedBoundingBox) {
      const {
        halfAxes
      } = boundingVolume;
      const obbSize = getObbSize(halfAxes);
      return Math.log2(WGS84_RADIUS_Z2 / (obbSize + cartorgraphicCenter[2]));
    } else if (boundingVolume instanceof BoundingSphere) {
      const {
        radius
      } = boundingVolume;
      return Math.log2(WGS84_RADIUS_Z2 / (radius + cartorgraphicCenter[2]));
    } else if (boundingVolume.width && boundingVolume.height) {
      const {
        width,
        height
      } = boundingVolume;
      const zoomX = Math.log2(WGS84_RADIUS_X2 / width);
      const zoomY = Math.log2(WGS84_RADIUS_Y2 / height);
      return (zoomX + zoomY) / 2;
    }
    return 1;
  }
  function getZoomFromFullExtent(fullExtent, cartorgraphicCenter, cartesianCenter) {
    const extentVertex = Ellipsoid.WGS84.cartographicToCartesian([fullExtent.xmax, fullExtent.ymax, fullExtent.zmax], new Vector3());
    const extentSize = Math.sqrt(Math.pow(extentVertex[0] - cartesianCenter[0], 2) + Math.pow(extentVertex[1] - cartesianCenter[1], 2) + Math.pow(extentVertex[2] - cartesianCenter[2], 2));
    return Math.log2(WGS84_RADIUS_Z2 / (extentSize + cartorgraphicCenter[2]));
  }
  function getZoomFromExtent(extent, cartorgraphicCenter, cartesianCenter) {
    const [xmin, ymin, xmax, ymax] = extent;
    return getZoomFromFullExtent({
      xmin,
      xmax,
      ymin,
      ymax,
      zmin: 0,
      zmax: 0
    }, cartorgraphicCenter, cartesianCenter);
  }
  function getObbSize(halfAxes) {
    halfAxes.getColumn(0, scratchVector12);
    const axeY = halfAxes.getColumn(1);
    const axeZ = halfAxes.getColumn(2);
    const farthestVertex = scratchVector12.add(axeY).add(axeZ);
    const size = farthestVertex.len();
    return size;
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/constants.js
  var TILE_CONTENT_STATE = {
    UNLOADED: 0,
    LOADING: 1,
    PROCESSING: 2,
    READY: 3,
    EXPIRED: 4,
    FAILED: 5
  };
  var TILE_REFINEMENT = {
    ADD: 1,
    REPLACE: 2
  };
  var TILE_TYPE = {
    EMPTY: "empty",
    SCENEGRAPH: "scenegraph",
    POINTCLOUD: "pointcloud",
    MESH: "mesh"
  };
  var TILESET_TYPE = {
    I3S: "I3S",
    TILES3D: "TILES3D"
  };
  var LOD_METRIC_TYPE = {
    GEOMETRIC_ERROR: "geometricError",
    MAX_SCREEN_THRESHOLD: "maxScreenThreshold"
  };
  var TILE3D_OPTIMIZATION_HINT = {
    NOT_COMPUTED: -1,
    USE_OPTIMIZATION: 1,
    SKIP_OPTIMIZATION: 0
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/bounding-volume.js
  function defined(x2) {
    return x2 !== void 0 && x2 !== null;
  }
  var scratchPoint = new Vector3();
  var scratchScale = new Vector3();
  var scratchNorthWest = new Vector3();
  var scratchSouthEast = new Vector3();
  function createBoundingVolume(boundingVolumeHeader, transform3, result) {
    assert2(boundingVolumeHeader, "3D Tile: boundingVolume must be defined");
    if (boundingVolumeHeader.box) {
      return createBox(boundingVolumeHeader.box, transform3, result);
    }
    if (boundingVolumeHeader.region) {
      const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;
      const northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees(west), degrees(north), minHeight], scratchNorthWest);
      const southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees(east), degrees(south), maxHeight], scratchSouthEast);
      const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);
      const radius = new Vector3().subVectors(northWest, southEast).len() / 2;
      return createSphere([centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius], new Matrix4());
    }
    if (boundingVolumeHeader.sphere) {
      return createSphere(boundingVolumeHeader.sphere, transform3, result);
    }
    throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
  }
  function getCartographicBounds(boundingVolumeHeader, boundingVolume) {
    if (boundingVolumeHeader.box) {
      return orientedBoundingBoxToCartographicBounds(boundingVolume);
    }
    if (boundingVolumeHeader.region) {
      const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;
      return [[degrees(west), degrees(south), minHeight], [degrees(east), degrees(north), maxHeight]];
    }
    if (boundingVolumeHeader.sphere) {
      return boundingSphereToCartographicBounds(boundingVolume);
    }
    throw new Error("Unkown boundingVolume type");
  }
  function createBox(box, transform3, result) {
    const center = new Vector3(box[0], box[1], box[2]);
    transform3.transform(center, center);
    let origin = [];
    if (box.length === 10) {
      const halfSize = box.slice(3, 6);
      const quaternion2 = new Quaternion();
      quaternion2.fromArray(box, 6);
      const x2 = new Vector3([1, 0, 0]);
      const y2 = new Vector3([0, 1, 0]);
      const z = new Vector3([0, 0, 1]);
      x2.transformByQuaternion(quaternion2);
      x2.scale(halfSize[0]);
      y2.transformByQuaternion(quaternion2);
      y2.scale(halfSize[1]);
      z.transformByQuaternion(quaternion2);
      z.scale(halfSize[2]);
      origin = [...x2.toArray(), ...y2.toArray(), ...z.toArray()];
    } else {
      origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];
    }
    const xAxis = transform3.transformAsVector(origin.slice(0, 3));
    const yAxis = transform3.transformAsVector(origin.slice(3, 6));
    const zAxis = transform3.transformAsVector(origin.slice(6, 9));
    const halfAxes = new Matrix3([xAxis[0], xAxis[1], xAxis[2], yAxis[0], yAxis[1], yAxis[2], zAxis[0], zAxis[1], zAxis[2]]);
    if (defined(result)) {
      result.center = center;
      result.halfAxes = halfAxes;
      return result;
    }
    return new OrientedBoundingBox(center, halfAxes);
  }
  function createSphere(sphere, transform3, result) {
    const center = new Vector3(sphere[0], sphere[1], sphere[2]);
    transform3.transform(center, center);
    const scale8 = transform3.getScale(scratchScale);
    const uniformScale = Math.max(Math.max(scale8[0], scale8[1]), scale8[2]);
    const radius = sphere[3] * uniformScale;
    if (defined(result)) {
      result.center = center;
      result.radius = radius;
      return result;
    }
    return new BoundingSphere(center, radius);
  }
  function orientedBoundingBoxToCartographicBounds(boundingVolume) {
    const result = emptyCartographicBounds();
    const {
      halfAxes
    } = boundingVolume;
    const xAxis = new Vector3(halfAxes.getColumn(0));
    const yAxis = new Vector3(halfAxes.getColumn(1));
    const zAxis = new Vector3(halfAxes.getColumn(2));
    for (let x2 = 0; x2 < 2; x2++) {
      for (let y2 = 0; y2 < 2; y2++) {
        for (let z = 0; z < 2; z++) {
          scratchPoint.copy(boundingVolume.center);
          scratchPoint.add(xAxis);
          scratchPoint.add(yAxis);
          scratchPoint.add(zAxis);
          addToCartographicBounds(result, scratchPoint);
          zAxis.negate();
        }
        yAxis.negate();
      }
      xAxis.negate();
    }
    return result;
  }
  function boundingSphereToCartographicBounds(boundingVolume) {
    const result = emptyCartographicBounds();
    const {
      center,
      radius
    } = boundingVolume;
    const point = Ellipsoid.WGS84.scaleToGeodeticSurface(center, scratchPoint);
    let zAxis;
    if (point) {
      zAxis = Ellipsoid.WGS84.geodeticSurfaceNormal(point);
    } else {
      zAxis = new Vector3(0, 0, 1);
    }
    let xAxis = new Vector3(zAxis[2], -zAxis[1], 0);
    if (xAxis.len() > 0) {
      xAxis.normalize();
    } else {
      xAxis = new Vector3(0, 1, 0);
    }
    const yAxis = xAxis.clone().cross(zAxis);
    for (const axis of [xAxis, yAxis, zAxis]) {
      scratchScale.copy(axis).scale(radius);
      for (let dir = 0; dir < 2; dir++) {
        scratchPoint.copy(center);
        scratchPoint.add(scratchScale);
        addToCartographicBounds(result, scratchPoint);
        scratchScale.negate();
      }
    }
    return result;
  }
  function emptyCartographicBounds() {
    return [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
  }
  function addToCartographicBounds(target, cartesian) {
    Ellipsoid.WGS84.cartesianToCartographic(cartesian, scratchPoint);
    target[0][0] = Math.min(target[0][0], scratchPoint[0]);
    target[0][1] = Math.min(target[0][1], scratchPoint[1]);
    target[0][2] = Math.min(target[0][2], scratchPoint[2]);
    target[1][0] = Math.max(target[1][0], scratchPoint[0]);
    target[1][1] = Math.max(target[1][1], scratchPoint[1]);
    target[1][2] = Math.max(target[1][2], scratchPoint[2]);
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/tiles-3d-lod.js
  var scratchPositionNormal = new Vector3();
  var scratchCartographic = new Vector3();
  var scratchMatrix2 = new Matrix4();
  var scratchCenter = new Vector3();
  var scratchPosition4 = new Vector3();
  var scratchDirection = new Vector3();
  function fog(distanceToCamera, density) {
    const scalar = distanceToCamera * density;
    return 1 - Math.exp(-(scalar * scalar));
  }
  function getDynamicScreenSpaceError(tileset, distanceToCamera) {
    if (tileset.dynamicScreenSpaceError && tileset.dynamicScreenSpaceErrorComputedDensity) {
      const density = tileset.dynamicScreenSpaceErrorComputedDensity;
      const factor = tileset.dynamicScreenSpaceErrorFactor;
      const dynamicError = fog(distanceToCamera, density) * factor;
      return dynamicError;
    }
    return 0;
  }
  function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {
    const tileset = tile.tileset;
    const parentLodMetricValue = tile.parent && tile.parent.lodMetricValue || tile.lodMetricValue;
    const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;
    if (lodMetricValue === 0) {
      return 0;
    }
    const distance3 = Math.max(tile._distanceToCamera, 1e-7);
    const {
      height,
      sseDenominator
    } = frameState;
    const {
      viewDistanceScale
    } = tileset.options;
    let error2 = lodMetricValue * height * (viewDistanceScale || 1) / (distance3 * sseDenominator);
    error2 -= getDynamicScreenSpaceError(tileset, distance3);
    return error2;
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/i3s-lod.js
  var cameraPositionCartesian = new Vector3();
  var toEye = new Vector3();
  var cameraPositionEnu = new Vector3();
  var extraVertexEnu = new Vector3();
  var projectedOriginVector = new Vector3();
  var enuToCartesianMatrix = new Matrix4();
  var cartesianToEnuMatrix = new Matrix4();
  function getLodStatus(tile, frameState) {
    if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {
      return "DIG";
    }
    const screenSize = 2 * getProjectedRadius(tile, frameState);
    if (screenSize < 2) {
      return "OUT";
    }
    if (!tile.header.children || screenSize <= tile.lodMetricValue) {
      return "DRAW";
    } else if (tile.header.children) {
      return "DIG";
    }
    return "OUT";
  }
  function getProjectedRadius(tile, frameState) {
    const {
      topDownViewport: viewport
    } = frameState;
    const mbsLat = tile.header.mbs[1];
    const mbsLon = tile.header.mbs[0];
    const mbsZ = tile.header.mbs[2];
    const mbsR = tile.header.mbs[3];
    const mbsCenterCartesian = [...tile.boundingVolume.center];
    const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
    Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);
    toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();
    Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);
    cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();
    cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);
    const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);
    const extraZ = projection * projection / cameraPositionEnu[2];
    extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);
    const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);
    const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();
    const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);
    const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);
    const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);
    const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);
    const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);
    const projectedRadius = projectedOriginVector.copy(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();
    return projectedRadius;
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/helpers/3d-tiles-options.js
  function get3dTilesOptions(tileset) {
    return {
      assetGltfUpAxis: tileset.asset && tileset.asset.gltfUpAxis || "Y"
    };
  }

  // ../../node_modules/@loaders.gl/tiles/dist/esm/utils/managed-array.js
  var ManagedArray = class {
    constructor() {
      let length7 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      _defineProperty(this, "_map", /* @__PURE__ */ new Map());
      _defineProperty(this, "_array", void 0);
      _defineProperty(this, "_length", void 0);
      this._array = new Array(length7);
      this._length = length7;
    }
    get length() {
      return this._length;
    }
    set length(length7) {
      this._length = length7;
      if (length7 > this._array.length) {
        this._array.length = length7;
      }
    }
    get values() {
      return this._array;
    }
    get(index) {
      assert2(index < this._array.length);
      return this._array[index];
    }
    set(index, element) {
      assert2(index >= 0);
      if (index >= this.length) {
        this.length = index + 1;
      }
      if (this._map.has(this._array[index])) {
        this._map.delete(this._array[index]);
      }
      this._array[index] = element;
      this._map.set(element, index);
    }
    delete(element) {
      const index = this._map.get(element);
      if (index >= 0) {
        this._array.splice(index, 1);
        this._map.delete(element);
        this.length--;
      }
    }
    peek() {
      return this._array[this._length - 1];
    }
    push(element) {
      if (!this._map.has(element)) {
        const index = this.length++;
        this._array[index] = element;
        this._map.set(element, index);
      }
    }
    pop() {
      const element = this._array[--this.length];
      this._map.delete(element);
      return element;
    }
    reserve(length7) {
      assert2(length7 >= 0);
      if (length7 > this._array.length) {
        this._array.length = length7;
      }
    }
    resize(length7) {
      assert2(length7 >= 0);
      this.length = length7;
    }
    trim(length7) {
      if (length7 === null || length7 === void 0) {
        length7 = this.length;
      }
      this._array.length = length7;
    }
    reset() {
      this._array = [];
      this._map = /* @__PURE__ */ new Map();
      this._length = 0;
    }
    find(target) {
      return this._map.has(target);
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/tileset-traverser.js
  var DEFAULT_PROPS4 = {
    loadSiblings: false,
    skipLevelOfDetail: false,
    maximumScreenSpaceError: 2,
    updateTransforms: true,
    onTraversalEnd: () => {
    },
    viewportTraversersMap: {},
    basePath: ""
  };
  var TilesetTraverser = class {
    traversalFinished(frameState) {
      return true;
    }
    constructor(options) {
      _defineProperty(this, "options", void 0);
      _defineProperty(this, "root", null);
      _defineProperty(this, "selectedTiles", {});
      _defineProperty(this, "requestedTiles", {});
      _defineProperty(this, "emptyTiles", {});
      _defineProperty(this, "lastUpdate", new Date().getTime());
      _defineProperty(this, "updateDebounceTime", 1e3);
      _defineProperty(this, "_traversalStack", new ManagedArray());
      _defineProperty(this, "_emptyTraversalStack", new ManagedArray());
      _defineProperty(this, "_frameNumber", null);
      this.options = {
        ...DEFAULT_PROPS4,
        ...options
      };
    }
    traverse(root, frameState, options) {
      this.root = root;
      this.options = {
        ...this.options,
        ...options
      };
      this.reset();
      this.updateTile(root, frameState);
      this._frameNumber = frameState.frameNumber;
      this.executeTraversal(root, frameState);
    }
    reset() {
      this.requestedTiles = {};
      this.selectedTiles = {};
      this.emptyTiles = {};
      this._traversalStack.reset();
      this._emptyTraversalStack.reset();
    }
    executeTraversal(root, frameState) {
      const stack2 = this._traversalStack;
      root._selectionDepth = 1;
      stack2.push(root);
      while (stack2.length > 0) {
        const tile = stack2.pop();
        let shouldRefine = false;
        if (this.canTraverse(tile, frameState)) {
          this.updateChildTiles(tile, frameState);
          shouldRefine = this.updateAndPushChildren(tile, frameState, stack2, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);
        }
        const parent = tile.parent;
        const parentRefines = Boolean(!parent || parent._shouldRefine);
        const stoppedRefining = !shouldRefine;
        if (!tile.hasRenderContent) {
          this.emptyTiles[tile.id] = tile;
          this.loadTile(tile, frameState);
          if (stoppedRefining) {
            this.selectTile(tile, frameState);
          }
        } else if (tile.refine === TILE_REFINEMENT.ADD) {
          this.loadTile(tile, frameState);
          this.selectTile(tile, frameState);
        } else if (tile.refine === TILE_REFINEMENT.REPLACE) {
          this.loadTile(tile, frameState);
          if (stoppedRefining) {
            this.selectTile(tile, frameState);
          }
        }
        this.touchTile(tile, frameState);
        tile._shouldRefine = shouldRefine && parentRefines;
      }
      const newTime = new Date().getTime();
      if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {
        this.lastUpdate = newTime;
        this.options.onTraversalEnd(frameState);
      }
    }
    updateChildTiles(tile, frameState) {
      const children = tile.children;
      for (const child of children) {
        this.updateTile(child, frameState);
      }
    }
    updateAndPushChildren(tile, frameState, stack2, depth) {
      const {
        loadSiblings,
        skipLevelOfDetail
      } = this.options;
      const children = tile.children;
      children.sort(this.compareDistanceToCamera.bind(this));
      const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;
      let hasVisibleChild = false;
      let refines = true;
      for (const child of children) {
        child._selectionDepth = depth;
        if (child.isVisibleAndInRequestVolume) {
          if (stack2.find(child)) {
            stack2.delete(child);
          }
          stack2.push(child);
          hasVisibleChild = true;
        } else if (checkRefines || loadSiblings) {
          this.loadTile(child, frameState);
          this.touchTile(child, frameState);
        }
        if (checkRefines) {
          let childRefines;
          if (!child._inRequestVolume) {
            childRefines = false;
          } else if (!child.hasRenderContent) {
            childRefines = this.executeEmptyTraversal(child, frameState);
          } else {
            childRefines = child.contentAvailable;
          }
          refines = refines && childRefines;
          if (!refines) {
            return false;
          }
        }
      }
      if (!hasVisibleChild) {
        refines = false;
      }
      return refines;
    }
    updateTile(tile, frameState) {
      this.updateTileVisibility(tile, frameState);
    }
    selectTile(tile, frameState) {
      if (this.shouldSelectTile(tile)) {
        tile._selectedFrame = frameState.frameNumber;
        this.selectedTiles[tile.id] = tile;
      }
    }
    loadTile(tile, frameState) {
      if (this.shouldLoadTile(tile)) {
        tile._requestedFrame = frameState.frameNumber;
        tile._priority = tile._getPriority();
        this.requestedTiles[tile.id] = tile;
      }
    }
    touchTile(tile, frameState) {
      tile.tileset._cache.touch(tile);
      tile._touchedFrame = frameState.frameNumber;
    }
    canTraverse(tile, frameState) {
      let useParentMetric = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      let ignoreVisibility = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (!tile.hasChildren) {
        return false;
      }
      if (tile.hasTilesetContent) {
        return !tile.contentExpired;
      }
      if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {
        return false;
      }
      return this.shouldRefine(tile, frameState, useParentMetric);
    }
    shouldLoadTile(tile) {
      return tile.hasUnloadedContent || tile.contentExpired;
    }
    shouldSelectTile(tile) {
      return tile.contentAvailable && !this.options.skipLevelOfDetail;
    }
    shouldRefine(tile, frameState) {
      let useParentMetric = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      let screenSpaceError = tile._screenSpaceError;
      if (useParentMetric) {
        screenSpaceError = tile.getScreenSpaceError(frameState, true);
      }
      return screenSpaceError > this.options.maximumScreenSpaceError;
    }
    updateTileVisibility(tile, frameState) {
      const viewportIds = [];
      if (this.options.viewportTraversersMap) {
        for (const key in this.options.viewportTraversersMap) {
          const value = this.options.viewportTraversersMap[key];
          if (value === frameState.viewport.id) {
            viewportIds.push(key);
          }
        }
      } else {
        viewportIds.push(frameState.viewport.id);
      }
      tile.updateVisibility(frameState, viewportIds);
    }
    compareDistanceToCamera(b, a2) {
      return b._distanceToCamera - a2._distanceToCamera;
    }
    anyChildrenVisible(tile, frameState) {
      let anyVisible = false;
      for (const child of tile.children) {
        child.updateVisibility(frameState);
        anyVisible = anyVisible || child.isVisibleAndInRequestVolume;
      }
      return anyVisible;
    }
    executeEmptyTraversal(root, frameState) {
      let allDescendantsLoaded = true;
      const stack2 = this._emptyTraversalStack;
      stack2.push(root);
      while (stack2.length > 0 && allDescendantsLoaded) {
        const tile = stack2.pop();
        this.updateTile(tile, frameState);
        if (!tile.isVisibleAndInRequestVolume) {
          this.loadTile(tile, frameState);
        }
        this.touchTile(tile, frameState);
        const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);
        if (traverse) {
          const children = tile.children;
          for (const child of children) {
            if (stack2.find(child)) {
              stack2.delete(child);
            }
            stack2.push(child);
          }
        } else if (!tile.contentAvailable) {
          allDescendantsLoaded = false;
        }
      }
      return allDescendantsLoaded;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/tile-3d.js
  var scratchVector13 = new Vector3();
  function defined2(x2) {
    return x2 !== void 0 && x2 !== null;
  }
  var Tile3D = class {
    constructor(tileset, header, parentHeader) {
      let extendedId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
      _defineProperty(this, "tileset", void 0);
      _defineProperty(this, "header", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "url", void 0);
      _defineProperty(this, "parent", void 0);
      _defineProperty(this, "refine", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "contentUrl", void 0);
      _defineProperty(this, "lodMetricType", "geometricError");
      _defineProperty(this, "lodMetricValue", 0);
      _defineProperty(this, "boundingVolume", null);
      _defineProperty(this, "content", null);
      _defineProperty(this, "contentState", TILE_CONTENT_STATE.UNLOADED);
      _defineProperty(this, "gpuMemoryUsageInBytes", 0);
      _defineProperty(this, "children", []);
      _defineProperty(this, "depth", 0);
      _defineProperty(this, "viewportIds", []);
      _defineProperty(this, "transform", new Matrix4());
      _defineProperty(this, "extensions", null);
      _defineProperty(this, "implicitTiling", null);
      _defineProperty(this, "userData", {});
      _defineProperty(this, "computedTransform", void 0);
      _defineProperty(this, "hasEmptyContent", false);
      _defineProperty(this, "hasTilesetContent", false);
      _defineProperty(this, "traverser", new TilesetTraverser({}));
      _defineProperty(this, "_cacheNode", null);
      _defineProperty(this, "_frameNumber", null);
      _defineProperty(this, "_expireDate", null);
      _defineProperty(this, "_expiredContent", null);
      _defineProperty(this, "_boundingBox", void 0);
      _defineProperty(this, "_distanceToCamera", 0);
      _defineProperty(this, "_screenSpaceError", 0);
      _defineProperty(this, "_visibilityPlaneMask", void 0);
      _defineProperty(this, "_visible", void 0);
      _defineProperty(this, "_contentBoundingVolume", void 0);
      _defineProperty(this, "_viewerRequestVolume", void 0);
      _defineProperty(this, "_initialTransform", new Matrix4());
      _defineProperty(this, "_priority", 0);
      _defineProperty(this, "_selectedFrame", 0);
      _defineProperty(this, "_requestedFrame", 0);
      _defineProperty(this, "_selectionDepth", 0);
      _defineProperty(this, "_touchedFrame", 0);
      _defineProperty(this, "_centerZDepth", 0);
      _defineProperty(this, "_shouldRefine", false);
      _defineProperty(this, "_stackLength", 0);
      _defineProperty(this, "_visitedFrame", 0);
      _defineProperty(this, "_inRequestVolume", false);
      _defineProperty(this, "_lodJudge", null);
      this.header = header;
      this.tileset = tileset;
      this.id = extendedId || header.id;
      this.url = header.url;
      this.parent = parentHeader;
      this.refine = this._getRefine(header.refine);
      this.type = header.type;
      this.contentUrl = header.contentUrl;
      this._initializeLodMetric(header);
      this._initializeTransforms(header);
      this._initializeBoundingVolumes(header);
      this._initializeContent(header);
      this._initializeRenderingState(header);
      Object.seal(this);
    }
    destroy() {
      this.header = null;
    }
    isDestroyed() {
      return this.header === null;
    }
    get selected() {
      return this._selectedFrame === this.tileset._frameNumber;
    }
    get isVisible() {
      return this._visible;
    }
    get isVisibleAndInRequestVolume() {
      return this._visible && this._inRequestVolume;
    }
    get hasRenderContent() {
      return !this.hasEmptyContent && !this.hasTilesetContent;
    }
    get hasChildren() {
      return this.children.length > 0 || this.header.children && this.header.children.length > 0;
    }
    get contentReady() {
      return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;
    }
    get contentAvailable() {
      return Boolean(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
    }
    get hasUnloadedContent() {
      return this.hasRenderContent && this.contentUnloaded;
    }
    get contentUnloaded() {
      return this.contentState === TILE_CONTENT_STATE.UNLOADED;
    }
    get contentExpired() {
      return this.contentState === TILE_CONTENT_STATE.EXPIRED;
    }
    get contentFailed() {
      return this.contentState === TILE_CONTENT_STATE.FAILED;
    }
    get distanceToCamera() {
      return this._distanceToCamera;
    }
    get screenSpaceError() {
      return this._screenSpaceError;
    }
    get boundingBox() {
      if (!this._boundingBox) {
        this._boundingBox = getCartographicBounds(this.header.boundingVolume, this.boundingVolume);
      }
      return this._boundingBox;
    }
    getScreenSpaceError(frameState, useParentLodMetric) {
      switch (this.tileset.type) {
        case TILESET_TYPE.I3S:
          return getProjectedRadius(this, frameState);
        case TILESET_TYPE.TILES3D:
          return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);
        default:
          throw new Error("Unsupported tileset type");
      }
    }
    unselect() {
      this._selectedFrame = 0;
    }
    _getGpuMemoryUsageInBytes() {
      return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
    }
    _getPriority() {
      const traverser = this.tileset._traverser;
      const {
        skipLevelOfDetail
      } = traverser.options;
      const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;
      if (maySkipTile && !this.isVisible && this._visible !== void 0) {
        return -1;
      }
      if (this.tileset._frameNumber - this._touchedFrame >= 1) {
        return -1;
      }
      if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {
        return -1;
      }
      const parent = this.parent;
      const useParentScreenSpaceError = parent && (!maySkipTile || this._screenSpaceError === 0 || parent.hasTilesetContent);
      const screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : this._screenSpaceError;
      const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0;
      return Math.max(rootScreenSpaceError - screenSpaceError, 0);
    }
    async loadContent() {
      if (this.hasEmptyContent) {
        return false;
      }
      if (this.content) {
        return true;
      }
      const expired = this.contentExpired;
      if (expired) {
        this._expireDate = null;
      }
      this.contentState = TILE_CONTENT_STATE.LOADING;
      const requestToken = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
      if (!requestToken) {
        this.contentState = TILE_CONTENT_STATE.UNLOADED;
        return false;
      }
      try {
        const contentUrl = this.tileset.getTileUrl(this.contentUrl);
        const loader = this.tileset.loader;
        const options = {
          ...this.tileset.loadOptions,
          [loader.id]: {
            ...this.tileset.loadOptions[loader.id],
            isTileset: this.type === "json",
            ...this._getLoaderSpecificOptions(loader.id)
          }
        };
        this.content = await load(contentUrl, loader, options);
        if (this.tileset.options.contentLoader) {
          await this.tileset.options.contentLoader(this);
        }
        if (this._isTileset()) {
          this.tileset._initializeTileHeaders(this.content, this);
        }
        this.contentState = TILE_CONTENT_STATE.READY;
        this._onContentLoaded();
        return true;
      } catch (error2) {
        this.contentState = TILE_CONTENT_STATE.FAILED;
        throw error2;
      } finally {
        requestToken.done();
      }
    }
    unloadContent() {
      if (this.content && this.content.destroy) {
        this.content.destroy();
      }
      this.content = null;
      if (this.header.content && this.header.content.destroy) {
        this.header.content.destroy();
      }
      this.header.content = null;
      this.contentState = TILE_CONTENT_STATE.UNLOADED;
      return true;
    }
    updateVisibility(frameState, viewportIds) {
      if (this._frameNumber === frameState.frameNumber) {
        return;
      }
      const parent = this.parent;
      const parentVisibilityPlaneMask = parent ? parent._visibilityPlaneMask : CullingVolume.MASK_INDETERMINATE;
      if (this.tileset._traverser.options.updateTransforms) {
        const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;
        this._updateTransform(parentTransform);
      }
      this._distanceToCamera = this.distanceToTile(frameState);
      this._screenSpaceError = this.getScreenSpaceError(frameState, false);
      this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask);
      this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;
      this._inRequestVolume = this.insideViewerRequestVolume(frameState);
      this._frameNumber = frameState.frameNumber;
      this.viewportIds = viewportIds;
    }
    visibility(frameState, parentVisibilityPlaneMask) {
      const {
        cullingVolume: cullingVolume2
      } = frameState;
      const {
        boundingVolume
      } = this;
      return cullingVolume2.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);
    }
    contentVisibility() {
      return true;
    }
    distanceToTile(frameState) {
      const boundingVolume = this.boundingVolume;
      return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));
    }
    cameraSpaceZDepth(_ref) {
      let {
        camera
      } = _ref;
      const boundingVolume = this.boundingVolume;
      scratchVector13.subVectors(boundingVolume.center, camera.position);
      return camera.direction.dot(scratchVector13);
    }
    insideViewerRequestVolume(frameState) {
      const viewerRequestVolume = this._viewerRequestVolume;
      return !viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0;
    }
    updateExpiration() {
      if (defined2(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
        const now = Date.now();
        if (Date.lessThan(this._expireDate, now)) {
          this.contentState = TILE_CONTENT_STATE.EXPIRED;
          this._expiredContent = this.content;
        }
      }
    }
    get extras() {
      return this.header.extras;
    }
    _initializeLodMetric(header) {
      if ("lodMetricType" in header) {
        this.lodMetricType = header.lodMetricType;
      } else {
        this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType;
        console.warn("3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType");
      }
      if ("lodMetricValue" in header) {
        this.lodMetricValue = header.lodMetricValue;
      } else {
        this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue;
        console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue");
      }
    }
    _initializeTransforms(tileHeader) {
      this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();
      const parent = this.parent;
      const tileset = this.tileset;
      const parentTransform = parent && parent.computedTransform ? parent.computedTransform.clone() : tileset.modelMatrix.clone();
      this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);
      const parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();
      this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);
    }
    _initializeBoundingVolumes(tileHeader) {
      this._contentBoundingVolume = null;
      this._viewerRequestVolume = null;
      this._updateBoundingVolume(tileHeader);
    }
    _initializeContent(tileHeader) {
      this.content = {
        _tileset: this.tileset,
        _tile: this
      };
      this.hasEmptyContent = true;
      this.contentState = TILE_CONTENT_STATE.UNLOADED;
      this.hasTilesetContent = false;
      if (tileHeader.contentUrl) {
        this.content = null;
        this.hasEmptyContent = false;
      }
    }
    _initializeRenderingState(header) {
      this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);
      this._shouldRefine = false;
      this._distanceToCamera = 0;
      this._centerZDepth = 0;
      this._screenSpaceError = 0;
      this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;
      this._visible = void 0;
      this._inRequestVolume = false;
      this._stackLength = 0;
      this._selectionDepth = 0;
      this._frameNumber = 0;
      this._touchedFrame = 0;
      this._visitedFrame = 0;
      this._selectedFrame = 0;
      this._requestedFrame = 0;
      this._priority = 0;
    }
    _getRefine(refine) {
      return refine || this.parent && this.parent.refine || TILE_REFINEMENT.REPLACE;
    }
    _isTileset() {
      return this.contentUrl.indexOf(".json") !== -1;
    }
    _onContentLoaded() {
      switch (this.content && this.content.type) {
        case "vctr":
        case "geom":
          this.tileset._traverser.disableSkipLevelOfDetail = true;
          break;
        default:
      }
      if (this._isTileset()) {
        this.hasTilesetContent = true;
      } else {
        this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
      }
    }
    _updateBoundingVolume(header) {
      this.boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this.boundingVolume);
      const content = header.content;
      if (!content) {
        return;
      }
      if (content.boundingVolume) {
        this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);
      }
      if (header.viewerRequestVolume) {
        this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);
      }
    }
    _updateTransform() {
      let parentTransform = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Matrix4();
      const computedTransform = parentTransform.clone().multiplyRight(this.transform);
      const didTransformChange = !computedTransform.equals(this.computedTransform);
      if (!didTransformChange) {
        return;
      }
      this.computedTransform = computedTransform;
      this._updateBoundingVolume(this.header);
    }
    _getLoaderSpecificOptions(loaderId) {
      switch (loaderId) {
        case "i3s":
          return {
            ...this.tileset.options.i3s,
            _tileOptions: {
              attributeUrls: this.header.attributeUrls,
              textureUrl: this.header.textureUrl,
              textureFormat: this.header.textureFormat,
              textureLoaderOptions: this.header.textureLoaderOptions,
              materialDefinition: this.header.materialDefinition,
              isDracoGeometry: this.header.isDracoGeometry,
              mbs: this.header.mbs
            },
            _tilesetOptions: {
              store: this.tileset.tileset.store,
              attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
              fields: this.tileset.tileset.fields
            },
            isTileHeader: false
          };
        case "3d-tiles":
        case "cesium-ion":
        default:
          return get3dTilesOptions(this.tileset.tileset);
      }
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/format-3d-tiles/tileset-3d-traverser.js
  var Tileset3DTraverser = class extends TilesetTraverser {
    compareDistanceToCamera(a2, b) {
      return b._distanceToCamera === 0 && a2._distanceToCamera === 0 ? b._centerZDepth - a2._centerZDepth : b._distanceToCamera - a2._distanceToCamera;
    }
    updateTileVisibility(tile, frameState) {
      super.updateTileVisibility(tile, frameState);
      if (!tile.isVisibleAndInRequestVolume) {
        return;
      }
      const hasChildren = tile.children.length > 0;
      if (tile.hasTilesetContent && hasChildren) {
        const firstChild = tile.children[0];
        this.updateTileVisibility(firstChild, frameState);
        tile._visible = firstChild._visible;
        return;
      }
      if (this.meetsScreenSpaceErrorEarly(tile, frameState)) {
        tile._visible = false;
        return;
      }
      const replace = tile.refine === TILE_REFINEMENT.REPLACE;
      const useOptimization = tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;
      if (replace && useOptimization && hasChildren) {
        if (!this.anyChildrenVisible(tile, frameState)) {
          tile._visible = false;
          return;
        }
      }
    }
    meetsScreenSpaceErrorEarly(tile, frameState) {
      const {
        parent
      } = tile;
      if (!parent || parent.hasTilesetContent || parent.refine !== TILE_REFINEMENT.ADD) {
        return false;
      }
      return !this.shouldRefine(tile, frameState, true);
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/format-i3s/i3s-pending-tiles-register.js
  var I3SPendingTilesRegister = class {
    constructor() {
      _defineProperty(this, "frameNumberMap", /* @__PURE__ */ new Map());
    }
    register(viewportId, frameNumber) {
      const viewportMap = this.frameNumberMap.get(viewportId) || /* @__PURE__ */ new Map();
      const oldCount = viewportMap.get(frameNumber) || 0;
      viewportMap.set(frameNumber, oldCount + 1);
      this.frameNumberMap.set(viewportId, viewportMap);
    }
    deregister(viewportId, frameNumber) {
      const viewportMap = this.frameNumberMap.get(viewportId);
      if (!viewportMap) {
        return;
      }
      const oldCount = viewportMap.get(frameNumber) || 1;
      viewportMap.set(frameNumber, oldCount - 1);
    }
    isZero(viewportId, frameNumber) {
      var _this$frameNumberMap$;
      const count2 = ((_this$frameNumberMap$ = this.frameNumberMap.get(viewportId)) === null || _this$frameNumberMap$ === void 0 ? void 0 : _this$frameNumberMap$.get(frameNumber)) || 0;
      return count2 === 0;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/format-i3s/i3s-tile-manager.js
  var STATUS = {
    REQUESTED: "REQUESTED",
    COMPLETED: "COMPLETED",
    ERROR: "ERROR"
  };
  var I3STileManager = class {
    constructor() {
      _defineProperty(this, "_statusMap", void 0);
      _defineProperty(this, "pendingTilesRegister", new I3SPendingTilesRegister());
      this._statusMap = {};
    }
    add(request, key, callback, frameState) {
      if (!this._statusMap[key]) {
        const {
          frameNumber,
          viewport: {
            id
          }
        } = frameState;
        this._statusMap[key] = {
          request,
          callback,
          key,
          frameState,
          status: STATUS.REQUESTED
        };
        this.pendingTilesRegister.register(id, frameNumber);
        request().then((data) => {
          this._statusMap[key].status = STATUS.COMPLETED;
          const {
            frameNumber: actualFrameNumber,
            viewport: {
              id: id2
            }
          } = this._statusMap[key].frameState;
          this.pendingTilesRegister.deregister(id2, actualFrameNumber);
          this._statusMap[key].callback(data, frameState);
        }).catch((error2) => {
          this._statusMap[key].status = STATUS.ERROR;
          const {
            frameNumber: actualFrameNumber,
            viewport: {
              id: id2
            }
          } = this._statusMap[key].frameState;
          this.pendingTilesRegister.deregister(id2, actualFrameNumber);
          callback(error2);
        });
      }
    }
    update(key, frameState) {
      if (this._statusMap[key]) {
        const {
          frameNumber,
          viewport: {
            id
          }
        } = this._statusMap[key].frameState;
        this.pendingTilesRegister.deregister(id, frameNumber);
        const {
          frameNumber: newFrameNumber,
          viewport: {
            id: newViewportId
          }
        } = frameState;
        this.pendingTilesRegister.register(newViewportId, newFrameNumber);
        this._statusMap[key].frameState = frameState;
      }
    }
    find(key) {
      return this._statusMap[key];
    }
    hasPendingTiles(viewportId, frameNumber) {
      return !this.pendingTilesRegister.isZero(viewportId, frameNumber);
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/format-i3s/i3s-tileset-traverser.js
  var I3STilesetTraverser = class extends TilesetTraverser {
    constructor(options) {
      super(options);
      _defineProperty(this, "_tileManager", void 0);
      this._tileManager = new I3STileManager();
    }
    traversalFinished(frameState) {
      return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);
    }
    shouldRefine(tile, frameState) {
      tile._lodJudge = getLodStatus(tile, frameState);
      return tile._lodJudge === "DIG";
    }
    updateChildTiles(tile, frameState) {
      const children = tile.header.children || [];
      const childTiles = tile.children;
      const tileset = tile.tileset;
      for (const child of children) {
        const extendedId = "".concat(child.id, "-").concat(frameState.viewport.id);
        const childTile = childTiles && childTiles.find((t2) => t2.id === extendedId);
        if (!childTile) {
          let request = () => this._loadTile(child.id, tileset);
          const cachedRequest = this._tileManager.find(extendedId);
          if (!cachedRequest) {
            if (tileset.tileset.nodePages) {
              request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);
            }
            this._tileManager.add(request, extendedId, (header) => this._onTileLoad(header, tile, extendedId), frameState);
          } else {
            this._tileManager.update(extendedId, frameState);
          }
        } else if (childTile) {
          this.updateTile(childTile, frameState);
        }
      }
      return false;
    }
    async _loadTile(nodeId, tileset) {
      const {
        loader
      } = tileset;
      const nodeUrl = tileset.getTileUrl("".concat(tileset.url, "/nodes/").concat(nodeId));
      const options = {
        ...tileset.loadOptions,
        i3s: {
          ...tileset.loadOptions.i3s,
          isTileHeader: true
        }
      };
      return await load(nodeUrl, loader, options);
    }
    _onTileLoad(header, tile, extendedId) {
      const childTile = new Tile3D(tile.tileset, header, tile, extendedId);
      tile.children.push(childTile);
      const frameState = this._tileManager.find(childTile.id).frameState;
      this.updateTile(childTile, frameState);
      if (this._frameNumber === frameState.frameNumber && (this.traversalFinished(frameState) || new Date().getTime() - this.lastUpdate > this.updateDebounceTime)) {
        this.executeTraversal(childTile, frameState);
      }
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/esm/tileset/tileset-3d.js
  var DEFAULT_PROPS5 = {
    description: "",
    ellipsoid: Ellipsoid.WGS84,
    modelMatrix: new Matrix4(),
    throttleRequests: true,
    maxRequests: 64,
    maximumMemoryUsage: 32,
    maximumTilesSelected: 0,
    debounceTime: 0,
    onTileLoad: () => {
    },
    onTileUnload: () => {
    },
    onTileError: () => {
    },
    onTraversalComplete: (selectedTiles) => selectedTiles,
    contentLoader: void 0,
    viewDistanceScale: 1,
    maximumScreenSpaceError: 8,
    loadTiles: true,
    updateTransforms: true,
    viewportTraversersMap: null,
    loadOptions: {
      fetch: {}
    },
    attributions: [],
    basePath: "",
    i3s: {}
  };
  var TILES_TOTAL = "Tiles In Tileset(s)";
  var TILES_IN_MEMORY = "Tiles In Memory";
  var TILES_IN_VIEW = "Tiles In View";
  var TILES_RENDERABLE = "Tiles To Render";
  var TILES_LOADED = "Tiles Loaded";
  var TILES_LOADING = "Tiles Loading";
  var TILES_UNLOADED = "Tiles Unloaded";
  var TILES_LOAD_FAILED = "Failed Tile Loads";
  var POINTS_COUNT = "Points/Vertices";
  var TILES_GPU_MEMORY = "Tile Memory Use";
  var Tileset3D = class {
    constructor(tileset, options) {
      _defineProperty(this, "options", void 0);
      _defineProperty(this, "loadOptions", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "tileset", void 0);
      _defineProperty(this, "loader", void 0);
      _defineProperty(this, "url", void 0);
      _defineProperty(this, "basePath", void 0);
      _defineProperty(this, "modelMatrix", void 0);
      _defineProperty(this, "ellipsoid", void 0);
      _defineProperty(this, "lodMetricType", void 0);
      _defineProperty(this, "lodMetricValue", void 0);
      _defineProperty(this, "refine", void 0);
      _defineProperty(this, "root", null);
      _defineProperty(this, "roots", {});
      _defineProperty(this, "asset", {});
      _defineProperty(this, "description", "");
      _defineProperty(this, "properties", void 0);
      _defineProperty(this, "extras", null);
      _defineProperty(this, "attributions", {});
      _defineProperty(this, "credits", {});
      _defineProperty(this, "stats", void 0);
      _defineProperty(this, "contentFormats", {
        draco: false,
        meshopt: false,
        dds: false,
        ktx2: false
      });
      _defineProperty(this, "cartographicCenter", null);
      _defineProperty(this, "cartesianCenter", null);
      _defineProperty(this, "zoom", 1);
      _defineProperty(this, "boundingVolume", null);
      _defineProperty(this, "dynamicScreenSpaceErrorComputedDensity", 0);
      _defineProperty(this, "maximumMemoryUsage", 32);
      _defineProperty(this, "gpuMemoryUsageInBytes", 0);
      _defineProperty(this, "_frameNumber", 0);
      _defineProperty(this, "_queryParams", {});
      _defineProperty(this, "_extensionsUsed", []);
      _defineProperty(this, "_tiles", {});
      _defineProperty(this, "_pendingCount", 0);
      _defineProperty(this, "selectedTiles", []);
      _defineProperty(this, "traverseCounter", 0);
      _defineProperty(this, "geometricError", 0);
      _defineProperty(this, "lastUpdatedVieports", null);
      _defineProperty(this, "_requestedTiles", []);
      _defineProperty(this, "_emptyTiles", []);
      _defineProperty(this, "frameStateData", {});
      _defineProperty(this, "_traverser", void 0);
      _defineProperty(this, "_cache", new TilesetCache());
      _defineProperty(this, "_requestScheduler", void 0);
      _defineProperty(this, "updatePromise", null);
      _defineProperty(this, "tilesetInitializationPromise", void 0);
      this.options = {
        ...DEFAULT_PROPS5,
        ...options
      };
      this.tileset = tileset;
      this.loader = tileset.loader;
      this.type = tileset.type;
      this.url = tileset.url;
      this.basePath = tileset.basePath || path_exports.dirname(this.url);
      this.modelMatrix = this.options.modelMatrix;
      this.ellipsoid = this.options.ellipsoid;
      this.lodMetricType = tileset.lodMetricType;
      this.lodMetricValue = tileset.lodMetricValue;
      this.refine = tileset.root.refine;
      this.loadOptions = this.options.loadOptions || {};
      this._traverser = this._initializeTraverser();
      this._requestScheduler = new RequestScheduler({
        throttleRequests: this.options.throttleRequests,
        maxRequests: this.options.maxRequests
      });
      this.stats = new Stats3({
        id: this.url
      });
      this._initializeStats();
      this.tilesetInitializationPromise = this._initializeTileSet(tileset);
    }
    destroy() {
      this._destroy();
    }
    isLoaded() {
      return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
    }
    get tiles() {
      return Object.values(this._tiles);
    }
    get frameNumber() {
      return this._frameNumber;
    }
    get queryParams() {
      return new URLSearchParams(this._queryParams).toString();
    }
    setProps(props) {
      this.options = {
        ...this.options,
        ...props
      };
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options
      };
    }
    getTileUrl(tilePath) {
      const isDataUrl = tilePath.startsWith("data:");
      if (isDataUrl) {
        return tilePath;
      }
      return "".concat(tilePath).concat(tilePath.includes("?") ? "&" : "?").concat(this.queryParams);
    }
    hasExtension(extensionName) {
      return Boolean(this._extensionsUsed.indexOf(extensionName) > -1);
    }
    update() {
      let viewports = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      this.tilesetInitializationPromise.then(() => {
        if (!viewports && this.lastUpdatedVieports) {
          viewports = this.lastUpdatedVieports;
        } else {
          this.lastUpdatedVieports = viewports;
        }
        if (viewports) {
          this.doUpdate(viewports);
        }
      });
    }
    async selectTiles() {
      let viewports = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      await this.tilesetInitializationPromise;
      if (viewports) {
        this.lastUpdatedVieports = viewports;
      }
      if (!this.updatePromise) {
        this.updatePromise = new Promise((resolve2) => {
          setTimeout(() => {
            if (this.lastUpdatedVieports) {
              this.doUpdate(this.lastUpdatedVieports);
            }
            resolve2(this._frameNumber);
            this.updatePromise = null;
          }, this.options.debounceTime);
        });
      }
      return this.updatePromise;
    }
    doUpdate(viewports) {
      if ("loadTiles" in this.options && !this.options.loadTiles) {
        return;
      }
      if (this.traverseCounter > 0) {
        return;
      }
      const preparedViewports = viewports instanceof Array ? viewports : [viewports];
      this._cache.reset();
      this._frameNumber++;
      this.traverseCounter = preparedViewports.length;
      const viewportsToTraverse = [];
      for (const viewport of preparedViewports) {
        const id = viewport.id;
        if (this._needTraverse(id)) {
          viewportsToTraverse.push(id);
        } else {
          this.traverseCounter--;
        }
      }
      for (const viewport of preparedViewports) {
        const id = viewport.id;
        if (!this.roots[id]) {
          this.roots[id] = this._initializeTileHeaders(this.tileset, null);
        }
        if (!viewportsToTraverse.includes(id)) {
          continue;
        }
        const frameState = getFrameState(viewport, this._frameNumber);
        this._traverser.traverse(this.roots[id], frameState, this.options);
      }
    }
    _needTraverse(viewportId) {
      let traverserId = viewportId;
      if (this.options.viewportTraversersMap) {
        traverserId = this.options.viewportTraversersMap[viewportId];
      }
      if (traverserId !== viewportId) {
        return false;
      }
      return true;
    }
    _onTraversalEnd(frameState) {
      const id = frameState.viewport.id;
      if (!this.frameStateData[id]) {
        this.frameStateData[id] = {
          selectedTiles: [],
          _requestedTiles: [],
          _emptyTiles: []
        };
      }
      const currentFrameStateData = this.frameStateData[id];
      const selectedTiles = Object.values(this._traverser.selectedTiles);
      const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(selectedTiles, frameState, this.options.maximumTilesSelected);
      currentFrameStateData.selectedTiles = filteredSelectedTiles;
      for (const tile of unselectedTiles) {
        tile.unselect();
      }
      currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);
      currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);
      this.traverseCounter--;
      if (this.traverseCounter > 0) {
        return;
      }
      this._updateTiles();
    }
    _updateTiles() {
      this.selectedTiles = [];
      this._requestedTiles = [];
      this._emptyTiles = [];
      for (const frameStateKey in this.frameStateData) {
        const frameStateDataValue = this.frameStateData[frameStateKey];
        this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);
        this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);
        this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);
      }
      this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
      for (const tile of this.selectedTiles) {
        this._tiles[tile.id] = tile;
      }
      this._loadTiles();
      this._unloadTiles();
      this._updateStats();
    }
    _tilesChanged(oldSelectedTiles, selectedTiles) {
      if (oldSelectedTiles.length !== selectedTiles.length) {
        return true;
      }
      const set1 = new Set(oldSelectedTiles.map((t2) => t2.id));
      const set2 = new Set(selectedTiles.map((t2) => t2.id));
      let changed = oldSelectedTiles.filter((x2) => !set2.has(x2.id)).length > 0;
      changed = changed || selectedTiles.filter((x2) => !set1.has(x2.id)).length > 0;
      return changed;
    }
    _loadTiles() {
      for (const tile of this._requestedTiles) {
        if (tile.contentUnloaded) {
          this._loadTile(tile);
        }
      }
    }
    _unloadTiles() {
      this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));
    }
    _updateStats() {
      let tilesRenderable = 0;
      let pointsRenderable = 0;
      for (const tile of this.selectedTiles) {
        if (tile.contentAvailable && tile.content) {
          tilesRenderable++;
          if (tile.content.pointCount) {
            pointsRenderable += tile.content.pointCount;
          } else {
            pointsRenderable += tile.content.vertexCount;
          }
        }
      }
      this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;
      this.stats.get(TILES_RENDERABLE).count = tilesRenderable;
      this.stats.get(POINTS_COUNT).count = pointsRenderable;
    }
    async _initializeTileSet(tilesetJson) {
      if (this.type === TILESET_TYPE.I3S) {
        this.calculateViewPropsI3S();
        tilesetJson.root = await tilesetJson.root;
      }
      this.root = this._initializeTileHeaders(tilesetJson, null);
      if (this.type === TILESET_TYPE.TILES3D) {
        this._initializeTiles3DTileset(tilesetJson);
        this.calculateViewPropsTiles3D();
      }
      if (this.type === TILESET_TYPE.I3S) {
        this._initializeI3STileset();
      }
    }
    calculateViewPropsI3S() {
      var _this$tileset$store;
      const fullExtent = this.tileset.fullExtent;
      if (fullExtent) {
        const {
          xmin,
          xmax,
          ymin,
          ymax,
          zmin,
          zmax
        } = fullExtent;
        this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, zmin + (zmax - zmin) / 2);
        this.cartesianCenter = Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, new Vector3());
        this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);
        return;
      }
      const extent = (_this$tileset$store = this.tileset.store) === null || _this$tileset$store === void 0 ? void 0 : _this$tileset$store.extent;
      if (extent) {
        const [xmin, ymin, xmax, ymax] = extent;
        this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);
        this.cartesianCenter = Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, new Vector3());
        this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);
        return;
      }
      console.warn("Extent is not defined in the tileset header");
      this.cartographicCenter = new Vector3();
      this.zoom = 1;
      return;
    }
    calculateViewPropsTiles3D() {
      const root = this.root;
      const {
        center
      } = root.boundingVolume;
      if (!center) {
        console.warn("center was not pre-calculated for the root tile");
        this.cartographicCenter = new Vector3();
        this.zoom = 1;
        return;
      }
      if (center[0] !== 0 || center[1] !== 0 || center[2] !== 0) {
        this.cartographicCenter = Ellipsoid.WGS84.cartesianToCartographic(center, new Vector3());
      } else {
        this.cartographicCenter = new Vector3(0, 0, -Ellipsoid.WGS84.radii[0]);
      }
      this.cartesianCenter = center;
      this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);
    }
    _initializeStats() {
      this.stats.get(TILES_TOTAL);
      this.stats.get(TILES_LOADING);
      this.stats.get(TILES_IN_MEMORY);
      this.stats.get(TILES_IN_VIEW);
      this.stats.get(TILES_RENDERABLE);
      this.stats.get(TILES_LOADED);
      this.stats.get(TILES_UNLOADED);
      this.stats.get(TILES_LOAD_FAILED);
      this.stats.get(POINTS_COUNT);
      this.stats.get(TILES_GPU_MEMORY, "memory");
    }
    _initializeTileHeaders(tilesetJson, parentTileHeader) {
      const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader);
      if (parentTileHeader) {
        parentTileHeader.children.push(rootTile);
        rootTile.depth = parentTileHeader.depth + 1;
      }
      if (this.type === TILESET_TYPE.TILES3D) {
        const stack2 = [];
        stack2.push(rootTile);
        while (stack2.length > 0) {
          const tile = stack2.pop();
          this.stats.get(TILES_TOTAL).incrementCount();
          const children = tile.header.children || [];
          for (const childHeader of children) {
            var _childTile$contentUrl;
            const childTile = new Tile3D(this, childHeader, tile);
            if ((_childTile$contentUrl = childTile.contentUrl) !== null && _childTile$contentUrl !== void 0 && _childTile$contentUrl.includes("?session=")) {
              const url = new URL(childTile.contentUrl);
              const session = url.searchParams.get("session");
              if (session) {
                this._queryParams.session = session;
              }
            }
            tile.children.push(childTile);
            childTile.depth = tile.depth + 1;
            stack2.push(childTile);
          }
        }
      }
      return rootTile;
    }
    _initializeTraverser() {
      let TraverserClass;
      const type = this.type;
      switch (type) {
        case TILESET_TYPE.TILES3D:
          TraverserClass = Tileset3DTraverser;
          break;
        case TILESET_TYPE.I3S:
          TraverserClass = I3STilesetTraverser;
          break;
        default:
          TraverserClass = TilesetTraverser;
      }
      return new TraverserClass({
        basePath: this.basePath,
        onTraversalEnd: this._onTraversalEnd.bind(this)
      });
    }
    _destroyTileHeaders(parentTile) {
      this._destroySubtree(parentTile);
    }
    async _loadTile(tile) {
      let loaded;
      try {
        this._onStartTileLoading();
        loaded = await tile.loadContent();
      } catch (error2) {
        this._onTileLoadError(tile, error2 instanceof Error ? error2 : new Error("load failed"));
      } finally {
        this._onEndTileLoading();
        this._onTileLoad(tile, loaded);
      }
    }
    _onTileLoadError(tile, error2) {
      this.stats.get(TILES_LOAD_FAILED).incrementCount();
      const message = error2.message || error2.toString();
      const url = tile.url;
      console.error("A 3D tile failed to load: ".concat(tile.url, " ").concat(message));
      this.options.onTileError(tile, message, url);
    }
    _onTileLoad(tile, loaded) {
      if (!loaded) {
        return;
      }
      if (this.type === TILESET_TYPE.I3S) {
        var _this$tileset, _this$tileset$nodePag;
        const nodesInNodePages = ((_this$tileset = this.tileset) === null || _this$tileset === void 0 ? void 0 : (_this$tileset$nodePag = _this$tileset.nodePagesTile) === null || _this$tileset$nodePag === void 0 ? void 0 : _this$tileset$nodePag.nodesInNodePages) || 0;
        this.stats.get(TILES_TOTAL).reset();
        this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);
      }
      if (tile && tile.content) {
        calculateTransformProps(tile, tile.content);
      }
      this.updateContentTypes(tile);
      this._addTileToCache(tile);
      this.options.onTileLoad(tile);
    }
    updateContentTypes(tile) {
      if (this.type === TILESET_TYPE.I3S) {
        if (tile.header.isDracoGeometry) {
          this.contentFormats.draco = true;
        }
        switch (tile.header.textureFormat) {
          case "dds":
            this.contentFormats.dds = true;
            break;
          case "ktx2":
            this.contentFormats.ktx2 = true;
            break;
          default:
        }
      } else if (this.type === TILESET_TYPE.TILES3D) {
        var _tile$content;
        const {
          extensionsRemoved = []
        } = ((_tile$content = tile.content) === null || _tile$content === void 0 ? void 0 : _tile$content.gltf) || {};
        if (extensionsRemoved.includes("KHR_draco_mesh_compression")) {
          this.contentFormats.draco = true;
        }
        if (extensionsRemoved.includes("EXT_meshopt_compression")) {
          this.contentFormats.meshopt = true;
        }
        if (extensionsRemoved.includes("KHR_texture_basisu")) {
          this.contentFormats.ktx2 = true;
        }
      }
    }
    _onStartTileLoading() {
      this._pendingCount++;
      this.stats.get(TILES_LOADING).incrementCount();
    }
    _onEndTileLoading() {
      this._pendingCount--;
      this.stats.get(TILES_LOADING).decrementCount();
    }
    _addTileToCache(tile) {
      this._cache.add(this, tile, (tileset) => tileset._updateCacheStats(tile));
    }
    _updateCacheStats(tile) {
      this.stats.get(TILES_LOADED).incrementCount();
      this.stats.get(TILES_IN_MEMORY).incrementCount();
      this.gpuMemoryUsageInBytes += tile.gpuMemoryUsageInBytes || 0;
      this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
    }
    _unloadTile(tile) {
      this.gpuMemoryUsageInBytes -= tile.gpuMemoryUsageInBytes || 0;
      this.stats.get(TILES_IN_MEMORY).decrementCount();
      this.stats.get(TILES_UNLOADED).incrementCount();
      this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
      this.options.onTileUnload(tile);
      tile.unloadContent();
    }
    _destroy() {
      const stack2 = [];
      if (this.root) {
        stack2.push(this.root);
      }
      while (stack2.length > 0) {
        const tile = stack2.pop();
        for (const child of tile.children) {
          stack2.push(child);
        }
        this._destroyTile(tile);
      }
      this.root = null;
    }
    _destroySubtree(tile) {
      const root = tile;
      const stack2 = [];
      stack2.push(root);
      while (stack2.length > 0) {
        tile = stack2.pop();
        for (const child of tile.children) {
          stack2.push(child);
        }
        if (tile !== root) {
          this._destroyTile(tile);
        }
      }
      root.children = [];
    }
    _destroyTile(tile) {
      this._cache.unloadTile(this, tile);
      this._unloadTile(tile);
      tile.destroy();
    }
    _initializeTiles3DTileset(tilesetJson) {
      if (tilesetJson.queryString) {
        const searchParams = new URLSearchParams(tilesetJson.queryString);
        const queryParams = Object.fromEntries(searchParams.entries());
        this._queryParams = {
          ...this._queryParams,
          ...queryParams
        };
      }
      this.asset = tilesetJson.asset;
      if (!this.asset) {
        throw new Error("Tileset must have an asset property.");
      }
      if (this.asset.version !== "0.0" && this.asset.version !== "1.0") {
        throw new Error("The tileset must be 3D Tiles version 0.0 or 1.0.");
      }
      if ("tilesetVersion" in this.asset) {
        this._queryParams.v = this.asset.tilesetVersion;
      }
      this.credits = {
        attributions: this.options.attributions || []
      };
      this.description = this.options.description || "";
      this.properties = tilesetJson.properties;
      this.geometricError = tilesetJson.geometricError;
      this._extensionsUsed = tilesetJson.extensionsUsed || [];
      this.extras = tilesetJson.extras;
    }
    _initializeI3STileset() {
      if (this.loadOptions.i3s && "token" in this.loadOptions.i3s) {
        this._queryParams.token = this.loadOptions.i3s.token;
      }
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/utils/version.js
  var VERSION15 = true ? "3.4.2" : "latest";

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/constants.js
  var TILE3D_TYPE = {
    COMPOSITE: "cmpt",
    POINT_CLOUD: "pnts",
    BATCHED_3D_MODEL: "b3dm",
    INSTANCED_3D_MODEL: "i3dm",
    GEOMETRY: "geom",
    VECTOR: "vect",
    GLTF: "glTF"
  };
  var TILE3D_TYPES = Object.keys(TILE3D_TYPE);

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-utils.js
  function getStringFromArrayBuffer(arrayBuffer2, byteOffset, byteLength) {
    assert2(arrayBuffer2 instanceof ArrayBuffer);
    const textDecoder = new TextDecoder("utf8");
    const typedArray = new Uint8Array(arrayBuffer2, byteOffset, byteLength);
    const string = textDecoder.decode(typedArray);
    return string;
  }
  function getMagicString4(arrayBuffer2) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const dataView = new DataView(arrayBuffer2);
    return "".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));
  }

  // ../../node_modules/@loaders.gl/math/dist/esm/geometry/constants.js
  var GL_PRIMITIVE_MODE = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  };
  var GL_TYPE = {
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    INT: 5124,
    UNSIGNED_INT: 5125,
    FLOAT: 5126,
    DOUBLE: 5130
  };
  var GL2 = {
    ...GL_PRIMITIVE_MODE,
    ...GL_TYPE
  };

  // ../../node_modules/@loaders.gl/math/dist/esm/geometry/gl/gl-type.js
  var GL_TYPE_TO_ARRAY_TYPE = {
    [GL_TYPE.DOUBLE]: Float64Array,
    [GL_TYPE.FLOAT]: Float32Array,
    [GL_TYPE.UNSIGNED_SHORT]: Uint16Array,
    [GL_TYPE.UNSIGNED_INT]: Uint32Array,
    [GL_TYPE.UNSIGNED_BYTE]: Uint8Array,
    [GL_TYPE.BYTE]: Int8Array,
    [GL_TYPE.SHORT]: Int16Array,
    [GL_TYPE.INT]: Int32Array
  };
  var NAME_TO_GL_TYPE = {
    DOUBLE: GL_TYPE.DOUBLE,
    FLOAT: GL_TYPE.FLOAT,
    UNSIGNED_SHORT: GL_TYPE.UNSIGNED_SHORT,
    UNSIGNED_INT: GL_TYPE.UNSIGNED_INT,
    UNSIGNED_BYTE: GL_TYPE.UNSIGNED_BYTE,
    BYTE: GL_TYPE.BYTE,
    SHORT: GL_TYPE.SHORT,
    INT: GL_TYPE.INT
  };
  var ERR_TYPE_CONVERSION = "Failed to convert GL type";
  var GLType = class {
    static fromTypedArray(arrayOrType) {
      arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
      for (const glType in GL_TYPE_TO_ARRAY_TYPE) {
        const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];
        if (ArrayType === arrayOrType) {
          return glType;
        }
      }
      throw new Error(ERR_TYPE_CONVERSION);
    }
    static fromName(name10) {
      const glType = NAME_TO_GL_TYPE[name10];
      if (!glType) {
        throw new Error(ERR_TYPE_CONVERSION);
      }
      return glType;
    }
    static getArrayType(glType) {
      switch (glType) {
        case GL_TYPE.UNSIGNED_SHORT_5_6_5:
        case GL_TYPE.UNSIGNED_SHORT_4_4_4_4:
        case GL_TYPE.UNSIGNED_SHORT_5_5_5_1:
          return Uint16Array;
        default:
          const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];
          if (!ArrayType) {
            throw new Error(ERR_TYPE_CONVERSION);
          }
          return ArrayType;
      }
    }
    static getByteSize(glType) {
      const ArrayType = GLType.getArrayType(glType);
      return ArrayType.BYTES_PER_ELEMENT;
    }
    static validate(glType) {
      return Boolean(GLType.getArrayType(glType));
    }
    static createTypedArray(glType, buffer) {
      let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      let length7 = arguments.length > 3 ? arguments[3] : void 0;
      if (length7 === void 0) {
        length7 = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);
      }
      const ArrayType = GLType.getArrayType(glType);
      return new ArrayType(buffer, byteOffset, length7);
    }
  };

  // ../../node_modules/@loaders.gl/math/dist/esm/geometry/utils/assert.js
  function assert14(condition, message) {
    if (!condition) {
      throw new Error("math.gl assertion failed. ".concat(message));
    }
  }

  // ../../node_modules/@loaders.gl/math/dist/esm/geometry/colors/rgb565.js
  function decodeRGB565(rgb565) {
    let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const r5 = rgb565 >> 11 & 31;
    const g6 = rgb565 >> 5 & 63;
    const b5 = rgb565 & 31;
    target[0] = r5 << 3;
    target[1] = g6 << 2;
    target[2] = b5 << 3;
    return target;
  }

  // ../../node_modules/@loaders.gl/math/dist/esm/geometry/compression/attribute-compression.js
  var RIGHT_SHIFT = 1 / 256;
  var scratchVector25 = new Vector2();
  var scratchVector35 = new Vector3();
  var scratchEncodeVector2 = new Vector2();
  var octEncodeScratch = new Vector2();
  var uint8ForceArray = new Uint8Array(1);
  function fromSNorm(value) {
    let rangeMaximum = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;
    return clamp(value, 0, rangeMaximum) / rangeMaximum * 2 - 1;
  }
  function signNotZero(value) {
    return value < 0 ? -1 : 1;
  }
  function octDecodeInRange(x2, y2, rangeMax, result) {
    assert14(result);
    if (x2 < 0 || x2 > rangeMax || y2 < 0 || y2 > rangeMax) {
      throw new Error("x and y must be unsigned normalized integers between 0 and ".concat(rangeMax));
    }
    result.x = fromSNorm(x2, rangeMax);
    result.y = fromSNorm(y2, rangeMax);
    result.z = 1 - (Math.abs(result.x) + Math.abs(result.y));
    if (result.z < 0) {
      const oldVX = result.x;
      result.x = (1 - Math.abs(result.y)) * signNotZero(oldVX);
      result.y = (1 - Math.abs(oldVX)) * signNotZero(result.y);
    }
    return result.normalize();
  }
  function octDecode(x2, y2, result) {
    return octDecodeInRange(x2, y2, 255, result);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/tile-3d-feature-table.js
  var Tile3DFeatureTable = class {
    constructor(featureTableJson, featureTableBinary) {
      _defineProperty(this, "json", void 0);
      _defineProperty(this, "buffer", void 0);
      _defineProperty(this, "featuresLength", 0);
      _defineProperty(this, "_cachedTypedArrays", {});
      this.json = featureTableJson;
      this.buffer = featureTableBinary;
    }
    getExtension(extensionName) {
      return this.json.extensions && this.json.extensions[extensionName];
    }
    hasProperty(propertyName) {
      return Boolean(this.json[propertyName]);
    }
    getGlobalProperty(propertyName) {
      let componentType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : GL2.UNSIGNED_INT;
      let componentLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      const jsonValue = this.json[propertyName];
      if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
        return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, 1, jsonValue.byteOffset);
      }
      return jsonValue;
    }
    getPropertyArray(propertyName, componentType, componentLength) {
      const jsonValue = this.json[propertyName];
      if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
        if ("componentType" in jsonValue) {
          componentType = GLType.fromName(jsonValue.componentType);
        }
        return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, this.featuresLength, jsonValue.byteOffset);
      }
      return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);
    }
    getProperty(propertyName, componentType, componentLength, featureId, result) {
      const jsonValue = this.json[propertyName];
      if (!jsonValue) {
        return jsonValue;
      }
      const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);
      if (componentLength === 1) {
        return typedArray[featureId];
      }
      for (let i3 = 0; i3 < componentLength; ++i3) {
        result[i3] = typedArray[componentLength * featureId + i3];
      }
      return result;
    }
    _getTypedArrayFromBinary(propertyName, componentType, componentLength, count2, byteOffset) {
      const cachedTypedArrays = this._cachedTypedArrays;
      let typedArray = cachedTypedArrays[propertyName];
      if (!typedArray) {
        typedArray = GLType.createTypedArray(componentType, this.buffer.buffer, this.buffer.byteOffset + byteOffset, count2 * componentLength);
        cachedTypedArrays[propertyName] = typedArray;
      }
      return typedArray;
    }
    _getTypedArrayFromArray(propertyName, componentType, array) {
      const cachedTypedArrays = this._cachedTypedArrays;
      let typedArray = cachedTypedArrays[propertyName];
      if (!typedArray) {
        typedArray = GLType.createTypedArray(componentType, array);
        cachedTypedArrays[propertyName] = typedArray;
      }
      return typedArray;
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/helpers/tile-3d-accessor-utils.js
  var COMPONENTS_PER_ATTRIBUTE = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var UNPACKER = {
    SCALAR: (values, i3) => values[i3],
    VEC2: (values, i3) => [values[2 * i3 + 0], values[2 * i3 + 1]],
    VEC3: (values, i3) => [values[3 * i3 + 0], values[3 * i3 + 1], values[3 * i3 + 2]],
    VEC4: (values, i3) => [values[4 * i3 + 0], values[4 * i3 + 1], values[4 * i3 + 2], values[4 * i3 + 3]],
    MAT2: (values, i3) => [values[4 * i3 + 0], values[4 * i3 + 1], values[4 * i3 + 2], values[4 * i3 + 3]],
    MAT3: (values, i3) => [values[9 * i3 + 0], values[9 * i3 + 1], values[9 * i3 + 2], values[9 * i3 + 3], values[9 * i3 + 4], values[9 * i3 + 5], values[9 * i3 + 6], values[9 * i3 + 7], values[9 * i3 + 8]],
    MAT4: (values, i3) => [values[16 * i3 + 0], values[16 * i3 + 1], values[16 * i3 + 2], values[16 * i3 + 3], values[16 * i3 + 4], values[16 * i3 + 5], values[16 * i3 + 6], values[16 * i3 + 7], values[16 * i3 + 8], values[16 * i3 + 9], values[16 * i3 + 10], values[16 * i3 + 11], values[16 * i3 + 12], values[16 * i3 + 13], values[16 * i3 + 14], values[16 * i3 + 15]]
  };
  var PACKER = {
    SCALAR: (x2, values, i3) => {
      values[i3] = x2;
    },
    VEC2: (x2, values, i3) => {
      values[2 * i3 + 0] = x2[0];
      values[2 * i3 + 1] = x2[1];
    },
    VEC3: (x2, values, i3) => {
      values[3 * i3 + 0] = x2[0];
      values[3 * i3 + 1] = x2[1];
      values[3 * i3 + 2] = x2[2];
    },
    VEC4: (x2, values, i3) => {
      values[4 * i3 + 0] = x2[0];
      values[4 * i3 + 1] = x2[1];
      values[4 * i3 + 2] = x2[2];
      values[4 * i3 + 3] = x2[3];
    },
    MAT2: (x2, values, i3) => {
      values[4 * i3 + 0] = x2[0];
      values[4 * i3 + 1] = x2[1];
      values[4 * i3 + 2] = x2[2];
      values[4 * i3 + 3] = x2[3];
    },
    MAT3: (x2, values, i3) => {
      values[9 * i3 + 0] = x2[0];
      values[9 * i3 + 1] = x2[1];
      values[9 * i3 + 2] = x2[2];
      values[9 * i3 + 3] = x2[3];
      values[9 * i3 + 4] = x2[4];
      values[9 * i3 + 5] = x2[5];
      values[9 * i3 + 6] = x2[6];
      values[9 * i3 + 7] = x2[7];
      values[9 * i3 + 8] = x2[8];
      values[9 * i3 + 9] = x2[9];
    },
    MAT4: (x2, values, i3) => {
      values[16 * i3 + 0] = x2[0];
      values[16 * i3 + 1] = x2[1];
      values[16 * i3 + 2] = x2[2];
      values[16 * i3 + 3] = x2[3];
      values[16 * i3 + 4] = x2[4];
      values[16 * i3 + 5] = x2[5];
      values[16 * i3 + 6] = x2[6];
      values[16 * i3 + 7] = x2[7];
      values[16 * i3 + 8] = x2[8];
      values[16 * i3 + 9] = x2[9];
      values[16 * i3 + 10] = x2[10];
      values[16 * i3 + 11] = x2[11];
      values[16 * i3 + 12] = x2[12];
      values[16 * i3 + 13] = x2[13];
      values[16 * i3 + 14] = x2[14];
      values[16 * i3 + 15] = x2[15];
    }
  };
  function createTypedArrayFromAccessor(tile3DAccessor, buffer, byteOffset, length7) {
    const {
      componentType
    } = tile3DAccessor;
    assert2(tile3DAccessor.componentType);
    const type = typeof componentType === "string" ? GLType.fromName(componentType) : componentType;
    const size = COMPONENTS_PER_ATTRIBUTE[tile3DAccessor.type];
    const unpacker = UNPACKER[tile3DAccessor.type];
    const packer = PACKER[tile3DAccessor.type];
    byteOffset += tile3DAccessor.byteOffset;
    const values = GLType.createTypedArray(type, buffer, byteOffset, size * length7);
    return {
      values,
      type,
      size,
      unpacker,
      packer
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/tile-3d-batch-table-hierarchy.js
  var defined3 = (x2) => x2 !== void 0;
  function initializeHierarchy(batchTable, jsonHeader, binaryBody) {
    if (!jsonHeader) {
      return null;
    }
    let hierarchy = batchTable.getExtension("3DTILES_batch_table_hierarchy");
    const legacyHierarchy = jsonHeader.HIERARCHY;
    if (legacyHierarchy) {
      console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.");
      jsonHeader.extensions = jsonHeader.extensions || {};
      jsonHeader.extensions["3DTILES_batch_table_hierarchy"] = legacyHierarchy;
      hierarchy = legacyHierarchy;
    }
    if (!hierarchy) {
      return null;
    }
    return initializeHierarchyValues(hierarchy, binaryBody);
  }
  function initializeHierarchyValues(hierarchyJson, binaryBody) {
    let i3;
    let classId;
    let binaryAccessor;
    const instancesLength = hierarchyJson.instancesLength;
    const classes = hierarchyJson.classes;
    let classIds = hierarchyJson.classIds;
    let parentCounts = hierarchyJson.parentCounts;
    let parentIds = hierarchyJson.parentIds;
    let parentIdsLength = instancesLength;
    if (defined3(classIds.byteOffset)) {
      classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);
      classIds.type = AttributeType.SCALAR;
      binaryAccessor = getBinaryAccessor(classIds);
      classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);
    }
    let parentIndexes;
    if (defined3(parentCounts)) {
      if (defined3(parentCounts.byteOffset)) {
        parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);
        parentCounts.type = AttributeType.SCALAR;
        binaryAccessor = getBinaryAccessor(parentCounts);
        parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);
      }
      parentIndexes = new Uint16Array(instancesLength);
      parentIdsLength = 0;
      for (i3 = 0; i3 < instancesLength; ++i3) {
        parentIndexes[i3] = parentIdsLength;
        parentIdsLength += parentCounts[i3];
      }
    }
    if (defined3(parentIds) && defined3(parentIds.byteOffset)) {
      parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);
      parentIds.type = AttributeType.SCALAR;
      binaryAccessor = getBinaryAccessor(parentIds);
      parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);
    }
    const classesLength = classes.length;
    for (i3 = 0; i3 < classesLength; ++i3) {
      const classInstancesLength = classes[i3].length;
      const properties = classes[i3].instances;
      const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);
      classes[i3].instances = combine(binaryProperties, properties);
    }
    const classCounts = new Array(classesLength).fill(0);
    const classIndexes = new Uint16Array(instancesLength);
    for (i3 = 0; i3 < instancesLength; ++i3) {
      classId = classIds[i3];
      classIndexes[i3] = classCounts[classId];
      ++classCounts[classId];
    }
    const hierarchy = {
      classes,
      classIds,
      classIndexes,
      parentCounts,
      parentIndexes,
      parentIds
    };
    validateHierarchy(hierarchy);
    return hierarchy;
  }
  function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {
    if (!hierarchy) {
      return;
    }
    const parentCounts = hierarchy.parentCounts;
    const parentIds = hierarchy.parentIds;
    if (parentIds) {
      return endConditionCallback(hierarchy, instanceIndex);
    }
    if (parentCounts > 0) {
      return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);
    }
    return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);
  }
  function traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {
    const classIds = hierarchy.classIds;
    const parentCounts = hierarchy.parentCounts;
    const parentIds = hierarchy.parentIds;
    const parentIndexes = hierarchy.parentIndexes;
    const instancesLength = classIds.length;
    const visited = scratchVisited;
    visited.length = Math.max(visited.length, instancesLength);
    const visitedMarker = ++marker;
    const stack2 = scratchStack;
    stack2.length = 0;
    stack2.push(instanceIndex);
    while (stack2.length > 0) {
      instanceIndex = stack2.pop();
      if (visited[instanceIndex] === visitedMarker) {
        continue;
      }
      visited[instanceIndex] = visitedMarker;
      const result = endConditionCallback(hierarchy, instanceIndex);
      if (defined3(result)) {
        return result;
      }
      const parentCount = parentCounts[instanceIndex];
      const parentIndex = parentIndexes[instanceIndex];
      for (let i3 = 0; i3 < parentCount; ++i3) {
        const parentId = parentIds[parentIndex + i3];
        if (parentId !== instanceIndex) {
          stack2.push(parentId);
        }
      }
    }
    return null;
  }
  function traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {
    let hasParent = true;
    while (hasParent) {
      const result = endConditionCallback(hierarchy, instanceIndex);
      if (defined3(result)) {
        return result;
      }
      const parentId = hierarchy.parentIds[instanceIndex];
      hasParent = parentId !== instanceIndex;
      instanceIndex = parentId;
    }
    throw new Error("traverseHierarchySingleParent");
  }
  function validateHierarchy(hierarchy) {
    const scratchValidateStack = [];
    const classIds = hierarchy.classIds;
    const instancesLength = classIds.length;
    for (let i3 = 0; i3 < instancesLength; ++i3) {
      validateInstance(hierarchy, i3, stack);
    }
  }
  function validateInstance(hierarchy, instanceIndex, stack2) {
    const parentCounts = hierarchy.parentCounts;
    const parentIds = hierarchy.parentIds;
    const parentIndexes = hierarchy.parentIndexes;
    const classIds = hierarchy.classIds;
    const instancesLength = classIds.length;
    if (!defined3(parentIds)) {
      return;
    }
    assert(instanceIndex < instancesLength, "Parent index ".concat(instanceIndex, " exceeds the total number of instances: ").concat(instancesLength));
    assert(stack2.indexOf(instanceIndex) === -1, "Circular dependency detected in the batch table hierarchy.");
    stack2.push(instanceIndex);
    const parentCount = defined3(parentCounts) ? parentCounts[instanceIndex] : 1;
    const parentIndex = defined3(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;
    for (let i3 = 0; i3 < parentCount; ++i3) {
      const parentId = parentIds[parentIndex + i3];
      if (parentId !== instanceIndex) {
        validateInstance(hierarchy, parentId, stack2);
      }
    }
    stack2.pop(instanceIndex);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/classes/tile-3d-batch-table.js
  function defined4(x2) {
    return x2 !== void 0 && x2 !== null;
  }
  var clone3 = (x2, y2) => x2;
  var IGNORED_PROPERTY_FIELDS = {
    HIERARCHY: true,
    extensions: true,
    extras: true
  };
  var Tile3DBatchTableParser = class {
    constructor(json, binary, featureCount) {
      var _this$json;
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      _defineProperty(this, "json", void 0);
      _defineProperty(this, "binary", void 0);
      _defineProperty(this, "featureCount", void 0);
      _defineProperty(this, "_extensions", void 0);
      _defineProperty(this, "_properties", void 0);
      _defineProperty(this, "_binaryProperties", void 0);
      _defineProperty(this, "_hierarchy", void 0);
      assert2(featureCount >= 0);
      this.json = json || {};
      this.binary = binary;
      this.featureCount = featureCount;
      this._extensions = ((_this$json = this.json) === null || _this$json === void 0 ? void 0 : _this$json.extensions) || {};
      this._properties = {};
      for (const propertyName in this.json) {
        if (!IGNORED_PROPERTY_FIELDS[propertyName]) {
          this._properties[propertyName] = this.json[propertyName];
        }
      }
      this._binaryProperties = this._initializeBinaryProperties();
      if (options["3DTILES_batch_table_hierarchy"]) {
        this._hierarchy = initializeHierarchy(this, this.json, this.binary);
      }
    }
    getExtension(extensionName) {
      return this.json && this.json.extensions && this.json.extensions[extensionName];
    }
    memorySizeInBytes() {
      return 0;
    }
    isClass(batchId, className) {
      this._checkBatchId(batchId);
      assert2(typeof className === "string", className);
      if (this._hierarchy) {
        const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
          const classId = hierarchy.classIds[instanceIndex];
          const instanceClass = hierarchy.classes[classId];
          return instanceClass.name === className;
        });
        return defined4(result);
      }
      return false;
    }
    isExactClass(batchId, className) {
      assert2(typeof className === "string", className);
      return this.getExactClassName(batchId) === className;
    }
    getExactClassName(batchId) {
      this._checkBatchId(batchId);
      if (this._hierarchy) {
        const classId = this._hierarchy.classIds[batchId];
        const instanceClass = this._hierarchy.classes[classId];
        return instanceClass.name;
      }
      return void 0;
    }
    hasProperty(batchId, name10) {
      this._checkBatchId(batchId);
      assert2(typeof name10 === "string", name10);
      return defined4(this._properties[name10]) || this._hasPropertyInHierarchy(batchId, name10);
    }
    getPropertyNames(batchId, results) {
      this._checkBatchId(batchId);
      results = defined4(results) ? results : [];
      results.length = 0;
      const propertyNames = Object.keys(this._properties);
      results.push(...propertyNames);
      if (this._hierarchy) {
        this._getPropertyNamesInHierarchy(batchId, results);
      }
      return results;
    }
    getProperty(batchId, name10) {
      this._checkBatchId(batchId);
      assert2(typeof name10 === "string", name10);
      if (this._binaryProperties) {
        const binaryProperty = this._binaryProperties[name10];
        if (defined4(binaryProperty)) {
          return this._getBinaryProperty(binaryProperty, batchId);
        }
      }
      const propertyValues = this._properties[name10];
      if (defined4(propertyValues)) {
        return clone3(propertyValues[batchId], true);
      }
      if (this._hierarchy) {
        const hierarchyProperty = this._getHierarchyProperty(batchId, name10);
        if (defined4(hierarchyProperty)) {
          return hierarchyProperty;
        }
      }
      return void 0;
    }
    setProperty(batchId, name10, value) {
      const featureCount = this.featureCount;
      this._checkBatchId(batchId);
      assert2(typeof name10 === "string", name10);
      if (this._binaryProperties) {
        const binaryProperty = this._binaryProperties[name10];
        if (binaryProperty) {
          this._setBinaryProperty(binaryProperty, batchId, value);
          return;
        }
      }
      if (this._hierarchy) {
        if (this._setHierarchyProperty(this, batchId, name10, value)) {
          return;
        }
      }
      let propertyValues = this._properties[name10];
      if (!defined4(propertyValues)) {
        this._properties[name10] = new Array(featureCount);
        propertyValues = this._properties[name10];
      }
      propertyValues[batchId] = clone3(value, true);
    }
    _checkBatchId(batchId) {
      const valid = batchId >= 0 && batchId < this.featureCount;
      if (!valid) {
        throw new Error("batchId not in range [0, featureCount - 1].");
      }
    }
    _getBinaryProperty(binaryProperty, index) {
      return binaryProperty.unpack(binaryProperty.typedArray, index);
    }
    _setBinaryProperty(binaryProperty, index, value) {
      binaryProperty.pack(value, binaryProperty.typedArray, index);
    }
    _initializeBinaryProperties() {
      let binaryProperties = null;
      for (const name10 in this._properties) {
        const property = this._properties[name10];
        const binaryProperty = this._initializeBinaryProperty(name10, property);
        if (binaryProperty) {
          binaryProperties = binaryProperties || {};
          binaryProperties[name10] = binaryProperty;
        }
      }
      return binaryProperties;
    }
    _initializeBinaryProperty(name10, property) {
      if ("byteOffset" in property) {
        const tile3DAccessor = property;
        assert2(this.binary, "Property ".concat(name10, " requires a batch table binary."));
        assert2(tile3DAccessor.type, "Property ".concat(name10, " requires a type."));
        const accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
        return {
          typedArray: accessor.values,
          componentCount: accessor.size,
          unpack: accessor.unpacker,
          pack: accessor.packer
        };
      }
      return null;
    }
    _hasPropertyInHierarchy(batchId, name10) {
      if (!this._hierarchy) {
        return false;
      }
      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instances = hierarchy.classes[classId].instances;
        return defined4(instances[name10]);
      });
      return defined4(result);
    }
    _getPropertyNamesInHierarchy(batchId, results) {
      traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instances = hierarchy.classes[classId].instances;
        for (const name10 in instances) {
          if (instances.hasOwnProperty(name10)) {
            if (results.indexOf(name10) === -1) {
              results.push(name10);
            }
          }
        }
      });
    }
    _getHierarchyProperty(batchId, name10) {
      return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instanceClass = hierarchy.classes[classId];
        const indexInClass = hierarchy.classIndexes[instanceIndex];
        const propertyValues = instanceClass.instances[name10];
        if (defined4(propertyValues)) {
          if (defined4(propertyValues.typedArray)) {
            return this._getBinaryProperty(propertyValues, indexInClass);
          }
          return clone3(propertyValues[indexInClass], true);
        }
        return null;
      });
    }
    _setHierarchyProperty(batchTable, batchId, name10, value) {
      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instanceClass = hierarchy.classes[classId];
        const indexInClass = hierarchy.classIndexes[instanceIndex];
        const propertyValues = instanceClass.instances[name10];
        if (defined4(propertyValues)) {
          assert2(instanceIndex === batchId, 'Inherited property "'.concat(name10, '" is read-only.'));
          if (defined4(propertyValues.typedArray)) {
            this._setBinaryProperty(propertyValues, indexInClass, value);
          } else {
            propertyValues[indexInClass] = clone3(value, true);
          }
          return true;
        }
        return false;
      });
      return defined4(result);
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-header.js
  var SIZEOF_UINT32 = 4;
  function parse3DTileHeaderSync(tile, arrayBuffer2) {
    let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const view = new DataView(arrayBuffer2);
    tile.magic = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT32;
    tile.version = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT32;
    tile.byteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT32;
    if (tile.version !== 1) {
      throw new Error("3D Tile Version ".concat(tile.version, " not supported"));
    }
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-tables.js
  var SIZEOF_UINT322 = 4;
  var DEPRECATION_WARNING = "b3dm tile in legacy format.";
  function parse3DTileTablesHeaderSync(tile, arrayBuffer2, byteOffset) {
    const view = new DataView(arrayBuffer2);
    let batchLength;
    tile.header = tile.header || {};
    let featureTableJsonByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    let featureTableBinaryByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    let batchTableJsonByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    let batchTableBinaryByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    if (batchTableJsonByteLength >= 570425344) {
      byteOffset -= SIZEOF_UINT322 * 2;
      batchLength = featureTableJsonByteLength;
      batchTableJsonByteLength = featureTableBinaryByteLength;
      batchTableBinaryByteLength = 0;
      featureTableJsonByteLength = 0;
      featureTableBinaryByteLength = 0;
      console.warn(DEPRECATION_WARNING);
    } else if (batchTableBinaryByteLength >= 570425344) {
      byteOffset -= SIZEOF_UINT322;
      batchLength = batchTableJsonByteLength;
      batchTableJsonByteLength = featureTableJsonByteLength;
      batchTableBinaryByteLength = featureTableBinaryByteLength;
      featureTableJsonByteLength = 0;
      featureTableBinaryByteLength = 0;
      console.warn(DEPRECATION_WARNING);
    }
    tile.header.featureTableJsonByteLength = featureTableJsonByteLength;
    tile.header.featureTableBinaryByteLength = featureTableBinaryByteLength;
    tile.header.batchTableJsonByteLength = batchTableJsonByteLength;
    tile.header.batchTableBinaryByteLength = batchTableBinaryByteLength;
    tile.header.batchLength = batchLength;
    return byteOffset;
  }
  function parse3DTileTablesSync(tile, arrayBuffer2, byteOffset, options) {
    byteOffset = parse3DTileFeatureTable(tile, arrayBuffer2, byteOffset, options);
    byteOffset = parse3DTileBatchTable(tile, arrayBuffer2, byteOffset, options);
    return byteOffset;
  }
  function parse3DTileFeatureTable(tile, arrayBuffer2, byteOffset, options) {
    const {
      featureTableJsonByteLength,
      featureTableBinaryByteLength,
      batchLength
    } = tile.header;
    tile.featureTableJson = {
      BATCH_LENGTH: batchLength || 0
    };
    if (featureTableJsonByteLength > 0) {
      const featureTableString = getStringFromArrayBuffer(arrayBuffer2, byteOffset, featureTableJsonByteLength);
      tile.featureTableJson = JSON.parse(featureTableString);
    }
    byteOffset += featureTableJsonByteLength;
    tile.featureTableBinary = new Uint8Array(arrayBuffer2, byteOffset, featureTableBinaryByteLength);
    byteOffset += featureTableBinaryByteLength;
    return byteOffset;
  }
  function parse3DTileBatchTable(tile, arrayBuffer2, byteOffset, options) {
    const {
      batchTableJsonByteLength,
      batchTableBinaryByteLength
    } = tile.header;
    if (batchTableJsonByteLength > 0) {
      const batchTableString = getStringFromArrayBuffer(arrayBuffer2, byteOffset, batchTableJsonByteLength);
      tile.batchTableJson = JSON.parse(batchTableString);
      byteOffset += batchTableJsonByteLength;
      if (batchTableBinaryByteLength > 0) {
        tile.batchTableBinary = new Uint8Array(arrayBuffer2, byteOffset, batchTableBinaryByteLength);
        tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);
        byteOffset += batchTableBinaryByteLength;
      }
    }
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/normalize-3d-tile-colors.js
  function normalize3DTileColorAttribute(tile, colors, batchTable) {
    if (!colors && (!tile || !tile.batchIds || !batchTable)) {
      return null;
    }
    const {
      batchIds,
      isRGB565,
      pointCount
    } = tile;
    if (batchIds && batchTable) {
      const colorArray = new Uint8ClampedArray(pointCount * 3);
      for (let i3 = 0; i3 < pointCount; i3++) {
        const batchId = batchIds[i3];
        const dimensions = batchTable.getProperty(batchId, "dimensions");
        const color = dimensions.map((d) => d * 255);
        colorArray[i3 * 3] = color[0];
        colorArray[i3 * 3 + 1] = color[1];
        colorArray[i3 * 3 + 2] = color[2];
      }
      return {
        type: GL2.UNSIGNED_BYTE,
        value: colorArray,
        size: 3,
        normalized: true
      };
    }
    if (isRGB565) {
      const colorArray = new Uint8ClampedArray(pointCount * 3);
      for (let i3 = 0; i3 < pointCount; i3++) {
        const color = decodeRGB565(colors[i3]);
        colorArray[i3 * 3] = color[0];
        colorArray[i3 * 3 + 1] = color[1];
        colorArray[i3 * 3 + 2] = color[2];
      }
      return {
        type: GL2.UNSIGNED_BYTE,
        value: colorArray,
        size: 3,
        normalized: true
      };
    }
    if (colors && colors.length === pointCount * 3) {
      return {
        type: GL2.UNSIGNED_BYTE,
        value: colors,
        size: 3,
        normalized: true
      };
    }
    return {
      type: GL2.UNSIGNED_BYTE,
      value: colors,
      size: 4,
      normalized: true
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/normalize-3d-tile-normals.js
  var scratchNormal4 = new Vector3();
  function normalize3DTileNormalAttribute(tile, normals) {
    if (!normals) {
      return null;
    }
    if (tile.isOctEncoded16P) {
      const decodedArray = new Float32Array(tile.pointsLength * 3);
      for (let i3 = 0; i3 < tile.pointsLength; i3++) {
        octDecode(normals[i3 * 2], normals[i3 * 2 + 1], scratchNormal4);
        scratchNormal4.toArray(decodedArray, i3 * 3);
      }
      return {
        type: GL2.FLOAT,
        size: 2,
        value: decodedArray
      };
    }
    return {
      type: GL2.FLOAT,
      size: 2,
      value: normals
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/normalize-3d-tile-positions.js
  function normalize3DTilePositionAttribute(tile, positions, options) {
    if (!tile.isQuantized) {
      return positions;
    }
    if (options["3d-tiles"] && options["3d-tiles"].decodeQuantizedPositions) {
      tile.isQuantized = false;
      return decodeQuantizedPositions(tile, positions);
    }
    return {
      type: GL2.UNSIGNED_SHORT,
      value: positions,
      size: 3,
      normalized: true
    };
  }
  function decodeQuantizedPositions(tile, positions) {
    const scratchPosition5 = new Vector3();
    const decodedArray = new Float32Array(tile.pointCount * 3);
    for (let i3 = 0; i3 < tile.pointCount; i3++) {
      scratchPosition5.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]).scale(1 / tile.quantizedRange).multiply(tile.quantizedVolumeScale).add(tile.quantizedVolumeOffset).toArray(decodedArray, i3 * 3);
    }
    return decodedArray;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-point-cloud.js
  async function parsePointCloud3DTile(tile, arrayBuffer2, byteOffset, options, context) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer2, byteOffset);
    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer2, byteOffset);
    byteOffset = parse3DTileTablesSync(tile, arrayBuffer2, byteOffset, options);
    initializeTile(tile);
    const {
      featureTable,
      batchTable
    } = parsePointCloudTables(tile);
    await parseDraco(tile, featureTable, batchTable, options, context);
    parsePositions(tile, featureTable, options);
    parseColors(tile, featureTable, batchTable);
    parseNormals(tile, featureTable);
    return byteOffset;
  }
  function initializeTile(tile) {
    tile.attributes = {
      positions: null,
      colors: null,
      normals: null,
      batchIds: null
    };
    tile.isQuantized = false;
    tile.isTranslucent = false;
    tile.isRGB565 = false;
    tile.isOctEncoded16P = false;
  }
  function parsePointCloudTables(tile) {
    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
    const pointsLength = featureTable.getGlobalProperty("POINTS_LENGTH");
    if (!Number.isFinite(pointsLength)) {
      throw new Error("POINTS_LENGTH must be defined");
    }
    featureTable.featuresLength = pointsLength;
    tile.featuresLength = pointsLength;
    tile.pointsLength = pointsLength;
    tile.pointCount = pointsLength;
    tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
    const batchTable = parseBatchIds(tile, featureTable);
    return {
      featureTable,
      batchTable
    };
  }
  function parsePositions(tile, featureTable, options) {
    if (!tile.attributes.positions) {
      if (featureTable.hasProperty("POSITION")) {
        tile.attributes.positions = featureTable.getPropertyArray("POSITION", GL2.FLOAT, 3);
      } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
        const positions = featureTable.getPropertyArray("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3);
        tile.isQuantized = true;
        tile.quantizedRange = (1 << 16) - 1;
        tile.quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3);
        if (!tile.quantizedVolumeScale) {
          throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
        }
        tile.quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3);
        if (!tile.quantizedVolumeOffset) {
          throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
        }
        tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);
      }
    }
    if (!tile.attributes.positions) {
      throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
    }
  }
  function parseColors(tile, featureTable, batchTable) {
    if (!tile.attributes.colors) {
      let colors = null;
      if (featureTable.hasProperty("RGBA")) {
        colors = featureTable.getPropertyArray("RGBA", GL2.UNSIGNED_BYTE, 4);
        tile.isTranslucent = true;
      } else if (featureTable.hasProperty("RGB")) {
        colors = featureTable.getPropertyArray("RGB", GL2.UNSIGNED_BYTE, 3);
      } else if (featureTable.hasProperty("RGB565")) {
        colors = featureTable.getPropertyArray("RGB565", GL2.UNSIGNED_SHORT, 1);
        tile.isRGB565 = true;
      }
      tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);
    }
    if (featureTable.hasProperty("CONSTANT_RGBA")) {
      tile.constantRGBA = featureTable.getGlobalProperty("CONSTANT_RGBA", GL2.UNSIGNED_BYTE, 4);
    }
  }
  function parseNormals(tile, featureTable) {
    if (!tile.attributes.normals) {
      let normals = null;
      if (featureTable.hasProperty("NORMAL")) {
        normals = featureTable.getPropertyArray("NORMAL", GL2.FLOAT, 3);
      } else if (featureTable.hasProperty("NORMAL_OCT16P")) {
        normals = featureTable.getPropertyArray("NORMAL_OCT16P", GL2.UNSIGNED_BYTE, 2);
        tile.isOctEncoded16P = true;
      }
      tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);
    }
  }
  function parseBatchIds(tile, featureTable) {
    let batchTable = null;
    if (!tile.batchIds && featureTable.hasProperty("BATCH_ID")) {
      tile.batchIds = featureTable.getPropertyArray("BATCH_ID", GL2.UNSIGNED_SHORT, 1);
      if (tile.batchIds) {
        const batchFeatureLength = featureTable.getGlobalProperty("BATCH_LENGTH");
        if (!batchFeatureLength) {
          throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
        }
        const {
          batchTableJson,
          batchTableBinary
        } = tile;
        batchTable = new Tile3DBatchTableParser(batchTableJson, batchTableBinary, batchFeatureLength);
      }
    }
    return batchTable;
  }
  async function parseDraco(tile, featureTable, batchTable, options, context) {
    let dracoBuffer;
    let dracoFeatureTableProperties;
    let dracoBatchTableProperties;
    const batchTableDraco = tile.batchTableJson && tile.batchTableJson.extensions && tile.batchTableJson.extensions["3DTILES_draco_point_compression"];
    if (batchTableDraco) {
      dracoBatchTableProperties = batchTableDraco.properties;
    }
    const featureTableDraco = featureTable.getExtension("3DTILES_draco_point_compression");
    if (featureTableDraco) {
      dracoFeatureTableProperties = featureTableDraco.properties;
      const dracoByteOffset = featureTableDraco.byteOffset;
      const dracoByteLength = featureTableDraco.byteLength;
      if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {
        throw new Error("Draco properties, byteOffset, and byteLength must be defined");
      }
      dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);
      tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);
      tile.hasColors = Number.isFinite(dracoFeatureTableProperties.RGB) || Number.isFinite(dracoFeatureTableProperties.RGBA);
      tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);
      tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);
      tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);
    }
    if (!dracoBuffer) {
      return true;
    }
    const dracoData = {
      buffer: dracoBuffer,
      properties: {
        ...dracoFeatureTableProperties,
        ...dracoBatchTableProperties
      },
      featureTableProperties: dracoFeatureTableProperties,
      batchTableProperties: dracoBatchTableProperties,
      dequantizeInShader: false
    };
    return await loadDraco(tile, dracoData, options, context);
  }
  async function loadDraco(tile, dracoData, options, context) {
    const {
      parse: parse5
    } = context;
    const dracoOptions = {
      ...options,
      draco: {
        ...options.draco,
        extraAttributes: dracoData.batchTableProperties || {}
      }
    };
    delete dracoOptions["3d-tiles"];
    const data = await parse5(dracoData.buffer, DracoLoader2, dracoOptions);
    const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;
    const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;
    const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;
    const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;
    const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;
    const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;
    if (isQuantizedDraco) {
      const quantization = data.POSITION.data.quantization;
      const range = quantization.range;
      tile.quantizedVolumeScale = new Vector3(range, range, range);
      tile.quantizedVolumeOffset = new Vector3(quantization.minValues);
      tile.quantizedRange = (1 << quantization.quantizationBits) - 1;
      tile.isQuantizedDraco = true;
    }
    if (isOctEncodedDraco) {
      tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1;
      tile.isOctEncodedDraco = true;
    }
    const batchTableAttributes = {};
    if (dracoData.batchTableProperties) {
      for (const attributeName of Object.keys(dracoData.batchTableProperties)) {
        if (data.attributes[attributeName] && data.attributes[attributeName].value) {
          batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;
        }
      }
    }
    tile.attributes = {
      positions: decodedPositions,
      colors: normalize3DTileColorAttribute(tile, decodedColors, void 0),
      normals: decodedNormals,
      batchIds: decodedBatchIds,
      ...batchTableAttributes
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-gltf-view.js
  var GLTF_FORMAT = {
    URI: 0,
    EMBEDDED: 1
  };
  function parse3DTileGLTFViewSync(tile, arrayBuffer2, byteOffset, options) {
    tile.rotateYtoZ = true;
    const gltfByteLength = tile.byteOffset + tile.byteLength - byteOffset;
    if (gltfByteLength === 0) {
      throw new Error("glTF byte length must be greater than 0.");
    }
    tile.gltfUpAxis = options["3d-tiles"] && options["3d-tiles"].assetGltfUpAxis ? options["3d-tiles"].assetGltfUpAxis : "Y";
    tile.gltfArrayBuffer = sliceArrayBuffer(arrayBuffer2, byteOffset, gltfByteLength);
    tile.gltfByteOffset = 0;
    tile.gltfByteLength = gltfByteLength;
    if (byteOffset % 4 === 0) {
    } else {
      console.warn("".concat(tile.type, ": embedded glb is not aligned to a 4-byte boundary."));
    }
    return tile.byteOffset + tile.byteLength;
  }
  async function extractGLTF(tile, gltfFormat, options, context) {
    const tile3DOptions = options["3d-tiles"] || {};
    extractGLTFBufferOrURL(tile, gltfFormat, options);
    if (tile3DOptions.loadGLTF) {
      const {
        parse: parse5,
        fetch: fetch2
      } = context;
      if (tile.gltfUrl) {
        tile.gltfArrayBuffer = await fetch2(tile.gltfUrl, options);
        tile.gltfByteOffset = 0;
      }
      if (tile.gltfArrayBuffer) {
        tile.gltf = await parse5(tile.gltfArrayBuffer, GLTFLoader, options, context);
        tile.gpuMemoryUsageInBytes = getMemoryUsageGLTF(tile.gltf);
        delete tile.gltfArrayBuffer;
        delete tile.gltfByteOffset;
        delete tile.gltfByteLength;
      }
    }
  }
  function extractGLTFBufferOrURL(tile, gltfFormat, options) {
    switch (gltfFormat) {
      case GLTF_FORMAT.URI:
        const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);
        const textDecoder = new TextDecoder();
        const gltfUrl = textDecoder.decode(gltfUrlBytes);
        tile.gltfUrl = gltfUrl.replace(/[\s\0]+$/, "");
        delete tile.gltfArrayBuffer;
        delete tile.gltfByteOffset;
        delete tile.gltfByteLength;
        break;
      case GLTF_FORMAT.EMBEDDED:
        break;
      default:
        throw new Error("b3dm: Illegal glTF format field");
    }
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-batched-model.js
  async function parseBatchedModel3DTile(tile, arrayBuffer2, byteOffset, options, context) {
    var _tile$gltf;
    byteOffset = parseBatchedModel(tile, arrayBuffer2, byteOffset, options, context);
    await extractGLTF(tile, GLTF_FORMAT.EMBEDDED, options, context);
    const extensions = tile === null || tile === void 0 ? void 0 : (_tile$gltf = tile.gltf) === null || _tile$gltf === void 0 ? void 0 : _tile$gltf.extensions;
    if (extensions && extensions.CESIUM_RTC) {
      tile.rtcCenter = extensions.CESIUM_RTC.center;
    }
    return byteOffset;
  }
  function parseBatchedModel(tile, arrayBuffer2, byteOffset, options, context) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer2, byteOffset);
    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer2, byteOffset);
    byteOffset = parse3DTileTablesSync(tile, arrayBuffer2, byteOffset, options);
    byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer2, byteOffset, options);
    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
    tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-instanced-model.js
  async function parseInstancedModel3DTile(tile, arrayBuffer2, byteOffset, options, context) {
    byteOffset = parseInstancedModel(tile, arrayBuffer2, byteOffset, options, context);
    await extractGLTF(tile, tile.gltfFormat, options, context);
    return byteOffset;
  }
  function parseInstancedModel(tile, arrayBuffer2, byteOffset, options, context) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer2, byteOffset);
    if (tile.version !== 1) {
      throw new Error("Instanced 3D Model version ".concat(tile.version, " is not supported"));
    }
    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer2, byteOffset);
    const view = new DataView(arrayBuffer2);
    tile.gltfFormat = view.getUint32(byteOffset, true);
    byteOffset += 4;
    byteOffset = parse3DTileTablesSync(tile, arrayBuffer2, byteOffset, options);
    byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer2, byteOffset, options);
    if (tile.featureTableJsonByteLength === 0) {
      throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
    }
    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
    const instancesLength = featureTable.getGlobalProperty("INSTANCES_LENGTH");
    featureTable.featuresLength = instancesLength;
    if (!Number.isFinite(instancesLength)) {
      throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
    }
    tile.eastNorthUp = featureTable.getGlobalProperty("EAST_NORTH_UP");
    tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
    const batchTable = new Tile3DBatchTableParser(tile.batchTableJson, tile.batchTableBinary, instancesLength);
    extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);
    return byteOffset;
  }
  function extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {
    const collectionOptions = {
      instances: new Array(instancesLength),
      batchTable: tile._batchTable,
      cull: false,
      url: void 0,
      gltf: void 0,
      basePath: void 0,
      incrementallyLoadTextures: false,
      forwardAxis: [1, 0, 0]
    };
    const instances = collectionOptions.instances;
    const instancePosition = new Vector3();
    const instanceNormalRight = new Vector3();
    const instanceNormalUp = new Vector3();
    const instanceNormalForward = new Vector3();
    const instanceRotation = new Matrix3();
    const instanceQuaternion = new Quaternion();
    const instanceScale = new Vector3();
    const instanceTranslationRotationScale = {};
    const instanceTransform = new Matrix4();
    const scratch1 = [];
    const scratch2 = [];
    const scratchVector14 = new Vector3();
    const scratchVector26 = new Vector3();
    for (let i3 = 0; i3 < instancesLength; i3++) {
      let position;
      if (featureTable.hasProperty("POSITION")) {
        position = featureTable.getProperty("POSITION", GL2.FLOAT, 3, i3, instancePosition);
      } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
        position = featureTable.getProperty("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3, i3, instancePosition);
        const quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3, scratchVector14);
        if (!quantizedVolumeOffset) {
          throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
        }
        const quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3, scratchVector26);
        if (!quantizedVolumeScale) {
          throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
        }
        const MAX_UNSIGNED_SHORT = 65535;
        for (let j = 0; j < 3; j++) {
          position[j] = position[j] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j] + quantizedVolumeOffset[j];
        }
      }
      if (!position) {
        throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
      }
      instancePosition.copy(position);
      instanceTranslationRotationScale.translation = instancePosition;
      tile.normalUp = featureTable.getProperty("NORMAL_UP", GL2.FLOAT, 3, i3, scratch1);
      tile.normalRight = featureTable.getProperty("NORMAL_RIGHT", GL2.FLOAT, 3, i3, scratch2);
      const hasCustomOrientation = false;
      if (tile.normalUp) {
        if (!tile.normalRight) {
          throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
        }
        tile.hasCustomOrientation = true;
      } else {
        tile.octNormalUp = featureTable.getProperty("NORMAL_UP_OCT32P", GL2.UNSIGNED_SHORT, 2, scratch1);
        tile.octNormalRight = featureTable.getProperty("NORMAL_RIGHT_OCT32P", GL2.UNSIGNED_SHORT, 2, scratch2);
        if (tile.octNormalUp) {
          if (!tile.octNormalRight) {
            throw new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
          }
          throw new Error("i3dm: oct-encoded orientation not implemented");
        } else if (tile.eastNorthUp) {
          Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);
          instanceTransform.getRotationMatrix3(instanceRotation);
        } else {
          instanceRotation.identity();
        }
      }
      if (hasCustomOrientation) {
        instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();
        instanceRotation.setColumn(0, instanceNormalRight);
        instanceRotation.setColumn(1, instanceNormalUp);
        instanceRotation.setColumn(2, instanceNormalForward);
      }
      instanceQuaternion.fromMatrix3(instanceRotation);
      instanceTranslationRotationScale.rotation = instanceQuaternion;
      instanceScale.set(1, 1, 1);
      const scale8 = featureTable.getProperty("SCALE", GL2.FLOAT, 1, i3);
      if (Number.isFinite(scale8)) {
        instanceScale.multiplyByScalar(scale8);
      }
      const nonUniformScale = featureTable.getProperty("SCALE_NON_UNIFORM", GL2.FLOAT, 3, i3, scratch1);
      if (nonUniformScale) {
        instanceScale.scale(nonUniformScale);
      }
      instanceTranslationRotationScale.scale = instanceScale;
      let batchId = featureTable.getProperty("BATCH_ID", GL2.UNSIGNED_SHORT, 1, i3);
      if (batchId === void 0) {
        batchId = i3;
      }
      const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);
      instanceTransform.identity();
      instanceTransform.translate(instanceTranslationRotationScale.translation);
      instanceTransform.multiplyRight(rotationMatrix);
      instanceTransform.scale(instanceTranslationRotationScale.scale);
      const modelMatrix2 = instanceTransform.clone();
      instances[i3] = {
        modelMatrix: modelMatrix2,
        batchId
      };
    }
    tile.instances = instances;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-composite.js
  async function parseComposite3DTile(tile, arrayBuffer2, byteOffset, options, context, parse3DTile2) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer2, byteOffset);
    const view = new DataView(arrayBuffer2);
    tile.tilesLength = view.getUint32(byteOffset, true);
    byteOffset += 4;
    tile.tiles = [];
    while (tile.tiles.length < tile.tilesLength && tile.byteLength - byteOffset > 12) {
      const subtile = {};
      tile.tiles.push(subtile);
      byteOffset = await parse3DTile2(arrayBuffer2, byteOffset, options, context, subtile);
    }
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-gltf.js
  async function parseGltf3DTile(tile, arrayBuffer2, options, context) {
    tile.rotateYtoZ = true;
    tile.gltfUpAxis = options["3d-tiles"] && options["3d-tiles"].assetGltfUpAxis ? options["3d-tiles"].assetGltfUpAxis : "Y";
    const {
      parse: parse5
    } = context;
    tile.gltf = await parse5(arrayBuffer2, GLTFLoader, options, context);
    tile.gpuMemoryUsageInBytes = getMemoryUsageGLTF(tile.gltf);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile.js
  async function parse3DTile(arrayBuffer2) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let options = arguments.length > 2 ? arguments[2] : void 0;
    let context = arguments.length > 3 ? arguments[3] : void 0;
    let tile = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    tile.byteOffset = byteOffset;
    tile.type = getMagicString4(arrayBuffer2, byteOffset);
    switch (tile.type) {
      case TILE3D_TYPE.COMPOSITE:
        return await parseComposite3DTile(tile, arrayBuffer2, byteOffset, options, context, parse3DTile);
      case TILE3D_TYPE.BATCHED_3D_MODEL:
        return await parseBatchedModel3DTile(tile, arrayBuffer2, byteOffset, options, context);
      case TILE3D_TYPE.GLTF:
        return await parseGltf3DTile(tile, arrayBuffer2, options, context);
      case TILE3D_TYPE.INSTANCED_3D_MODEL:
        return await parseInstancedModel3DTile(tile, arrayBuffer2, byteOffset, options, context);
      case TILE3D_TYPE.POINT_CLOUD:
        return await parsePointCloud3DTile(tile, arrayBuffer2, byteOffset, options, context);
      default:
        throw new Error("3DTileLoader: unknown type ".concat(tile.type));
    }
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-tile-subtree.js
  var SUBTREE_FILE_MAGIC = 1952609651;
  var SUBTREE_FILE_VERSION = 1;
  async function parse3DTilesSubtree(data, options, context) {
    const magic = new Uint32Array(data.slice(0, 4));
    if (magic[0] !== SUBTREE_FILE_MAGIC) {
      throw new Error("Wrong subtree file magic number");
    }
    const version = new Uint32Array(data.slice(4, 8));
    if (version[0] !== SUBTREE_FILE_VERSION) {
      throw new Error("Wrong subtree file verson, must be 1");
    }
    const jsonByteLength = parseUint64Value(data.slice(8, 16));
    const stringAttribute = new Uint8Array(data, 24, jsonByteLength);
    const textDecoder = new TextDecoder("utf8");
    const string = textDecoder.decode(stringAttribute);
    const subtree = JSON.parse(string);
    const binaryByteLength = parseUint64Value(data.slice(16, 24));
    let internalBinaryBuffer = new ArrayBuffer(0);
    if (binaryByteLength) {
      internalBinaryBuffer = data.slice(24 + jsonByteLength);
    }
    if ("bufferView" in subtree.tileAvailability) {
      subtree.tileAvailability.explicitBitstream = await getExplicitBitstream(subtree, "tileAvailability", internalBinaryBuffer, context);
    }
    if ("bufferView" in subtree.contentAvailability) {
      subtree.contentAvailability.explicitBitstream = await getExplicitBitstream(subtree, "contentAvailability", internalBinaryBuffer, context);
    }
    if ("bufferView" in subtree.childSubtreeAvailability) {
      subtree.childSubtreeAvailability.explicitBitstream = await getExplicitBitstream(subtree, "childSubtreeAvailability", internalBinaryBuffer, context);
    }
    return subtree;
  }
  function resolveBufferUri(bitstreamRelativeUri, basePath) {
    const hasProtocol = basePath.startsWith("http");
    if (hasProtocol) {
      const resolvedUri2 = new URL(bitstreamRelativeUri, basePath);
      return decodeURI(resolvedUri2.toString());
    }
    const basePathWithProtocol = "http://".concat(basePath);
    const resolvedUri = new URL(bitstreamRelativeUri, basePathWithProtocol);
    return "/".concat(resolvedUri.host).concat(resolvedUri.pathname);
  }
  async function getExplicitBitstream(subtree, name10, internalBinaryBuffer, context) {
    const bufferViewIndex = subtree[name10].bufferView;
    const bufferView = subtree.bufferViews[bufferViewIndex];
    const buffer = subtree.buffers[bufferView.buffer];
    if (!(context !== null && context !== void 0 && context.url) || !context.fetch) {
      throw new Error("Url is not provided");
    }
    if (!context.fetch) {
      throw new Error("fetch is not provided");
    }
    if (buffer.uri) {
      const bufferUri = resolveBufferUri(buffer.uri, context === null || context === void 0 ? void 0 : context.url);
      const response = await context.fetch(bufferUri);
      const data = await response.arrayBuffer();
      return new Uint8Array(data, bufferView.byteOffset, bufferView.byteLength);
    }
    return new Uint8Array(internalBinaryBuffer, bufferView.byteOffset, bufferView.byteLength);
  }
  function parseUint64Value(buffer) {
    const dataView = new DataView(buffer);
    const left = dataView.getUint32(0, true);
    const right = dataView.getUint32(4, true);
    return left + 2 ** 32 * right;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/tile-3d-subtree-loader.js
  var Tile3DSubtreeLoader = {
    id: "3d-tiles-subtree",
    name: "3D Tiles Subtree",
    module: "3d-tiles",
    version: VERSION15,
    extensions: ["subtree"],
    mimeTypes: ["application/octet-stream"],
    tests: ["subtree"],
    parse: parse3DTilesSubtree,
    options: {}
  };

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/long/index.js
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      13,
      2,
      96,
      0,
      1,
      127,
      96,
      4,
      127,
      127,
      127,
      127,
      1,
      127,
      3,
      7,
      6,
      0,
      1,
      1,
      1,
      1,
      1,
      6,
      6,
      1,
      127,
      1,
      65,
      0,
      11,
      7,
      50,
      6,
      3,
      109,
      117,
      108,
      0,
      1,
      5,
      100,
      105,
      118,
      95,
      115,
      0,
      2,
      5,
      100,
      105,
      118,
      95,
      117,
      0,
      3,
      5,
      114,
      101,
      109,
      95,
      115,
      0,
      4,
      5,
      114,
      101,
      109,
      95,
      117,
      0,
      5,
      8,
      103,
      101,
      116,
      95,
      104,
      105,
      103,
      104,
      0,
      0,
      10,
      191,
      1,
      6,
      4,
      0,
      35,
      0,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      126,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      127,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      128,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      129,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      130,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11
    ])), {}).exports;
  } catch (e2) {
  }
  function Long3(low, high, unsigned) {
    this.low = low | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  }
  Long3.prototype.__isLong__;
  Object.defineProperty(Long3.prototype, "__isLong__", { value: true });
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  function ctz32(value) {
    var c = Math.clz32(value & -value);
    return value ? 31 - c : c;
  }
  Long3.isLong = isLong;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache4;
    if (unsigned) {
      value >>>= 0;
      if (cache4 = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, 0, true);
      if (cache4)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache4 = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache4)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  Long3.fromInt = fromInt;
  function fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO4;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  Long3.fromNumber = fromNumber;
  function fromBits(lowBits, highBits, unsigned) {
    return new Long3(lowBits, highBits, unsigned);
  }
  Long3.fromBits = fromBits;
  var pow_dbl = Math.pow;
  function fromString(str, unsigned, radix) {
    if (str.length === 0)
      throw Error("empty string");
    if (typeof unsigned === "number") {
      radix = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
      return unsigned ? UZERO : ZERO4;
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    var p2;
    if ((p2 = str.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p2 === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO4;
    for (var i3 = 0; i3 < str.length; i3 += 8) {
      var size = Math.min(8, str.length - i3), value = parseInt(str.substring(i3, i3 + size), radix);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  Long3.fromString = fromString;
  function fromValue(val2, unsigned) {
    if (typeof val2 === "number")
      return fromNumber(val2, unsigned);
    if (typeof val2 === "string")
      return fromString(val2, unsigned);
    return fromBits(val2.low, val2.high, typeof unsigned === "boolean" ? unsigned : val2.unsigned);
  }
  Long3.fromValue = fromValue;
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  var ZERO4 = fromInt(0);
  Long3.ZERO = ZERO4;
  var UZERO = fromInt(0, true);
  Long3.UZERO = UZERO;
  var ONE = fromInt(1);
  Long3.ONE = ONE;
  var UONE = fromInt(1, true);
  Long3.UONE = UONE;
  var NEG_ONE = fromInt(-1);
  Long3.NEG_ONE = NEG_ONE;
  var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long3.MAX_VALUE = MAX_VALUE;
  var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long3.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
  Long3.MIN_VALUE = MIN_VALUE;
  var LongPrototype = Long3.prototype;
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(MIN_VALUE)) {
        var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
      } else
        return "-" + this.neg().toString(radix);
    }
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
    var result = "";
    while (true) {
      var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero())
        return digits + result;
      else {
        while (digits.length < 6)
          digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  };
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val2 = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
      if ((val2 & 1 << bit) != 0)
        break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  LongPrototype.eqz = LongPrototype.isZero;
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  LongPrototype.equals = function equals4(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
      return false;
    return this.high === other.high && this.low === other.low;
  };
  LongPrototype.eq = LongPrototype.equals;
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(other);
  };
  LongPrototype.neq = LongPrototype.notEquals;
  LongPrototype.ne = LongPrototype.notEquals;
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(other) < 0;
  };
  LongPrototype.lt = LongPrototype.lessThan;
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(other) <= 0;
  };
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(other) > 0;
  };
  LongPrototype.gt = LongPrototype.greaterThan;
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(other) >= 0;
  };
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  LongPrototype.compare = function compare(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.eq(other))
      return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
      return -1;
    if (!thisNeg && otherNeg)
      return 1;
    if (!this.unsigned)
      return this.sub(other).isNegative() ? -1 : 1;
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  LongPrototype.comp = LongPrototype.compare;
  LongPrototype.negate = function negate3() {
    if (!this.unsigned && this.eq(MIN_VALUE))
      return MIN_VALUE;
    return this.not().add(ONE);
  };
  LongPrototype.neg = LongPrototype.negate;
  LongPrototype.add = function add6(addend) {
    if (!isLong(addend))
      addend = fromValue(addend);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 65535;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.subtract = function subtract3(subtrahend) {
    if (!isLong(subtrahend))
      subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  LongPrototype.sub = LongPrototype.subtract;
  LongPrototype.multiply = function multiply5(multiplier) {
    if (this.isZero())
      return this;
    if (!isLong(multiplier))
      multiplier = fromValue(multiplier);
    if (wasm) {
      var low = wasm["mul"](
        this.low,
        this.high,
        multiplier.low,
        multiplier.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (multiplier.isZero())
      return this.unsigned ? UZERO : ZERO4;
    if (this.eq(MIN_VALUE))
      return multiplier.isOdd() ? MIN_VALUE : ZERO4;
    if (multiplier.eq(MIN_VALUE))
      return this.isOdd() ? MIN_VALUE : ZERO4;
    if (this.isNegative()) {
      if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
      else
        return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
      return this.mul(multiplier.neg()).neg();
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
      return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 65535;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.mul = LongPrototype.multiply;
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (divisor.isZero())
      throw Error("division by zero");
    if (wasm) {
      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
        return this;
      }
      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? UZERO : ZERO4;
    var approx, rem, res;
    if (!this.unsigned) {
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
          return MIN_VALUE;
        else if (divisor.eq(MIN_VALUE))
          return ONE;
        else {
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(ZERO4)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE))
        return this.unsigned ? UZERO : ZERO4;
      if (this.isNegative()) {
        if (divisor.isNegative())
          return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
      res = ZERO4;
    } else {
      if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
      if (divisor.gt(this))
        return UZERO;
      if (divisor.gt(this.shru(1)))
        return UONE;
      res = UZERO;
    }
    rem = this;
    while (rem.gte(divisor)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
      var log23 = Math.ceil(Math.log(approx) / Math.LN2), delta = log23 <= 48 ? 1 : pow_dbl(2, log23 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }
      if (approxRes.isZero())
        approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  };
  LongPrototype.div = LongPrototype.divide;
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (wasm) {
      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
  };
  LongPrototype.mod = LongPrototype.modulo;
  LongPrototype.rem = LongPrototype.modulo;
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  };
  LongPrototype.clz = LongPrototype.countLeadingZeros;
  LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  };
  LongPrototype.ctz = LongPrototype.countTrailingZeros;
  LongPrototype.and = function and(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  LongPrototype.or = function or(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  LongPrototype.xor = function xor(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else
      return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  LongPrototype.shl = LongPrototype.shiftLeft;
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else
      return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  LongPrototype.shr = LongPrototype.shiftRight;
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
    if (numBits === 32)
      return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
  };
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b;
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits === 32)
      return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
    }
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
  };
  LongPrototype.rotl = LongPrototype.rotateLeft;
  LongPrototype.rotateRight = function rotateRight(numBits) {
    var b;
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits === 32)
      return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b = 32 - numBits;
      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
    }
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
  };
  LongPrototype.rotr = LongPrototype.rotateRight;
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
      return this;
    return fromBits(this.low, this.high, false);
  };
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
      return this;
    return fromBits(this.low, this.high, true);
  };
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high, lo = this.low;
    return [
      lo & 255,
      lo >>> 8 & 255,
      lo >>> 16 & 255,
      lo >>> 24,
      hi & 255,
      hi >>> 8 & 255,
      hi >>> 16 & 255,
      hi >>> 24
    ];
  };
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high, lo = this.low;
    return [
      hi >>> 24,
      hi >>> 16 & 255,
      hi >>> 8 & 255,
      hi & 255,
      lo >>> 24,
      lo >>> 16 & 255,
      lo >>> 8 & 255,
      lo & 255
    ];
  };
  Long3.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long3.fromBytesLE(bytes, unsigned) : Long3.fromBytesBE(bytes, unsigned);
  };
  Long3.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long3(
      bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
      bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
      unsigned
    );
  };
  Long3.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long3(
      bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
      bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
      unsigned
    );
  };
  var long_default = Long3;

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/utils/s2/s2-token-functions.js
  var MAXIMUM_TOKEN_LENGTH = 16;
  function getS2CellIdFromToken(token) {
    if (token === "X") {
      token = "";
    }
    const paddedToken = token.padEnd(MAXIMUM_TOKEN_LENGTH, "0");
    return long_default.fromString(paddedToken, true, 16);
  }
  function getS2TokenFromCellId(cellId) {
    if (cellId.isZero()) {
      return "X";
    }
    let numZeroDigits = cellId.countTrailingZeros();
    const remainder = numZeroDigits % 4;
    numZeroDigits = (numZeroDigits - remainder) / 4;
    const trailingZeroHexChars = numZeroDigits;
    numZeroDigits *= 4;
    const x2 = cellId.shiftRightUnsigned(numZeroDigits);
    const hexString = x2.toString(16).replace(/0+$/, "");
    const zeroString = Array(17 - trailingZeroHexChars - hexString.length).join("0");
    return zeroString + hexString;
  }
  function getS2ChildCellId(cellId, index) {
    const newLsb = lsb(cellId).shiftRightUnsigned(2);
    const childCellId = cellId.add(long_default.fromNumber(2 * index + 1 - 4).multiply(newLsb));
    return childCellId;
  }
  function lsb(cellId) {
    return cellId.and(cellId.not().add(1));
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/utils/s2/s2geometry/s2-geometry.js
  var FACE_BITS2 = 3;
  var MAX_LEVEL2 = 30;
  var POS_BITS2 = 2 * MAX_LEVEL2 + 1;
  var RADIAN_TO_DEGREE2 = 180 / Math.PI;
  function getS2CellFromQuadKey(hilbertQuadkey) {
    if (hilbertQuadkey.length === 0) {
      throw new Error("Invalid Hilbert quad key ".concat(hilbertQuadkey));
    }
    const parts = hilbertQuadkey.split("/");
    const face = parseInt(parts[0], 10);
    const position = parts[1];
    const maxLevel = position.length;
    let level = 0;
    const point = [0, 0];
    for (let i3 = maxLevel - 1; i3 >= 0; i3--) {
      level = maxLevel - i3;
      const bit = position[i3];
      let rx = 0;
      let ry = 0;
      if (bit === "1") {
        ry = 1;
      } else if (bit === "2") {
        rx = 1;
        ry = 1;
      } else if (bit === "3") {
        rx = 1;
      }
      const val2 = Math.pow(2, level - 1);
      rotateAndFlipQuadrant2(val2, point, rx, ry);
      point[0] += val2 * rx;
      point[1] += val2 * ry;
    }
    if (face % 2 === 1) {
      const t2 = point[0];
      point[0] = point[1];
      point[1] = t2;
    }
    return {
      face,
      ij: point,
      level
    };
  }
  function getS2QuadkeyFromCellId(cellId) {
    if (cellId.isZero()) {
      return "";
    }
    let bin = cellId.toString(2);
    while (bin.length < FACE_BITS2 + POS_BITS2) {
      bin = "0" + bin;
    }
    const lsbIndex = bin.lastIndexOf("1");
    const faceB = bin.substring(0, 3);
    const posB = bin.substring(3, lsbIndex);
    const levelN = posB.length / 2;
    const faceS = long_default.fromString(faceB, true, 2).toString(10);
    let posS = "";
    if (levelN !== 0) {
      posS = long_default.fromString(posB, true, 2).toString(4);
      while (posS.length < levelN) {
        posS = "0" + posS;
      }
    }
    return "".concat(faceS, "/").concat(posS);
  }
  function IJToST2(ij, level, offsets) {
    const maxSize = 1 << level;
    return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
  }
  function singleSTtoUV2(st) {
    if (st >= 0.5) {
      return 1 / 3 * (4 * st * st - 1);
    }
    return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
  }
  function STToUV2(st) {
    return [singleSTtoUV2(st[0]), singleSTtoUV2(st[1])];
  }
  function FaceUVToXYZ2(face, _ref) {
    let [u, v] = _ref;
    switch (face) {
      case 0:
        return [1, u, v];
      case 1:
        return [-u, 1, v];
      case 2:
        return [-u, -v, 1];
      case 3:
        return [-1, -v, -u];
      case 4:
        return [v, -1, -u];
      case 5:
        return [v, u, -1];
      default:
        throw new Error("Invalid face");
    }
  }
  function XYZToLngLat2(_ref2) {
    let [x2, y2, z] = _ref2;
    const lat = Math.atan2(z, Math.sqrt(x2 * x2 + y2 * y2));
    const lng = Math.atan2(y2, x2);
    return [lng * RADIAN_TO_DEGREE2, lat * RADIAN_TO_DEGREE2];
  }
  function rotateAndFlipQuadrant2(n2, point, rx, ry) {
    if (ry === 0) {
      if (rx === 1) {
        point[0] = n2 - 1 - point[0];
        point[1] = n2 - 1 - point[1];
      }
      const x2 = point[0];
      point[0] = point[1];
      point[1] = x2;
    }
  }
  function getS2LngLatFromS2Cell(s2Cell) {
    const st = IJToST2(s2Cell.ij, s2Cell.level, [0.5, 0.5]);
    const uv = STToUV2(st);
    const xyz = FaceUVToXYZ2(s2Cell.face, uv);
    return XYZToLngLat2(xyz);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/utils/s2/converters/s2-to-boundary.js
  var MAX_RESOLUTION2 = 100;
  function getS2BoundaryFlatFromS2Cell(s2cell) {
    const {
      face,
      ij,
      level
    } = s2cell;
    const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];
    const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION2 * Math.pow(2, -level)));
    const result = new Float64Array(4 * resolution * 2 + 2);
    let ptIndex = 0;
    let prevLng = 0;
    for (let i3 = 0; i3 < 4; i3++) {
      const offset = offsets[i3].slice(0);
      const nextOffset = offsets[i3 + 1];
      const stepI = (nextOffset[0] - offset[0]) / resolution;
      const stepJ = (nextOffset[1] - offset[1]) / resolution;
      for (let j = 0; j < resolution; j++) {
        offset[0] += stepI;
        offset[1] += stepJ;
        const st = IJToST2(ij, level, offset);
        const uv = STToUV2(st);
        const xyz = FaceUVToXYZ2(face, uv);
        const lngLat = XYZToLngLat2(xyz);
        if (Math.abs(lngLat[1]) > 89.999) {
          lngLat[0] = prevLng;
        }
        const deltaLng = lngLat[0] - prevLng;
        lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
        result[ptIndex++] = lngLat[0];
        result[ptIndex++] = lngLat[1];
        prevLng = lngLat[0];
      }
    }
    result[ptIndex++] = result[0];
    result[ptIndex++] = result[1];
    return result;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/utils/s2/s2geometry/s2-cell-utils.js
  function getS2Cell(tokenOrKey) {
    const key = getS2QuadKey2(tokenOrKey);
    const s2cell = getS2CellFromQuadKey(key);
    return s2cell;
  }
  function getS2QuadKey2(tokenOrKey) {
    if (tokenOrKey.indexOf("/") > 0) {
      return tokenOrKey;
    }
    const id = getS2CellIdFromToken(tokenOrKey);
    return getS2QuadkeyFromCellId(id);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/utils/s2/s2-geometry-functions.js
  function getS2LngLat(s2Token) {
    const s2cell = getS2Cell(s2Token);
    return getS2LngLatFromS2Cell(s2cell);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/utils/s2/converters/s2-to-region.js
  function getS2Region(s2cell) {
    let region;
    if (s2cell.face === 2 || s2cell.face === 5) {
      let corners = null;
      let len3 = 0;
      for (let i3 = 0; i3 < 4; i3++) {
        const key = "".concat(s2cell.face, "/").concat(i3);
        const cell = getS2Cell(key);
        const corns = getS2BoundaryFlatFromS2Cell(cell);
        if (typeof corners === "undefined" || corners === null)
          corners = new Float64Array(4 * corns.length);
        corners.set(corns, len3);
        len3 += corns.length;
      }
      region = get2DRegionFromS2Corners(corners);
    } else {
      const corners = getS2BoundaryFlatFromS2Cell(s2cell);
      region = get2DRegionFromS2Corners(corners);
    }
    return region;
  }
  function get2DRegionFromS2Corners(corners) {
    if (corners.length % 2 !== 0) {
      throw new Error("Invalid corners");
    }
    const longitudes = [];
    const latitudes = [];
    for (let i3 = 0; i3 < corners.length; i3 += 2) {
      longitudes.push(corners[i3]);
      latitudes.push(corners[i3 + 1]);
    }
    longitudes.sort((a2, b) => a2 - b);
    latitudes.sort((a2, b) => a2 - b);
    return {
      west: longitudes[0],
      east: longitudes[longitudes.length - 1],
      north: latitudes[latitudes.length - 1],
      south: latitudes[0]
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/utils/s2/converters/s2-to-obb-points.js
  function getS2OrientedBoundingBoxCornerPoints(tokenOrKey, heightInfo) {
    const min = (heightInfo === null || heightInfo === void 0 ? void 0 : heightInfo.minimumHeight) || 0;
    const max = (heightInfo === null || heightInfo === void 0 ? void 0 : heightInfo.maximumHeight) || 0;
    const s2cell = getS2Cell(tokenOrKey);
    const region = getS2Region(s2cell);
    const W = region.west;
    const S = region.south;
    const E = region.east;
    const N = region.north;
    const points = [];
    points.push(new Vector3(W, N, min));
    points.push(new Vector3(E, N, min));
    points.push(new Vector3(E, S, min));
    points.push(new Vector3(W, S, min));
    points.push(new Vector3(W, N, max));
    points.push(new Vector3(E, N, max));
    points.push(new Vector3(E, S, max));
    points.push(new Vector3(W, S, max));
    return points;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/utils/obb/s2-corners-to-obb.js
  function convertS2BoundingVolumetoOBB(s2VolumeInfo) {
    const token = s2VolumeInfo.token;
    const heightInfo = {
      minimumHeight: s2VolumeInfo.minimumHeight,
      maximumHeight: s2VolumeInfo.maximumHeight
    };
    const corners = getS2OrientedBoundingBoxCornerPoints(token, heightInfo);
    const center = getS2LngLat(token);
    const centerLng = center[0];
    const centerLat = center[1];
    const point = Ellipsoid.WGS84.cartographicToCartesian([centerLng, centerLat, heightInfo.maximumHeight]);
    const centerPointAdditional = new Vector3(point[0], point[1], point[2]);
    corners.push(centerPointAdditional);
    const obb = makeOrientedBoundingBoxFromPoints(corners);
    const box = [...obb.center, ...obb.halfAxes];
    return box;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/helpers/parse-3d-implicit-tiles.js
  var QUADTREE_DEVISION_COUNT = 4;
  var OCTREE_DEVISION_COUNT = 8;
  var SUBDIVISION_COUNT_MAP = {
    QUADTREE: QUADTREE_DEVISION_COUNT,
    OCTREE: OCTREE_DEVISION_COUNT
  };
  function getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme) {
    if (s2VolumeBox !== null && s2VolumeBox !== void 0 && s2VolumeBox.box) {
      const cellId = getS2CellIdFromToken(s2VolumeBox.s2VolumeInfo.token);
      const childCellId = getS2ChildCellId(cellId, index);
      const childToken = getS2TokenFromCellId(childCellId);
      const s2ChildVolumeInfo = {
        ...s2VolumeBox.s2VolumeInfo
      };
      s2ChildVolumeInfo.token = childToken;
      switch (subdivisionScheme) {
        case "OCTREE":
          const s2VolumeInfo = s2VolumeBox.s2VolumeInfo;
          const delta = s2VolumeInfo.maximumHeight - s2VolumeInfo.minimumHeight;
          const sizeZ = delta / 2;
          const midZ = s2VolumeInfo.minimumHeight + delta / 2;
          s2VolumeInfo.minimumHeight = midZ - sizeZ;
          s2VolumeInfo.maximumHeight = midZ + sizeZ;
          break;
        default:
          break;
      }
      const box = convertS2BoundingVolumetoOBB(s2ChildVolumeInfo);
      const childS2VolumeBox = {
        box,
        s2VolumeInfo: s2ChildVolumeInfo
      };
      return childS2VolumeBox;
    }
    return void 0;
  }
  async function parseImplicitTiles(params) {
    const {
      options,
      parentData = {
        mortonIndex: 0,
        x: 0,
        y: 0,
        z: 0
      },
      childIndex = 0,
      globalData = {
        level: 0,
        mortonIndex: 0,
        x: 0,
        y: 0,
        z: 0
      },
      s2VolumeBox
    } = params;
    let {
      subtree,
      level = 0
    } = params;
    const {
      subdivisionScheme,
      subtreeLevels,
      maximumLevel,
      contentUrlTemplate,
      subtreesUriTemplate,
      basePath
    } = options;
    const tile = {
      children: [],
      lodMetricValue: 0,
      contentUrl: ""
    };
    const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];
    const childX = childIndex & 1;
    const childY = childIndex >> 1 & 1;
    const childZ = childIndex >> 2 & 1;
    const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);
    let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);
    let tileAvailabilityIndex = levelOffset + childTileMortonIndex;
    let childTileX = concatBits(parentData.x, childX);
    let childTileY = concatBits(parentData.y, childY);
    let childTileZ = concatBits(parentData.z, childZ);
    let isChildSubtreeAvailable = false;
    if (level + 1 > subtreeLevels) {
      isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);
    }
    const x2 = concatBits(globalData.x, childTileX);
    const y2 = concatBits(globalData.y, childTileY);
    const z = concatBits(globalData.z, childTileZ);
    const lev = level + globalData.level;
    if (isChildSubtreeAvailable) {
      const subtreePath = "".concat(basePath, "/").concat(subtreesUriTemplate);
      const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x2, y2, z);
      const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader);
      subtree = childSubtree;
      globalData.mortonIndex = childTileMortonIndex;
      globalData.x = childTileX;
      globalData.y = childTileY;
      globalData.z = childTileZ;
      globalData.level = level;
      childTileMortonIndex = 0;
      tileAvailabilityIndex = 0;
      childTileX = 0;
      childTileY = 0;
      childTileZ = 0;
      level = 0;
    }
    const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);
    if (!isTileAvailable || level > maximumLevel) {
      return tile;
    }
    const isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);
    if (isContentAvailable) {
      tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x2, y2, z);
    }
    const childTileLevel = level + 1;
    const pData = {
      mortonIndex: childTileMortonIndex,
      x: childTileX,
      y: childTileY,
      z: childTileZ
    };
    for (let index = 0; index < childrenPerTile; index++) {
      const childS2VolumeBox = getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme);
      const childTileParsed = await parseImplicitTiles({
        subtree,
        options,
        parentData: pData,
        childIndex: index,
        level: childTileLevel,
        globalData,
        s2VolumeBox: childS2VolumeBox
      });
      if (childTileParsed.contentUrl || childTileParsed.children.length) {
        const globalLevel = lev + 1;
        const childCoordinates = {
          childTileX,
          childTileY,
          childTileZ
        };
        const formattedTile = formatTileData(childTileParsed, globalLevel, childCoordinates, options, s2VolumeBox);
        tile.children.push(formattedTile);
      }
    }
    return tile;
  }
  function getAvailabilityResult(availabilityData, index) {
    if ("constant" in availabilityData) {
      return Boolean(availabilityData.constant);
    }
    if (availabilityData.explicitBitstream) {
      return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);
    }
    return false;
  }
  function formatTileData(tile, level, childCoordinates, options, s2VolumeBox) {
    const {
      basePath,
      refine,
      getRefine: getRefine2,
      lodMetricType,
      getTileType: getTileType2,
      rootLodMetricValue,
      rootBoundingVolume
    } = options;
    const uri = tile.contentUrl && tile.contentUrl.replace("".concat(basePath, "/"), "");
    const lodMetricValue = rootLodMetricValue / 2 ** level;
    const boundingVolume = s2VolumeBox !== null && s2VolumeBox !== void 0 && s2VolumeBox.box ? {
      box: s2VolumeBox.box
    } : rootBoundingVolume;
    const boundingVolumeForChildTile = calculateBoundingVolumeForChildTile(level, boundingVolume, childCoordinates);
    return {
      children: tile.children,
      contentUrl: tile.contentUrl,
      content: {
        uri
      },
      id: tile.contentUrl,
      refine: getRefine2(refine),
      type: getTileType2(tile),
      lodMetricType,
      lodMetricValue,
      geometricError: lodMetricValue,
      transform: tile.transform,
      boundingVolume: boundingVolumeForChildTile
    };
  }
  function calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates) {
    if (rootBoundingVolume.region) {
      const {
        childTileX,
        childTileY,
        childTileZ
      } = childCoordinates;
      const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;
      const boundingVolumesCount = 2 ** level;
      const sizeX = (east - west) / boundingVolumesCount;
      const sizeY = (north - south) / boundingVolumesCount;
      const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;
      const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];
      const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];
      const [childMinimumHeight, childMaximumHeight] = [minimumHeight + sizeZ * childTileZ, minimumHeight + sizeZ * (childTileZ + 1)];
      return {
        region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]
      };
    }
    if (rootBoundingVolume.box) {
      return rootBoundingVolume;
    }
    throw new Error("Unsupported bounding volume type ".concat(rootBoundingVolume));
  }
  function concatBits(first, second) {
    return parseInt(first.toString(2) + second.toString(2), 2);
  }
  function replaceContentUrlTemplate(templateUrl, level, x2, y2, z) {
    const mapUrl = generateMapUrl({
      level,
      x: x2,
      y: y2,
      z
    });
    return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);
  }
  function generateMapUrl(items) {
    const mapUrl = {};
    for (const key in items) {
      mapUrl["{".concat(key, "}")] = items[key];
    }
    return mapUrl;
  }
  function getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {
    const byteIndex = Math.floor(availabilityIndex / 8);
    const bitIndex = availabilityIndex % 8;
    const bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;
    return bitValue === 1;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/lib/parsers/parse-3d-tile-header.js
  function getTileType(tile) {
    if (!tile.contentUrl) {
      return TILE_TYPE.EMPTY;
    }
    const contentUrl = tile.contentUrl.split("?")[0];
    const fileExtension = contentUrl.split(".").pop();
    switch (fileExtension) {
      case "pnts":
        return TILE_TYPE.POINTCLOUD;
      case "i3dm":
      case "b3dm":
      case "glb":
      case "gltf":
        return TILE_TYPE.SCENEGRAPH;
      default:
        return fileExtension;
    }
  }
  function getRefine(refine) {
    switch (refine) {
      case "REPLACE":
      case "replace":
        return TILE_REFINEMENT.REPLACE;
      case "ADD":
      case "add":
        return TILE_REFINEMENT.ADD;
      default:
        return refine;
    }
  }
  function resolveUri(uri, basePath) {
    const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;
    if (urlSchemeRegex.test(basePath)) {
      const url = new URL(uri, "".concat(basePath, "/"));
      return decodeURI(url.toString());
    } else if (uri.startsWith("/")) {
      return uri;
    }
    return "".concat(basePath, "/").concat(uri);
  }
  function normalizeTileData(tile, options) {
    if (!tile) {
      return null;
    }
    if (tile.content) {
      const contentUri = tile.content.uri || tile.content.url;
      tile.contentUrl = resolveUri(contentUri, options.basePath);
    }
    tile.id = tile.contentUrl;
    tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;
    tile.lodMetricValue = tile.geometricError;
    tile.transformMatrix = tile.transform;
    tile.type = getTileType(tile);
    tile.refine = getRefine(tile.refine);
    return tile;
  }
  async function normalizeTileHeaders(tileset, options) {
    const basePath = tileset.basePath;
    let root;
    const rootImplicitTilingExtension = getImplicitTilingExtensionData(tileset === null || tileset === void 0 ? void 0 : tileset.root);
    if (rootImplicitTilingExtension && tileset.root) {
      root = await normalizeImplicitTileHeaders(tileset.root, tileset, rootImplicitTilingExtension, options);
    } else {
      root = normalizeTileData(tileset.root, tileset);
    }
    const stack2 = [];
    stack2.push(root);
    while (stack2.length > 0) {
      const tile = stack2.pop() || {};
      const children = tile.children || [];
      for (let childHeader of children) {
        const childImplicitTilingExtension = getImplicitTilingExtensionData(childHeader);
        if (childImplicitTilingExtension) {
          childHeader = await normalizeImplicitTileHeaders(childHeader, tileset, childImplicitTilingExtension, options);
        } else {
          normalizeTileData(childHeader, {
            basePath
          });
        }
        stack2.push(childHeader);
      }
    }
    return root;
  }
  async function normalizeImplicitTileHeaders(tile, tileset, implicitTilingExtension, options) {
    var _tileset$root, _tile$boundingVolume$;
    const basePath = tileset.basePath;
    const {
      subdivisionScheme,
      maximumLevel,
      subtreeLevels,
      subtrees: {
        uri: subtreesUriTemplate
      }
    } = implicitTilingExtension;
    const replacedUrlTemplate = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);
    const subtreeUrl = resolveUri(replacedUrlTemplate, basePath);
    const subtree = await load(subtreeUrl, Tile3DSubtreeLoader, options);
    const contentUrlTemplate = resolveUri(tile.content.uri, basePath);
    const refine = tileset === null || tileset === void 0 ? void 0 : (_tileset$root = tileset.root) === null || _tileset$root === void 0 ? void 0 : _tileset$root.refine;
    const rootLodMetricValue = tile.geometricError;
    const s2VolumeInfo = (_tile$boundingVolume$ = tile.boundingVolume.extensions) === null || _tile$boundingVolume$ === void 0 ? void 0 : _tile$boundingVolume$["3DTILES_bounding_volume_S2"];
    if (s2VolumeInfo) {
      const box = convertS2BoundingVolumetoOBB(s2VolumeInfo);
      const s2VolumeBox = {
        box,
        s2VolumeInfo
      };
      tile.boundingVolume = s2VolumeBox;
    }
    const rootBoundingVolume = tile.boundingVolume;
    const implicitOptions = {
      contentUrlTemplate,
      subtreesUriTemplate,
      subdivisionScheme,
      subtreeLevels,
      maximumLevel,
      refine,
      basePath,
      lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
      rootLodMetricValue,
      rootBoundingVolume,
      getTileType,
      getRefine
    };
    return await normalizeImplicitTileData(tile, subtree, implicitOptions);
  }
  async function normalizeImplicitTileData(tile, rootSubtree, options) {
    if (!tile) {
      return null;
    }
    tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;
    tile.lodMetricValue = tile.geometricError;
    tile.transformMatrix = tile.transform;
    const {
      children,
      contentUrl
    } = await parseImplicitTiles({
      subtree: rootSubtree,
      options,
      s2VolumeBox: tile
    });
    if (contentUrl) {
      tile.contentUrl = contentUrl;
      tile.content = {
        uri: contentUrl.replace("".concat(options.basePath, "/"), "")
      };
    }
    tile.refine = getRefine(tile.refine);
    tile.type = getTileType(tile);
    tile.children = children;
    tile.id = tile.contentUrl;
    return tile;
  }
  function getImplicitTilingExtensionData(tile) {
    var _tile$extensions;
    return (tile === null || tile === void 0 ? void 0 : (_tile$extensions = tile.extensions) === null || _tile$extensions === void 0 ? void 0 : _tile$extensions["3DTILES_implicit_tiling"]) || (tile === null || tile === void 0 ? void 0 : tile.implicitTiling);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/esm/tiles-3d-loader.js
  var Tiles3DLoader = {
    id: "3d-tiles",
    name: "3D Tiles",
    module: "3d-tiles",
    version: VERSION15,
    extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
    mimeTypes: ["application/octet-stream"],
    tests: ["cmpt", "pnts", "b3dm", "i3dm"],
    parse: parse4,
    options: {
      "3d-tiles": {
        loadGLTF: true,
        decodeQuantizedPositions: false,
        isTileset: "auto",
        assetGltfUpAxis: null
      }
    }
  };
  function getBaseUri(tileset) {
    return path_exports.dirname(tileset.url);
  }
  async function parseTile(arrayBuffer2, options, context) {
    const tile = {
      content: {
        featureIds: null
      }
    };
    const byteOffset = 0;
    await parse3DTile(arrayBuffer2, byteOffset, options, context, tile.content);
    return tile.content;
  }
  async function parseTileset(data, options, context) {
    var _tilesetJson$root;
    const tilesetJson = JSON.parse(new TextDecoder().decode(data));
    tilesetJson.loader = options.loader || Tiles3DLoader;
    tilesetJson.url = context.url;
    tilesetJson.queryString = context.queryString;
    tilesetJson.basePath = getBaseUri(tilesetJson);
    tilesetJson.root = await normalizeTileHeaders(tilesetJson, options);
    tilesetJson.type = TILESET_TYPE.TILES3D;
    tilesetJson.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;
    tilesetJson.lodMetricValue = ((_tilesetJson$root = tilesetJson.root) === null || _tilesetJson$root === void 0 ? void 0 : _tilesetJson$root.lodMetricValue) || 0;
    return tilesetJson;
  }
  async function parse4(data, options, context) {
    const loaderOptions = options["3d-tiles"] || {};
    let isTileset;
    if (loaderOptions.isTileset === "auto") {
      isTileset = context.url && context.url.indexOf(".json") !== -1;
    } else {
      isTileset = loaderOptions.isTileset;
    }
    if (isTileset) {
      data = await parseTileset(data, options, context);
    } else {
      data = await parseTile(data, options, context);
    }
    return data;
  }

  // ../geo-layers/src/tile-3d-layer/tile-3d-layer.ts
  var SINGLE_DATA = [0];
  var defaultProps30 = {
    getPointColor: {
      type: "accessor",
      value: [0, 0, 0, 255]
    },
    pointSize: 1,
    data: "",
    loader: Tiles3DLoader,
    onTilesetLoad: {
      type: "function",
      value: (tileset3d) => {
      }
    },
    onTileLoad: {
      type: "function",
      value: (tileHeader) => {
      }
    },
    onTileUnload: {
      type: "function",
      value: (tileHeader) => {
      }
    },
    onTileError: {
      type: "function",
      value: (tile, message, url) => {
      }
    },
    _getMeshColor: {
      type: "function",
      value: (tileHeader) => [255, 255, 255]
    }
  };
  var Tile3DLayer = class extends CompositeLayer {
    initializeState() {
      if ("onTileLoadFail" in this.props) {
        log_default.removed("onTileLoadFail", "onTileError")();
      }
      this.state = {
        layerMap: {},
        tileset3d: null,
        activeViewports: {},
        lastUpdatedViewports: null
      };
    }
    get isLoaded() {
      const {
        tileset3d
      } = this.state;
      return tileset3d !== null && tileset3d.isLoaded();
    }
    shouldUpdateState({
      changeFlags
    }) {
      return changeFlags.somethingChanged;
    }
    updateState({
      props,
      oldProps,
      changeFlags
    }) {
      if (props.data && props.data !== oldProps.data) {
        this._loadTileset(props.data);
      }
      if (changeFlags.viewportChanged) {
        const {
          activeViewports
        } = this.state;
        const viewportsNumber = Object.keys(activeViewports).length;
        if (viewportsNumber) {
          this._updateTileset(activeViewports);
          this.state.lastUpdatedViewports = activeViewports;
          this.state.activeViewports = {};
        }
      }
      if (changeFlags.propsChanged) {
        const {
          layerMap
        } = this.state;
        for (const key in layerMap) {
          layerMap[key].needsUpdate = true;
        }
      }
    }
    activateViewport(viewport) {
      const {
        activeViewports,
        lastUpdatedViewports
      } = this.state;
      this.internalState.viewport = viewport;
      activeViewports[viewport.id] = viewport;
      const lastViewport = lastUpdatedViewports?.[viewport.id];
      if (!lastViewport || !viewport.equals(lastViewport)) {
        this.setChangeFlags({
          viewportChanged: true
        });
        this.setNeedsUpdate();
      }
    }
    getPickingInfo({
      info,
      sourceLayer
    }) {
      const sourceTile = sourceLayer && sourceLayer.props.tile;
      if (info.picked) {
        info.object = sourceTile;
      }
      info.sourceTile = sourceTile;
      return info;
    }
    filterSubLayer({
      layer,
      viewport
    }) {
      const {
        tile
      } = layer.props;
      const {
        id: viewportId
      } = viewport;
      return tile.selected && tile.viewportIds.includes(viewportId);
    }
    _updateAutoHighlight(info) {
      const sourceTile = info.sourceTile;
      const layerCache = this.state.layerMap[sourceTile?.id];
      if (layerCache && layerCache.layer) {
        layerCache.layer.updateAutoHighlight(info);
      }
    }
    async _loadTileset(tilesetUrl) {
      const {
        loadOptions = {}
      } = this.props;
      let loader = this.props.loader || this.props.loaders;
      if (Array.isArray(loader)) {
        loader = loader[0];
      }
      const options = {
        loadOptions: {
          ...loadOptions
        }
      };
      if (loader.preload) {
        const preloadOptions = await loader.preload(tilesetUrl, loadOptions);
        if (preloadOptions.headers) {
          options.loadOptions.fetch = {
            ...options.loadOptions.fetch,
            headers: preloadOptions.headers
          };
        }
        Object.assign(options, preloadOptions);
      }
      const tilesetJson = await load(tilesetUrl, loader, options.loadOptions);
      const tileset3d = new Tileset3D(tilesetJson, {
        onTileLoad: this._onTileLoad.bind(this),
        onTileUnload: this._onTileUnload.bind(this),
        onTileError: this.props.onTileError,
        ...options
      });
      this.setState({
        tileset3d,
        layerMap: {}
      });
      this._updateTileset(this.state.activeViewports);
      this.props.onTilesetLoad(tileset3d);
    }
    _onTileLoad(tileHeader) {
      const {
        lastUpdatedViewports
      } = this.state;
      this.props.onTileLoad(tileHeader);
      this._updateTileset(lastUpdatedViewports);
      this.setNeedsUpdate();
    }
    _onTileUnload(tileHeader) {
      delete this.state.layerMap[tileHeader.id];
      this.props.onTileUnload(tileHeader);
    }
    _updateTileset(viewports) {
      if (!viewports) {
        return;
      }
      const {
        tileset3d
      } = this.state;
      const {
        timeline
      } = this.context;
      const viewportsNumber = Object.keys(viewports).length;
      if (!timeline || !viewportsNumber || !tileset3d) {
        return;
      }
      tileset3d.selectTiles(Object.values(viewports)).then((frameNumber) => {
        const tilesetChanged = this.state.frameNumber !== frameNumber;
        if (tilesetChanged) {
          this.setState({
            frameNumber
          });
        }
      });
    }
    _getSubLayer(tileHeader, oldLayer) {
      if (!tileHeader.content) {
        return null;
      }
      switch (tileHeader.type) {
        case TILE_TYPE.POINTCLOUD:
          return this._makePointCloudLayer(tileHeader, oldLayer);
        case TILE_TYPE.SCENEGRAPH:
          return this._make3DModelLayer(tileHeader);
        case TILE_TYPE.MESH:
          return this._makeSimpleMeshLayer(tileHeader, oldLayer);
        default:
          throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);
      }
    }
    _makePointCloudLayer(tileHeader, oldLayer) {
      const {
        attributes,
        pointCount,
        constantRGBA,
        cartographicOrigin,
        modelMatrix: modelMatrix2
      } = tileHeader.content;
      const {
        positions,
        normals,
        colors
      } = attributes;
      if (!positions) {
        return null;
      }
      const data = oldLayer && oldLayer.props.data || {
        header: {
          vertexCount: pointCount
        },
        attributes: {
          POSITION: positions,
          NORMAL: normals,
          COLOR_0: colors
        }
      };
      const {
        pointSize,
        getPointColor
      } = this.props;
      const SubLayerClass = this.getSubLayerClass("pointcloud", PointCloudLayer);
      return new SubLayerClass({
        pointSize
      }, this.getSubLayerProps({
        id: "pointcloud"
      }), {
        id: `${this.id}-pointcloud-${tileHeader.id}`,
        tile: tileHeader,
        data,
        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
        coordinateOrigin: cartographicOrigin,
        modelMatrix: modelMatrix2,
        getColor: constantRGBA || getPointColor,
        _offset: 0
      });
    }
    _make3DModelLayer(tileHeader) {
      const {
        gltf,
        instances,
        cartographicOrigin,
        modelMatrix: modelMatrix2
      } = tileHeader.content;
      const SubLayerClass = this.getSubLayerClass("scenegraph", ScenegraphLayer);
      return new SubLayerClass({
        _lighting: "pbr"
      }, this.getSubLayerProps({
        id: "scenegraph"
      }), {
        id: `${this.id}-scenegraph-${tileHeader.id}`,
        tile: tileHeader,
        data: instances || SINGLE_DATA,
        scenegraph: gltf,
        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
        coordinateOrigin: cartographicOrigin,
        modelMatrix: modelMatrix2,
        getTransformMatrix: (instance) => instance.modelMatrix,
        getPosition: [0, 0, 0],
        _offset: 0
      });
    }
    _makeSimpleMeshLayer(tileHeader, oldLayer) {
      const content = tileHeader.content;
      const {
        attributes,
        indices,
        modelMatrix: modelMatrix2,
        cartographicOrigin,
        coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS,
        material,
        featureIds
      } = content;
      const {
        _getMeshColor
      } = this.props;
      const geometry = oldLayer && oldLayer.props.mesh || new Geometry({
        drawMode: esm_default2.TRIANGLES,
        attributes: getMeshGeometry(attributes),
        indices
      });
      const SubLayerClass = this.getSubLayerClass("mesh", MeshLayer);
      return new SubLayerClass(this.getSubLayerProps({
        id: "mesh"
      }), {
        id: `${this.id}-mesh-${tileHeader.id}`,
        tile: tileHeader,
        mesh: geometry,
        data: SINGLE_DATA,
        getColor: _getMeshColor(tileHeader),
        pbrMaterial: material,
        modelMatrix: modelMatrix2,
        coordinateOrigin: cartographicOrigin,
        coordinateSystem,
        featureIds,
        _offset: 0
      });
    }
    renderLayers() {
      const {
        tileset3d,
        layerMap
      } = this.state;
      if (!tileset3d) {
        return null;
      }
      return tileset3d.tiles.map((tile) => {
        const layerCache = layerMap[tile.id] = layerMap[tile.id] || {
          tile
        };
        let {
          layer
        } = layerCache;
        if (tile.selected) {
          if (!layer) {
            layer = this._getSubLayer(tile);
          } else if (layerCache.needsUpdate) {
            layer = this._getSubLayer(tile, layer);
            layerCache.needsUpdate = false;
          }
        }
        layerCache.layer = layer;
        return layer;
      }).filter(Boolean);
    }
  };
  __publicField(Tile3DLayer, "defaultProps", defaultProps30);
  __publicField(Tile3DLayer, "layerName", "Tile3DLayer");
  function getMeshGeometry(contentAttributes) {
    const attributes = {};
    attributes.positions = {
      ...contentAttributes.positions,
      value: new Float32Array(contentAttributes.positions.value)
    };
    if (contentAttributes.normals) {
      attributes.normals = contentAttributes.normals;
    }
    if (contentAttributes.texCoords) {
      attributes.texCoords = contentAttributes.texCoords;
    }
    if (contentAttributes.colors) {
      attributes.colors = contentAttributes.colors;
    }
    if (contentAttributes.uvRegions) {
      attributes.uvRegions = contentAttributes.uvRegions;
    }
    return attributes;
  }

  // ../../node_modules/@loaders.gl/terrain/dist/esm/lib/decode-quantized-mesh.js
  var QUANTIZED_MESH_HEADER = /* @__PURE__ */ new Map([["centerX", Float64Array.BYTES_PER_ELEMENT], ["centerY", Float64Array.BYTES_PER_ELEMENT], ["centerZ", Float64Array.BYTES_PER_ELEMENT], ["minHeight", Float32Array.BYTES_PER_ELEMENT], ["maxHeight", Float32Array.BYTES_PER_ELEMENT], ["boundingSphereCenterX", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereCenterY", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereCenterZ", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereRadius", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointX", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointY", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointZ", Float64Array.BYTES_PER_ELEMENT]]);
  function decodeZigZag(value) {
    return value >> 1 ^ -(value & 1);
  }
  function decodeHeader(dataView) {
    let position = 0;
    const header = {};
    for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {
      const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;
      header[key] = getter.call(dataView, position, true);
      position += bytesCount;
    }
    return {
      header,
      headerEndPosition: position
    };
  }
  function decodeVertexData(dataView, headerEndPosition) {
    let position = headerEndPosition;
    const elementsPerVertex = 3;
    const vertexCount = dataView.getUint32(position, true);
    const vertexData = new Uint16Array(vertexCount * elementsPerVertex);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;
    const elementArrayLength = vertexCount * bytesPerArrayElement;
    const uArrayStartPosition = position;
    const vArrayStartPosition = uArrayStartPosition + elementArrayLength;
    const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;
    let u = 0;
    let v = 0;
    let height = 0;
    for (let i3 = 0; i3 < vertexCount; i3++) {
      u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i3, true));
      v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i3, true));
      height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i3, true));
      vertexData[i3] = u;
      vertexData[i3 + vertexCount] = v;
      vertexData[i3 + vertexCount * 2] = height;
    }
    position += elementArrayLength * 3;
    return {
      vertexData,
      vertexDataEndPosition: position
    };
  }
  function decodeIndex(buffer, position, indicesCount, bytesPerIndex) {
    let encoded = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    let indices;
    if (bytesPerIndex === 2) {
      indices = new Uint16Array(buffer, position, indicesCount);
    } else {
      indices = new Uint32Array(buffer, position, indicesCount);
    }
    if (!encoded) {
      return indices;
    }
    let highest = 0;
    for (let i3 = 0; i3 < indices.length; ++i3) {
      const code = indices[i3];
      indices[i3] = highest - code;
      if (code === 0) {
        ++highest;
      }
    }
    return indices;
  }
  function decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {
    let position = vertexDataEndPosition;
    const elementsPerVertex = 3;
    const vertexCount = vertexData.length / elementsPerVertex;
    const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
    if (position % bytesPerIndex !== 0) {
      position += bytesPerIndex - position % bytesPerIndex;
    }
    const triangleCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const triangleIndicesCount = triangleCount * 3;
    const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);
    position += triangleIndicesCount * bytesPerIndex;
    return {
      triangleIndicesEndPosition: position,
      triangleIndices
    };
  }
  function decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {
    let position = triangleIndicesEndPosition;
    const elementsPerVertex = 3;
    const vertexCount = vertexData.length / elementsPerVertex;
    const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
    const westVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);
    position += westVertexCount * bytesPerIndex;
    const southVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);
    position += southVertexCount * bytesPerIndex;
    const eastVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);
    position += eastVertexCount * bytesPerIndex;
    const northVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);
    position += northVertexCount * bytesPerIndex;
    return {
      edgeIndicesEndPosition: position,
      westIndices,
      southIndices,
      eastIndices,
      northIndices
    };
  }
  function decodeVertexNormalsExtension(extensionDataView) {
    return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);
  }
  function decodeWaterMaskExtension(extensionDataView) {
    return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);
  }
  function decodeExtensions2(dataView, indicesEndPosition) {
    const extensions = {};
    if (dataView.byteLength <= indicesEndPosition) {
      return {
        extensions,
        extensionsEndPosition: indicesEndPosition
      };
    }
    let position = indicesEndPosition;
    while (position < dataView.byteLength) {
      const extensionId = dataView.getUint8(position, true);
      position += Uint8Array.BYTES_PER_ELEMENT;
      const extensionLength = dataView.getUint32(position, true);
      position += Uint32Array.BYTES_PER_ELEMENT;
      const extensionView = new DataView(dataView.buffer, position, extensionLength);
      switch (extensionId) {
        case 1: {
          extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);
          break;
        }
        case 2: {
          extensions.waterMask = decodeWaterMaskExtension(extensionView);
          break;
        }
        default: {
        }
      }
      position += extensionLength;
    }
    return {
      extensions,
      extensionsEndPosition: position
    };
  }
  var DECODING_STEPS = {
    header: 0,
    vertices: 1,
    triangleIndices: 2,
    edgeIndices: 3,
    extensions: 4
  };
  var DEFAULT_OPTIONS4 = {
    maxDecodingStep: DECODING_STEPS.extensions
  };
  function decode9(data, userOptions) {
    const options = Object.assign({}, DEFAULT_OPTIONS4, userOptions);
    const view = new DataView(data);
    const {
      header,
      headerEndPosition
    } = decodeHeader(view);
    if (options.maxDecodingStep < DECODING_STEPS.vertices) {
      return {
        header
      };
    }
    const {
      vertexData,
      vertexDataEndPosition
    } = decodeVertexData(view, headerEndPosition);
    if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {
      return {
        header,
        vertexData
      };
    }
    const {
      triangleIndices,
      triangleIndicesEndPosition
    } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);
    if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {
      return {
        header,
        vertexData,
        triangleIndices
      };
    }
    const {
      westIndices,
      southIndices,
      eastIndices,
      northIndices,
      edgeIndicesEndPosition
    } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);
    if (options.maxDecodingStep < DECODING_STEPS.extensions) {
      return {
        header,
        vertexData,
        triangleIndices,
        westIndices,
        northIndices,
        eastIndices,
        southIndices
      };
    }
    const {
      extensions
    } = decodeExtensions2(view, edgeIndicesEndPosition);
    return {
      header,
      vertexData,
      triangleIndices,
      westIndices,
      northIndices,
      eastIndices,
      southIndices,
      extensions
    };
  }

  // ../../node_modules/@loaders.gl/terrain/dist/esm/lib/helpers/skirt.js
  function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {
    const outsideEdges = outsideIndices ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value) : getOutsideEdgesFromTriangles(triangles);
    const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);
    const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);
    const newTriangles = new triangles.constructor(outsideEdges.length * 6);
    for (let i3 = 0; i3 < outsideEdges.length; i3++) {
      const edge = outsideEdges[i3];
      updateAttributesForNewEdge({
        edge,
        edgeIndex: i3,
        attributes,
        skirtHeight,
        newPosition,
        newTexcoord0,
        newTriangles
      });
    }
    attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);
    attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);
    const resultTriangles = triangles instanceof Array ? triangles.concat(newTriangles) : concatenateTypedArrays(triangles, newTriangles);
    return {
      attributes,
      triangles: resultTriangles
    };
  }
  function getOutsideEdgesFromTriangles(triangles) {
    const edges = [];
    for (let i3 = 0; i3 < triangles.length; i3 += 3) {
      edges.push([triangles[i3], triangles[i3 + 1]]);
      edges.push([triangles[i3 + 1], triangles[i3 + 2]]);
      edges.push([triangles[i3 + 2], triangles[i3]]);
    }
    edges.sort((a2, b) => Math.min(...a2) - Math.min(...b) || Math.max(...a2) - Math.max(...b));
    const outsideEdges = [];
    let index = 0;
    while (index < edges.length) {
      var _edges, _edges2;
      if (edges[index][0] === ((_edges = edges[index + 1]) === null || _edges === void 0 ? void 0 : _edges[1]) && edges[index][1] === ((_edges2 = edges[index + 1]) === null || _edges2 === void 0 ? void 0 : _edges2[0])) {
        index += 2;
      } else {
        outsideEdges.push(edges[index]);
        index++;
      }
    }
    return outsideEdges;
  }
  function getOutsideEdgesFromIndices(indices, position) {
    indices.westIndices.sort((a2, b) => position[3 * a2 + 1] - position[3 * b + 1]);
    indices.eastIndices.sort((a2, b) => position[3 * b + 1] - position[3 * a2 + 1]);
    indices.southIndices.sort((a2, b) => position[3 * b] - position[3 * a2]);
    indices.northIndices.sort((a2, b) => position[3 * a2] - position[3 * b]);
    const edges = [];
    for (const index in indices) {
      const indexGroup = indices[index];
      for (let i3 = 0; i3 < indexGroup.length - 1; i3++) {
        edges.push([indexGroup[i3], indexGroup[i3 + 1]]);
      }
    }
    return edges;
  }
  function updateAttributesForNewEdge(_ref) {
    let {
      edge,
      edgeIndex,
      attributes,
      skirtHeight,
      newPosition,
      newTexcoord0,
      newTriangles
    } = _ref;
    const positionsLength = attributes.POSITION.value.length;
    const vertex1Offset = edgeIndex * 2;
    const vertex2Offset = edgeIndex * 2 + 1;
    newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);
    newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight;
    newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);
    newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight;
    newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);
    newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);
    const triangle1Offset = edgeIndex * 2 * 3;
    newTriangles[triangle1Offset] = edge[0];
    newTriangles[triangle1Offset + 1] = positionsLength / 3 + vertex2Offset;
    newTriangles[triangle1Offset + 2] = edge[1];
    newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;
    newTriangles[triangle1Offset + 4] = edge[0];
    newTriangles[triangle1Offset + 5] = positionsLength / 3 + vertex1Offset;
  }

  // ../../node_modules/@loaders.gl/terrain/dist/esm/lib/parse-quantized-mesh.js
  function getMeshAttributes(vertexData, header, bounds) {
    const {
      minHeight,
      maxHeight
    } = header;
    const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];
    const xScale = maxX - minX;
    const yScale = maxY - minY;
    const zScale = maxHeight - minHeight;
    const nCoords = vertexData.length / 3;
    const positions = new Float32Array(nCoords * 3);
    const texCoords = new Float32Array(nCoords * 2);
    for (let i3 = 0; i3 < nCoords; i3++) {
      const x2 = vertexData[i3] / 32767;
      const y2 = vertexData[i3 + nCoords] / 32767;
      const z = vertexData[i3 + nCoords * 2] / 32767;
      positions[3 * i3 + 0] = x2 * xScale + minX;
      positions[3 * i3 + 1] = y2 * yScale + minY;
      positions[3 * i3 + 2] = z * zScale + minHeight;
      texCoords[2 * i3 + 0] = x2;
      texCoords[2 * i3 + 1] = y2;
    }
    return {
      POSITION: {
        value: positions,
        size: 3
      },
      TEXCOORD_0: {
        value: texCoords,
        size: 2
      }
    };
  }
  function getTileMesh(arrayBuffer2, options) {
    if (!arrayBuffer2) {
      return null;
    }
    const {
      bounds
    } = options;
    const {
      header,
      vertexData,
      triangleIndices: originalTriangleIndices,
      westIndices,
      northIndices,
      eastIndices,
      southIndices
    } = decode9(arrayBuffer2, DECODING_STEPS.triangleIndices);
    let triangleIndices = originalTriangleIndices;
    let attributes = getMeshAttributes(vertexData, header, bounds);
    const boundingBox = getMeshBoundingBox(attributes);
    if (options.skirtHeight) {
      const {
        attributes: newAttributes,
        triangles: newTriangles
      } = addSkirt(attributes, triangleIndices, options.skirtHeight, {
        westIndices,
        northIndices,
        eastIndices,
        southIndices
      });
      attributes = newAttributes;
      triangleIndices = newTriangles;
    }
    return {
      loaderData: {
        header: {}
      },
      header: {
        vertexCount: triangleIndices.length,
        boundingBox
      },
      mode: 4,
      indices: {
        value: triangleIndices,
        size: 1
      },
      attributes
    };
  }
  function loadQuantizedMesh(arrayBuffer2, options) {
    return getTileMesh(arrayBuffer2, options["quantized-mesh"]);
  }

  // ../../node_modules/@mapbox/martini/index.js
  var Martini = class {
    constructor(gridSize = 257) {
      this.gridSize = gridSize;
      const tileSize = gridSize - 1;
      if (tileSize & tileSize - 1)
        throw new Error(
          `Expected grid size to be 2^n+1, got ${gridSize}.`
        );
      this.numTriangles = tileSize * tileSize * 2 - 2;
      this.numParentTriangles = this.numTriangles - tileSize * tileSize;
      this.indices = new Uint32Array(this.gridSize * this.gridSize);
      this.coords = new Uint16Array(this.numTriangles * 4);
      for (let i3 = 0; i3 < this.numTriangles; i3++) {
        let id = i3 + 2;
        let ax = 0, ay = 0, bx = 0, by = 0, cx = 0, cy = 0;
        if (id & 1) {
          bx = by = cx = tileSize;
        } else {
          ax = ay = cy = tileSize;
        }
        while ((id >>= 1) > 1) {
          const mx = ax + bx >> 1;
          const my = ay + by >> 1;
          if (id & 1) {
            bx = ax;
            by = ay;
            ax = cx;
            ay = cy;
          } else {
            ax = bx;
            ay = by;
            bx = cx;
            by = cy;
          }
          cx = mx;
          cy = my;
        }
        const k = i3 * 4;
        this.coords[k + 0] = ax;
        this.coords[k + 1] = ay;
        this.coords[k + 2] = bx;
        this.coords[k + 3] = by;
      }
    }
    createTile(terrain) {
      return new Tile(terrain, this);
    }
  };
  var Tile = class {
    constructor(terrain, martini) {
      const size = martini.gridSize;
      if (terrain.length !== size * size)
        throw new Error(
          `Expected terrain data of length ${size * size} (${size} x ${size}), got ${terrain.length}.`
        );
      this.terrain = terrain;
      this.martini = martini;
      this.errors = new Float32Array(terrain.length);
      this.update();
    }
    update() {
      const { numTriangles, numParentTriangles, coords, gridSize: size } = this.martini;
      const { terrain, errors } = this;
      for (let i3 = numTriangles - 1; i3 >= 0; i3--) {
        const k = i3 * 4;
        const ax = coords[k + 0];
        const ay = coords[k + 1];
        const bx = coords[k + 2];
        const by = coords[k + 3];
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        const cx = mx + my - ay;
        const cy = my + ax - mx;
        const interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;
        const middleIndex = my * size + mx;
        const middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);
        errors[middleIndex] = Math.max(errors[middleIndex], middleError);
        if (i3 < numParentTriangles) {
          const leftChildIndex = (ay + cy >> 1) * size + (ax + cx >> 1);
          const rightChildIndex = (by + cy >> 1) * size + (bx + cx >> 1);
          errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);
        }
      }
    }
    getMesh(maxError = 0) {
      const { gridSize: size, indices } = this.martini;
      const { errors } = this;
      let numVertices = 0;
      let numTriangles = 0;
      const max = size - 1;
      indices.fill(0);
      function countElements(ax, ay, bx, by, cx, cy) {
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
          countElements(cx, cy, ax, ay, mx, my);
          countElements(bx, by, cx, cy, mx, my);
        } else {
          indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;
          indices[by * size + bx] = indices[by * size + bx] || ++numVertices;
          indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;
          numTriangles++;
        }
      }
      countElements(0, 0, max, max, max, 0);
      countElements(max, max, 0, 0, 0, max);
      const vertices = new Uint16Array(numVertices * 2);
      const triangles = new Uint32Array(numTriangles * 3);
      let triIndex = 0;
      function processTriangle(ax, ay, bx, by, cx, cy) {
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
          processTriangle(cx, cy, ax, ay, mx, my);
          processTriangle(bx, by, cx, cy, mx, my);
        } else {
          const a2 = indices[ay * size + ax] - 1;
          const b = indices[by * size + bx] - 1;
          const c = indices[cy * size + cx] - 1;
          vertices[2 * a2] = ax;
          vertices[2 * a2 + 1] = ay;
          vertices[2 * b] = bx;
          vertices[2 * b + 1] = by;
          vertices[2 * c] = cx;
          vertices[2 * c + 1] = cy;
          triangles[triIndex++] = a2;
          triangles[triIndex++] = b;
          triangles[triIndex++] = c;
        }
      }
      processTriangle(0, 0, max, max, max, 0);
      processTriangle(max, max, 0, 0, 0, max);
      return { vertices, triangles };
    }
  };

  // ../../node_modules/@loaders.gl/terrain/dist/esm/lib/delatin/index.js
  var Delatin = class {
    constructor(data, width) {
      let height = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : width;
      this.data = data;
      this.width = width;
      this.height = height;
      this.coords = [];
      this.triangles = [];
      this._halfedges = [];
      this._candidates = [];
      this._queueIndices = [];
      this._queue = [];
      this._errors = [];
      this._rms = [];
      this._pending = [];
      this._pendingLen = 0;
      this._rmsSum = 0;
      const x1 = width - 1;
      const y1 = height - 1;
      const p0 = this._addPoint(0, 0);
      const p1 = this._addPoint(x1, 0);
      const p2 = this._addPoint(0, y1);
      const p3 = this._addPoint(x1, y1);
      const t0 = this._addTriangle(p3, p0, p2, -1, -1, -1);
      this._addTriangle(p0, p3, p1, t0, -1, -1);
      this._flush();
    }
    run() {
      let maxError = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      while (this.getMaxError() > maxError) {
        this.refine();
      }
    }
    refine() {
      this._step();
      this._flush();
    }
    getMaxError() {
      return this._errors[0];
    }
    getRMSD() {
      return this._rmsSum > 0 ? Math.sqrt(this._rmsSum / (this.width * this.height)) : 0;
    }
    heightAt(x2, y2) {
      return this.data[this.width * y2 + x2];
    }
    _flush() {
      const coords = this.coords;
      for (let i3 = 0; i3 < this._pendingLen; i3++) {
        const t2 = this._pending[i3];
        const a2 = 2 * this.triangles[t2 * 3 + 0];
        const b = 2 * this.triangles[t2 * 3 + 1];
        const c = 2 * this.triangles[t2 * 3 + 2];
        this._findCandidate(coords[a2], coords[a2 + 1], coords[b], coords[b + 1], coords[c], coords[c + 1], t2);
      }
      this._pendingLen = 0;
    }
    _findCandidate(p0x, p0y, p1x, p1y, p2x, p2y, t2) {
      const minX = Math.min(p0x, p1x, p2x);
      const minY = Math.min(p0y, p1y, p2y);
      const maxX = Math.max(p0x, p1x, p2x);
      const maxY = Math.max(p0y, p1y, p2y);
      let w00 = orient(p1x, p1y, p2x, p2y, minX, minY);
      let w01 = orient(p2x, p2y, p0x, p0y, minX, minY);
      let w02 = orient(p0x, p0y, p1x, p1y, minX, minY);
      const a01 = p1y - p0y;
      const b01 = p0x - p1x;
      const a12 = p2y - p1y;
      const b12 = p1x - p2x;
      const a20 = p0y - p2y;
      const b20 = p2x - p0x;
      const a2 = orient(p0x, p0y, p1x, p1y, p2x, p2y);
      const z0 = this.heightAt(p0x, p0y) / a2;
      const z1 = this.heightAt(p1x, p1y) / a2;
      const z2 = this.heightAt(p2x, p2y) / a2;
      let maxError = 0;
      let mx = 0;
      let my = 0;
      let rms = 0;
      for (let y2 = minY; y2 <= maxY; y2++) {
        let dx = 0;
        if (w00 < 0 && a12 !== 0) {
          dx = Math.max(dx, Math.floor(-w00 / a12));
        }
        if (w01 < 0 && a20 !== 0) {
          dx = Math.max(dx, Math.floor(-w01 / a20));
        }
        if (w02 < 0 && a01 !== 0) {
          dx = Math.max(dx, Math.floor(-w02 / a01));
        }
        let w0 = w00 + a12 * dx;
        let w1 = w01 + a20 * dx;
        let w2 = w02 + a01 * dx;
        let wasInside = false;
        for (let x2 = minX + dx; x2 <= maxX; x2++) {
          if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
            wasInside = true;
            const z = z0 * w0 + z1 * w1 + z2 * w2;
            const dz = Math.abs(z - this.heightAt(x2, y2));
            rms += dz * dz;
            if (dz > maxError) {
              maxError = dz;
              mx = x2;
              my = y2;
            }
          } else if (wasInside) {
            break;
          }
          w0 += a12;
          w1 += a20;
          w2 += a01;
        }
        w00 += b12;
        w01 += b20;
        w02 += b01;
      }
      if (mx === p0x && my === p0y || mx === p1x && my === p1y || mx === p2x && my === p2y) {
        maxError = 0;
      }
      this._candidates[2 * t2] = mx;
      this._candidates[2 * t2 + 1] = my;
      this._rms[t2] = rms;
      this._queuePush(t2, maxError, rms);
    }
    _step() {
      const t2 = this._queuePop();
      const e0 = t2 * 3 + 0;
      const e1 = t2 * 3 + 1;
      const e2 = t2 * 3 + 2;
      const p0 = this.triangles[e0];
      const p1 = this.triangles[e1];
      const p2 = this.triangles[e2];
      const ax = this.coords[2 * p0];
      const ay = this.coords[2 * p0 + 1];
      const bx = this.coords[2 * p1];
      const by = this.coords[2 * p1 + 1];
      const cx = this.coords[2 * p2];
      const cy = this.coords[2 * p2 + 1];
      const px = this._candidates[2 * t2];
      const py = this._candidates[2 * t2 + 1];
      const pn = this._addPoint(px, py);
      if (orient(ax, ay, bx, by, px, py) === 0) {
        this._handleCollinear(pn, e0);
      } else if (orient(bx, by, cx, cy, px, py) === 0) {
        this._handleCollinear(pn, e1);
      } else if (orient(cx, cy, ax, ay, px, py) === 0) {
        this._handleCollinear(pn, e2);
      } else {
        const h0 = this._halfedges[e0];
        const h1 = this._halfedges[e1];
        const h2 = this._halfedges[e2];
        const t0 = this._addTriangle(p0, p1, pn, h0, -1, -1, e0);
        const t1 = this._addTriangle(p1, p2, pn, h1, -1, t0 + 1);
        const t22 = this._addTriangle(p2, p0, pn, h2, t0 + 2, t1 + 1);
        this._legalize(t0);
        this._legalize(t1);
        this._legalize(t22);
      }
    }
    _addPoint(x2, y2) {
      const i3 = this.coords.length >> 1;
      this.coords.push(x2, y2);
      return i3;
    }
    _addTriangle(a2, b, c, ab, bc, ca) {
      let e2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this.triangles.length;
      const t2 = e2 / 3;
      this.triangles[e2 + 0] = a2;
      this.triangles[e2 + 1] = b;
      this.triangles[e2 + 2] = c;
      this._halfedges[e2 + 0] = ab;
      this._halfedges[e2 + 1] = bc;
      this._halfedges[e2 + 2] = ca;
      if (ab >= 0) {
        this._halfedges[ab] = e2 + 0;
      }
      if (bc >= 0) {
        this._halfedges[bc] = e2 + 1;
      }
      if (ca >= 0) {
        this._halfedges[ca] = e2 + 2;
      }
      this._candidates[2 * t2 + 0] = 0;
      this._candidates[2 * t2 + 1] = 0;
      this._queueIndices[t2] = -1;
      this._rms[t2] = 0;
      this._pending[this._pendingLen++] = t2;
      return e2;
    }
    _legalize(a2) {
      const b = this._halfedges[a2];
      if (b < 0) {
        return;
      }
      const a0 = a2 - a2 % 3;
      const b0 = b - b % 3;
      const al = a0 + (a2 + 1) % 3;
      const ar = a0 + (a2 + 2) % 3;
      const bl = b0 + (b + 2) % 3;
      const br = b0 + (b + 1) % 3;
      const p0 = this.triangles[ar];
      const pr = this.triangles[a2];
      const pl = this.triangles[al];
      const p1 = this.triangles[bl];
      const coords = this.coords;
      if (!inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1])) {
        return;
      }
      const hal = this._halfedges[al];
      const har = this._halfedges[ar];
      const hbl = this._halfedges[bl];
      const hbr = this._halfedges[br];
      this._queueRemove(a0 / 3);
      this._queueRemove(b0 / 3);
      const t0 = this._addTriangle(p0, p1, pl, -1, hbl, hal, a0);
      const t1 = this._addTriangle(p1, p0, pr, t0, har, hbr, b0);
      this._legalize(t0 + 1);
      this._legalize(t1 + 2);
    }
    _handleCollinear(pn, a2) {
      const a0 = a2 - a2 % 3;
      const al = a0 + (a2 + 1) % 3;
      const ar = a0 + (a2 + 2) % 3;
      const p0 = this.triangles[ar];
      const pr = this.triangles[a2];
      const pl = this.triangles[al];
      const hal = this._halfedges[al];
      const har = this._halfedges[ar];
      const b = this._halfedges[a2];
      if (b < 0) {
        const t02 = this._addTriangle(pn, p0, pr, -1, har, -1, a0);
        const t12 = this._addTriangle(p0, pn, pl, t02, -1, hal);
        this._legalize(t02 + 1);
        this._legalize(t12 + 2);
        return;
      }
      const b0 = b - b % 3;
      const bl = b0 + (b + 2) % 3;
      const br = b0 + (b + 1) % 3;
      const p1 = this.triangles[bl];
      const hbl = this._halfedges[bl];
      const hbr = this._halfedges[br];
      this._queueRemove(b0 / 3);
      const t0 = this._addTriangle(p0, pr, pn, har, -1, -1, a0);
      const t1 = this._addTriangle(pr, p1, pn, hbr, -1, t0 + 1, b0);
      const t2 = this._addTriangle(p1, pl, pn, hbl, -1, t1 + 1);
      const t3 = this._addTriangle(pl, p0, pn, hal, t0 + 2, t2 + 1);
      this._legalize(t0);
      this._legalize(t1);
      this._legalize(t2);
      this._legalize(t3);
    }
    _queuePush(t2, error2, rms) {
      const i3 = this._queue.length;
      this._queueIndices[t2] = i3;
      this._queue.push(t2);
      this._errors.push(error2);
      this._rmsSum += rms;
      this._queueUp(i3);
    }
    _queuePop() {
      const n2 = this._queue.length - 1;
      this._queueSwap(0, n2);
      this._queueDown(0, n2);
      return this._queuePopBack();
    }
    _queuePopBack() {
      const t2 = this._queue.pop();
      this._errors.pop();
      this._rmsSum -= this._rms[t2];
      this._queueIndices[t2] = -1;
      return t2;
    }
    _queueRemove(t2) {
      const i3 = this._queueIndices[t2];
      if (i3 < 0) {
        const it = this._pending.indexOf(t2);
        if (it !== -1) {
          this._pending[it] = this._pending[--this._pendingLen];
        } else {
          throw new Error("Broken triangulation (something went wrong).");
        }
        return;
      }
      const n2 = this._queue.length - 1;
      if (n2 !== i3) {
        this._queueSwap(i3, n2);
        if (!this._queueDown(i3, n2)) {
          this._queueUp(i3);
        }
      }
      this._queuePopBack();
    }
    _queueLess(i3, j) {
      return this._errors[i3] > this._errors[j];
    }
    _queueSwap(i3, j) {
      const pi = this._queue[i3];
      const pj = this._queue[j];
      this._queue[i3] = pj;
      this._queue[j] = pi;
      this._queueIndices[pi] = j;
      this._queueIndices[pj] = i3;
      const e2 = this._errors[i3];
      this._errors[i3] = this._errors[j];
      this._errors[j] = e2;
    }
    _queueUp(j0) {
      let j = j0;
      while (true) {
        const i3 = j - 1 >> 1;
        if (i3 === j || !this._queueLess(j, i3)) {
          break;
        }
        this._queueSwap(i3, j);
        j = i3;
      }
    }
    _queueDown(i0, n2) {
      let i3 = i0;
      while (true) {
        const j1 = 2 * i3 + 1;
        if (j1 >= n2 || j1 < 0) {
          break;
        }
        const j2 = j1 + 1;
        let j = j1;
        if (j2 < n2 && this._queueLess(j2, j1)) {
          j = j2;
        }
        if (!this._queueLess(j, i3)) {
          break;
        }
        this._queueSwap(i3, j);
        i3 = j;
      }
      return i3 > i0;
    }
  };
  function orient(ax, ay, bx, by, cx, cy) {
    return (bx - cx) * (ay - cy) - (by - cy) * (ax - cx);
  }
  function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;
    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;
    return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
  }

  // ../../node_modules/@loaders.gl/terrain/dist/esm/lib/parse-terrain.js
  function getTerrain(imageData, width, height, elevationDecoder, tesselator) {
    const {
      rScaler,
      bScaler,
      gScaler,
      offset
    } = elevationDecoder;
    const terrain = new Float32Array((width + 1) * (height + 1));
    for (let i3 = 0, y2 = 0; y2 < height; y2++) {
      for (let x2 = 0; x2 < width; x2++, i3++) {
        const k = i3 * 4;
        const r2 = imageData[k + 0];
        const g = imageData[k + 1];
        const b = imageData[k + 2];
        terrain[i3 + y2] = r2 * rScaler + g * gScaler + b * bScaler + offset;
      }
    }
    if (tesselator === "martini") {
      for (let i3 = (width + 1) * width, x2 = 0; x2 < width; x2++, i3++) {
        terrain[i3] = terrain[i3 - width - 1];
      }
      for (let i3 = height, y2 = 0; y2 < height + 1; y2++, i3 += height + 1) {
        terrain[i3] = terrain[i3 - 1];
      }
    }
    return terrain;
  }
  function getMeshAttributes2(vertices, terrain, width, height, bounds) {
    const gridSize = width + 1;
    const numOfVerticies = vertices.length / 2;
    const positions = new Float32Array(numOfVerticies * 3);
    const texCoords = new Float32Array(numOfVerticies * 2);
    const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];
    const xScale = (maxX - minX) / width;
    const yScale = (maxY - minY) / height;
    for (let i3 = 0; i3 < numOfVerticies; i3++) {
      const x2 = vertices[i3 * 2];
      const y2 = vertices[i3 * 2 + 1];
      const pixelIdx = y2 * gridSize + x2;
      positions[3 * i3 + 0] = x2 * xScale + minX;
      positions[3 * i3 + 1] = -y2 * yScale + maxY;
      positions[3 * i3 + 2] = terrain[pixelIdx];
      texCoords[2 * i3 + 0] = x2 / width;
      texCoords[2 * i3 + 1] = y2 / height;
    }
    return {
      POSITION: {
        value: positions,
        size: 3
      },
      TEXCOORD_0: {
        value: texCoords,
        size: 2
      }
    };
  }
  function getMesh(terrainImage, terrainOptions) {
    if (terrainImage === null) {
      return null;
    }
    const {
      meshMaxError,
      bounds,
      elevationDecoder
    } = terrainOptions;
    const {
      data,
      width,
      height
    } = terrainImage;
    let terrain;
    let mesh;
    switch (terrainOptions.tesselator) {
      case "martini":
        terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
        mesh = getMartiniTileMesh(meshMaxError, width, terrain);
        break;
      case "delatin":
        terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
        break;
      default:
        if (width === height && !(height & width - 1)) {
          terrain = getTerrain(data, width, height, elevationDecoder, "martini");
          mesh = getMartiniTileMesh(meshMaxError, width, terrain);
        } else {
          terrain = getTerrain(data, width, height, elevationDecoder, "delatin");
          mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
        }
        break;
    }
    const {
      vertices
    } = mesh;
    let {
      triangles
    } = mesh;
    let attributes = getMeshAttributes2(vertices, terrain, width, height, bounds);
    const boundingBox = getMeshBoundingBox(attributes);
    if (terrainOptions.skirtHeight) {
      const {
        attributes: newAttributes,
        triangles: newTriangles
      } = addSkirt(attributes, triangles, terrainOptions.skirtHeight);
      attributes = newAttributes;
      triangles = newTriangles;
    }
    return {
      loaderData: {
        header: {}
      },
      header: {
        vertexCount: triangles.length,
        boundingBox
      },
      mode: 4,
      indices: {
        value: Uint32Array.from(triangles),
        size: 1
      },
      attributes
    };
  }
  function getMartiniTileMesh(meshMaxError, width, terrain) {
    const gridSize = width + 1;
    const martini = new Martini(gridSize);
    const tile = martini.createTile(terrain);
    const {
      vertices,
      triangles
    } = tile.getMesh(meshMaxError);
    return {
      vertices,
      triangles
    };
  }
  function getDelatinTileMesh(meshMaxError, width, height, terrain) {
    const tin = new Delatin(terrain, width + 1, height + 1);
    tin.run(meshMaxError);
    const {
      coords,
      triangles
    } = tin;
    const vertices = coords;
    return {
      vertices,
      triangles
    };
  }
  async function loadTerrain(arrayBuffer2, options, context) {
    const loadImageOptions = {
      ...options,
      mimeType: "application/x.image",
      image: {
        ...options.image,
        type: "data"
      }
    };
    const image = await context.parse(arrayBuffer2, loadImageOptions);
    return getMesh(image, options.terrain);
  }

  // ../../node_modules/@loaders.gl/terrain/dist/esm/lib/utils/version.js
  var VERSION16 = true ? "3.4.2" : "latest";

  // ../../node_modules/@loaders.gl/terrain/dist/esm/terrain-loader.js
  var TerrainLoader = {
    name: "Terrain",
    id: "terrain",
    module: "terrain",
    version: VERSION16,
    worker: true,
    extensions: ["png", "pngraw", "jpg", "jpeg", "gif", "webp", "bmp"],
    mimeTypes: ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp"],
    options: {
      terrain: {
        tesselator: "auto",
        bounds: null,
        meshMaxError: 10,
        elevationDecoder: {
          rScaler: 1,
          gScaler: 0,
          bScaler: 0,
          offset: 0
        },
        skirtHeight: null
      }
    }
  };

  // ../../node_modules/@loaders.gl/terrain/dist/esm/quantized-mesh-loader.js
  var QuantizedMeshLoader = {
    name: "Quantized Mesh",
    id: "quantized-mesh",
    module: "terrain",
    version: VERSION16,
    worker: true,
    extensions: ["terrain"],
    mimeTypes: ["application/vnd.quantized-mesh"],
    options: {
      "quantized-mesh": {
        bounds: [0, 0, 1, 1],
        skirtHeight: null
      }
    }
  };

  // ../../node_modules/@loaders.gl/terrain/dist/esm/index.js
  var TerrainLoader2 = {
    ...TerrainLoader,
    parse: loadTerrain
  };
  var QuantizedMeshLoader2 = {
    ...QuantizedMeshLoader,
    parseSync: loadQuantizedMesh,
    parse: async (arrayBuffer2, options) => loadQuantizedMesh(arrayBuffer2, options)
  };

  // ../geo-layers/src/terrain-layer/terrain-layer.ts
  var DUMMY_DATA = [1];
  var defaultProps31 = {
    ...TileLayer.defaultProps,
    elevationData: urlType,
    texture: {
      ...urlType,
      optional: true
    },
    meshMaxError: {
      type: "number",
      value: 4
    },
    bounds: {
      type: "array",
      value: null,
      optional: true,
      compare: true
    },
    color: {
      type: "color",
      value: [255, 255, 255]
    },
    elevationDecoder: {
      type: "object",
      value: {
        rScaler: 1,
        gScaler: 0,
        bScaler: 0,
        offset: 0
      }
    },
    workerUrl: "",
    wireframe: false,
    material: true,
    loaders: [TerrainLoader]
  };
  function urlTemplateToUpdateTrigger(template) {
    if (Array.isArray(template)) {
      return template.join(";");
    }
    return template || "";
  }
  var TerrainLayer = class extends CompositeLayer {
    updateState({
      props,
      oldProps
    }) {
      const elevationDataChanged = props.elevationData !== oldProps.elevationData;
      if (elevationDataChanged) {
        const {
          elevationData
        } = props;
        const isTiled = elevationData && (Array.isArray(elevationData) || elevationData.includes("{x}") && elevationData.includes("{y}"));
        this.setState({
          isTiled
        });
      }
      const shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;
      if (!this.state.isTiled && shouldReload) {
        const terrain = this.loadTerrain(props);
        this.setState({
          terrain
        });
      }
      if (props.workerUrl) {
        log_default.removed("workerUrl", "loadOptions.terrain.workerUrl")();
      }
    }
    loadTerrain({
      elevationData,
      bounds,
      elevationDecoder,
      meshMaxError,
      signal
    }) {
      if (!elevationData) {
        return null;
      }
      let loadOptions = this.getLoadOptions();
      loadOptions = {
        ...loadOptions,
        terrain: {
          skirtHeight: this.state.isTiled ? meshMaxError * 2 : 0,
          ...loadOptions?.terrain,
          bounds,
          meshMaxError,
          elevationDecoder
        }
      };
      const {
        fetch: fetch2
      } = this.props;
      return fetch2(elevationData, {
        propName: "elevationData",
        layer: this,
        loadOptions,
        signal
      });
    }
    getTiledTerrainData(tile) {
      const {
        elevationData,
        fetch: fetch2,
        texture,
        elevationDecoder,
        meshMaxError
      } = this.props;
      const {
        viewport
      } = this.context;
      const dataUrl = getURLFromTemplate(elevationData, tile);
      const textureUrl = texture && getURLFromTemplate(texture, tile);
      const {
        signal
      } = tile;
      let bottomLeft = [0, 0];
      let topRight = [0, 0];
      if (viewport.isGeospatial) {
        const bbox = tile.bbox;
        bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);
        topRight = viewport.projectFlat([bbox.east, bbox.north]);
      } else {
        const bbox = tile.bbox;
        bottomLeft = [bbox.left, bbox.bottom];
        topRight = [bbox.right, bbox.top];
      }
      const bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];
      const terrain = this.loadTerrain({
        elevationData: dataUrl,
        bounds,
        elevationDecoder,
        meshMaxError,
        signal
      });
      const surface = textureUrl ? fetch2(textureUrl, {
        propName: "texture",
        layer: this,
        loaders: [],
        signal
      }).catch((_) => null) : Promise.resolve(null);
      return Promise.all([terrain, surface]);
    }
    renderSubLayers(props) {
      const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
      const {
        color,
        wireframe,
        material
      } = this.props;
      const {
        data
      } = props;
      if (!data) {
        return null;
      }
      const [mesh, texture] = data;
      return new SubLayerClass(props, {
        data: DUMMY_DATA,
        mesh,
        texture,
        _instanced: false,
        coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
        getPosition: (d) => [0, 0, 0],
        getColor: color,
        wireframe,
        material
      });
    }
    onViewportLoad(tiles) {
      if (!tiles) {
        return;
      }
      const {
        zRange
      } = this.state;
      const ranges = tiles.map((tile) => tile.content).filter(Boolean).map((arr) => {
        const bounds = arr[0].header.boundingBox;
        return bounds.map((bound) => bound[2]);
      });
      if (ranges.length === 0) {
        return;
      }
      const minZ = Math.min(...ranges.map((x2) => x2[0]));
      const maxZ = Math.max(...ranges.map((x2) => x2[1]));
      if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {
        this.setState({
          zRange: [minZ, maxZ]
        });
      }
    }
    renderLayers() {
      const {
        color,
        material,
        elevationData,
        texture,
        wireframe,
        meshMaxError,
        elevationDecoder,
        tileSize,
        maxZoom,
        minZoom,
        extent,
        maxRequests,
        onTileLoad,
        onTileUnload,
        onTileError,
        maxCacheSize,
        maxCacheByteSize,
        refinementStrategy
      } = this.props;
      if (this.state.isTiled) {
        return new TileLayer(this.getSubLayerProps({
          id: "tiles"
        }), {
          getTileData: this.getTiledTerrainData.bind(this),
          renderSubLayers: this.renderSubLayers.bind(this),
          updateTriggers: {
            getTileData: {
              elevationData: urlTemplateToUpdateTrigger(elevationData),
              texture: urlTemplateToUpdateTrigger(texture),
              meshMaxError,
              elevationDecoder
            }
          },
          onViewportLoad: this.onViewportLoad.bind(this),
          zRange: this.state.zRange || null,
          tileSize,
          maxZoom,
          minZoom,
          extent,
          maxRequests,
          onTileLoad,
          onTileUnload,
          onTileError,
          maxCacheSize,
          maxCacheByteSize,
          refinementStrategy
        });
      }
      const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
      return new SubLayerClass(this.getSubLayerProps({
        id: "mesh"
      }), {
        data: DUMMY_DATA,
        mesh: this.state.terrain,
        texture,
        _instanced: false,
        getPosition: (d) => [0, 0, 0],
        getColor: color,
        material,
        wireframe
      });
    }
  };
  __publicField(TerrainLayer, "defaultProps", defaultProps31);
  __publicField(TerrainLayer, "layerName", "TerrainLayer");

  // ../extensions/src/brushing/shader-module.ts
  var vs8 = `
  uniform bool brushing_enabled;
  uniform int brushing_target;
  uniform vec2 brushing_mousePos;
  uniform float brushing_radius;

  #ifdef NON_INSTANCED_MODEL
  attribute vec2 brushingTargets;
  #else
  attribute vec2 instanceBrushingTargets;
  #endif

  varying float brushing_isVisible;

  bool brushing_isPointInRange(vec2 position) {
    if (!brushing_enabled) {
      return true;
    }
    vec2 source_commonspace = project_position(position);
    vec2 target_commonspace = project_position(brushing_mousePos);
    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);

    return distance <= brushing_radius;
  }

  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {
    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);
  }

  void brushing_setVisible(bool visible) {
    brushing_isVisible = float(visible);
  }
`;
  var fs5 = `
  uniform bool brushing_enabled;
  varying float brushing_isVisible;
`;
  var TARGET = {
    source: 0,
    target: 1,
    custom: 2,
    source_target: 3
  };
  var inject = {
    "vs:DECKGL_FILTER_GL_POSITION": `
    vec2 brushingTarget;
    vec2 brushingSource;
    if (brushing_target == 3) {
      brushingTarget = geometry.worldPositionAlt.xy;
      brushingSource = geometry.worldPosition.xy;
    } else if (brushing_target == 0) {
      brushingTarget = geometry.worldPosition.xy;
    } else if (brushing_target == 1) {
      brushingTarget = geometry.worldPositionAlt.xy;
    } else {
      #ifdef NON_INSTANCED_MODEL
      brushingTarget = brushingTargets;
      #else
      brushingTarget = instanceBrushingTargets;
      #endif
    }
    bool visible;
    if (brushing_target == 3) {
      visible = brushing_arePointsInRange(brushingSource, brushingTarget);
    } else {
      visible = brushing_isPointInRange(brushingTarget);
    }
    brushing_setVisible(visible);
  `,
    "fs:DECKGL_FILTER_COLOR": `
    if (brushing_enabled && brushing_isVisible < 0.5) {
      discard;
    }
  `
  };
  var shader_module_default = {
    name: "brushing",
    dependencies: [project_default],
    vs: vs8,
    fs: fs5,
    inject,
    getUniforms: (opts) => {
      if (!opts || !("viewport" in opts)) {
        return {};
      }
      const {
        brushingEnabled = true,
        brushingRadius = 1e4,
        brushingTarget = "source",
        mousePosition,
        viewport
      } = opts;
      return {
        brushing_enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),
        brushing_radius: brushingRadius,
        brushing_target: TARGET[brushingTarget] || 0,
        brushing_mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]
      };
    }
  };

  // ../extensions/src/brushing/brushing-extension.ts
  var defaultProps32 = {
    getBrushingTarget: {
      type: "accessor",
      value: [0, 0]
    },
    brushingTarget: "source",
    brushingEnabled: true,
    brushingRadius: 1e4
  };
  var BrushingExtension = class extends LayerExtension {
    getShaders() {
      return {
        modules: [shader_module_default]
      };
    }
    initializeState(context, extension) {
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.add({
          brushingTargets: {
            size: 2,
            accessor: "getBrushingTarget",
            shaderAttributes: {
              brushingTargets: {
                divisor: 0
              },
              instanceBrushingTargets: {
                divisor: 1
              }
            }
          }
        });
      }
      this.state.onMouseMove = () => {
        this.getCurrentLayer()?.setNeedsRedraw();
      };
      if (context.deck) {
        context.deck.eventManager.on({
          pointermove: this.state.onMouseMove,
          pointerleave: this.state.onMouseMove
        });
      }
    }
    finalizeState(context, extension) {
      if (context.deck) {
        context.deck.eventManager.off({
          pointermove: this.state.onMouseMove,
          pointerleave: this.state.onMouseMove
        });
      }
    }
  };
  __publicField(BrushingExtension, "defaultProps", defaultProps32);
  __publicField(BrushingExtension, "extensionName", "BrushingExtension");

  // ../extensions/src/data-filter/shader-module.ts
  var vs9 = `
uniform DATAFILTER_TYPE filter_min;
uniform DATAFILTER_TYPE filter_softMin;
uniform DATAFILTER_TYPE filter_softMax;
uniform DATAFILTER_TYPE filter_max;
uniform bool filter_useSoftMargin;
uniform bool filter_enabled;
uniform bool filter_transformSize;

#ifdef NON_INSTANCED_MODEL
  #define DATAFILTER_ATTRIB filterValues
  #define DATAFILTER_ATTRIB_64LOW filterValues64Low
#else
  #define DATAFILTER_ATTRIB instanceFilterValues
  #define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low
#endif

attribute DATAFILTER_TYPE DATAFILTER_ATTRIB;
#ifdef DATAFILTER_DOUBLE
  attribute DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;

  uniform DATAFILTER_TYPE filter_min64High;
  uniform DATAFILTER_TYPE filter_max64High;
#endif

varying float dataFilter_value;

float dataFilter_reduceValue(float value) {
  return value;
}
float dataFilter_reduceValue(vec2 value) {
  return min(value.x, value.y);
}
float dataFilter_reduceValue(vec3 value) {
  return min(min(value.x, value.y), value.z);
}
float dataFilter_reduceValue(vec4 value) {
  return min(min(value.x, value.y), min(value.z, value.w));
}
void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {
  if (filter_enabled) {
    if (filter_useSoftMargin) {
      dataFilter_value = dataFilter_reduceValue(
        smoothstep(filter_min, filter_softMin, valueFromMin) *
        (1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))
      );
    } else {
      dataFilter_value = dataFilter_reduceValue(
        step(filter_min, valueFromMin) * step(valueFromMax, filter_max)
      );
    }
  } else {
    dataFilter_value = 1.0;
  }
}
`;
  var fs6 = `
uniform bool filter_transformColor;
varying float dataFilter_value;
`;
  function getUniforms6(opts) {
    if (!opts || !("extensions" in opts)) {
      return {};
    }
    const {
      filterRange = [-1, 1],
      filterEnabled = true,
      filterTransformSize = true,
      filterTransformColor = true
    } = opts;
    const filterSoftRange = opts.filterSoftRange || filterRange;
    return {
      ...Number.isFinite(filterRange[0]) ? {
        filter_min: filterRange[0],
        filter_softMin: filterSoftRange[0],
        filter_softMax: filterSoftRange[1],
        filter_max: filterRange[1]
      } : {
        filter_min: filterRange.map((r2) => r2[0]),
        filter_softMin: filterSoftRange.map((r2) => r2[0]),
        filter_softMax: filterSoftRange.map((r2) => r2[1]),
        filter_max: filterRange.map((r2) => r2[1])
      },
      filter_enabled: filterEnabled,
      filter_useSoftMargin: Boolean(opts.filterSoftRange),
      filter_transformSize: filterEnabled && filterTransformSize,
      filter_transformColor: filterEnabled && filterTransformColor
    };
  }
  function getUniforms64(opts) {
    if (!opts || !("extensions" in opts)) {
      return {};
    }
    const uniforms = getUniforms6(opts);
    if (Number.isFinite(uniforms.filter_min)) {
      const min64High = Math.fround(uniforms.filter_min);
      uniforms.filter_min -= min64High;
      uniforms.filter_softMin -= min64High;
      uniforms.filter_min64High = min64High;
      const max64High = Math.fround(uniforms.filter_max);
      uniforms.filter_max -= max64High;
      uniforms.filter_softMax -= max64High;
      uniforms.filter_max64High = max64High;
    } else {
      const min64High = uniforms.filter_min.map(Math.fround);
      uniforms.filter_min = uniforms.filter_min.map((x2, i3) => x2 - min64High[i3]);
      uniforms.filter_softMin = uniforms.filter_softMin.map((x2, i3) => x2 - min64High[i3]);
      uniforms.filter_min64High = min64High;
      const max64High = uniforms.filter_max.map(Math.fround);
      uniforms.filter_max = uniforms.filter_max.map((x2, i3) => x2 - max64High[i3]);
      uniforms.filter_softMax = uniforms.filter_softMax.map((x2, i3) => x2 - max64High[i3]);
      uniforms.filter_max64High = max64High;
    }
    return uniforms;
  }
  var inject2 = {
    "vs:#main-start": `
    #ifdef DATAFILTER_DOUBLE
      dataFilter_setValue(
        DATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,
        DATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW
      );
    #else
      dataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB);
    #endif
  `,
    "vs:#main-end": `
    if (dataFilter_value == 0.0) {
      gl_Position = vec4(0.);
    }
  `,
    "vs:DECKGL_FILTER_SIZE": `
    if (filter_transformSize) {
      size = size * dataFilter_value;
    }
  `,
    "fs:DECKGL_FILTER_COLOR": `
    if (dataFilter_value == 0.0) discard;
    if (filter_transformColor) {
      color.a *= dataFilter_value;
    }
  `
  };
  var shaderModule = {
    name: "data-filter",
    vs: vs9,
    fs: fs6,
    inject: inject2,
    getUniforms: getUniforms6
  };
  var shaderModule64 = {
    name: "data-filter-fp64",
    vs: vs9,
    fs: fs6,
    inject: inject2,
    getUniforms: getUniforms64
  };

  // ../extensions/src/data-filter/aggregator.ts
  var AGGREGATE_VS = `#define SHADER_NAME data-filter-vertex-shader

#ifdef FLOAT_TARGET
  attribute float filterIndices;
  attribute float filterPrevIndices;
#else
  attribute vec2 filterIndices;
  attribute vec2 filterPrevIndices;
#endif

varying vec4 vColor;
const float component = 1.0 / 255.0;

void main() {
  #ifdef FLOAT_TARGET
    dataFilter_value *= float(filterIndices != filterPrevIndices);
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
    vColor = vec4(0.0, 0.0, 0.0, 1.0);
  #else
    // Float texture is not supported: pack result into 4 channels x 256 px x 64px
    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);
    float col = filterIndices.x;
    float row = filterIndices.y * 4.0;
    float channel = floor(row);
    row = fract(row);
    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));
    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);
  #endif
  gl_PointSize = 1.0;
}
`;
  var AGGREGATE_FS = `#define SHADER_NAME data-filter-fragment-shader
precision highp float;

varying vec4 vColor;

void main() {
  if (dataFilter_value < 0.5) {
    discard;
  }
  gl_FragColor = vColor;
}
`;
  function supportsFloatTarget(gl) {
    return Boolean(gl.getExtension("EXT_float_blend") && (gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float")));
  }
  function getFramebuffer3(gl, useFloatTarget) {
    if (useFloatTarget) {
      return new Framebuffer(gl, {
        width: 1,
        height: 1,
        attachments: {
          [esm_default2.COLOR_ATTACHMENT0]: new Texture2D(gl, {
            format: isWebGL2(gl) ? esm_default2.RGBA32F : esm_default2.RGBA,
            type: esm_default2.FLOAT,
            mipmaps: false
          })
        }
      });
    }
    return new Framebuffer(gl, {
      width: 256,
      height: 64,
      depth: false
    });
  }
  function getModel(gl, shaderOptions, useFloatTarget) {
    shaderOptions.defines.NON_INSTANCED_MODEL = 1;
    if (useFloatTarget) {
      shaderOptions.defines.FLOAT_TARGET = 1;
    }
    return new Model(gl, {
      id: "data-filter-aggregation-model",
      vertexCount: 1,
      isInstanced: false,
      drawMode: esm_default2.POINTS,
      vs: AGGREGATE_VS,
      fs: AGGREGATE_FS,
      ...shaderOptions
    });
  }
  var parameters = {
    blend: true,
    blendFunc: [esm_default2.ONE, esm_default2.ONE, esm_default2.ONE, esm_default2.ONE],
    blendEquation: [esm_default2.FUNC_ADD, esm_default2.FUNC_ADD],
    depthTest: false
  };

  // ../extensions/src/data-filter/data-filter-extension.ts
  var defaultProps33 = {
    getFilterValue: {
      type: "accessor",
      value: 0
    },
    onFilteredItemsChange: {
      type: "function",
      value: null,
      optional: true
    },
    filterEnabled: true,
    filterRange: [-1, 1],
    filterSoftRange: null,
    filterTransformSize: true,
    filterTransformColor: true
  };
  var DATA_TYPE_FROM_SIZE = {
    1: "float",
    2: "vec2",
    3: "vec3",
    4: "vec4"
  };
  var DataFilterExtension = class extends LayerExtension {
    constructor({
      filterSize = 1,
      fp64: fp642 = false,
      countItems = false
    } = {}) {
      if (!DATA_TYPE_FROM_SIZE[filterSize]) {
        throw new Error("filterSize out of range");
      }
      super({
        filterSize,
        fp64: fp642,
        countItems
      });
    }
    getShaders(extension) {
      const {
        filterSize,
        fp64: fp642
      } = extension.opts;
      return {
        modules: [fp642 ? shaderModule64 : shaderModule],
        defines: {
          DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],
          DATAFILTER_DOUBLE: Boolean(fp642)
        }
      };
    }
    initializeState(context, extension) {
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.add({
          filterValues: {
            size: extension.opts.filterSize,
            type: extension.opts.fp64 ? esm_default2.DOUBLE : esm_default2.FLOAT,
            accessor: "getFilterValue",
            shaderAttributes: {
              filterValues: {
                divisor: 0
              },
              instanceFilterValues: {
                divisor: 1
              }
            }
          }
        });
      }
      const {
        gl
      } = this.context;
      if (attributeManager && extension.opts.countItems) {
        const useFloatTarget = supportsFloatTarget(gl);
        attributeManager.add({
          filterIndices: {
            size: useFloatTarget ? 1 : 2,
            vertexOffset: 1,
            type: esm_default2.UNSIGNED_BYTE,
            normalized: true,
            accessor: (object, {
              index
            }) => {
              const i3 = object && object.__source ? object.__source.index : index;
              return useFloatTarget ? (i3 + 1) % 255 : [(i3 + 1) % 255, Math.floor(i3 / 255) % 255];
            },
            shaderAttributes: {
              filterPrevIndices: {
                vertexOffset: 0
              },
              filterIndices: {
                vertexOffset: 1
              }
            }
          }
        });
        const filterFBO = getFramebuffer3(gl, useFloatTarget);
        const filterModel = getModel(gl, extension.getShaders.call(this, extension), useFloatTarget);
        this.setState({
          filterFBO,
          filterModel
        });
      }
    }
    updateState({
      props,
      oldProps
    }) {
      if (this.state.filterModel) {
        const attributeManager = this.getAttributeManager();
        const filterNeedsUpdate = attributeManager.attributes.filterValues.needsUpdate() || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange;
        if (filterNeedsUpdate) {
          this.setState({
            filterNeedsUpdate
          });
        }
      }
    }
    draw(params, extension) {
      const {
        filterFBO,
        filterModel,
        filterNeedsUpdate
      } = this.state;
      const {
        onFilteredItemsChange
      } = this.props;
      if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {
        const {
          attributes: {
            filterValues,
            filterIndices
          }
        } = this.getAttributeManager();
        filterModel.setVertexCount(this.getNumInstances());
        const {
          gl
        } = this.context;
        clear(gl, {
          framebuffer: filterFBO,
          color: [0, 0, 0, 0]
        });
        filterModel.updateModuleSettings(params.moduleParameters).setAttributes({
          ...filterValues.getShaderAttributes(),
          ...filterIndices && filterIndices.getShaderAttributes()
        }).draw({
          framebuffer: filterFBO,
          parameters: {
            ...parameters,
            viewport: [0, 0, filterFBO.width, filterFBO.height]
          }
        });
        const color = readPixelsToArray(filterFBO);
        let count2 = 0;
        for (let i3 = 0; i3 < color.length; i3++) {
          count2 += color[i3];
        }
        onFilteredItemsChange({
          id: this.id,
          count: count2
        });
        this.state.filterNeedsUpdate = false;
      }
    }
    finalizeState() {
      const {
        filterFBO,
        filterModel
      } = this.state;
      if (filterFBO) {
        filterFBO.color.delete();
        filterFBO.delete();
        filterModel.delete();
      }
    }
  };
  __publicField(DataFilterExtension, "defaultProps", defaultProps33);
  __publicField(DataFilterExtension, "extensionName", "DataFilterExtension");

  // ../extensions/src/fp64/project64.glsl.ts
  var project64_glsl_default = `
const vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);

uniform vec2 project_uViewProjectionMatrixFP64[16];

// longitude: lnglat_fp64.xy; latitude: lnglat_fp64.zw
void mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {

#if defined(NVIDIA_FP64_WORKAROUND)
  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);
#else
  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);
#endif
  out_val[1] = sum_fp64(PI_FP64,
    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));
  return;
}

void project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {
  vec2 pos_fp64[2];
  mercatorProject_fp64(position_fp64, pos_fp64);
  out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);
  out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);

  return;
}

void project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {
  vec4 position64xy = vec4(
    position.x, position64xyLow.x,
    position.y, position64xyLow.y);

  project_position_fp64(position64xy, out_val);
}

vec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {
  vec2 vertex_pos_clipspace[4];
  mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,
    vertex_pos_clipspace);
  return vec4(
    vertex_pos_clipspace[0].x,
    vertex_pos_clipspace[1].x,
    vertex_pos_clipspace[2].x,
    vertex_pos_clipspace[3].x
    );
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition
) {
  // This is the local offset to the instance position
  vec2 offset64[4];
  vec4_fp64(vec4(offset, 0.0), offset64);

  float z = project_size(position.z);

  // Apply web mercator projection (depends on coordinate system imn use)
  vec2 projectedPosition64xy[2];
  project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);

  vec2 commonPosition64[4];
  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);
  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);
  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));
  commonPosition64[3] = vec2(1.0, 0.0);

  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);

  return project_common_position_to_clipspace_fp64(commonPosition64);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64xyLow, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(
    position, position64xyLow, offset, commonPosition
  );
}
`;

  // ../extensions/src/fp64/project64.ts
  var {
    fp64ify: fp64ify2,
    fp64ifyMatrix4: fp64ifyMatrix42
  } = fp64;
  var project64_default = {
    name: "project64",
    dependencies: [project_default, fp64],
    vs: project64_glsl_default,
    getUniforms: getUniforms7
  };
  var getMemoizedUniforms = memoize(calculateUniforms);
  function getUniforms7(opts) {
    if (opts && "viewport" in opts) {
      const {
        viewProjectionMatrix,
        scale: scale8
      } = opts.viewport;
      return getMemoizedUniforms({
        viewProjectionMatrix,
        scale: scale8
      });
    }
    return {};
  }
  function calculateUniforms({
    viewProjectionMatrix,
    scale: scale8
  }) {
    const glViewProjectionMatrixFP64 = fp64ifyMatrix42(viewProjectionMatrix);
    const scaleFP64 = fp64ify2(scale8);
    return {
      project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,
      project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,
      project64_uScale: scaleFP64
    };
  }

  // ../extensions/src/fp64/fp64-extension.ts
  var Fp64Extension = class extends LayerExtension {
    getShaders() {
      const {
        coordinateSystem
      } = this.props;
      if (coordinateSystem !== COORDINATE_SYSTEM.LNGLAT && coordinateSystem !== COORDINATE_SYSTEM.DEFAULT) {
        throw new Error("fp64: coordinateSystem must be LNGLAT");
      }
      return {
        modules: [project64_default]
      };
    }
  };
  __publicField(Fp64Extension, "extensionName", "Fp64Extension");

  // ../extensions/src/path-style/shaders.glsl.ts
  var dashShaders = {
    inject: {
      "vs:#decl": `
attribute vec2 instanceDashArrays;
attribute float instanceDashOffsets;
varying vec2 vDashArray;
varying float vDashOffset;
`,
      "vs:#main-end": `
vDashArray = instanceDashArrays;
vDashOffset = instanceDashOffsets / width.x;
`,
      "fs:#decl": `
uniform float dashAlignMode;
uniform float capType;
uniform bool dashGapPickable;
varying vec2 vDashArray;
varying float vDashOffset;

float round(float x) {
  return floor(x + 0.5);
}
`,
      "fs:#main-start": `
  float solidLength = vDashArray.x;
  float gapLength = vDashArray.y;
  float unitLength = solidLength + gapLength;

  float offset;

  if (unitLength > 0.0) {
    if (dashAlignMode == 0.0) {
      offset = vDashOffset;
    } else {
      unitLength = vPathLength / round(vPathLength / unitLength);
      offset = solidLength / 2.0;
    }

    float unitOffset = mod(clamp(vPathPosition.y, 0.0, vPathLength) + offset, unitLength);

    if (gapLength > 0.0 && unitOffset > solidLength) {
      if (capType <= 0.5) {
        if (!(dashGapPickable && picking_uActive)) {
          discard;
        }
      } else {
        // caps are rounded, test the distance to solid ends
        float distToEnd = length(vec2(
          min(unitOffset - solidLength, unitLength - unitOffset),
          vPathPosition.x
        ));
        if (distToEnd > 1.0) {
          if (!(dashGapPickable && picking_uActive)) {
            discard;
          }
        }
      }
    }
  }
`
    }
  };
  var offsetShaders = {
    inject: {
      "vs:#decl": `
attribute float instanceOffsets;
`,
      "vs:DECKGL_FILTER_SIZE": `
  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
  size *= offsetWidth;
`,
      "vCornerOffset = offsetVec;": `
  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
  vec2 offsetCenter = -instanceOffsets * (isCap ? perp : miterVec * miterSize) * 2.0;
  vCornerOffset = vCornerOffset * offsetWidth - offsetCenter;
`,
      "fs:#main-start": `
  float isInside;
  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);
  if (isInside == 0.0) {
    discard;
  }
`
    }
  };

  // ../extensions/src/path-style/path-style-extension.ts
  var defaultProps34 = {
    getDashArray: {
      type: "accessor",
      value: [0, 0]
    },
    getOffset: {
      type: "accessor",
      value: 0
    },
    dashJustified: false,
    dashGapPickable: false
  };
  var PathStyleExtension = class extends LayerExtension {
    constructor({
      dash = false,
      offset = false,
      highPrecisionDash = false
    } = {}) {
      super({
        dash: dash || highPrecisionDash,
        offset,
        highPrecisionDash
      });
    }
    isEnabled(layer) {
      return "pathTesselator" in layer.state;
    }
    getShaders(extension) {
      if (!extension.isEnabled(this)) {
        return null;
      }
      let result = {};
      if (extension.opts.dash) {
        result = mergeShaders(result, dashShaders);
      }
      if (extension.opts.offset) {
        result = mergeShaders(result, offsetShaders);
      }
      return result;
    }
    initializeState(context, extension) {
      const attributeManager = this.getAttributeManager();
      if (!attributeManager || !extension.isEnabled(this)) {
        return;
      }
      if (extension.opts.dash) {
        attributeManager.addInstanced({
          instanceDashArrays: {
            size: 2,
            accessor: "getDashArray"
          }
        });
      }
      if (extension.opts.highPrecisionDash) {
        attributeManager.addInstanced({
          instanceDashOffsets: {
            size: 1,
            accessor: "getPath",
            transform: extension.getDashOffsets.bind(this)
          }
        });
      }
      if (extension.opts.offset) {
        attributeManager.addInstanced({
          instanceOffsets: {
            size: 1,
            accessor: "getOffset"
          }
        });
      }
    }
    updateState(params, extension) {
      if (!extension.isEnabled(this)) {
        return;
      }
      const uniforms = {};
      if (extension.opts.dash) {
        uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;
        uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);
      }
      this.state.model.setUniforms(uniforms);
    }
    getDashOffsets(path) {
      const result = [0];
      const positionSize = this.props.positionFormat === "XY" ? 2 : 3;
      const isNested2 = Array.isArray(path[0]);
      const geometrySize = isNested2 ? path.length : path.length / positionSize;
      let p2;
      let prevP;
      for (let i3 = 0; i3 < geometrySize - 1; i3++) {
        p2 = isNested2 ? path[i3] : path.slice(i3 * positionSize, i3 * positionSize + positionSize);
        p2 = this.projectPosition(p2);
        if (i3 > 0) {
          result[i3] = result[i3 - 1] + dist(prevP, p2);
        }
        prevP = p2;
      }
      return result;
    }
  };
  __publicField(PathStyleExtension, "defaultProps", defaultProps34);
  __publicField(PathStyleExtension, "extensionName", "PathStyleExtension");

  // ../extensions/src/fill-style/shaders.glsl.ts
  var patternVs = `
#ifdef NON_INSTANCED_MODEL
  #define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames
  #define FILL_PATTERN_SCALE_ATTRIB fillPatternScales
  #define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets
#else
  #define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames
  #define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales
  #define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets
#endif

attribute vec4 FILL_PATTERN_FRAME_ATTRIB;
attribute float FILL_PATTERN_SCALE_ATTRIB;
attribute vec2 FILL_PATTERN_OFFSET_ATTRIB;

uniform bool fill_patternEnabled;
uniform vec2 fill_patternTextureSize;

varying vec2 fill_uv;
varying vec4 fill_patternBounds;
varying vec4 fill_patternPlacement;
`;
  var patternFs = `
uniform bool fill_patternEnabled;
uniform bool fill_patternMask;
uniform sampler2D fill_patternTexture;
uniform vec2 fill_uvCoordinateOrigin;
uniform vec2 fill_uvCoordinateOrigin64Low;

varying vec4 fill_patternBounds;
varying vec4 fill_patternPlacement;
varying vec2 fill_uv;

const float FILL_UV_SCALE = 512.0 / 40000000.0;
`;
  var inject3 = {
    "vs:DECKGL_FILTER_GL_POSITION": `
    fill_uv = geometry.position.xy;
  `,
    "vs:DECKGL_FILTER_COLOR": `
    if (fill_patternEnabled) {
      fill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);
      fill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;
      fill_patternPlacement.zw = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.zw;
    }
  `,
    "fs:DECKGL_FILTER_COLOR": `
    if (fill_patternEnabled) {
      vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;
      vec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uvCoordinateOrigin64Low + fill_uv, scale) / scale;
      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);

      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;

      vec4 patternColor = texture2D(fill_patternTexture, texCoords);
      color.a *= patternColor.a;
      if (!fill_patternMask) {
        color.rgb = patternColor.rgb;
      }
    }
  `
  };
  function getPatternUniforms(opts, uniforms) {
    if (!opts) {
      return {};
    }
    if ("fillPatternTexture" in opts) {
      const {
        fillPatternTexture
      } = opts;
      return {
        fill_patternTexture: fillPatternTexture,
        fill_patternTextureSize: [fillPatternTexture.width, fillPatternTexture.height]
      };
    }
    if ("viewport" in opts) {
      const {
        fillPatternMask = true,
        fillPatternEnabled = true
      } = opts;
      const {
        project_uCommonOrigin: coordinateOriginCommon
      } = uniforms;
      const coordinateOriginCommon64Low = [fp64LowPart2(coordinateOriginCommon[0]), fp64LowPart2(coordinateOriginCommon[1])];
      return {
        fill_uvCoordinateOrigin: coordinateOriginCommon.slice(0, 2),
        fill_uvCoordinateOrigin64Low: coordinateOriginCommon64Low,
        fill_patternMask: fillPatternMask,
        fill_patternEnabled: fillPatternEnabled
      };
    }
    return {};
  }
  var patternShaders = {
    name: "fill-pattern",
    vs: patternVs,
    fs: patternFs,
    inject: inject3,
    dependencies: [project_default],
    getUniforms: getPatternUniforms
  };

  // ../extensions/src/fill-style/fill-style-extension.ts
  var defaultProps35 = {
    fillPatternEnabled: true,
    fillPatternAtlas: {
      type: "image",
      value: null,
      async: true,
      parameters: {
        [esm_default2.TEXTURE_MIN_FILTER]: esm_default2.LINEAR
      }
    },
    fillPatternMapping: {
      type: "object",
      value: {},
      async: true
    },
    fillPatternMask: true,
    getFillPattern: {
      type: "accessor",
      value: (d) => d.pattern
    },
    getFillPatternScale: {
      type: "accessor",
      value: 1
    },
    getFillPatternOffset: {
      type: "accessor",
      value: [0, 0]
    }
  };
  var FillStyleExtension = class extends LayerExtension {
    constructor({
      pattern = false
    } = {}) {
      super({
        pattern
      });
    }
    isEnabled(layer) {
      return layer.getAttributeManager() !== null && !("pathTesselator" in layer.state);
    }
    getShaders(extension) {
      if (!extension.isEnabled(this)) {
        return null;
      }
      return {
        modules: [extension.opts.pattern && patternShaders].filter(Boolean)
      };
    }
    initializeState(context, extension) {
      if (!extension.isEnabled(this)) {
        return;
      }
      const attributeManager = this.getAttributeManager();
      if (extension.opts.pattern) {
        attributeManager.add({
          fillPatternFrames: {
            size: 4,
            accessor: "getFillPattern",
            transform: extension.getPatternFrame.bind(this),
            shaderAttributes: {
              fillPatternFrames: {
                divisor: 0
              },
              instanceFillPatternFrames: {
                divisor: 1
              }
            }
          },
          fillPatternScales: {
            size: 1,
            accessor: "getFillPatternScale",
            defaultValue: 1,
            shaderAttributes: {
              fillPatternScales: {
                divisor: 0
              },
              instanceFillPatternScales: {
                divisor: 1
              }
            }
          },
          fillPatternOffsets: {
            size: 2,
            accessor: "getFillPatternOffset",
            shaderAttributes: {
              fillPatternOffsets: {
                divisor: 0
              },
              instanceFillPatternOffsets: {
                divisor: 1
              }
            }
          }
        });
      }
      this.setState({
        emptyTexture: new Texture2D(this.context.gl, {
          data: new Uint8Array(4),
          width: 1,
          height: 1
        })
      });
    }
    updateState({
      props,
      oldProps
    }, extension) {
      if (!extension.isEnabled(this)) {
        return;
      }
      if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {
        this.getAttributeManager().invalidate("getFillPattern");
      }
    }
    draw(params, extension) {
      if (!extension.isEnabled(this)) {
        return;
      }
      const {
        fillPatternAtlas
      } = this.props;
      this.setModuleParameters({
        fillPatternTexture: fillPatternAtlas || this.state.emptyTexture
      });
    }
    finalizeState() {
      const {
        emptyTexture
      } = this.state;
      emptyTexture?.delete();
    }
    getPatternFrame(name10) {
      const {
        fillPatternMapping
      } = this.getCurrentLayer().props;
      const def = fillPatternMapping && fillPatternMapping[name10];
      return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];
    }
  };
  __publicField(FillStyleExtension, "defaultProps", defaultProps35);
  __publicField(FillStyleExtension, "extensionName", "FillStyleExtension");

  // ../extensions/src/clip/clip-extension.ts
  var defaultProps36 = {
    clipBounds: [0, 0, 1, 1],
    clipByInstance: void 0
  };
  var shaderFunction = `
uniform vec4 clip_bounds;

bool clip_isInBounds(vec2 position) {
  return position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];
}
`;
  var shaderModuleVs = {
    name: "clip-vs",
    vs: shaderFunction
  };
  var injectionVs = {
    "vs:#decl": `
varying float clip_isVisible;
`,
    "vs:DECKGL_FILTER_GL_POSITION": `
  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));
`,
    "fs:#decl": `
varying float clip_isVisible;
`,
    "fs:DECKGL_FILTER_COLOR": `
  if (clip_isVisible < 0.5) discard;
`
  };
  var shaderModuleFs = {
    name: "clip-fs",
    fs: shaderFunction
  };
  var injectionFs = {
    "vs:#decl": `
varying vec2 clip_commonPosition;
`,
    "vs:DECKGL_FILTER_GL_POSITION": `
  clip_commonPosition = geometry.position.xy;
`,
    "fs:#decl": `
varying vec2 clip_commonPosition;
`,
    "fs:DECKGL_FILTER_COLOR": `
  if (!clip_isInBounds(clip_commonPosition)) discard;
`
  };
  var ClipExtension = class extends LayerExtension {
    getShaders() {
      let clipByInstance = "instancePositions" in this.getAttributeManager().attributes;
      if (this.props.clipByInstance !== void 0) {
        clipByInstance = Boolean(this.props.clipByInstance);
      }
      this.state.clipByInstance = clipByInstance;
      return clipByInstance ? {
        modules: [shaderModuleVs],
        inject: injectionVs
      } : {
        modules: [shaderModuleFs],
        inject: injectionFs
      };
    }
    draw({
      uniforms
    }) {
      const {
        clipBounds
      } = this.props;
      if (this.state.clipByInstance) {
        uniforms.clip_bounds = clipBounds;
      } else {
        const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);
        const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);
        uniforms.clip_bounds = [Math.min(corner0[0], corner1[0]), Math.min(corner0[1], corner1[1]), Math.max(corner0[0], corner1[0]), Math.max(corner0[1], corner1[1])];
      }
    }
  };
  __publicField(ClipExtension, "defaultProps", defaultProps36);
  __publicField(ClipExtension, "extensionName", "ClipExtension");

  // ../extensions/src/collision-filter/shader-module.ts
  var vs10 = `
#ifdef NON_INSTANCED_MODEL
attribute float collisionPriorities;
#else
attribute float instanceCollisionPriorities;
#endif

uniform sampler2D collision_texture;
uniform bool collision_sort;
uniform bool collision_enabled;

vec2 collision_getCoords(vec4 position) {
  vec4 collision_clipspace = project_common_position_to_clipspace(position);
  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;
}

float collision_match(vec2 tex, vec3 pickingColor) {
  vec4 collision_pickingColor = texture2D(collision_texture, tex);
  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));
  float e = 0.001;
  return step(delta, e);
}

float collision_isVisible(vec2 texCoords, vec3 pickingColor) {
  if (!collision_enabled) {
    return 1.0;
  }

  // Visibility test, sample area of 5x5 pixels in order to fade in/out.
  // Due to the locality, the lookups will be cached
  // This reduces the flicker present when objects are shown/hidden
  const int N = 2;
  float accumulator = 0.0;
  vec2 step = vec2(1.0 / project_uViewportSize);

  const float floatN = float(N);
  vec2 delta = -floatN * step;
  for(int i = -N; i <= N; i++) {
    delta.x = -step.x * floatN;
    for(int j = -N; j <= N; j++) {
      accumulator += collision_match(texCoords + delta, pickingColor);
      delta.x += step.x;
    }
    delta.y += step.y;
  }

  float W = 2.0 * floatN + 1.0;
  return pow(accumulator / (W * W), 2.2);
}
`;
  var inject4 = {
    "vs:#decl": `
  float collision_fade = 1.0;
`,
    "vs:DECKGL_FILTER_GL_POSITION": `
  if (collision_sort) {
    #ifdef NON_INSTANCED_MODEL
    float collisionPriority = collisionPriorities;
    #else
    float collisionPriority = instanceCollisionPriorities;
    #endif
    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000
  }

  if (collision_enabled) {
    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));
    vec2 collision_texCoords = collision_getCoords(collision_common_position);
    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);
    if (collision_fade < 0.0001) {
      // Position outside clip space bounds to discard
      position = vec4(0.0, 0.0, 2.0, 1.0);
    }
  }
  `,
    "vs:DECKGL_FILTER_COLOR": `
  color.a *= collision_fade;
  `
  };
  var getCollisionUniforms = (opts, uniforms) => {
    if (!opts || !("dummyCollisionMap" in opts)) {
      return {};
    }
    const {
      collisionFBO,
      drawToCollisionMap,
      dummyCollisionMap
    } = opts;
    return {
      collision_sort: Boolean(drawToCollisionMap),
      collision_texture: !drawToCollisionMap && collisionFBO ? collisionFBO : dummyCollisionMap
    };
  };
  var shader_module_default2 = {
    name: "collision",
    dependencies: [project_default],
    vs: vs10,
    inject: inject4,
    getUniforms: getCollisionUniforms
  };

  // ../extensions/src/collision-filter/collision-filter-pass.ts
  var CollisionFilterPass = class extends LayersPass {
    renderCollisionMap(target, options) {
      const gl = this.gl;
      const padding = 1;
      return withParameters(gl, {
        scissorTest: true,
        scissor: [padding, padding, target.width - 2 * padding, target.height - 2 * padding],
        clearColor: [0, 0, 0, 0],
        blend: false,
        depthTest: true,
        depthRange: [0, 1]
      }, () => this.render({
        ...options,
        target,
        pass: "collision"
      }));
    }
    getModuleParameters() {
      return {
        drawToCollisionMap: true,
        pickingActive: 1,
        pickingAttribute: false,
        lightSources: {}
      };
    }
  };

  // ../extensions/src/mask/mask-pass.ts
  var MaskPass = class extends LayersPass {
    constructor(gl, props) {
      super(gl, props);
      const {
        mapSize = 2048
      } = props;
      this.maskMap = new Texture2D(gl, {
        width: mapSize,
        height: mapSize,
        parameters: {
          [gl.TEXTURE_MIN_FILTER]: gl.LINEAR,
          [gl.TEXTURE_MAG_FILTER]: gl.LINEAR,
          [gl.TEXTURE_WRAP_S]: gl.CLAMP_TO_EDGE,
          [gl.TEXTURE_WRAP_T]: gl.CLAMP_TO_EDGE
        }
      });
      this.fbo = new Framebuffer(gl, {
        id: "maskmap",
        width: mapSize,
        height: mapSize,
        attachments: {
          [gl.COLOR_ATTACHMENT0]: this.maskMap
        }
      });
    }
    render(options) {
      const gl = this.gl;
      const colorMask = [false, false, false, false];
      colorMask[options.channel] = true;
      return withParameters(gl, {
        clearColor: [255, 255, 255, 255],
        blend: true,
        blendFunc: [gl.ZERO, gl.ONE],
        blendEquation: gl.FUNC_SUBTRACT,
        colorMask,
        depthTest: false
      }, () => super.render({
        ...options,
        target: this.fbo,
        pass: "mask"
      }));
    }
    shouldDrawLayer(layer) {
      return layer.props.operation.includes("mask");
    }
    delete() {
      this.fbo.delete();
      this.maskMap.delete();
    }
  };

  // ../extensions/src/utils/projection-utils.ts
  function joinLayerBounds(layers, viewport) {
    const bounds = [Infinity, Infinity, -Infinity, -Infinity];
    for (const layer of layers) {
      const layerBounds = layer.getBounds();
      if (layerBounds) {
        const bottomLeftCommon = layer.projectPosition(layerBounds[0], {
          viewport,
          autoOffset: false
        });
        const topRightCommon = layer.projectPosition(layerBounds[1], {
          viewport,
          autoOffset: false
        });
        bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);
        bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);
        bounds[2] = Math.max(bounds[2], topRightCommon[0]);
        bounds[3] = Math.max(bounds[3], topRightCommon[1]);
      }
    }
    if (Number.isFinite(bounds[0])) {
      return bounds;
    }
    return null;
  }
  var MAX_VIEWPORT_SIZE = 2048;
  function makeViewport(opts) {
    const {
      bounds,
      viewport,
      border = 0
    } = opts;
    const {
      isGeospatial
    } = viewport;
    if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
      return null;
    }
    const centerWorld = viewport.unprojectPosition([(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0]);
    let {
      width,
      height,
      zoom
    } = opts;
    if (zoom === void 0) {
      width = width - border * 2;
      height = height - border * 2;
      const scale8 = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));
      zoom = Math.min(Math.log2(scale8), 20);
    } else if (!width || !height) {
      const scale8 = 2 ** zoom;
      width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale8);
      height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale8);
      const maxSize = MAX_VIEWPORT_SIZE - border * 2;
      if (width > maxSize || height > maxSize) {
        const r2 = maxSize / Math.max(width, height);
        width = Math.round(width * r2);
        height = Math.round(height * r2);
        zoom += Math.log2(r2);
      }
    }
    return isGeospatial ? new WebMercatorViewport2({
      id: viewport.id,
      x: border,
      y: border,
      width,
      height,
      longitude: centerWorld[0],
      latitude: centerWorld[1],
      zoom,
      orthographic: true
    }) : new OrthographicViewport({
      id: viewport.id,
      x: border,
      y: border,
      width,
      height,
      target: centerWorld,
      zoom,
      flipY: false
    });
  }
  function getViewportBounds(viewport, zRange) {
    let viewportBoundsWorld;
    if (zRange && zRange.length === 2) {
      const [minZ, maxZ] = zRange;
      const bounds0 = viewport.getBounds({
        z: minZ
      });
      const bounds1 = viewport.getBounds({
        z: maxZ
      });
      viewportBoundsWorld = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];
    } else {
      viewportBoundsWorld = viewport.getBounds();
    }
    const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));
    const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));
    return [viewportBottomLeftCommon[0], viewportBottomLeftCommon[1], viewportTopRightCommon[0], viewportTopRightCommon[1]];
  }
  function getRenderBounds(layerBounds, viewport, zRange) {
    if (!layerBounds) {
      return [0, 0, 1, 1];
    }
    const viewportBounds = getViewportBounds(viewport, zRange);
    const paddedBounds = doubleBounds(viewportBounds);
    if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] && layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {
      return layerBounds;
    }
    return [Math.max(layerBounds[0], paddedBounds[0]), Math.max(layerBounds[1], paddedBounds[1]), Math.min(layerBounds[2], paddedBounds[2]), Math.min(layerBounds[3], paddedBounds[3])];
  }
  function doubleBounds(bounds) {
    const dx = bounds[2] - bounds[0];
    const dy = bounds[3] - bounds[1];
    const centerX = (bounds[0] + bounds[2]) / 2;
    const centerY = (bounds[1] + bounds[3]) / 2;
    return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];
  }

  // ../extensions/src/mask/mask-effect.ts
  var MaskEffect = class {
    id = "mask-effect";
    props = null;
    useInPicking = true;
    order = 0;
    channels = [];
    masks = null;
    preRender(gl, {
      layers,
      layerFilter,
      viewports,
      onViewportActive,
      views,
      isPicking
    }) {
      let didRender = false;
      if (!this.dummyMaskMap) {
        this.dummyMaskMap = new Texture2D(gl, {
          width: 1,
          height: 1
        });
      }
      if (isPicking) {
        return {
          didRender
        };
      }
      const maskLayers = layers.filter((l2) => l2.props.visible && l2.props.operation.includes("mask"));
      if (maskLayers.length === 0) {
        this.masks = null;
        this.channels.length = 0;
        return {
          didRender
        };
      }
      this.masks = {};
      if (!this.maskPass) {
        this.maskPass = new MaskPass(gl, {
          id: "default-mask"
        });
        this.maskMap = this.maskPass.maskMap;
      }
      const channelMap = this._sortMaskChannels(maskLayers);
      const viewport = viewports[0];
      const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);
      if (viewport.resolution !== void 0) {
        log_default.warn("MaskExtension is not supported in GlobeView")();
        return {
          didRender
        };
      }
      for (const maskId in channelMap) {
        const result = this._renderChannel(channelMap[maskId], {
          layerFilter,
          onViewportActive,
          views,
          viewport,
          viewportChanged
        });
        didRender ||= result;
      }
      return {
        didRender
      };
    }
    _renderChannel(channelInfo, {
      layerFilter,
      onViewportActive,
      views,
      viewport,
      viewportChanged
    }) {
      let didRender = false;
      const oldChannelInfo = this.channels[channelInfo.index];
      if (!oldChannelInfo) {
        return didRender;
      }
      const maskChanged = channelInfo === oldChannelInfo || channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some((layer, i3) => layer !== oldChannelInfo.layers[i3] || layer.props.transitions) || channelInfo.layerBounds.some((b, i3) => b !== oldChannelInfo.layerBounds[i3]);
      channelInfo.bounds = oldChannelInfo.bounds;
      channelInfo.maskBounds = oldChannelInfo.maskBounds;
      this.channels[channelInfo.index] = channelInfo;
      if (maskChanged || viewportChanged) {
        this.lastViewport = viewport;
        const layerBounds = joinLayerBounds(channelInfo.layers, viewport);
        channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);
        if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {
          const {
            maskPass,
            maskMap
          } = this;
          const maskViewport = layerBounds && makeViewport({
            bounds: channelInfo.bounds,
            viewport,
            width: maskMap.width,
            height: maskMap.height,
            border: 1
          });
          channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];
          maskPass.render({
            pass: "mask",
            channel: channelInfo.index,
            layers: channelInfo.layers,
            layerFilter,
            viewports: maskViewport ? [maskViewport] : [],
            onViewportActive,
            views,
            moduleParameters: {
              devicePixelRatio: 1
            }
          });
          didRender = true;
        }
      }
      this.masks[channelInfo.id] = {
        index: channelInfo.index,
        bounds: channelInfo.maskBounds,
        coordinateOrigin: channelInfo.coordinateOrigin,
        coordinateSystem: channelInfo.coordinateSystem
      };
      return didRender;
    }
    _sortMaskChannels(maskLayers) {
      const channelMap = {};
      let channelCount = 0;
      for (const layer of maskLayers) {
        const {
          id
        } = layer.root;
        let channelInfo = channelMap[id];
        if (!channelInfo) {
          if (++channelCount > 4) {
            log_default.warn("Too many mask layers. The max supported is 4")();
            continue;
          }
          channelInfo = {
            id,
            index: this.channels.findIndex((c) => c?.id === id),
            layers: [],
            layerBounds: [],
            coordinateOrigin: layer.root.props.coordinateOrigin,
            coordinateSystem: layer.root.props.coordinateSystem
          };
          channelMap[id] = channelInfo;
        }
        channelInfo.layers.push(layer);
        channelInfo.layerBounds.push(layer.getBounds());
      }
      for (let i3 = 0; i3 < 4; i3++) {
        const channelInfo = this.channels[i3];
        if (!channelInfo || !(channelInfo.id in channelMap)) {
          this.channels[i3] = null;
        }
      }
      for (const maskId in channelMap) {
        const channelInfo = channelMap[maskId];
        if (channelInfo.index < 0) {
          channelInfo.index = this.channels.findIndex((c) => !c);
          this.channels[channelInfo.index] = channelInfo;
        }
      }
      return channelMap;
    }
    getModuleParameters() {
      return {
        maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
        maskChannels: this.masks
      };
    }
    cleanup() {
      if (this.dummyMaskMap) {
        this.dummyMaskMap.delete();
        this.dummyMaskMap = void 0;
      }
      if (this.maskPass) {
        this.maskPass.delete();
        this.maskPass = void 0;
        this.maskMap = void 0;
      }
      this.lastViewport = void 0;
      this.masks = null;
      this.channels.length = 0;
    }
  };

  // ../extensions/src/collision-filter/collision-filter-effect.ts
  var DOWNSCALE = 2;
  var CollisionFilterEffect = class {
    id = "collision-filter-effect";
    props = null;
    useInPicking = true;
    order = 1;
    channels = {};
    collisionFBOs = {};
    preRender(gl, {
      effects: allEffects,
      layers,
      layerFilter,
      viewports,
      onViewportActive,
      views,
      isPicking,
      preRenderStats = {}
    }) {
      if (!this.dummyCollisionMap) {
        this.dummyCollisionMap = new Texture2D(gl, {
          width: 1,
          height: 1
        });
      }
      if (isPicking) {
        return;
      }
      const collisionLayers = layers.filter(
        ({
          props: {
            visible,
            collisionEnabled
          }
        }) => visible && collisionEnabled
      );
      if (collisionLayers.length === 0) {
        this.channels = {};
        return;
      }
      if (!this.collisionFilterPass) {
        this.collisionFilterPass = new CollisionFilterPass(gl, {
          id: "default-collision-filter"
        });
      }
      const effects = allEffects?.filter((e2) => e2.constructor === MaskEffect);
      const maskEffectRendered = preRenderStats["mask-effect"]?.didRender;
      const channels = this._groupByCollisionGroup(gl, collisionLayers);
      const viewport = viewports[0];
      const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;
      for (const collisionGroup in channels) {
        const collisionFBO = this.collisionFBOs[collisionGroup];
        const renderInfo = channels[collisionGroup];
        collisionFBO.resize({
          width: gl.canvas.width / DOWNSCALE,
          height: gl.canvas.height / DOWNSCALE
        });
        this._render(renderInfo, {
          effects,
          layerFilter,
          onViewportActive,
          views,
          viewport,
          viewportChanged
        });
      }
    }
    _render(renderInfo, {
      effects,
      layerFilter,
      onViewportActive,
      views,
      viewport,
      viewportChanged
    }) {
      const {
        collisionGroup
      } = renderInfo;
      const oldRenderInfo = this.channels[collisionGroup];
      if (!oldRenderInfo) {
        return;
      }
      const needsRender = viewportChanged || renderInfo === oldRenderInfo || !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) || renderInfo.layerBounds.some((b, i3) => !equals(b, oldRenderInfo.layerBounds[i3])) || renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded || renderInfo.layers.some((layer) => layer.props.transitions);
      this.channels[collisionGroup] = renderInfo;
      if (needsRender) {
        this.lastViewport = viewport;
        const collisionFBO = this.collisionFBOs[collisionGroup];
        this.collisionFilterPass.renderCollisionMap(collisionFBO, {
          pass: "collision-filter",
          isPicking: true,
          layers: renderInfo.layers,
          effects,
          layerFilter,
          viewports: viewport ? [viewport] : [],
          onViewportActive,
          views,
          moduleParameters: {
            dummyCollisionMap: this.dummyCollisionMap,
            devicePixelRatio: cssToDeviceRatio(collisionFBO.gl) / DOWNSCALE
          }
        });
      }
    }
    _groupByCollisionGroup(gl, collisionLayers) {
      const channelMap = {};
      for (const layer of collisionLayers) {
        const {
          collisionGroup
        } = layer.props;
        let channelInfo = channelMap[collisionGroup];
        if (!channelInfo) {
          channelInfo = {
            collisionGroup,
            layers: [],
            layerBounds: [],
            allLayersLoaded: true
          };
          channelMap[collisionGroup] = channelInfo;
        }
        channelInfo.layers.push(layer);
        channelInfo.layerBounds.push(layer.getBounds());
        if (!layer.isLoaded) {
          channelInfo.allLayersLoaded = false;
        }
      }
      for (const collisionGroup of Object.keys(channelMap)) {
        if (!this.collisionFBOs[collisionGroup]) {
          this.createFBO(gl, collisionGroup);
        }
        if (!this.channels[collisionGroup]) {
          this.channels[collisionGroup] = channelMap[collisionGroup];
        }
      }
      for (const collisionGroup of Object.keys(this.collisionFBOs)) {
        if (!channelMap[collisionGroup]) {
          this.destroyFBO(collisionGroup);
        }
      }
      return channelMap;
    }
    getModuleParameters(layer) {
      const {
        collisionGroup
      } = layer.props;
      const {
        collisionFBOs,
        dummyCollisionMap
      } = this;
      return {
        collisionFBO: collisionFBOs[collisionGroup],
        dummyCollisionMap
      };
    }
    cleanup() {
      if (this.dummyCollisionMap) {
        this.dummyCollisionMap.delete();
        this.dummyCollisionMap = void 0;
      }
      this.channels = {};
      for (const collisionGroup of Object.keys(this.collisionFBOs)) {
        this.destroyFBO(collisionGroup);
      }
      this.collisionFBOs = {};
      this.lastViewport = void 0;
    }
    createFBO(gl, collisionGroup) {
      const {
        width,
        height
      } = gl.canvas;
      const collisionMap = new Texture2D(gl, {
        width,
        height,
        parameters: {
          [gl.TEXTURE_MIN_FILTER]: gl.NEAREST,
          [gl.TEXTURE_MAG_FILTER]: gl.NEAREST,
          [gl.TEXTURE_WRAP_S]: gl.CLAMP_TO_EDGE,
          [gl.TEXTURE_WRAP_T]: gl.CLAMP_TO_EDGE
        }
      });
      const depthBuffer = new Renderbuffer(gl, {
        format: gl.DEPTH_COMPONENT16,
        width,
        height
      });
      this.collisionFBOs[collisionGroup] = new Framebuffer(gl, {
        id: `Collision-${collisionGroup}`,
        width,
        height,
        attachments: {
          [gl.COLOR_ATTACHMENT0]: collisionMap,
          [gl.DEPTH_ATTACHMENT]: depthBuffer
        }
      });
    }
    destroyFBO(collisionGroup) {
      const fbo = this.collisionFBOs[collisionGroup];
      for (const attachment of Object.values(fbo.attachments)) {
        attachment.delete();
      }
      fbo.delete();
      delete this.collisionFBOs[collisionGroup];
    }
  };

  // ../extensions/src/collision-filter/collision-filter-extension.ts
  var defaultProps37 = {
    getCollisionPriority: {
      type: "accessor",
      value: 0
    },
    collisionEnabled: true,
    collisionGroup: {
      type: "string",
      value: "default"
    },
    collisionTestProps: {}
  };
  var CollisionFilterExtension = class extends LayerExtension {
    getShaders() {
      return {
        modules: [shader_module_default2]
      };
    }
    draw({
      uniforms,
      context,
      moduleParameters
    }) {
      const {
        collisionEnabled
      } = this.props;
      const {
        collisionFBO,
        drawToCollisionMap
      } = moduleParameters;
      const enabled = collisionEnabled && Boolean(collisionFBO);
      uniforms.collision_enabled = enabled;
      if (drawToCollisionMap) {
        this.props = this.clone(this.props.collisionTestProps).props;
      }
    }
    initializeState(context, extension) {
      if (this.getAttributeManager() === null) {
        return;
      }
      this.context.deck?._addDefaultEffect(new CollisionFilterEffect());
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        collisionPriorities: {
          size: 1,
          accessor: "getCollisionPriority",
          shaderAttributes: {
            collisionPriorities: {
              divisor: 0
            },
            instanceCollisionPriorities: {
              divisor: 1
            }
          }
        }
      });
    }
    getNeedsPickingBuffer() {
      return this.props.collisionEnabled;
    }
  };
  __publicField(CollisionFilterExtension, "defaultProps", defaultProps37);
  __publicField(CollisionFilterExtension, "extensionName", "CollisionFilterExtension");

  // ../extensions/src/mask/shader-module.ts
  var vs11 = `
uniform vec4 mask_bounds;
uniform bool mask_maskByInstance;
vec2 mask_getCoords(vec4 position) {
  return (position.xy - mask_bounds.xy) / (mask_bounds.zw - mask_bounds.xy);
}
`;
  var fs7 = `
uniform sampler2D mask_texture;
uniform int mask_channel;
uniform bool mask_enabled;
uniform bool mask_inverted;
bool mask_isInBounds(vec2 texCoords) {
  if (!mask_enabled) {
    return true;
  }
  vec4 maskColor = texture2D(mask_texture, texCoords);
  float maskValue = 1.0;
  if (mask_channel == 0) {
    maskValue = maskColor.r;
  } else if (mask_channel == 1) {
    maskValue = maskColor.g;
  } else if (mask_channel == 2) {
    maskValue = maskColor.b;
  } else if (mask_channel == 3) {
    maskValue = maskColor.a;
  }

  if (mask_inverted) {
    return maskValue >= 0.5;
  } else {
    return maskValue < 0.5;
  }
}
`;
  var inject5 = {
    "vs:#decl": `
varying vec2 mask_texCoords;
`,
    "vs:#main-end": `
   vec4 mask_common_position;
   if (mask_maskByInstance) {
     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));
   } else {
     mask_common_position = geometry.position;
   }
   mask_texCoords = mask_getCoords(mask_common_position);
`,
    "fs:#decl": `
varying vec2 mask_texCoords;
`,
    "fs:#main-start": `
  if (mask_enabled) {
    bool mask = mask_isInBounds(mask_texCoords);

    // Debug: show extent of render target
    // gl_FragColor = vec4(mask_texCoords, 0.0, 1.0);
    gl_FragColor = texture2D(mask_texture, mask_texCoords);

    if (!mask) discard;
  }
`
  };
  var getMaskUniforms = (opts) => {
    if (opts && "maskMap" in opts) {
      return {
        mask_texture: opts.maskMap
      };
    }
    return {};
  };
  var shader_module_default3 = {
    name: "mask",
    dependencies: [project_default],
    vs: vs11,
    fs: fs7,
    inject: inject5,
    getUniforms: getMaskUniforms
  };

  // ../extensions/src/mask/mask-extension.ts
  var defaultProps38 = {
    maskId: "",
    maskByInstance: void 0,
    maskInverted: false
  };
  var MaskExtension = class extends LayerExtension {
    initializeState() {
      this.context.deck?._addDefaultEffect(new MaskEffect());
    }
    getShaders() {
      let maskByInstance = "instancePositions" in this.getAttributeManager().attributes;
      if (this.props.maskByInstance !== void 0) {
        maskByInstance = Boolean(this.props.maskByInstance);
      }
      this.state.maskByInstance = maskByInstance;
      return {
        modules: [shader_module_default3]
      };
    }
    draw({
      uniforms,
      context,
      moduleParameters
    }) {
      uniforms.mask_maskByInstance = this.state.maskByInstance;
      const {
        maskId,
        maskInverted
      } = this.props;
      const {
        maskChannels
      } = moduleParameters;
      const {
        viewport
      } = context;
      if (maskChannels && maskChannels[maskId]) {
        const {
          index,
          bounds,
          coordinateOrigin: fromCoordinateOrigin
        } = maskChannels[maskId];
        let {
          coordinateSystem: fromCoordinateSystem
        } = maskChannels[maskId];
        uniforms.mask_enabled = true;
        uniforms.mask_channel = index;
        uniforms.mask_inverted = maskInverted;
        if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
          fromCoordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
        }
        const opts = {
          modelMatrix: null,
          fromCoordinateOrigin,
          fromCoordinateSystem
        };
        const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);
        const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);
        uniforms.mask_bounds = [bl[0], bl[1], tr[0], tr[1]];
      } else {
        if (maskId) {
          log_default.warn(`Could not find a mask layer with id: ${maskId}`)();
        }
        uniforms.mask_enabled = false;
      }
    }
  };
  __publicField(MaskExtension, "defaultProps", defaultProps38);
  __publicField(MaskExtension, "extensionName", "MaskExtension");

  // ../extensions/src/terrain/shader-module.ts
  var TERRAIN_MODE = {
    NONE: 0,
    WRITE_HEIGHT_MAP: 1,
    USE_HEIGHT_MAP: 2,
    USE_COVER: 3,
    USE_COVER_ONLY: 4,
    SKIP: 5
  };
  var TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE).map((key) => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`).join("\n");
  var terrainModule = {
    name: "terrain",
    dependencies: [project_default],
    inject: {
      "vs:#decl": `
uniform float terrain_mode;
uniform sampler2D terrain_map;
uniform vec4 terrain_bounds;
varying vec3 commonPos;
${TERRAIN_MODE_CONSTANTS}
    `,
      "vs:#main-start": `
if (terrain_mode == TERRAIN_MODE_SKIP) {
  gl_Position = vec4(0.0);
  return;
}
`,
      "vs:DECKGL_FILTER_GL_POSITION": `
commonPos = geometry.position.xyz;
if (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;
  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);
  commonPos.z += project_uCommonOrigin.z;
}
if (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {
  vec3 anchor = geometry.worldPosition;
  anchor.z = 0.0;
  vec3 anchorCommon = project_position(anchor);
  vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;
  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {
    float terrainZ = texture2D(terrain_map, texCoords).r;
    geometry.position.z += terrainZ;
    position = project_common_position_to_clipspace(geometry.position);
  }
}
    `,
      "fs:#decl": `
uniform float terrain_mode;
uniform sampler2D terrain_map;
uniform vec4 terrain_bounds;
varying vec3 commonPos;
${TERRAIN_MODE_CONSTANTS}
    `,
      "fs:#main-start": `
if (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
  gl_FragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);
  return;
}
    `,
      "fs:DECKGL_FILTER_COLOR": `
if ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {
  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;
  vec4 pixel = texture2D(terrain_map, texCoords);
  if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {
    color = pixel;
  } else {
    // pixel is premultiplied
    color = pixel + color * (1.0 - pixel.a);
  }
  return;
}
    `
    },
    getUniforms: (opts = {}, uniforms) => {
      if ("dummyHeightMap" in opts) {
        const {
          drawToTerrainHeightMap,
          heightMap,
          heightMapBounds,
          dummyHeightMap,
          terrainCover,
          useTerrainHeightMap,
          terrainSkipRender
        } = opts;
        const {
          project_uCommonOrigin
        } = uniforms;
        let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;
        let sampler = dummyHeightMap;
        let bounds = null;
        if (drawToTerrainHeightMap) {
          mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;
          bounds = heightMapBounds;
        } else if (useTerrainHeightMap && heightMap) {
          mode = TERRAIN_MODE.USE_HEIGHT_MAP;
          sampler = heightMap;
          bounds = heightMapBounds;
        } else if (terrainCover) {
          const isPicking = opts.pickingActive;
          sampler = isPicking ? terrainCover.getPickingFramebuffer() : terrainCover.getRenderFramebuffer();
          if (isPicking) {
            mode = TERRAIN_MODE.SKIP;
          }
          if (sampler) {
            mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;
            bounds = terrainCover.bounds;
          } else {
            sampler = dummyHeightMap;
          }
        }
        return {
          terrain_mode: mode,
          terrain_map: sampler,
          terrain_bounds: bounds ? [bounds[0] - project_uCommonOrigin[0], bounds[1] - project_uCommonOrigin[1], bounds[2] - bounds[0], bounds[3] - bounds[1]] : [0, 0, 0, 0]
        };
      }
      return null;
    }
  };

  // ../extensions/src/terrain/utils.ts
  function createRenderTarget(gl, opts) {
    return new Framebuffer(gl, {
      id: opts.id,
      attachments: {
        [gl.COLOR_ATTACHMENT0]: new Texture2D(gl, {
          ...opts.float && {
            format: isWebGL2(gl) ? esm_default2.RGBA32F : esm_default2.RGBA,
            type: esm_default2.FLOAT
          },
          mipmaps: false,
          parameters: {
            [gl.TEXTURE_MIN_FILTER]: gl.LINEAR,
            [gl.TEXTURE_MAG_FILTER]: gl.LINEAR,
            [gl.TEXTURE_WRAP_S]: gl.CLAMP_TO_EDGE,
            [gl.TEXTURE_WRAP_T]: gl.CLAMP_TO_EDGE
          }
        })
      }
    });
  }

  // ../extensions/src/terrain/terrain-cover.ts
  var TerrainCover = class {
    isDirty = true;
    renderViewport = null;
    bounds = null;
    layers = [];
    targetBounds = null;
    targetBoundsCommon = null;
    constructor(targetLayer) {
      this.targetLayer = targetLayer;
      this.tile = getTile(targetLayer);
    }
    get id() {
      return this.targetLayer.id;
    }
    get isActive() {
      return Boolean(this.targetLayer.getCurrentLayer());
    }
    shouldUpdate({
      targetLayer,
      viewport,
      layers,
      layerNeedsRedraw
    }) {
      if (targetLayer) {
        this.targetLayer = targetLayer;
      }
      const sizeChanged = viewport ? this._updateViewport(viewport) : false;
      let layersChanged = layers ? this._updateLayers(layers) : false;
      if (layerNeedsRedraw) {
        for (const id of this.layers) {
          if (layerNeedsRedraw[id]) {
            layersChanged = true;
            break;
          }
        }
      }
      return layersChanged || sizeChanged;
    }
    _updateLayers(layers) {
      let needsRedraw = false;
      layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;
      if (layers.length !== this.layers.length) {
        needsRedraw = true;
      } else {
        for (let i3 = 0; i3 < layers.length; i3++) {
          const id = layers[i3].id;
          if (id !== this.layers[i3]) {
            needsRedraw = true;
            break;
          }
        }
      }
      if (needsRedraw) {
        this.layers = layers.map((layer) => layer.id);
      }
      return needsRedraw;
    }
    _updateViewport(viewport) {
      const targetLayer = this.targetLayer;
      let shouldRedraw = false;
      if (this.tile && "boundingBox" in this.tile) {
        if (!this.targetBounds) {
          shouldRedraw = true;
          this.targetBounds = this.tile.boundingBox;
          const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);
          const topRightCommon = viewport.projectPosition(this.targetBounds[1]);
          this.targetBoundsCommon = [bottomLeftCommon[0], bottomLeftCommon[1], topRightCommon[0], topRightCommon[1]];
        }
      } else if (this.targetBounds !== targetLayer.getBounds()) {
        shouldRedraw = true;
        this.targetBounds = targetLayer.getBounds();
        this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);
      }
      if (!this.targetBoundsCommon) {
        return false;
      }
      const newZoom = Math.ceil(viewport.zoom + 0.5);
      if (this.tile) {
        this.bounds = this.targetBoundsCommon;
      } else {
        const oldZoom = this.renderViewport?.zoom;
        shouldRedraw = shouldRedraw || newZoom !== oldZoom;
        const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);
        const oldBounds = this.bounds;
        shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x2, i3) => x2 !== oldBounds[i3]);
        this.bounds = newBounds;
      }
      if (shouldRedraw) {
        this.renderViewport = makeViewport({
          bounds: this.bounds,
          zoom: newZoom,
          viewport
        });
      }
      return shouldRedraw;
    }
    getRenderFramebuffer() {
      if (!this.renderViewport || this.layers.length === 0) {
        return null;
      }
      if (!this.fbo) {
        this.fbo = createRenderTarget(this.targetLayer.context.gl, {
          id: this.id
        });
      }
      return this.fbo;
    }
    getPickingFramebuffer() {
      if (!this.renderViewport || this.layers.length === 0 && !this.targetLayer.props.pickable) {
        return null;
      }
      if (!this.pickingFbo) {
        this.pickingFbo = createRenderTarget(this.targetLayer.context.gl, {
          id: `${this.id}-picking`
        });
      }
      return this.pickingFbo;
    }
    filterLayers(layers) {
      return layers.filter(({
        id
      }) => this.layers.includes(id));
    }
    delete() {
      const {
        fbo,
        pickingFbo
      } = this;
      if (fbo) {
        fbo.texture.delete();
        fbo.delete();
      }
      if (pickingFbo) {
        pickingFbo.texture.delete();
        pickingFbo.delete();
      }
    }
  };
  function getIntersectingLayers(sourceTile, layers) {
    return layers.filter((layer) => {
      const tile = getTile(layer);
      if (tile) {
        return intersect2(sourceTile.boundingBox, tile.boundingBox);
      }
      return true;
    });
  }
  function getTile(layer) {
    while (layer) {
      const {
        tile
      } = layer.props;
      if (tile) {
        return tile;
      }
      layer = layer.parent;
    }
    return null;
  }
  function intersect2(b1, b2) {
    if (b1 && b2) {
      return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];
    }
    return false;
  }

  // ../extensions/src/terrain/terrain-pass.ts
  var TerrainPass = class extends LayersPass {
    getRenderableLayers(viewport, opts) {
      const {
        layers
      } = opts;
      const result = [];
      const drawParamsByIndex = this._getDrawLayerParams(viewport, opts, true);
      for (let i3 = 0; i3 < layers.length; i3++) {
        const layer = layers[i3];
        if (!layer.isComposite && drawParamsByIndex[i3].shouldDrawLayer) {
          result.push(layer);
        }
      }
      return result;
    }
    renderHeightMap(heightMap, opts) {
      const target = heightMap.getRenderFramebuffer();
      const viewport = heightMap.renderViewport;
      if (!target || !viewport) {
        return;
      }
      target.resize(viewport);
      withParameters(this.gl, {
        clearColor: [0, 0, 0, 0],
        blend: true,
        blendFunc: [esm_default2.ONE, esm_default2.ONE],
        blendEquation: esm_default2.MAX,
        depthTest: false
      }, () => this.render({
        ...opts,
        target,
        pass: "terrain-height-map",
        layers: opts.layers,
        viewports: [viewport],
        effects: []
      }));
    }
    renderTerrainCover(terrainCover, opts) {
      const target = terrainCover.getRenderFramebuffer();
      const viewport = terrainCover.renderViewport;
      if (!target || !viewport) {
        return;
      }
      const layers = terrainCover.filterLayers(opts.layers);
      target.resize(viewport);
      withParameters(this.gl, {
        depthTest: false
      }, () => this.render({
        ...opts,
        target,
        pass: `terrain-cover-${terrainCover.id}`,
        layers,
        effects: [],
        viewports: [viewport]
      }));
    }
  };

  // ../extensions/src/terrain/terrain-picking-pass.ts
  var TerrainPickingPass = class extends PickLayersPass {
    drawParameters = {};
    getRenderableLayers(viewport, opts) {
      const {
        layers
      } = opts;
      const result = [];
      this.drawParameters = {};
      this._resetColorEncoder(opts.pickZ);
      const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);
      for (let i3 = 0; i3 < layers.length; i3++) {
        const layer = layers[i3];
        if (!layer.isComposite && drawParamsByIndex[i3].shouldDrawLayer) {
          result.push(layer);
          this.drawParameters[layer.id] = drawParamsByIndex[i3].layerParameters;
        }
      }
      return result;
    }
    renderTerrainCover(terrainCover, opts) {
      const target = terrainCover.getPickingFramebuffer();
      const viewport = terrainCover.renderViewport;
      if (!target || !viewport) {
        return;
      }
      const layers = terrainCover.filterLayers(opts.layers);
      const terrainLayer = terrainCover.targetLayer;
      if (terrainLayer.props.pickable) {
        layers.unshift(terrainLayer);
      }
      target.resize(viewport);
      withParameters(this.gl, {
        depthTest: false
      }, () => this.render({
        ...opts,
        pickingFBO: target,
        pass: `terrain-cover-picking-${terrainCover.id}`,
        layers,
        effects: [],
        viewports: [viewport],
        cullRect: void 0,
        deviceRect: viewport,
        pickZ: false
      }));
    }
    getLayerParameters(layer, layerIndex, viewport) {
      if (this.drawParameters[layer.id]) {
        return this.drawParameters[layer.id];
      }
      const parameters2 = super.getLayerParameters(layer, layerIndex, viewport);
      parameters2.blend = true;
      return parameters2;
    }
  };

  // ../extensions/src/terrain/height-map-builder.ts
  var MAP_MAX_SIZE = 2048;
  var HeightMapBuilder = class {
    renderViewport = null;
    bounds = null;
    layers = [];
    layersBounds = [];
    layersBoundsCommon = null;
    lastViewport = null;
    static isSupported(gl) {
      return Framebuffer.isSupported(gl, {
        colorBufferFloat: true
      });
    }
    constructor(gl) {
      this.gl = gl;
    }
    getRenderFramebuffer() {
      if (!this.renderViewport) {
        return null;
      }
      if (!this.fbo) {
        this.fbo = createRenderTarget(this.gl, {
          id: "height-map",
          float: true
        });
      }
      return this.fbo;
    }
    shouldUpdate({
      layers,
      viewport
    }) {
      const layersChanged = layers.length !== this.layers.length || layers.some((layer, i3) => layer !== this.layers[i3] || layer.props.transitions || layer.getBounds() !== this.layersBounds[i3]);
      if (layersChanged) {
        this.layers = layers;
        this.layersBounds = layers.map((layer) => layer.getBounds());
        this.layersBoundsCommon = joinLayerBounds(layers, viewport);
      }
      const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);
      if (!this.layersBoundsCommon) {
        this.renderViewport = null;
      } else if (layersChanged || viewportChanged) {
        const bounds = getRenderBounds(this.layersBoundsCommon, viewport);
        if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
          this.renderViewport = null;
          return false;
        }
        this.bounds = bounds;
        this.lastViewport = viewport;
        const scale8 = viewport.scale;
        const pixelWidth = (bounds[2] - bounds[0]) * scale8;
        const pixelHeight = (bounds[3] - bounds[1]) * scale8;
        this.renderViewport = pixelWidth > 0 || pixelHeight > 0 ? makeViewport({
          bounds: [viewport.center[0] - 1, viewport.center[1] - 1, viewport.center[0] + 1, viewport.center[1] + 1],
          zoom: viewport.zoom,
          width: Math.min(pixelWidth, MAP_MAX_SIZE),
          height: Math.min(pixelHeight, MAP_MAX_SIZE),
          viewport
        }) : null;
        return true;
      }
      return false;
    }
    delete() {
      if (this.fbo) {
        this.fbo.color.delete();
        this.fbo.delete();
      }
    }
  };

  // ../extensions/src/terrain/terrain-effect.ts
  var TerrainEffect = class {
    id = "terrain-effect";
    props = null;
    useInPicking = true;
    isPicking = false;
    isDrapingEnabled = false;
    terrainCovers = /* @__PURE__ */ new Map();
    initialize(gl) {
      this.dummyHeightMap = new Texture2D(gl, {
        width: 1,
        height: 1,
        data: new Uint8Array([0, 0, 0, 0])
      });
      this.terrainPass = new TerrainPass(gl, {
        id: "terrain"
      });
      this.terrainPickingPass = new TerrainPickingPass(gl, {
        id: "terrain-picking"
      });
      if (HeightMapBuilder.isSupported(gl)) {
        this.heightMap = new HeightMapBuilder(gl);
      } else {
        log_default.warn("Terrain offset mode is not supported by this browser")();
      }
      ProgramManager.getDefaultProgramManager(gl).addDefaultModule(terrainModule);
    }
    preRender(gl, opts) {
      if (!this.dummyHeightMap) {
        this.initialize(gl);
        for (const layer of opts.layers) {
          if (layer.props.operation.includes("terrain")) {
            layer.setChangeFlags({
              extensionsChanged: true
            });
          }
        }
      }
      if (opts.pickZ) {
        this.isDrapingEnabled = false;
        return;
      }
      const {
        viewports,
        isPicking = false
      } = opts;
      this.isPicking = isPicking;
      this.isDrapingEnabled = true;
      const viewport = viewports[0];
      const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(viewport, opts);
      const terrainLayers = layers.filter((l2) => l2.props.operation.includes("terrain"));
      if (terrainLayers.length === 0) {
        return;
      }
      if (!isPicking) {
        const offsetLayers = layers.filter((l2) => l2.state.terrainDrawMode === "offset");
        if (offsetLayers.length > 0) {
          this._updateHeightMap(terrainLayers, viewport, opts);
        }
      }
      const drapeLayers = layers.filter((l2) => l2.state.terrainDrawMode === "drape");
      this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);
    }
    getModuleParameters(layer) {
      const {
        terrainDrawMode
      } = layer.state;
      return {
        heightMap: this.heightMap?.getRenderFramebuffer(),
        heightMapBounds: this.heightMap?.bounds,
        dummyHeightMap: this.dummyHeightMap,
        terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,
        useTerrainHeightMap: terrainDrawMode === "offset",
        terrainSkipRender: terrainDrawMode === "drape" || !layer.props.operation.includes("draw")
      };
    }
    cleanup() {
      if (this.dummyHeightMap) {
        this.dummyHeightMap.delete();
        this.dummyHeightMap = void 0;
      }
      if (this.heightMap) {
        this.heightMap.delete();
        this.heightMap = void 0;
      }
      for (const terrainCover of this.terrainCovers.values()) {
        terrainCover.delete();
      }
      this.terrainCovers.clear();
    }
    _updateHeightMap(terrainLayers, viewport, opts) {
      if (!this.heightMap) {
        return;
      }
      const shouldUpdate = this.heightMap.shouldUpdate({
        layers: terrainLayers,
        viewport
      });
      if (!shouldUpdate) {
        return;
      }
      this.terrainPass.renderHeightMap(this.heightMap, {
        ...opts,
        layers: terrainLayers,
        moduleParameters: {
          heightMapBounds: this.heightMap.bounds,
          dummyHeightMap: this.dummyHeightMap,
          devicePixelRatio: 1,
          drawToTerrainHeightMap: true
        }
      });
    }
    _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {
      const layerNeedsRedraw = {};
      for (const layer of drapeLayers) {
        if (layer.state.terrainCoverNeedsRedraw) {
          layerNeedsRedraw[layer.id] = true;
          layer.state.terrainCoverNeedsRedraw = false;
        }
      }
      for (const terrainCover of this.terrainCovers.values()) {
        terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({
          layerNeedsRedraw
        });
      }
      for (const layer of terrainLayers) {
        this._updateTerrainCover(layer, drapeLayers, viewport, opts);
      }
      if (!this.isPicking) {
        this._pruneTerrainCovers();
      }
    }
    _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {
      const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;
      let terrainCover = this.terrainCovers.get(terrainLayer.id);
      if (!terrainCover) {
        terrainCover = new TerrainCover(terrainLayer);
        this.terrainCovers.set(terrainLayer.id, terrainCover);
      }
      try {
        const isDirty = terrainCover.shouldUpdate({
          targetLayer: terrainLayer,
          viewport,
          layers: drapeLayers
        });
        if (this.isPicking || terrainCover.isDirty || isDirty) {
          renderPass.renderTerrainCover(terrainCover, {
            ...opts,
            layers: drapeLayers,
            moduleParameters: {
              dummyHeightMap: this.dummyHeightMap,
              terrainSkipRender: false,
              devicePixelRatio: 1
            }
          });
          terrainCover.isDirty = false;
        }
      } catch (err) {
        terrainLayer.raiseError(err, `Error rendering terrain cover ${terrainCover.id}`);
      }
    }
    _pruneTerrainCovers() {
      const idsToRemove = [];
      for (const [id, terrainCover] of this.terrainCovers) {
        if (!terrainCover.isActive) {
          idsToRemove.push(id);
        }
      }
      for (const id of idsToRemove) {
        this.terrainCovers.delete(id);
      }
    }
  };

  // ../extensions/src/terrain/terrain-extension.ts
  var defaultProps39 = {
    terrainDrawMode: void 0
  };
  var TerrainExtension = class extends LayerExtension {
    getShaders() {
      return {
        modules: [terrainModule]
      };
    }
    initializeState() {
      this.context.deck?._addDefaultEffect(new TerrainEffect());
    }
    updateState(params) {
      const {
        props,
        oldProps
      } = params;
      if (this.state.terrainDrawMode && props.terrainDrawMode === oldProps.terrainDrawMode && props.extruded === oldProps.extruded) {
        return;
      }
      let {
        terrainDrawMode
      } = props;
      if (!terrainDrawMode) {
        const is3d = this.props.extruded;
        const attributes = this.getAttributeManager()?.attributes;
        const hasAnchor = attributes && "instancePositions" in attributes;
        terrainDrawMode = is3d || hasAnchor ? "offset" : "drape";
      }
      this.setState({
        terrainDrawMode
      });
    }
    onNeedsRedraw() {
      const state = this.state;
      if (state.terrainDrawMode === "drape") {
        state.terrainCoverNeedsRedraw = true;
      }
    }
  };
  __publicField(TerrainExtension, "defaultProps", defaultProps39);
  __publicField(TerrainExtension, "extensionName", "TerrainExtension");

  // ../../node_modules/@loaders.gl/gis/dist/esm/lib/flat-geojson-to-binary.js
  function flatGeojsonToBinary(features, geometryInfo, options) {
    const propArrayTypes = extractNumericPropTypes(features);
    const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);
    return fillArrays(features, {
      propArrayTypes,
      ...geometryInfo
    }, {
      numericPropKeys: options && options.numericPropKeys || numericPropKeys,
      PositionDataType: options ? options.PositionDataType : Float32Array
    });
  }
  function extractNumericPropTypes(features) {
    const propArrayTypes = {};
    for (const feature of features) {
      if (feature.properties) {
        for (const key in feature.properties) {
          const val2 = feature.properties[key];
          propArrayTypes[key] = deduceArrayType(val2, propArrayTypes[key]);
        }
      }
    }
    return propArrayTypes;
  }
  function fillArrays(features, geometryInfo, options) {
    const {
      pointPositionsCount,
      pointFeaturesCount,
      linePositionsCount,
      linePathsCount,
      lineFeaturesCount,
      polygonPositionsCount,
      polygonObjectsCount,
      polygonRingsCount,
      polygonFeaturesCount,
      propArrayTypes,
      coordLength
    } = geometryInfo;
    const {
      numericPropKeys = [],
      PositionDataType = Float32Array
    } = options;
    const hasGlobalId = features[0] && "id" in features[0];
    const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
    const points = {
      type: "Point",
      positions: new PositionDataType(pointPositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
      featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const lines = {
      type: "LineString",
      pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
      positions: new PositionDataType(linePositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
      featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const polygons = {
      type: "Polygon",
      polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
      primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
      positions: new PositionDataType(polygonPositionsCount * coordLength),
      triangles: [],
      globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
      featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    for (const object of [points, lines, polygons]) {
      for (const propName of numericPropKeys) {
        const T = propArrayTypes[propName];
        object.numericProps[propName] = new T(object.positions.length / coordLength);
      }
    }
    lines.pathIndices[linePathsCount] = linePositionsCount;
    polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
    polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
    const indexMap = {
      pointPosition: 0,
      pointFeature: 0,
      linePosition: 0,
      linePath: 0,
      lineFeature: 0,
      polygonPosition: 0,
      polygonObject: 0,
      polygonRing: 0,
      polygonFeature: 0,
      feature: 0
    };
    for (const feature of features) {
      const geometry = feature.geometry;
      const properties = feature.properties || {};
      switch (geometry.type) {
        case "Point":
          handlePoint(geometry, points, indexMap, coordLength, properties);
          points.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            points.fields.push({
              id: feature.id
            });
          }
          indexMap.pointFeature++;
          break;
        case "LineString":
          handleLineString(geometry, lines, indexMap, coordLength, properties);
          lines.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            lines.fields.push({
              id: feature.id
            });
          }
          indexMap.lineFeature++;
          break;
        case "Polygon":
          handlePolygon(geometry, polygons, indexMap, coordLength, properties);
          polygons.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            polygons.fields.push({
              id: feature.id
            });
          }
          indexMap.polygonFeature++;
          break;
        default:
          throw new Error("Invalid geometry type");
      }
      indexMap.feature++;
    }
    return makeAccessorObjects(points, lines, polygons, coordLength);
  }
  function handlePoint(geometry, points, indexMap, coordLength, properties) {
    points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
    points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
    points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
    indexMap.pointPosition += nPositions;
  }
  function handleLineString(geometry, lines, indexMap, coordLength, properties) {
    lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
    lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);
    lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);
    for (let i3 = 0, il = geometry.indices.length; i3 < il; ++i3) {
      const start = geometry.indices[i3];
      const end = i3 === il - 1 ? geometry.data.length : geometry.indices[i3 + 1];
      lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
      indexMap.linePosition += (end - start) / coordLength;
    }
  }
  function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
    polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
    polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
    polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
    for (let l2 = 0, ll = geometry.indices.length; l2 < ll; ++l2) {
      const startPosition = indexMap.polygonPosition;
      polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
      const areas = geometry.areas[l2];
      const indices = geometry.indices[l2];
      const nextIndices = geometry.indices[l2 + 1];
      for (let i3 = 0, il = indices.length; i3 < il; ++i3) {
        const start = indices[i3];
        const end = i3 === il - 1 ? nextIndices === void 0 ? geometry.data.length : nextIndices[0] : indices[i3 + 1];
        polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
        indexMap.polygonPosition += (end - start) / coordLength;
      }
      const endPosition = indexMap.polygonPosition;
      triangulatePolygon(polygons, areas, indices, {
        startPosition,
        endPosition,
        coordLength
      });
    }
  }
  function triangulatePolygon(polygons, areas, indices, _ref) {
    let {
      startPosition,
      endPosition,
      coordLength
    } = _ref;
    const start = startPosition * coordLength;
    const end = endPosition * coordLength;
    const polygonPositions = polygons.positions.subarray(start, end);
    const offset = indices[0];
    const holes = indices.slice(1).map((n2) => (n2 - offset) / coordLength);
    const triangles = earcut(polygonPositions, holes, coordLength, areas);
    for (let t2 = 0, tl = triangles.length; t2 < tl; ++t2) {
      polygons.triangles.push(startPosition + triangles[t2]);
    }
  }
  function wrapProps(obj, size) {
    const returnObj = {};
    for (const key in obj) {
      returnObj[key] = {
        value: obj[key],
        size
      };
    }
    return returnObj;
  }
  function makeAccessorObjects(points, lines, polygons, coordLength) {
    return {
      points: {
        ...points,
        positions: {
          value: points.positions,
          size: coordLength
        },
        globalFeatureIds: {
          value: points.globalFeatureIds,
          size: 1
        },
        featureIds: {
          value: points.featureIds,
          size: 1
        },
        numericProps: wrapProps(points.numericProps, 1)
      },
      lines: {
        ...lines,
        positions: {
          value: lines.positions,
          size: coordLength
        },
        pathIndices: {
          value: lines.pathIndices,
          size: 1
        },
        globalFeatureIds: {
          value: lines.globalFeatureIds,
          size: 1
        },
        featureIds: {
          value: lines.featureIds,
          size: 1
        },
        numericProps: wrapProps(lines.numericProps, 1)
      },
      polygons: {
        ...polygons,
        positions: {
          value: polygons.positions,
          size: coordLength
        },
        polygonIndices: {
          value: polygons.polygonIndices,
          size: 1
        },
        primitivePolygonIndices: {
          value: polygons.primitivePolygonIndices,
          size: 1
        },
        triangles: {
          value: new Uint32Array(polygons.triangles),
          size: 1
        },
        globalFeatureIds: {
          value: polygons.globalFeatureIds,
          size: 1
        },
        featureIds: {
          value: polygons.featureIds,
          size: 1
        },
        numericProps: wrapProps(polygons.numericProps, 1)
      }
    };
  }
  function fillNumericProperties(object, properties, index, length7) {
    for (const numericPropName in object.numericProps) {
      if (numericPropName in properties) {
        const value = properties[numericPropName];
        object.numericProps[numericPropName].fill(value, index, index + length7);
      }
    }
  }
  function keepStringProperties(properties, numericKeys) {
    const props = {};
    for (const key in properties) {
      if (!numericKeys.includes(key)) {
        props[key] = properties[key];
      }
    }
    return props;
  }
  function deduceArrayType(x2, constructor) {
    if (constructor === Array || !Number.isFinite(x2)) {
      return Array;
    }
    return constructor === Float64Array || Math.fround(x2) !== x2 ? Float64Array : Float32Array;
  }

  // ../../node_modules/@loaders.gl/gis/dist/esm/lib/binary-to-geojson.js
  function binaryToGeojson(data, options) {
    const globalFeatureId = options === null || options === void 0 ? void 0 : options.globalFeatureId;
    if (globalFeatureId !== void 0) {
      return getSingleFeature(data, globalFeatureId);
    }
    return parseFeatures(data, options === null || options === void 0 ? void 0 : options.type);
  }
  function getSingleFeature(data, globalFeatureId) {
    const dataArray = normalizeInput(data);
    for (const data2 of dataArray) {
      let lastIndex = 0;
      let lastValue = data2.featureIds.value[0];
      for (let i3 = 0; i3 < data2.featureIds.value.length; i3++) {
        const currValue = data2.featureIds.value[i3];
        if (currValue === lastValue) {
          continue;
        }
        if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
          return parseFeature(data2, lastIndex, i3);
        }
        lastIndex = i3;
        lastValue = currValue;
      }
      if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
        return parseFeature(data2, lastIndex, data2.featureIds.value.length);
      }
    }
    throw new Error("featureId:".concat(globalFeatureId, " not found"));
  }
  function parseFeatures(data, type) {
    const dataArray = normalizeInput(data, type);
    return parseFeatureCollection(dataArray);
  }
  function binaryToGeometry(data, startIndex, endIndex) {
    switch (data.type) {
      case "Point":
        return pointToGeoJson(data, startIndex, endIndex);
      case "LineString":
        return lineStringToGeoJson(data, startIndex, endIndex);
      case "Polygon":
        return polygonToGeoJson(data, startIndex, endIndex);
      default:
        const unexpectedInput = data;
        throw new Error("Unsupported geometry type: ".concat(unexpectedInput === null || unexpectedInput === void 0 ? void 0 : unexpectedInput.type));
    }
  }
  function normalizeInput(data, type) {
    const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);
    if (!isHeterogeneousType) {
      data.type = type || parseType(data);
      return [data];
    }
    const features = [];
    if (data.points) {
      data.points.type = "Point";
      features.push(data.points);
    }
    if (data.lines) {
      data.lines.type = "LineString";
      features.push(data.lines);
    }
    if (data.polygons) {
      data.polygons.type = "Polygon";
      features.push(data.polygons);
    }
    return features;
  }
  function parseFeatureCollection(dataArray) {
    const features = [];
    for (const data of dataArray) {
      if (data.featureIds.value.length === 0) {
        continue;
      }
      let lastIndex = 0;
      let lastValue = data.featureIds.value[0];
      for (let i3 = 0; i3 < data.featureIds.value.length; i3++) {
        const currValue = data.featureIds.value[i3];
        if (currValue === lastValue) {
          continue;
        }
        features.push(parseFeature(data, lastIndex, i3));
        lastIndex = i3;
        lastValue = currValue;
      }
      features.push(parseFeature(data, lastIndex, data.featureIds.value.length));
    }
    return features;
  }
  function parseFeature(data, startIndex, endIndex) {
    const geometry = binaryToGeometry(data, startIndex, endIndex);
    const properties = parseProperties(data, startIndex, endIndex);
    const fields = parseFields(data, startIndex, endIndex);
    return {
      type: "Feature",
      geometry,
      properties,
      ...fields
    };
  }
  function parseFields(data) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let endIndex = arguments.length > 2 ? arguments[2] : void 0;
    return data.fields && data.fields[data.featureIds.value[startIndex]];
  }
  function parseProperties(data) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let endIndex = arguments.length > 2 ? arguments[2] : void 0;
    const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);
    for (const key in data.numericProps) {
      properties[key] = data.numericProps[key].value[startIndex];
    }
    return properties;
  }
  function polygonToGeoJson(data) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -Infinity;
    let endIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
    const {
      positions
    } = data;
    const polygonIndices = data.polygonIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
    const primitivePolygonIndices = data.primitivePolygonIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
    const multi = polygonIndices.length > 2;
    if (!multi) {
      const coordinates2 = [];
      for (let i3 = 0; i3 < primitivePolygonIndices.length - 1; i3++) {
        const startRingIndex = primitivePolygonIndices[i3];
        const endRingIndex = primitivePolygonIndices[i3 + 1];
        const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);
        coordinates2.push(ringCoordinates);
      }
      return {
        type: "Polygon",
        coordinates: coordinates2
      };
    }
    const coordinates = [];
    for (let i3 = 0; i3 < polygonIndices.length - 1; i3++) {
      const startPolygonIndex = polygonIndices[i3];
      const endPolygonIndex = polygonIndices[i3 + 1];
      const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;
      coordinates.push(polygonCoordinates);
    }
    return {
      type: "MultiPolygon",
      coordinates
    };
  }
  function lineStringToGeoJson(data) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -Infinity;
    let endIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
    const {
      positions
    } = data;
    const pathIndices = data.pathIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
    const multi = pathIndices.length > 2;
    if (!multi) {
      const coordinates2 = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);
      return {
        type: "LineString",
        coordinates: coordinates2
      };
    }
    const coordinates = [];
    for (let i3 = 0; i3 < pathIndices.length - 1; i3++) {
      const ringCoordinates = ringToGeoJson(positions, pathIndices[i3], pathIndices[i3 + 1]);
      coordinates.push(ringCoordinates);
    }
    return {
      type: "MultiLineString",
      coordinates
    };
  }
  function pointToGeoJson(data, startIndex, endIndex) {
    const {
      positions
    } = data;
    const coordinates = ringToGeoJson(positions, startIndex, endIndex);
    const multi = coordinates.length > 1;
    if (multi) {
      return {
        type: "MultiPoint",
        coordinates
      };
    }
    return {
      type: "Point",
      coordinates: coordinates[0]
    };
  }
  function ringToGeoJson(positions, startIndex, endIndex) {
    startIndex = startIndex || 0;
    endIndex = endIndex || positions.value.length / positions.size;
    const ringCoordinates = [];
    for (let j = startIndex; j < endIndex; j++) {
      const coord = Array();
      for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {
        coord.push(Number(positions.value[k]));
      }
      ringCoordinates.push(coord);
    }
    return ringCoordinates;
  }
  function parseType(data) {
    if (data.pathIndices) {
      return "LineString";
    }
    if (data.polygonIndices) {
      return "Polygon";
    }
    return "Point";
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/parse-mvt.js
  var import_pbf = __toESM(require_pbf());

  // ../../node_modules/@loaders.gl/mvt/dist/esm/helpers/mapbox-util-functions.js
  function classifyRings(rings) {
    const len3 = rings.length;
    if (len3 <= 1)
      return [rings];
    const polygons = [];
    let polygon;
    let ccw;
    for (let i3 = 0; i3 < len3; i3++) {
      const area2 = signedArea(rings[i3]);
      if (area2 === 0)
        continue;
      if (ccw === void 0)
        ccw = area2 < 0;
      if (ccw === area2 < 0) {
        if (polygon)
          polygons.push(polygon);
        polygon = [rings[i3]];
      } else if (polygon)
        polygon.push(rings[i3]);
    }
    if (polygon)
      polygons.push(polygon);
    return polygons;
  }
  function signedArea(ring) {
    let sum = 0;
    for (let i3 = 0, j = ring.length - 1, p1, p2; i3 < ring.length; j = i3++) {
      p1 = ring[i3];
      p2 = ring[j];
      sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }
    return sum;
  }
  function readFeature(tag, feature, pbf) {
    if (feature && pbf) {
      if (tag === 1)
        feature.id = pbf.readVarint();
      else if (tag === 2)
        readTag(pbf, feature);
      else if (tag === 3)
        feature.type = pbf.readVarint();
      else if (tag === 4)
        feature._geometry = pbf.pos;
    }
  }
  function readTag(pbf, feature) {
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const key = feature._keys[pbf.readVarint()];
      const value = feature._values[pbf.readVarint()];
      feature.properties[key] = value;
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile-feature.js
  var VectorTileFeature = class {
    static get types() {
      return ["Unknown", "Point", "LineString", "Polygon"];
    }
    constructor(pbf, end, extent, keys, values) {
      _defineProperty(this, "properties", void 0);
      _defineProperty(this, "extent", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "_pbf", void 0);
      _defineProperty(this, "_geometry", void 0);
      _defineProperty(this, "_keys", void 0);
      _defineProperty(this, "_values", void 0);
      this.properties = {};
      this.extent = extent;
      this.type = 0;
      this.id = null;
      this._pbf = pbf;
      this._geometry = -1;
      this._keys = keys;
      this._values = values;
      pbf.readFields(readFeature, this, end);
    }
    loadGeometry() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      const end = pbf.readVarint() + pbf.pos;
      let cmd2 = 1;
      let length7 = 0;
      let x2 = 0;
      let y2 = 0;
      const lines = [];
      let line;
      while (pbf.pos < end) {
        if (length7 <= 0) {
          const cmdLen2 = pbf.readVarint();
          cmd2 = cmdLen2 & 7;
          length7 = cmdLen2 >> 3;
        }
        length7--;
        if (cmd2 === 1 || cmd2 === 2) {
          x2 += pbf.readSVarint();
          y2 += pbf.readSVarint();
          if (cmd2 === 1) {
            if (line)
              lines.push(line);
            line = [];
          }
          if (line)
            line.push([x2, y2]);
        } else if (cmd2 === 7) {
          if (line) {
            line.push(line[0].slice());
          }
        } else {
          throw new Error("unknown command ".concat(cmd2));
        }
      }
      if (line)
        lines.push(line);
      return lines;
    }
    bbox() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      const end = pbf.readVarint() + pbf.pos;
      let cmd2 = 1;
      let length7 = 0;
      let x2 = 0;
      let y2 = 0;
      let x1 = Infinity;
      let x22 = -Infinity;
      let y1 = Infinity;
      let y22 = -Infinity;
      while (pbf.pos < end) {
        if (length7 <= 0) {
          const cmdLen2 = pbf.readVarint();
          cmd2 = cmdLen2 & 7;
          length7 = cmdLen2 >> 3;
        }
        length7--;
        if (cmd2 === 1 || cmd2 === 2) {
          x2 += pbf.readSVarint();
          y2 += pbf.readSVarint();
          if (x2 < x1)
            x1 = x2;
          if (x2 > x22)
            x22 = x2;
          if (y2 < y1)
            y1 = y2;
          if (y2 > y22)
            y22 = y2;
        } else if (cmd2 !== 7) {
          throw new Error("unknown command ".concat(cmd2));
        }
      }
      return [x1, y1, x22, y22];
    }
    _toGeoJSON(transform3) {
      let coords = this.loadGeometry();
      let type = VectorTileFeature.types[this.type];
      let i3;
      let j;
      switch (this.type) {
        case 1:
          const points = [];
          for (i3 = 0; i3 < coords.length; i3++) {
            points[i3] = coords[i3][0];
          }
          coords = points;
          transform3(coords, this);
          break;
        case 2:
          for (i3 = 0; i3 < coords.length; i3++) {
            transform3(coords[i3], this);
          }
          break;
        case 3:
          coords = classifyRings(coords);
          for (i3 = 0; i3 < coords.length; i3++) {
            for (j = 0; j < coords[i3].length; j++) {
              transform3(coords[i3][j], this);
            }
          }
          break;
      }
      if (coords.length === 1) {
        coords = coords[0];
      } else {
        type = "Multi".concat(type);
      }
      const result = {
        type: "Feature",
        geometry: {
          type,
          coordinates: coords
        },
        properties: this.properties
      };
      if (this.id !== null) {
        result.id = this.id;
      }
      return result;
    }
    toGeoJSON(options) {
      if (typeof options === "function") {
        return this._toGeoJSON(options);
      }
      const {
        x: x2,
        y: y2,
        z
      } = options;
      const size = this.extent * Math.pow(2, z);
      const x0 = this.extent * x2;
      const y0 = this.extent * y2;
      function project3(line) {
        for (let j = 0; j < line.length; j++) {
          const p2 = line[j];
          p2[0] = (p2[0] + x0) * 360 / size - 180;
          const y22 = 180 - (p2[1] + y0) * 360 / size;
          p2[1] = 360 / Math.PI * Math.atan(Math.exp(y22 * Math.PI / 180)) - 90;
        }
      }
      return this._toGeoJSON(project3);
    }
  };

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile-layer.js
  var VectorTileLayer = class {
    constructor(pbf, end) {
      _defineProperty(this, "version", void 0);
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "extent", void 0);
      _defineProperty(this, "length", void 0);
      _defineProperty(this, "_pbf", void 0);
      _defineProperty(this, "_keys", void 0);
      _defineProperty(this, "_values", void 0);
      _defineProperty(this, "_features", void 0);
      this.version = 1;
      this.name = "";
      this.extent = 4096;
      this.length = 0;
      this._pbf = pbf;
      this._keys = [];
      this._values = [];
      this._features = [];
      pbf.readFields(readLayer, this, end);
      this.length = this._features.length;
    }
    feature(i3) {
      if (i3 < 0 || i3 >= this._features.length) {
        throw new Error("feature index out of bounds");
      }
      this._pbf.pos = this._features[i3];
      const end = this._pbf.readVarint() + this._pbf.pos;
      return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
    }
  };
  function readLayer(tag, layer, pbf) {
    if (layer && pbf) {
      if (tag === 15)
        layer.version = pbf.readVarint();
      else if (tag === 1)
        layer.name = pbf.readString();
      else if (tag === 5)
        layer.extent = pbf.readVarint();
      else if (tag === 2)
        layer._features.push(pbf.pos);
      else if (tag === 3)
        layer._keys.push(pbf.readString());
      else if (tag === 4)
        layer._values.push(readValueMessage(pbf));
    }
  }
  function readValueMessage(pbf) {
    let value = null;
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }
    return value;
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/mapbox-vector-tile/vector-tile.js
  var VectorTile = class {
    constructor(pbf, end) {
      _defineProperty(this, "layers", void 0);
      this.layers = pbf.readFields(readTile, {}, end);
    }
  };
  function readTile(tag, layers, pbf) {
    if (tag === 3) {
      if (pbf) {
        const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length && layers) {
          layers[layer.name] = layer;
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/helpers/binary-util-functions.js
  function classifyRings2(geom) {
    const len3 = geom.indices.length;
    const type = "Polygon";
    if (len3 <= 1) {
      return {
        type,
        data: geom.data,
        areas: [[getPolygonSignedArea(geom.data)]],
        indices: [geom.indices]
      };
    }
    const areas = [];
    const polygons = [];
    let ringAreas = [];
    let polygon = [];
    let ccw;
    let offset = 0;
    for (let endIndex, i3 = 0, startIndex; i3 < len3; i3++) {
      startIndex = geom.indices[i3] - offset;
      endIndex = geom.indices[i3 + 1] - offset || geom.data.length;
      const shape = geom.data.slice(startIndex, endIndex);
      const area2 = getPolygonSignedArea(shape);
      if (area2 === 0) {
        const before = geom.data.slice(0, startIndex);
        const after = geom.data.slice(endIndex);
        geom.data = before.concat(after);
        offset += endIndex - startIndex;
        continue;
      }
      if (ccw === void 0)
        ccw = area2 < 0;
      if (ccw === area2 < 0) {
        if (polygon.length) {
          areas.push(ringAreas);
          polygons.push(polygon);
        }
        polygon = [startIndex];
        ringAreas = [area2];
      } else {
        ringAreas.push(area2);
        polygon.push(startIndex);
      }
    }
    if (ringAreas)
      areas.push(ringAreas);
    if (polygon.length)
      polygons.push(polygon);
    return {
      type,
      areas,
      indices: polygons,
      data: geom.data
    };
  }
  function project2(data, x0, y0, size) {
    for (let j = 0, jl = data.length; j < jl; j += 2) {
      data[j] = (data[j] + x0) * 360 / size - 180;
      const y2 = 180 - (data[j + 1] + y0) * 360 / size;
      data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
    }
  }
  function readFeature2(tag, feature, pbf) {
    if (feature && pbf) {
      if (tag === 1)
        feature.id = pbf.readVarint();
      else if (tag === 2)
        readTag2(pbf, feature);
      else if (tag === 3)
        feature.type = pbf.readVarint();
      else if (tag === 4)
        feature._geometry = pbf.pos;
    }
  }
  function readTag2(pbf, feature) {
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const key = feature._keys[pbf.readVarint()];
      const value = feature._values[pbf.readVarint()];
      feature.properties[key] = value;
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile-feature.js
  var endPos;
  var cmd;
  var cmdLen;
  var length6;
  var x;
  var y;
  var i2;
  var VectorTileFeature2 = class {
    constructor(pbf, end, extent, keys, values, geometryInfo) {
      _defineProperty(this, "properties", void 0);
      _defineProperty(this, "extent", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "_pbf", void 0);
      _defineProperty(this, "_geometry", void 0);
      _defineProperty(this, "_keys", void 0);
      _defineProperty(this, "_values", void 0);
      _defineProperty(this, "_geometryInfo", void 0);
      this.properties = {};
      this.extent = extent;
      this.type = 0;
      this.id = null;
      this._pbf = pbf;
      this._geometry = -1;
      this._keys = keys;
      this._values = values;
      this._geometryInfo = geometryInfo;
      pbf.readFields(readFeature2, this, end);
    }
    loadGeometry() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      endPos = pbf.readVarint() + pbf.pos;
      cmd = 1;
      length6 = 0;
      x = 0;
      y = 0;
      i2 = 0;
      const indices = [];
      const data = [];
      while (pbf.pos < endPos) {
        if (length6 <= 0) {
          cmdLen = pbf.readVarint();
          cmd = cmdLen & 7;
          length6 = cmdLen >> 3;
        }
        length6--;
        if (cmd === 1 || cmd === 2) {
          x += pbf.readSVarint();
          y += pbf.readSVarint();
          if (cmd === 1) {
            indices.push(i2);
          }
          data.push(x, y);
          i2 += 2;
        } else if (cmd === 7) {
          if (i2 > 0) {
            const start = indices[indices.length - 1];
            data.push(data[start], data[start + 1]);
            i2 += 2;
          }
        } else {
          throw new Error("unknown command ".concat(cmd));
        }
      }
      return {
        data,
        indices
      };
    }
    _toBinaryCoordinates(transform3) {
      const geom = this.loadGeometry();
      let geometry;
      transform3(geom.data, this);
      const coordLength = 2;
      switch (this.type) {
        case 1:
          this._geometryInfo.pointFeaturesCount++;
          this._geometryInfo.pointPositionsCount += geom.indices.length;
          geometry = {
            type: "Point",
            ...geom
          };
          break;
        case 2:
          this._geometryInfo.lineFeaturesCount++;
          this._geometryInfo.linePathsCount += geom.indices.length;
          this._geometryInfo.linePositionsCount += geom.data.length / coordLength;
          geometry = {
            type: "LineString",
            ...geom
          };
          break;
        case 3:
          geometry = classifyRings2(geom);
          this._geometryInfo.polygonFeaturesCount++;
          this._geometryInfo.polygonObjectsCount += geometry.indices.length;
          for (const indices of geometry.indices) {
            this._geometryInfo.polygonRingsCount += indices.length;
          }
          this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;
          break;
        default:
          throw new Error("Invalid geometry type: ".concat(this.type));
      }
      const result = {
        type: "Feature",
        geometry,
        properties: this.properties
      };
      if (this.id !== null) {
        result.id = this.id;
      }
      return result;
    }
    toBinaryCoordinates(options) {
      if (typeof options === "function") {
        return this._toBinaryCoordinates(options);
      }
      const {
        x: x2,
        y: y2,
        z
      } = options;
      const size = this.extent * Math.pow(2, z);
      const x0 = this.extent * x2;
      const y0 = this.extent * y2;
      return this._toBinaryCoordinates((data) => project2(data, x0, y0, size));
    }
  };

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile-layer.js
  var VectorTileLayer2 = class {
    constructor(pbf, end) {
      _defineProperty(this, "version", void 0);
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "extent", void 0);
      _defineProperty(this, "length", void 0);
      _defineProperty(this, "_pbf", void 0);
      _defineProperty(this, "_keys", void 0);
      _defineProperty(this, "_values", void 0);
      _defineProperty(this, "_features", void 0);
      this.version = 1;
      this.name = "";
      this.extent = 4096;
      this.length = 0;
      this._pbf = pbf;
      this._keys = [];
      this._values = [];
      this._features = [];
      pbf.readFields(readLayer2, this, end);
      this.length = this._features.length;
    }
    feature(i3, geometryInfo) {
      if (i3 < 0 || i3 >= this._features.length) {
        throw new Error("feature index out of bounds");
      }
      this._pbf.pos = this._features[i3];
      const end = this._pbf.readVarint() + this._pbf.pos;
      return new VectorTileFeature2(this._pbf, end, this.extent, this._keys, this._values, geometryInfo);
    }
  };
  function readLayer2(tag, layer, pbf) {
    if (layer && pbf) {
      if (tag === 15)
        layer.version = pbf.readVarint();
      else if (tag === 1)
        layer.name = pbf.readString();
      else if (tag === 5)
        layer.extent = pbf.readVarint();
      else if (tag === 2)
        layer._features.push(pbf.pos);
      else if (tag === 3)
        layer._keys.push(pbf.readString());
      else if (tag === 4)
        layer._values.push(readValueMessage2(pbf));
    }
  }
  function readValueMessage2(pbf) {
    let value = null;
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }
    return value;
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/binary-vector-tile/vector-tile.js
  var VectorTile2 = class {
    constructor(pbf, end) {
      _defineProperty(this, "layers", void 0);
      this.layers = pbf.readFields(readTile2, {}, end);
    }
  };
  function readTile2(tag, layers, pbf) {
    if (tag === 3) {
      if (pbf) {
        const layer = new VectorTileLayer2(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length && layers) {
          layers[layer.name] = layer;
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/lib/parse-mvt.js
  function parseMVT(arrayBuffer2, options) {
    var _options$gis, _options$mvt;
    const mvtOptions = normalizeOptions2(options);
    const shape = (options === null || options === void 0 ? void 0 : (_options$gis = options.gis) === null || _options$gis === void 0 ? void 0 : _options$gis.format) || (options === null || options === void 0 ? void 0 : (_options$mvt = options.mvt) === null || _options$mvt === void 0 ? void 0 : _options$mvt.shape);
    switch (shape) {
      case "columnar-table":
        return {
          shape: "columnar-table",
          data: parseToBinary(arrayBuffer2, mvtOptions)
        };
      case "geojson-row-table": {
        const table = {
          shape: "geojson-row-table",
          data: parseToGeojson(arrayBuffer2, mvtOptions)
        };
        return table;
      }
      case "geojson":
        return parseToGeojson(arrayBuffer2, mvtOptions);
      case "binary-geometry":
        return parseToBinary(arrayBuffer2, mvtOptions);
      case "binary":
        return parseToBinary(arrayBuffer2, mvtOptions);
      default:
        throw new Error(shape);
    }
  }
  function parseToBinary(arrayBuffer2, options) {
    const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer2, options);
    const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);
    binaryData.byteLength = arrayBuffer2.byteLength;
    return binaryData;
  }
  function parseToFlatGeoJson(arrayBuffer2, options) {
    const features = [];
    const geometryInfo = {
      coordLength: 2,
      pointPositionsCount: 0,
      pointFeaturesCount: 0,
      linePositionsCount: 0,
      linePathsCount: 0,
      lineFeaturesCount: 0,
      polygonPositionsCount: 0,
      polygonObjectsCount: 0,
      polygonRingsCount: 0,
      polygonFeaturesCount: 0
    };
    if (arrayBuffer2.byteLength <= 0) {
      return [features, geometryInfo];
    }
    const tile = new VectorTile2(new import_pbf.default(arrayBuffer2));
    const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
    selectedLayers.forEach((layerName) => {
      const vectorTileLayer = tile.layers[layerName];
      if (!vectorTileLayer) {
        return;
      }
      for (let i3 = 0; i3 < vectorTileLayer.length; i3++) {
        const vectorTileFeature = vectorTileLayer.feature(i3, geometryInfo);
        const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);
        features.push(decodedFeature);
      }
    });
    return [features, geometryInfo];
  }
  function parseToGeojson(arrayBuffer2, options) {
    if (arrayBuffer2.byteLength <= 0) {
      return [];
    }
    const features = [];
    const tile = new VectorTile(new import_pbf.default(arrayBuffer2));
    const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
    selectedLayers.forEach((layerName) => {
      const vectorTileLayer = tile.layers[layerName];
      if (!vectorTileLayer) {
        return;
      }
      for (let i3 = 0; i3 < vectorTileLayer.length; i3++) {
        const vectorTileFeature = vectorTileLayer.feature(i3);
        const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);
        features.push(decodedFeature);
      }
    });
    return features;
  }
  function normalizeOptions2(options) {
    var _options$mvt2;
    if (!(options !== null && options !== void 0 && options.mvt)) {
      throw new Error("mvt options required");
    }
    const wgs84Coordinates = ((_options$mvt2 = options.mvt) === null || _options$mvt2 === void 0 ? void 0 : _options$mvt2.coordinates) === "wgs84";
    const {
      tileIndex
    } = options.mvt;
    const hasTileIndex = tileIndex && Number.isFinite(tileIndex.x) && Number.isFinite(tileIndex.y) && Number.isFinite(tileIndex.z);
    if (wgs84Coordinates && !hasTileIndex) {
      throw new Error("MVT Loader: WGS84 coordinates need tileIndex property");
    }
    return options.mvt;
  }
  function getDecodedFeature(feature, options, layerName) {
    const decodedFeature = feature.toGeoJSON(options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinates);
    if (options.layerProperty) {
      decodedFeature.properties[options.layerProperty] = layerName;
    }
    return decodedFeature;
  }
  function getDecodedFeatureBinary(feature, options, layerName) {
    const decodedFeature = feature.toBinaryCoordinates(options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinatesBinary);
    if (options.layerProperty && decodedFeature.properties) {
      decodedFeature.properties[options.layerProperty] = layerName;
    }
    return decodedFeature;
  }
  function transformToLocalCoordinates(line, feature) {
    const {
      extent
    } = feature;
    for (let i3 = 0; i3 < line.length; i3++) {
      const p2 = line[i3];
      p2[0] /= extent;
      p2[1] /= extent;
    }
  }
  function transformToLocalCoordinatesBinary(data, feature) {
    const {
      extent
    } = feature;
    for (let i3 = 0, il = data.length; i3 < il; ++i3) {
      data[i3] /= extent;
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/esm/mvt-loader.js
  var VERSION17 = true ? "3.4.2" : "latest";
  var DEFAULT_MVT_LOADER_OPTIONS = {
    mvt: {
      shape: "geojson",
      coordinates: "local",
      layerProperty: "layerName",
      layers: void 0,
      tileIndex: null
    }
  };
  var MVTWorkerLoader = {
    name: "Mapbox Vector Tile",
    id: "mvt",
    module: "mvt",
    version: VERSION17,
    extensions: ["mvt", "pbf"],
    mimeTypes: ["application/vnd.mapbox-vector-tile", "application/x-protobuf"],
    worker: true,
    category: "geometry",
    options: DEFAULT_MVT_LOADER_OPTIONS
  };
  var MVTLoader = {
    ...MVTWorkerLoader,
    parse: async (arrayBuffer2, options) => parseMVT(arrayBuffer2, options),
    parseSync: parseMVT,
    binary: true
  };

  // ../geo-layers/src/mvt-layer/coordinate-transform.ts
  var availableTransformations = {
    Point,
    MultiPoint,
    LineString,
    MultiLineString,
    Polygon: Polygon2,
    MultiPolygon
  };
  function Point([pointX2, pointY2], [nw, se], viewport) {
    const x2 = lerp(nw[0], se[0], pointX2);
    const y2 = lerp(nw[1], se[1], pointY2);
    return viewport.unprojectFlat([x2, y2]);
  }
  function getPoints(geometry, bbox, viewport) {
    return geometry.map((g) => Point(g, bbox, viewport));
  }
  function MultiPoint(multiPoint, bbox, viewport) {
    return getPoints(multiPoint, bbox, viewport);
  }
  function LineString(line, bbox, viewport) {
    return getPoints(line, bbox, viewport);
  }
  function MultiLineString(multiLineString, bbox, viewport) {
    return multiLineString.map((lineString) => LineString(lineString, bbox, viewport));
  }
  function Polygon2(polygon, bbox, viewport) {
    return polygon.map((polygonRing) => getPoints(polygonRing, bbox, viewport));
  }
  function MultiPolygon(multiPolygon, bbox, viewport) {
    return multiPolygon.map((polygon) => Polygon2(polygon, bbox, viewport));
  }
  function transform2(geometry, bbox, viewport) {
    const nw = viewport.projectFlat([bbox.west, bbox.north]);
    const se = viewport.projectFlat([bbox.east, bbox.south]);
    const projectedBbox = [nw, se];
    return {
      ...geometry,
      coordinates: availableTransformations[geometry.type](geometry.coordinates, projectedBbox, viewport)
    };
  }

  // ../geo-layers/src/mvt-layer/find-index-binary.ts
  var GEOM_TYPES = ["points", "lines", "polygons"];
  function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {
    for (const gt of GEOM_TYPES) {
      const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);
      if (index >= 0) {
        return index;
      }
    }
    return -1;
  }
  function findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {
    const featureIds = geomData.featureIds.value;
    if (!featureIds.length) {
      return -1;
    }
    let startFeatureIndex = 0;
    let endFeatureIndex = featureIds[featureIds.length - 1] + 1;
    if (layerName) {
      const layerRange = getLayerRange(geomData, layerName);
      if (layerRange) {
        startFeatureIndex = layerRange[0];
        endFeatureIndex = layerRange[1] + 1;
      } else {
        return -1;
      }
    }
    let featureIndex = -1;
    if (uniqueIdProperty in geomData.numericProps) {
      const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex((x2, i3) => x2 === featureId && featureIds[i3] >= startFeatureIndex && featureIds[i3] < endFeatureIndex);
      return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;
    } else if (uniqueIdProperty) {
      featureIndex = findIndex(geomData.properties, (elem) => elem[uniqueIdProperty] === featureId, startFeatureIndex, endFeatureIndex);
    } else if (geomData.fields) {
      featureIndex = findIndex(geomData.fields, (elem) => elem.id === featureId, startFeatureIndex, endFeatureIndex);
    }
    return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;
  }
  function getLayerRange(geomData, layerName) {
    if (!geomData.__layers) {
      const layerNames = {};
      const {
        properties
      } = geomData;
      for (let i3 = 0; i3 < properties.length; i3++) {
        const {
          layerName: key
        } = properties[i3];
        if (!key) {
        } else if (layerNames[key]) {
          layerNames[key][1] = i3;
        } else {
          layerNames[key] = [i3, i3];
        }
      }
      geomData.__layers = layerNames;
    }
    return geomData.__layers[layerName];
  }
  function getGlobalFeatureId(geomData, featureIndex) {
    if (!geomData.__ids) {
      const result = [];
      const featureIds = geomData.featureIds.value;
      const globalFeatureIds = geomData.globalFeatureIds.value;
      for (let i3 = 0; i3 < featureIds.length; i3++) {
        result[featureIds[i3]] = globalFeatureIds[i3];
      }
      geomData.__ids = result;
    }
    return geomData.__ids[featureIndex];
  }
  function findIndex(array, predicate, startIndex, endIndex) {
    for (let i3 = startIndex; i3 < endIndex; i3++) {
      if (predicate(array[i3], i3)) {
        return i3;
      }
    }
    return -1;
  }

  // ../geo-layers/src/mvt-layer/mvt-layer.ts
  var WORLD_SIZE = 512;
  var defaultProps40 = {
    ...GeoJsonLayer.defaultProps,
    data: urlType,
    onDataLoad: {
      type: "function",
      value: null,
      optional: true,
      compare: false
    },
    uniqueIdProperty: "",
    highlightedFeatureId: null,
    loaders: [MVTWorkerLoader],
    binary: true
  };
  var MVTLayer = class extends TileLayer {
    initializeState() {
      super.initializeState();
      const binary = this.context.viewport.resolution !== void 0 ? false : this.props.binary;
      this.setState({
        binary,
        data: null,
        tileJSON: null
      });
    }
    get isLoaded() {
      return this.state && this.state.data && this.state.tileset && super.isLoaded;
    }
    updateState({
      props,
      oldProps,
      context,
      changeFlags
    }) {
      if (changeFlags.dataChanged) {
        this._updateTileData();
      }
      if (this.state?.data) {
        super.updateState({
          props,
          oldProps,
          context,
          changeFlags
        });
        this._setWGS84PropertyForTiles();
      }
      const {
        highlightColor
      } = props;
      if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {
        this.setState({
          highlightColor
        });
      }
    }
    async _updateTileData() {
      let data = this.props.data;
      let tileJSON = null;
      if (typeof data === "string" && !isURLTemplate(data)) {
        const {
          onDataLoad,
          fetch: fetch2
        } = this.props;
        this.setState({
          data: null,
          tileJSON: null
        });
        try {
          tileJSON = await fetch2(data, {
            propName: "data",
            layer: this,
            loaders: []
          });
        } catch (error2) {
          this.raiseError(error2, "loading TileJSON");
          data = null;
        }
        if (onDataLoad) {
          onDataLoad(tileJSON, {
            propName: "data",
            layer: this
          });
        }
      } else if (data.tilejson) {
        tileJSON = data;
      }
      if (tileJSON) {
        data = tileJSON.tiles;
      }
      this.setState({
        data,
        tileJSON
      });
    }
    _getTilesetOptions() {
      const opts = super._getTilesetOptions();
      const tileJSON = this.state.tileJSON;
      const {
        minZoom,
        maxZoom
      } = this.props;
      if (tileJSON) {
        if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {
          opts.minZoom = tileJSON.minzoom;
        }
        if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {
          opts.maxZoom = tileJSON.maxzoom;
        }
      }
      return opts;
    }
    renderLayers() {
      if (!this.state?.data)
        return null;
      return super.renderLayers();
    }
    getTileData(loadProps) {
      const {
        data,
        binary
      } = this.state;
      const {
        index,
        signal
      } = loadProps;
      const url = getURLFromTemplate(data, loadProps);
      if (!url) {
        return Promise.reject("Invalid URL");
      }
      let loadOptions = this.getLoadOptions();
      const {
        fetch: fetch2
      } = this.props;
      loadOptions = {
        ...loadOptions,
        mimeType: "application/x-protobuf",
        mvt: {
          ...loadOptions?.mvt,
          coordinates: this.context.viewport.resolution ? "wgs84" : "local",
          tileIndex: index
        },
        gis: binary ? {
          format: "binary"
        } : {}
      };
      return fetch2(url, {
        propName: "data",
        layer: this,
        loadOptions,
        signal
      });
    }
    renderSubLayers(props) {
      const {
        x: x2,
        y: y2,
        z
      } = props.tile.index;
      const worldScale = Math.pow(2, z);
      const xScale = WORLD_SIZE / worldScale;
      const yScale = -xScale;
      const xOffset = WORLD_SIZE * x2 / worldScale;
      const yOffset = WORLD_SIZE * (1 - y2 / worldScale);
      const modelMatrix2 = new Matrix4().scale([xScale, yScale, 1]);
      props.autoHighlight = false;
      if (!this.context.viewport.resolution) {
        props.modelMatrix = modelMatrix2;
        props.coordinateOrigin = [xOffset, yOffset, 0];
        props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;
        props.extensions = [...props.extensions || [], new ClipExtension()];
      }
      const subLayers = super.renderSubLayers(props);
      if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {
        log_default.warn("renderSubLayers() must return GeoJsonLayer when using binary:true")();
      }
      return subLayers;
    }
    _updateAutoHighlight(info) {
      const {
        uniqueIdProperty
      } = this.props;
      const {
        hoveredFeatureId,
        hoveredFeatureLayerName
      } = this.state;
      const hoveredFeature = info.object;
      let newHoveredFeatureId;
      let newHoveredFeatureLayerName;
      if (hoveredFeature) {
        newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);
        newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);
      }
      let {
        highlightColor
      } = this.props;
      if (typeof highlightColor === "function") {
        highlightColor = highlightColor(info);
      }
      if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {
        this.setState({
          highlightColor,
          hoveredFeatureId: newHoveredFeatureId,
          hoveredFeatureLayerName: newHoveredFeatureLayerName
        });
      }
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      const isWGS842 = Boolean(this.context.viewport.resolution);
      if (this.state.binary && info.index !== -1) {
        const {
          data
        } = params.sourceLayer.props;
        info.object = binaryToGeojson(data, {
          globalFeatureId: info.index
        });
      }
      if (info.object && !isWGS842) {
        info.object = transformTileCoordsToWGS84(
          info.object,
          info.tile.bbox,
          this.context.viewport
        );
      }
      return info;
    }
    getSubLayerPropsByTile(tile) {
      return {
        highlightedObjectIndex: this.getHighlightedObjectIndex(tile),
        highlightColor: this.state.highlightColor
      };
    }
    getHighlightedObjectIndex(tile) {
      const {
        hoveredFeatureId,
        hoveredFeatureLayerName,
        binary
      } = this.state;
      const {
        uniqueIdProperty,
        highlightedFeatureId
      } = this.props;
      const data = tile.content;
      const isHighlighted = isFeatureIdDefined(highlightedFeatureId);
      const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;
      if (!isFeatureIdPresent) {
        return -1;
      }
      const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;
      if (Array.isArray(data)) {
        return data.findIndex((feature) => {
          const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;
          const isMatchingLayer = isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;
          return isMatchingId && isMatchingLayer;
        });
      } else if (data && binary) {
        return findIndexBinary(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? "" : hoveredFeatureLayerName);
      }
      return -1;
    }
    _pickObjects(maxObjects) {
      const {
        deck,
        viewport
      } = this.context;
      const width = viewport.width;
      const height = viewport.height;
      const x2 = viewport.x;
      const y2 = viewport.y;
      const layerIds = [this.id];
      return deck.pickObjects({
        x: x2,
        y: y2,
        width,
        height,
        layerIds,
        maxObjects
      });
    }
    getRenderedFeatures(maxFeatures = null) {
      const features = this._pickObjects(maxFeatures);
      const featureCache = /* @__PURE__ */ new Set();
      const renderedFeatures = [];
      for (const f2 of features) {
        const featureId = getFeatureUniqueId(f2.object, this.props.uniqueIdProperty);
        if (featureId === void 0) {
          renderedFeatures.push(f2.object);
        } else if (!featureCache.has(featureId)) {
          featureCache.add(featureId);
          renderedFeatures.push(f2.object);
        }
      }
      return renderedFeatures;
    }
    _setWGS84PropertyForTiles() {
      const propName = "dataInWGS84";
      const tileset = this.state.tileset;
      tileset.selectedTiles.forEach((tile) => {
        if (!tile.hasOwnProperty(propName)) {
          Object.defineProperty(tile, propName, {
            get: () => {
              if (!tile.content) {
                return null;
              }
              if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {
                return [];
              }
              const {
                bbox
              } = tile;
              if (tile._contentWGS84 === void 0 && isGeoBoundingBox(bbox)) {
                const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;
                tile._contentWGS84 = content.map((feature) => transformTileCoordsToWGS84(feature, bbox, this.context.viewport));
              }
              return tile._contentWGS84;
            }
          });
        }
      });
    }
  };
  __publicField(MVTLayer, "layerName", "MVTLayer");
  __publicField(MVTLayer, "defaultProps", defaultProps40);
  function getFeatureUniqueId(feature, uniqueIdProperty) {
    if (feature.properties && uniqueIdProperty) {
      return feature.properties[uniqueIdProperty];
    }
    if ("id" in feature) {
      return feature.id;
    }
    return void 0;
  }
  function getFeatureLayerName(feature) {
    return feature.properties?.layerName || null;
  }
  function isFeatureIdDefined(value) {
    return value !== void 0 && value !== null && value !== "";
  }
  function transformTileCoordsToWGS84(object, bbox, viewport) {
    const feature = {
      ...object,
      geometry: {
        type: object.geometry.type
      }
    };
    Object.defineProperty(feature.geometry, "coordinates", {
      get: () => {
        const wgs84Geom = transform2(object.geometry, bbox, viewport);
        return wgs84Geom.coordinates;
      }
    });
    return feature;
  }

  // ../geo-layers/src/geohash-layer/geohash-utils.ts
  var BASE32_CODES = "0123456789bcdefghjkmnpqrstuvwxyz";
  var BASE32_CODES_DICT = {};
  for (let i3 = 0; i3 < BASE32_CODES.length; i3++) {
    BASE32_CODES_DICT[BASE32_CODES.charAt(i3)] = i3;
  }
  var MIN_LAT = -90;
  var MAX_LAT = 90;
  var MIN_LON = -180;
  var MAX_LON = 180;
  function getGeohashBounds(geohash) {
    let isLon = true;
    let maxLat = MAX_LAT;
    let minLat = MIN_LAT;
    let maxLon = MAX_LON;
    let minLon = MIN_LON;
    let mid;
    let hashValue = 0;
    for (let i3 = 0, l2 = geohash.length; i3 < l2; i3++) {
      const code = geohash[i3].toLowerCase();
      hashValue = BASE32_CODES_DICT[code];
      for (let bits = 4; bits >= 0; bits--) {
        const bit = hashValue >> bits & 1;
        if (isLon) {
          mid = (maxLon + minLon) / 2;
          if (bit === 1) {
            minLon = mid;
          } else {
            maxLon = mid;
          }
        } else {
          mid = (maxLat + minLat) / 2;
          if (bit === 1) {
            minLat = mid;
          } else {
            maxLat = mid;
          }
        }
        isLon = !isLon;
      }
    }
    return [minLat, minLon, maxLat, maxLon];
  }
  function getGeohashPolygon(geohash) {
    const [s2, w, n2, e2] = getGeohashBounds(geohash);
    return [e2, n2, e2, s2, w, s2, w, n2, e2, n2];
  }

  // ../geo-layers/src/geohash-layer/geohash-layer.ts
  var defaultProps41 = {
    getGeohash: {
      type: "accessor",
      value: (d) => d.geohash
    }
  };
  var GeohashLayer = class extends GeoCellLayer {
    indexToBounds() {
      const {
        data,
        getGeohash
      } = this.props;
      return {
        data,
        _normalize: false,
        positionFormat: "XY",
        getPolygon: (x2, objectInfo) => getGeohashPolygon(getGeohash(x2, objectInfo))
      };
    }
  };
  __publicField(GeohashLayer, "layerName", "GeohashLayer");
  __publicField(GeohashLayer, "defaultProps", defaultProps41);

  // ../core/src/scripting/lumagl.ts
  var lumagl_exports = {};
  __export(lumagl_exports, {
    Buffer: () => Buffer2,
    ConeGeometry: () => ConeGeometry,
    CubeGeometry: () => CubeGeometry,
    CylinderGeometry: () => CylinderGeometry,
    FEATURES: () => FEATURES,
    Framebuffer: () => Framebuffer,
    Geometry: () => Geometry,
    IcoSphereGeometry: () => IcoSphereGeometry,
    Model: () => Model,
    PlaneGeometry: () => PlaneGeometry,
    Program: () => Program,
    ProgramManager: () => ProgramManager,
    Renderbuffer: () => Renderbuffer,
    SphereGeometry: () => SphereGeometry,
    Texture2D: () => Texture2D,
    Texture3D: () => Texture3D,
    TextureCube: () => TextureCube,
    Timeline: () => Timeline,
    Transform: () => Transform,
    TransformFeedback: () => TransformFeedback,
    TruncatedConeGeometry: () => TruncatedConeGeometry,
    cloneTextureFrom: () => cloneTextureFrom,
    copyToTexture: () => copyToTexture,
    cssToDeviceRatio: () => cssToDeviceRatio,
    getParameters: () => getParameters,
    hasFeatures: () => hasFeatures,
    instrumentGLContext: () => instrumentGLContext,
    isWebGL2: () => isWebGL2,
    readPixelsToBuffer: () => readPixelsToBuffer,
    setParameters: () => setParameters,
    withParameters: () => withParameters
  });

  // ../core/src/scripting/loadersgl.ts
  var loadersgl_exports = {};
  __export(loadersgl_exports, {
    fetchFile: () => fetchFile,
    load: () => load,
    parse: () => parse,
    registerLoaders: () => registerLoaders
  });

  // ../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  // ../../node_modules/@babel/runtime/helpers/esm/createClass.js
  function _defineProperties(target, props) {
    for (var i3 = 0; i3 < props.length; i3++) {
      var descriptor = props[i3];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  // ../../node_modules/react-map-gl/dist/esm/mapbox/mapbox.js
  var import_prop_types3 = __toESM(require_prop_types());

  // ../../node_modules/react-map-gl/dist/esm/utils/globals.js
  var window_6 = typeof window !== "undefined" ? window : global;
  var document_5 = typeof document !== "undefined" ? document : {};

  // ../../node_modules/react-map-gl/dist/esm/mapbox/mapbox.js
  function noop6() {
  }
  function defaultOnError(event) {
    if (event) {
      console.error(event.error);
    }
  }
  var propTypes = {
    container: import_prop_types3.default.object,
    gl: import_prop_types3.default.object,
    mapboxApiAccessToken: import_prop_types3.default.string,
    mapboxApiUrl: import_prop_types3.default.string,
    attributionControl: import_prop_types3.default.bool,
    preserveDrawingBuffer: import_prop_types3.default.bool,
    reuseMaps: import_prop_types3.default.bool,
    transformRequest: import_prop_types3.default.func,
    mapOptions: import_prop_types3.default.object,
    mapStyle: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.object]),
    visible: import_prop_types3.default.bool,
    asyncRender: import_prop_types3.default.bool,
    onLoad: import_prop_types3.default.func,
    onError: import_prop_types3.default.func,
    width: import_prop_types3.default.number,
    height: import_prop_types3.default.number,
    viewState: import_prop_types3.default.object,
    longitude: import_prop_types3.default.number,
    latitude: import_prop_types3.default.number,
    zoom: import_prop_types3.default.number,
    bearing: import_prop_types3.default.number,
    pitch: import_prop_types3.default.number,
    altitude: import_prop_types3.default.number
  };
  var defaultProps42 = {
    container: document_5.body,
    mapboxApiAccessToken: getAccessToken(),
    mapboxApiUrl: "https://api.mapbox.com",
    preserveDrawingBuffer: false,
    attributionControl: true,
    reuseMaps: false,
    mapOptions: {},
    mapStyle: "mapbox://styles/mapbox/light-v8",
    visible: true,
    asyncRender: false,
    onLoad: noop6,
    onError: defaultOnError,
    width: 0,
    height: 0,
    longitude: 0,
    latitude: 0,
    zoom: 0,
    bearing: 0,
    pitch: 0,
    altitude: 1.5
  };
  function getAccessToken() {
    var accessToken = null;
    if (typeof window !== "undefined" && window.location) {
      var match = window.location.search.match(/access_token=([^&\/]*)/);
      accessToken = match && match[1];
    }
    if (!accessToken && typeof process !== "undefined") {
      accessToken = accessToken || process.env.MapboxAccessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;
    }
    return accessToken || "no-token";
  }
  function checkPropTypes(props) {
    var component = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "component";
    if (props.debug) {
      import_prop_types3.default.checkPropTypes(propTypes, props, "prop", component);
    }
  }
  var Mapbox = function() {
    function Mapbox2(props) {
      var _this = this;
      _classCallCheck(this, Mapbox2);
      _defineProperty(this, "mapboxgl", void 0);
      _defineProperty(this, "props", defaultProps42);
      _defineProperty(this, "_map", null);
      _defineProperty(this, "width", 0);
      _defineProperty(this, "height", 0);
      _defineProperty(this, "_fireLoadEvent", function() {
        _this.props.onLoad({
          type: "load",
          target: _this._map
        });
      });
      if (!props.mapboxgl) {
        throw new Error("Mapbox not available");
      }
      this.mapboxgl = props.mapboxgl;
      if (!Mapbox2.initialized) {
        Mapbox2.initialized = true;
        this._checkStyleSheet(this.mapboxgl.version);
      }
      this._initialize(props);
    }
    _createClass(Mapbox2, [{
      key: "finalize",
      value: function finalize() {
        this._destroy();
        return this;
      }
    }, {
      key: "setProps",
      value: function setProps(props) {
        this._update(this.props, props);
        return this;
      }
    }, {
      key: "resize",
      value: function resize() {
        this._map.resize();
        return this;
      }
    }, {
      key: "redraw",
      value: function redraw() {
        var map2 = this._map;
        if (map2.style) {
          if (map2._frame) {
            map2._frame.cancel();
            map2._frame = null;
          }
          map2._render();
        }
      }
    }, {
      key: "getMap",
      value: function getMap() {
        return this._map;
      }
    }, {
      key: "_reuse",
      value: function _reuse(props) {
        this._map = Mapbox2.savedMap;
        var oldContainer = this._map.getContainer();
        var newContainer = props.container;
        newContainer.classList.add("mapboxgl-map");
        while (oldContainer.childNodes.length > 0) {
          newContainer.appendChild(oldContainer.childNodes[0]);
        }
        this._map._container = newContainer;
        Mapbox2.savedMap = null;
        if (props.mapStyle) {
          this._map.setStyle(props.mapStyle, {
            diff: false
          });
        }
        if (this._map.isStyleLoaded()) {
          this._fireLoadEvent();
        } else {
          this._map.once("styledata", this._fireLoadEvent);
        }
      }
    }, {
      key: "_create",
      value: function _create(props) {
        if (props.reuseMaps && Mapbox2.savedMap) {
          this._reuse(props);
        } else {
          if (props.gl) {
            var getContext = HTMLCanvasElement.prototype.getContext;
            HTMLCanvasElement.prototype.getContext = function() {
              HTMLCanvasElement.prototype.getContext = getContext;
              return props.gl;
            };
          }
          var mapOptions = {
            container: props.container,
            center: [0, 0],
            zoom: 8,
            pitch: 0,
            bearing: 0,
            maxZoom: 24,
            style: props.mapStyle,
            interactive: false,
            trackResize: false,
            attributionControl: props.attributionControl,
            preserveDrawingBuffer: props.preserveDrawingBuffer
          };
          if (props.transformRequest) {
            mapOptions.transformRequest = props.transformRequest;
          }
          this._map = new this.mapboxgl.Map(Object.assign({}, mapOptions, props.mapOptions));
          this._map.once("load", props.onLoad);
          this._map.on("error", props.onError);
        }
        return this;
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        if (!this._map) {
          return;
        }
        if (!Mapbox2.savedMap) {
          Mapbox2.savedMap = this._map;
          this._map.off("load", this.props.onLoad);
          this._map.off("error", this.props.onError);
          this._map.off("styledata", this._fireLoadEvent);
        } else {
          this._map.remove();
        }
        this._map = null;
      }
    }, {
      key: "_initialize",
      value: function _initialize(props) {
        var _this2 = this;
        props = Object.assign({}, defaultProps42, props);
        checkPropTypes(props, "Mapbox");
        this.mapboxgl.accessToken = props.mapboxApiAccessToken || defaultProps42.mapboxApiAccessToken;
        this.mapboxgl.baseApiUrl = props.mapboxApiUrl;
        this._create(props);
        var _props = props, container = _props.container;
        Object.defineProperty(container, "offsetWidth", {
          get: function get() {
            return _this2.width;
          }
        });
        Object.defineProperty(container, "clientWidth", {
          get: function get() {
            return _this2.width;
          }
        });
        Object.defineProperty(container, "offsetHeight", {
          get: function get() {
            return _this2.height;
          }
        });
        Object.defineProperty(container, "clientHeight", {
          get: function get() {
            return _this2.height;
          }
        });
        var canvas = this._map.getCanvas();
        if (canvas) {
          canvas.style.outline = "none";
        }
        this._updateMapViewport({}, props);
        this._updateMapSize({}, props);
        this.props = props;
      }
    }, {
      key: "_update",
      value: function _update(oldProps, newProps) {
        if (!this._map) {
          return;
        }
        newProps = Object.assign({}, this.props, newProps);
        checkPropTypes(newProps, "Mapbox");
        var viewportChanged = this._updateMapViewport(oldProps, newProps);
        var sizeChanged = this._updateMapSize(oldProps, newProps);
        if (!newProps.asyncRender && (viewportChanged || sizeChanged)) {
          this.redraw();
        }
        this.props = newProps;
      }
    }, {
      key: "_updateMapSize",
      value: function _updateMapSize(oldProps, newProps) {
        var sizeChanged = oldProps.width !== newProps.width || oldProps.height !== newProps.height;
        if (sizeChanged) {
          this.width = newProps.width;
          this.height = newProps.height;
          this.resize();
        }
        return sizeChanged;
      }
    }, {
      key: "_updateMapViewport",
      value: function _updateMapViewport(oldProps, newProps) {
        var oldViewState = this._getViewState(oldProps);
        var newViewState = this._getViewState(newProps);
        var viewportChanged = newViewState.latitude !== oldViewState.latitude || newViewState.longitude !== oldViewState.longitude || newViewState.zoom !== oldViewState.zoom || newViewState.pitch !== oldViewState.pitch || newViewState.bearing !== oldViewState.bearing || newViewState.altitude !== oldViewState.altitude;
        if (viewportChanged) {
          this._map.jumpTo(this._viewStateToMapboxProps(newViewState));
          if (newViewState.altitude !== oldViewState.altitude) {
            this._map.transform.altitude = newViewState.altitude;
          }
        }
        return viewportChanged;
      }
    }, {
      key: "_getViewState",
      value: function _getViewState(props) {
        var _ref = props.viewState || props, longitude = _ref.longitude, latitude = _ref.latitude, zoom = _ref.zoom, _ref$pitch = _ref.pitch, pitch = _ref$pitch === void 0 ? 0 : _ref$pitch, _ref$bearing = _ref.bearing, bearing = _ref$bearing === void 0 ? 0 : _ref$bearing, _ref$altitude = _ref.altitude, altitude = _ref$altitude === void 0 ? 1.5 : _ref$altitude;
        return {
          longitude,
          latitude,
          zoom,
          pitch,
          bearing,
          altitude
        };
      }
    }, {
      key: "_checkStyleSheet",
      value: function _checkStyleSheet() {
        var mapboxVersion = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "0.47.0";
        if (typeof document_5 === "undefined") {
          return;
        }
        try {
          var testElement = document_5.createElement("div");
          testElement.className = "mapboxgl-map";
          testElement.style.display = "none";
          document_5.body.append(testElement);
          var isCssLoaded = window.getComputedStyle(testElement).position !== "static";
          if (!isCssLoaded) {
            var link = document_5.createElement("link");
            link.setAttribute("rel", "stylesheet");
            link.setAttribute("type", "text/css");
            link.setAttribute("href", "https://api.tiles.mapbox.com/mapbox-gl-js/v".concat(mapboxVersion, "/mapbox-gl.css"));
            document_5.head.append(link);
          }
        } catch (error2) {
        }
      }
    }, {
      key: "_viewStateToMapboxProps",
      value: function _viewStateToMapboxProps(viewState) {
        return {
          center: [viewState.longitude, viewState.latitude],
          zoom: viewState.zoom,
          bearing: viewState.bearing,
          pitch: viewState.pitch
        };
      }
    }]);
    return Mapbox2;
  }();
  _defineProperty(Mapbox, "initialized", false);
  _defineProperty(Mapbox, "propTypes", propTypes);
  _defineProperty(Mapbox, "defaultProps", defaultProps42);
  _defineProperty(Mapbox, "savedMap", null);

  // ../core/src/scripting/deckgl.ts
  var CANVAS_STYLE = {
    position: "absolute",
    left: 0,
    top: 0,
    width: "100%",
    height: "100%"
  };
  function createCanvas(props) {
    let {
      container = document.body
    } = props;
    if (typeof container === "string") {
      container = document.getElementById(container);
    }
    if (!container) {
      throw Error("Deck: container not found");
    }
    const containerStyle = window.getComputedStyle(container);
    if (containerStyle.position === "static") {
      container.style.position = "relative";
    }
    const mapCanvas = document.createElement("div");
    container.appendChild(mapCanvas);
    Object.assign(mapCanvas.style, CANVAS_STYLE);
    const deckCanvas = document.createElement("canvas");
    container.appendChild(deckCanvas);
    Object.assign(deckCanvas.style, CANVAS_STYLE);
    return {
      container,
      mapCanvas,
      deckCanvas
    };
  }
  var DeckGL = class extends Deck {
    constructor(props) {
      if (typeof document === "undefined") {
        throw Error("Deck can only be used in the browser");
      }
      const {
        mapCanvas,
        deckCanvas
      } = createCanvas(props);
      const viewState = props.viewState || props.initialViewState;
      const isMap = Number.isFinite(viewState && viewState.latitude);
      const {
        map: map2 = globalThis.mapboxgl || globalThis.maplibregl
      } = props;
      super({
        canvas: deckCanvas,
        ...props
      });
      if (map2 && map2.Map) {
        this._map = isMap && new Mapbox({
          ...props,
          viewState,
          container: mapCanvas,
          mapboxgl: map2
        });
      } else {
        this._map = map2;
      }
    }
    getMapboxMap() {
      return this._map && this._map.getMap();
    }
    finalize() {
      if (this._map) {
        this._map.finalize();
      }
      super.finalize();
    }
    setProps(props) {
      if ("mapStyle" in props && this._map) {
        this._map._map.setStyle(props.mapStyle);
      }
      super.setProps(props);
    }
    _drawLayers(redrawReason, options) {
      if (this._map) {
        const viewport = this.getViewports()[0];
        this._map.setProps({
          width: viewport.width,
          height: viewport.height,
          viewState: viewport
        });
      }
      super._drawLayers(redrawReason, options);
    }
  };

  // ../core/bundle/index.ts
  globalThis.luma = globalThis.luma || {};
  globalThis.loaders = globalThis.loaders || {};
  Object.assign(globalThis.luma, lumagl_exports);
  Object.assign(globalThis.loaders, loadersgl_exports);

  // ../aggregation-layers/src/utils/aggregation-operation-utils.js
  var AGGREGATION_OPERATION = {
    SUM: 1,
    MEAN: 2,
    MIN: 3,
    MAX: 4
  };
  function sumReducer(accu, cur) {
    return accu + cur;
  }
  function maxReducer(accu, cur) {
    return cur > accu ? cur : accu;
  }
  function minReducer(accu, cur) {
    return cur < accu ? cur : accu;
  }
  function getMean(pts, accessor) {
    if (Number.isFinite(accessor)) {
      return pts.length ? accessor : null;
    }
    const filtered = pts.map(accessor).filter(Number.isFinite);
    return filtered.length ? filtered.reduce(sumReducer, 0) / filtered.length : null;
  }
  function getSum(pts, accessor) {
    if (Number.isFinite(accessor)) {
      return pts.length ? pts.length * accessor : null;
    }
    const filtered = pts.map(accessor).filter(Number.isFinite);
    return filtered.length ? filtered.reduce(sumReducer, 0) : null;
  }
  function getMax(pts, accessor) {
    if (Number.isFinite(accessor)) {
      return pts.length ? accessor : null;
    }
    const filtered = pts.map(accessor).filter(Number.isFinite);
    return filtered.length ? filtered.reduce(maxReducer, -Infinity) : null;
  }
  function getMin(pts, accessor) {
    if (Number.isFinite(accessor)) {
      return pts.length ? accessor : null;
    }
    const filtered = pts.map(accessor).filter(Number.isFinite);
    return filtered.length ? filtered.reduce(minReducer, Infinity) : null;
  }
  function getValueFunc(aggregation, accessor, context) {
    const op = AGGREGATION_OPERATION[aggregation] || AGGREGATION_OPERATION.SUM;
    accessor = wrapAccessor(accessor, context);
    switch (op) {
      case AGGREGATION_OPERATION.MIN:
        return (pts) => getMin(pts, accessor);
      case AGGREGATION_OPERATION.SUM:
        return (pts) => getSum(pts, accessor);
      case AGGREGATION_OPERATION.MEAN:
        return (pts) => getMean(pts, accessor);
      case AGGREGATION_OPERATION.MAX:
        return (pts) => getMax(pts, accessor);
      default:
        return null;
    }
  }
  function wrapAccessor(accessor, context = {}) {
    if (Number.isFinite(accessor)) {
      return accessor;
    }
    return (pt) => {
      context.index = pt.index;
      return accessor(pt.source, context);
    };
  }
  function wrapGetValueFunc(getValue2, context = {}) {
    return (pts) => {
      context.indices = pts.map((pt) => pt.index);
      return getValue2(pts.map((pt) => pt.source), context);
    };
  }

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/gpu-grid-aggregator-constants.js
  var DEFAULT_RUN_PARAMS = {
    projectPoints: false,
    viewport: null,
    createBufferObjects: true,
    moduleSettings: {}
  };
  var MAX_32_BIT_FLOAT = 3402823466e29;
  var MIN_BLEND_EQUATION = [esm_default2.MIN, esm_default2.FUNC_ADD];
  var MAX_BLEND_EQUATION = [esm_default2.MAX, esm_default2.FUNC_ADD];
  var MAX_MIN_BLEND_EQUATION = [esm_default2.MAX, esm_default2.MIN];
  var EQUATION_MAP = {
    [AGGREGATION_OPERATION.SUM]: esm_default2.FUNC_ADD,
    [AGGREGATION_OPERATION.MEAN]: esm_default2.FUNC_ADD,
    [AGGREGATION_OPERATION.MIN]: MIN_BLEND_EQUATION,
    [AGGREGATION_OPERATION.MAX]: MAX_BLEND_EQUATION
  };
  var DEFAULT_WEIGHT_PARAMS = {
    size: 1,
    operation: AGGREGATION_OPERATION.SUM,
    needMin: false,
    needMax: false,
    combineMaxMin: false
  };
  var PIXEL_SIZE = 4;
  var MAX_MIN_TEXTURE_OPTS = {
    format: esm_default2.RGBA32F,
    type: esm_default2.FLOAT,
    border: 0,
    mipmaps: false,
    parameters: {
      [esm_default2.TEXTURE_MAG_FILTER]: esm_default2.NEAREST,
      [esm_default2.TEXTURE_MIN_FILTER]: esm_default2.NEAREST
    },
    dataFormat: esm_default2.RGBA,
    width: 1,
    height: 1
  };

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/aggregate-to-grid-vs.glsl.js
  var aggregate_to_grid_vs_glsl_default = `#define SHADER_NAME gpu-aggregation-to-grid-vs

attribute vec3 positions;
attribute vec3 positions64Low;
attribute vec3 weights;
uniform vec2 cellSize;
uniform vec2 gridSize;
uniform bool projectPoints;
uniform vec2 translation;
uniform vec3 scaling;

varying vec3 vWeights;

vec2 project_to_pixel(vec4 pos) {
  vec4 result;
  pos.xy = pos.xy/pos.w;
  result = pos + vec4(translation, 0., 0.);
  result.xy = scaling.z > 0. ? result.xy * scaling.xy : result.xy;
  return result.xy;
}

void main(void) {

  vWeights = weights;

  vec4 windowPos = vec4(positions, 1.);
  if (projectPoints) {
    windowPos = project_position_to_clipspace(positions, positions64Low, vec3(0));
  }

  vec2 pos = project_to_pixel(windowPos);

  vec2 pixelXY64[2];
  pixelXY64[0] = vec2(pos.x, 0.);
  pixelXY64[1] = vec2(pos.y, 0.);

  // Transform (0,0):windowSize -> (0, 0): gridSize
  vec2 gridXY64[2];
  gridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));
  gridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));
  float x = floor(gridXY64[0].x);
  float y = floor(gridXY64[1].x);
  pos = vec2(x, y);

  // Transform (0,0):gridSize -> (-1, -1):(1,1)
  pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);

  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize
  vec2 offset = 1.0 / gridSize;
  pos = pos + offset;

  gl_Position = vec4(pos, 0.0, 1.0);

  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)
  gl_PointSize = 1.0;
}
`;

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/aggregate-to-grid-fs.glsl.js
  var aggregate_to_grid_fs_glsl_default = `#define SHADER_NAME gpu-aggregation-to-grid-fs

precision highp float;

varying vec3 vWeights;

void main(void) {
  gl_FragColor = vec4(vWeights, 1.0);
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/aggregate-all-vs.glsl.js
  var aggregate_all_vs_glsl_default = `#version 300 es
#define SHADER_NAME gpu-aggregation-all-vs-64

in vec2 position;
uniform ivec2 gridSize;
out vec2 vTextureCoord;

void main(void) {
  // Map each position to single pixel
  vec2 pos = vec2(-1.0, -1.0);

  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize
  vec2 offset = 1.0 / vec2(gridSize);
  pos = pos + offset;

  gl_Position = vec4(pos, 0.0, 1.0);

  int yIndex = gl_InstanceID / gridSize[0];
  int xIndex = gl_InstanceID - (yIndex * gridSize[0]);

  vec2 yIndexFP64 = vec2(float(yIndex), 0.);
  vec2 xIndexFP64 = vec2(float(xIndex), 0.);
  vec2 gridSizeYFP64 = vec2(gridSize[1], 0.);
  vec2 gridSizeXFP64 = vec2(gridSize[0], 0.);

  vec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);
  vec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);

  vTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);
  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)
  gl_PointSize = 1.0;
}
`;

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/aggregate-all-fs.glsl.js
  var aggregate_all_fs_glsl_default = `#version 300 es
#define SHADER_NAME gpu-aggregation-all-fs

precision highp float;

in vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform bool combineMaxMin;
out vec4 fragColor;
void main(void) {
  vec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
  if (textureColor.a == 0.) {
    discard;
  }
  fragColor.rgb = textureColor.rgb;
  // if combineMinMax is true, use Alpha channel for first weights min value.
  fragColor.a = combineMaxMin ? textureColor.r : textureColor.a;
}
`;

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/transform-mean-vs.glsl.js
  var transform_mean_vs_glsl_default = `#define SHADER_NAME gpu-aggregation-transform-mean-vs
attribute vec4 aggregationValues;
varying vec4 meanValues;

void main()
{
  // TODO: Use 64-bit division ?? not needed given this is aggregation ??
  bool isCellValid = bool(aggregationValues.w > 0.);
  // aggregationValues:  XYZ contain aggregated values, W contains count
  meanValues.xyz = isCellValid ? aggregationValues.xyz/aggregationValues.w : vec3(0, 0, 0);
  meanValues.w = aggregationValues.w;

  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)
  gl_PointSize = 1.0;
}
`;

  // ../aggregation-layers/src/utils/resource-utils.js
  var DEFAULT_PARAMETERS = {
    [esm_default2.TEXTURE_MAG_FILTER]: esm_default2.NEAREST,
    [esm_default2.TEXTURE_MIN_FILTER]: esm_default2.NEAREST
  };
  function getFloatTexture(gl, opts = {}) {
    const {
      width = 1,
      height = 1,
      data = null,
      unpackFlipY = true,
      parameters: parameters2 = DEFAULT_PARAMETERS
    } = opts;
    const texture = new Texture2D(gl, {
      data,
      format: isWebGL2(gl) ? esm_default2.RGBA32F : esm_default2.RGBA,
      type: esm_default2.FLOAT,
      border: 0,
      mipmaps: false,
      parameters: parameters2,
      dataFormat: esm_default2.RGBA,
      width,
      height,
      unpackFlipY
    });
    return texture;
  }
  function getFramebuffer4(gl, opts) {
    const {
      id,
      width = 1,
      height = 1,
      texture
    } = opts;
    const fb = new Framebuffer(gl, {
      id,
      width,
      height,
      attachments: {
        [esm_default2.COLOR_ATTACHMENT0]: texture
      }
    });
    return fb;
  }

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js
  var BUFFER_NAMES = ["aggregationBuffer", "maxMinBuffer", "minBuffer", "maxBuffer"];
  var ARRAY_BUFFER_MAP = {
    maxData: "maxBuffer",
    minData: "minBuffer",
    maxMinData: "maxMinBuffer"
  };
  var REQUIRED_FEATURES = [
    FEATURES.WEBGL2,
    FEATURES.COLOR_ATTACHMENT_RGBA32F,
    FEATURES.BLEND_EQUATION_MINMAX,
    FEATURES.FLOAT_BLEND,
    FEATURES.TEXTURE_FLOAT
  ];
  var GPUGridAggregator = class {
    static getAggregationData({
      aggregationData,
      maxData,
      minData,
      maxMinData,
      pixelIndex
    }) {
      const index = pixelIndex * PIXEL_SIZE;
      const results = {};
      if (aggregationData) {
        results.cellCount = aggregationData[index + 3];
        results.cellWeight = aggregationData[index];
      }
      if (maxMinData) {
        results.maxCellWieght = maxMinData[0];
        results.minCellWeight = maxMinData[3];
      } else {
        if (maxData) {
          results.maxCellWieght = maxData[0];
          results.totalCount = maxData[3];
        }
        if (minData) {
          results.minCellWeight = minData[0];
          results.totalCount = maxData[3];
        }
      }
      return results;
    }
    static getCellData({
      countsData,
      size = 1
    }) {
      const numCells = countsData.length / 4;
      const cellWeights = new Float32Array(numCells * size);
      const cellCounts = new Uint32Array(numCells);
      for (let i3 = 0; i3 < numCells; i3++) {
        for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {
          cellWeights[i3 * size + sizeIndex] = countsData[i3 * 4 + sizeIndex];
        }
        cellCounts[i3] = countsData[i3 * 4 + 3];
      }
      return {
        cellCounts,
        cellWeights
      };
    }
    static isSupported(gl) {
      return hasFeatures(gl, REQUIRED_FEATURES);
    }
    constructor(gl, opts = {}) {
      this.id = opts.id || "gpu-grid-aggregator";
      this.gl = gl;
      this.state = {
        weightAttributes: {},
        textures: {},
        meanTextures: {},
        buffers: {},
        framebuffers: {},
        maxMinFramebuffers: {},
        minFramebuffers: {},
        maxFramebuffers: {},
        equations: {},
        resources: {},
        results: {}
      };
      this._hasGPUSupport = isWebGL2(gl) && hasFeatures(
        this.gl,
        FEATURES.BLEND_EQUATION_MINMAX,
        FEATURES.COLOR_ATTACHMENT_RGBA32F,
        FEATURES.TEXTURE_FLOAT
      );
      if (this._hasGPUSupport) {
        this._setupModels();
      }
    }
    delete() {
      const {
        gridAggregationModel,
        allAggregationModel,
        meanTransform
      } = this;
      const {
        textures,
        framebuffers,
        maxMinFramebuffers,
        minFramebuffers,
        maxFramebuffers,
        meanTextures,
        resources
      } = this.state;
      gridAggregationModel?.delete();
      allAggregationModel?.delete();
      meanTransform?.delete();
      deleteResources([framebuffers, textures, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, resources]);
    }
    run(opts = {}) {
      this.setState({
        results: {}
      });
      const aggregationParams = this._normalizeAggregationParams(opts);
      if (!this._hasGPUSupport) {
        log_default.log(1, "GPUGridAggregator: not supported")();
      }
      return this._runAggregation(aggregationParams);
    }
    getData(weightId) {
      const data = {};
      const results = this.state.results;
      if (!results[weightId].aggregationData) {
        results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();
      }
      data.aggregationData = results[weightId].aggregationData;
      for (const arrayName in ARRAY_BUFFER_MAP) {
        const bufferName = ARRAY_BUFFER_MAP[arrayName];
        if (results[weightId][arrayName] || results[weightId][bufferName]) {
          results[weightId][arrayName] = results[weightId][arrayName] || results[weightId][bufferName].getData();
          data[arrayName] = results[weightId][arrayName];
        }
      }
      return data;
    }
    updateShaders(shaderOptions = {}) {
      this.setState({
        shaderOptions,
        modelDirty: true
      });
    }
    _normalizeAggregationParams(opts) {
      const aggregationParams = {
        ...DEFAULT_RUN_PARAMS,
        ...opts
      };
      const {
        weights
      } = aggregationParams;
      if (weights) {
        aggregationParams.weights = normalizeWeightParams(weights);
      }
      return aggregationParams;
    }
    setState(updateObject) {
      Object.assign(this.state, updateObject);
    }
    _getAggregateData(opts) {
      const results = {};
      const {
        textures,
        framebuffers,
        maxMinFramebuffers,
        minFramebuffers,
        maxFramebuffers,
        resources
      } = this.state;
      const {
        weights
      } = opts;
      for (const id in weights) {
        results[id] = {};
        const {
          needMin,
          needMax,
          combineMaxMin
        } = weights[id];
        results[id].aggregationTexture = textures[id];
        results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {
          target: weights[id].aggregationBuffer,
          sourceType: esm_default2.FLOAT
        });
        if (needMin && needMax && combineMaxMin) {
          results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {
            target: weights[id].maxMinBuffer,
            sourceType: esm_default2.FLOAT
          });
          results[id].maxMinTexture = resources[`${id}-maxMinTexture`];
        } else {
          if (needMin) {
            results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {
              target: weights[id].minBuffer,
              sourceType: esm_default2.FLOAT
            });
            results[id].minTexture = resources[`${id}-minTexture`];
          }
          if (needMax) {
            results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {
              target: weights[id].maxBuffer,
              sourceType: esm_default2.FLOAT
            });
            results[id].maxTexture = resources[`${id}-maxTexture`];
          }
        }
      }
      this._trackGPUResultBuffers(results, weights);
      return results;
    }
    _renderAggregateData(opts) {
      const {
        cellSize,
        projectPoints,
        attributes,
        moduleSettings,
        numCol,
        numRow,
        weights,
        translation,
        scaling
      } = opts;
      const {
        maxMinFramebuffers,
        minFramebuffers,
        maxFramebuffers
      } = this.state;
      const gridSize = [numCol, numRow];
      const parameters2 = {
        blend: true,
        depthTest: false,
        blendFunc: [esm_default2.ONE, esm_default2.ONE]
      };
      const uniforms = {
        cellSize,
        gridSize,
        projectPoints,
        translation,
        scaling
      };
      for (const id in weights) {
        const {
          needMin,
          needMax
        } = weights[id];
        const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;
        this._renderToWeightsTexture({
          id,
          parameters: parameters2,
          moduleSettings,
          uniforms,
          gridSize,
          attributes,
          weights
        });
        if (combineMaxMin) {
          this._renderToMaxMinTexture({
            id,
            parameters: {
              ...parameters2,
              blendEquation: MAX_MIN_BLEND_EQUATION
            },
            gridSize,
            minOrMaxFb: maxMinFramebuffers[id],
            clearParams: {
              clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]
            },
            combineMaxMin
          });
        } else {
          if (needMin) {
            this._renderToMaxMinTexture({
              id,
              parameters: {
                ...parameters2,
                blendEquation: MIN_BLEND_EQUATION
              },
              gridSize,
              minOrMaxFb: minFramebuffers[id],
              clearParams: {
                clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]
              },
              combineMaxMin
            });
          }
          if (needMax) {
            this._renderToMaxMinTexture({
              id,
              parameters: {
                ...parameters2,
                blendEquation: MAX_BLEND_EQUATION
              },
              gridSize,
              minOrMaxFb: maxFramebuffers[id],
              clearParams: {
                clearColor: [0, 0, 0, 0]
              },
              combineMaxMin
            });
          }
        }
      }
    }
    _renderToMaxMinTexture(opts) {
      const {
        id,
        parameters: parameters2,
        gridSize,
        minOrMaxFb,
        combineMaxMin,
        clearParams = {}
      } = opts;
      const {
        framebuffers
      } = this.state;
      const {
        gl,
        allAggregationModel
      } = this;
      withParameters(gl, {
        ...clearParams,
        framebuffer: minOrMaxFb,
        viewport: [0, 0, gridSize[0], gridSize[1]]
      }, () => {
        gl.clear(gl.COLOR_BUFFER_BIT);
        allAggregationModel.draw({
          parameters: parameters2,
          uniforms: {
            uSampler: framebuffers[id].texture,
            gridSize,
            combineMaxMin
          }
        });
      });
    }
    _renderToWeightsTexture(opts) {
      const {
        id,
        parameters: parameters2,
        moduleSettings,
        uniforms,
        gridSize,
        weights
      } = opts;
      const {
        framebuffers,
        equations,
        weightAttributes
      } = this.state;
      const {
        gl,
        gridAggregationModel
      } = this;
      const {
        operation
      } = weights[id];
      const clearColor = operation === AGGREGATION_OPERATION.MIN ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] : [0, 0, 0, 0];
      withParameters(gl, {
        framebuffer: framebuffers[id],
        viewport: [0, 0, gridSize[0], gridSize[1]],
        clearColor
      }, () => {
        gl.clear(gl.COLOR_BUFFER_BIT);
        const attributes = {
          weights: weightAttributes[id]
        };
        gridAggregationModel.draw({
          parameters: {
            ...parameters2,
            blendEquation: equations[id]
          },
          moduleSettings,
          uniforms,
          attributes
        });
      });
      if (operation === AGGREGATION_OPERATION.MEAN) {
        const {
          meanTextures,
          textures
        } = this.state;
        const transformOptions = {
          _sourceTextures: {
            aggregationValues: meanTextures[id]
          },
          _targetTexture: textures[id],
          elementCount: textures[id].width * textures[id].height
        };
        if (this.meanTransform) {
          this.meanTransform.update(transformOptions);
        } else {
          this.meanTransform = getMeanTransform(gl, transformOptions);
        }
        this.meanTransform.run({
          parameters: {
            blend: false,
            depthTest: false
          }
        });
        framebuffers[id].attach({
          [esm_default2.COLOR_ATTACHMENT0]: textures[id]
        });
      }
    }
    _runAggregation(opts) {
      this._updateModels(opts);
      this._setupFramebuffers(opts);
      this._renderAggregateData(opts);
      const results = this._getAggregateData(opts);
      this.setState({
        results
      });
      return results;
    }
    _setupFramebuffers(opts) {
      const {
        textures,
        framebuffers,
        maxMinFramebuffers,
        minFramebuffers,
        maxFramebuffers,
        meanTextures,
        equations
      } = this.state;
      const {
        weights
      } = opts;
      const {
        numCol,
        numRow
      } = opts;
      const framebufferSize = {
        width: numCol,
        height: numRow
      };
      for (const id in weights) {
        const {
          needMin,
          needMax,
          combineMaxMin,
          operation
        } = weights[id];
        textures[id] = weights[id].aggregationTexture || textures[id] || getFloatTexture(this.gl, {
          id: `${id}-texture`,
          width: numCol,
          height: numRow
        });
        textures[id].resize(framebufferSize);
        let texture = textures[id];
        if (operation === AGGREGATION_OPERATION.MEAN) {
          meanTextures[id] = meanTextures[id] || getFloatTexture(this.gl, {
            id: `${id}-mean-texture`,
            width: numCol,
            height: numRow
          });
          meanTextures[id].resize(framebufferSize);
          texture = meanTextures[id];
        }
        if (framebuffers[id]) {
          framebuffers[id].attach({
            [esm_default2.COLOR_ATTACHMENT0]: texture
          });
        } else {
          framebuffers[id] = getFramebuffer4(this.gl, {
            id: `${id}-fb`,
            width: numCol,
            height: numRow,
            texture
          });
        }
        framebuffers[id].resize(framebufferSize);
        equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;
        if (needMin || needMax) {
          if (needMin && needMax && combineMaxMin) {
            if (!maxMinFramebuffers[id]) {
              texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);
              maxMinFramebuffers[id] = getFramebuffer4(this.gl, {
                id: `${id}-maxMinFb`,
                texture
              });
            }
          } else {
            if (needMin) {
              if (!minFramebuffers[id]) {
                texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);
                minFramebuffers[id] = getFramebuffer4(this.gl, {
                  id: `${id}-minFb`,
                  texture
                });
              }
            }
            if (needMax) {
              if (!maxFramebuffers[id]) {
                texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);
                maxFramebuffers[id] = getFramebuffer4(this.gl, {
                  id: `${id}-maxFb`,
                  texture
                });
              }
            }
          }
        }
      }
    }
    _getMinMaxTexture(name10) {
      const {
        resources
      } = this.state;
      if (!resources[name10]) {
        resources[name10] = getFloatTexture(this.gl, {
          id: `resourceName`
        });
      }
      return resources[name10];
    }
    _setupModels({
      numCol = 0,
      numRow = 0
    } = {}) {
      const {
        gl
      } = this;
      const {
        shaderOptions
      } = this.state;
      this.gridAggregationModel?.delete();
      this.gridAggregationModel = getAggregationModel(gl, shaderOptions);
      if (!this.allAggregationModel) {
        const instanceCount = numCol * numRow;
        this.allAggregationModel = getAllAggregationModel(gl, instanceCount);
      }
    }
    _setupWeightAttributes(opts) {
      const {
        weightAttributes
      } = this.state;
      const {
        weights
      } = opts;
      for (const id in weights) {
        weightAttributes[id] = opts.attributes[id];
      }
    }
    _trackGPUResultBuffers(results, weights) {
      const {
        resources
      } = this.state;
      for (const id in results) {
        if (results[id]) {
          for (const bufferName of BUFFER_NAMES) {
            if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {
              const name10 = `gpu-result-${id}-${bufferName}`;
              if (resources[name10]) {
                resources[name10].delete();
              }
              resources[name10] = results[id][bufferName];
            }
          }
        }
      }
    }
    _updateModels(opts) {
      const {
        vertexCount,
        attributes,
        numCol,
        numRow
      } = opts;
      const {
        modelDirty
      } = this.state;
      if (modelDirty) {
        this._setupModels(opts);
        this.setState({
          modelDirty: false
        });
      }
      this._setupWeightAttributes(opts);
      this.gridAggregationModel.setVertexCount(vertexCount);
      this.gridAggregationModel.setAttributes(attributes);
      this.allAggregationModel.setInstanceCount(numCol * numRow);
    }
  };
  function normalizeWeightParams(weights) {
    const result = {};
    for (const id in weights) {
      result[id] = {
        ...DEFAULT_WEIGHT_PARAMS,
        ...weights[id]
      };
    }
    return result;
  }
  function deleteResources(resources) {
    resources = Array.isArray(resources) ? resources : [resources];
    resources.forEach((obj) => {
      for (const name10 in obj) {
        obj[name10].delete();
      }
    });
  }
  function getAggregationModel(gl, shaderOptions) {
    const shaders = mergeShaders({
      vs: aggregate_to_grid_vs_glsl_default,
      fs: aggregate_to_grid_fs_glsl_default,
      modules: [fp64arithmetic, project32_default]
    }, shaderOptions);
    return new Model(gl, {
      id: "Gird-Aggregation-Model",
      vertexCount: 1,
      drawMode: esm_default2.POINTS,
      ...shaders
    });
  }
  function getAllAggregationModel(gl, instanceCount) {
    return new Model(gl, {
      id: "All-Aggregation-Model",
      vs: aggregate_all_vs_glsl_default,
      fs: aggregate_all_fs_glsl_default,
      modules: [fp64arithmetic],
      vertexCount: 1,
      drawMode: esm_default2.POINTS,
      isInstanced: true,
      instanceCount,
      attributes: {
        position: [0, 0]
      }
    });
  }
  function getMeanTransform(gl, opts) {
    return new Transform(gl, {
      vs: transform_mean_vs_glsl_default,
      _targetTextureVarying: "meanValues",
      ...opts
    });
  }

  // ../aggregation-layers/src/utils/color-utils.ts
  var defaultColorRange = [[255, 255, 178], [254, 217, 118], [254, 178, 76], [253, 141, 60], [240, 59, 32], [189, 0, 38]];
  function colorRangeToFlatArray(colorRange, normalize5 = false, ArrayType = Float32Array) {
    let flatArray;
    if (Number.isFinite(colorRange[0])) {
      flatArray = new ArrayType(colorRange);
    } else {
      flatArray = new ArrayType(colorRange.length * 4);
      let index = 0;
      for (let i3 = 0; i3 < colorRange.length; i3++) {
        const color = colorRange[i3];
        flatArray[index++] = color[0];
        flatArray[index++] = color[1];
        flatArray[index++] = color[2];
        flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;
      }
    }
    if (normalize5) {
      for (let i3 = 0; i3 < flatArray.length; i3++) {
        flatArray[i3] /= 255;
      }
    }
    return flatArray;
  }

  // ../aggregation-layers/src/screen-grid-layer/screen-grid-layer-vertex.glsl.ts
  var screen_grid_layer_vertex_glsl_default = `#define SHADER_NAME screen-grid-layer-vertex-shader
#define RANGE_COUNT 6

attribute vec3 positions;
attribute vec3 instancePositions;
attribute vec4 instanceCounts;
attribute vec3 instancePickingColors;

uniform float opacity;
uniform vec3 cellScale;
uniform vec4 minColor;
uniform vec4 maxColor;
uniform vec4 colorRange[RANGE_COUNT];
uniform vec2 colorDomain;
uniform bool shouldUseMinMax;
uniform sampler2D maxTexture;

varying vec4 vColor;
varying float vSampleCount;

vec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {
  vec4 outColor = vec4(0., 0., 0., 0.);
  if (value >= domain.x && value <= domain.y) {
    float domainRange = domain.y - domain.x;
    if (domainRange <= 0.) {
      outColor = colorRange[0];
    } else {
      float rangeCount = float(RANGE_COUNT);
      float rangeStep = domainRange / rangeCount;
      float idx = floor((value - domain.x) / rangeStep);
      idx = clamp(idx, 0., rangeCount - 1.);
      int intIdx = int(idx);
      outColor = colorRange[intIdx];
    }
  }
  outColor = outColor / 255.;
  return outColor;
}

void main(void) {
  vSampleCount = instanceCounts.a;

  float weight = instanceCounts.r;
  float maxWeight = texture2D(maxTexture, vec2(0.5)).r;

  float step = weight / maxWeight;
  vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;

  vec2 domain = colorDomain;
  float domainMaxValid = float(colorDomain.y != 0.);
  domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);
  vec4 rangeColor = quantizeScale(domain, colorRange, weight);

  float rangeMinMax = float(shouldUseMinMax);
  vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);
  vColor = vec4(color.rgb, color.a * opacity);

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);

  gl_Position = vec4(instancePositions + positions * cellScale, 1.);
}
`;

  // ../aggregation-layers/src/screen-grid-layer/screen-grid-layer-fragment.glsl.ts
  var screen_grid_layer_fragment_glsl_default = `#define SHADER_NAME screen-grid-layer-fragment-shader

precision highp float;

varying vec4 vColor;
varying float vSampleCount;

void main(void) {
  if (vSampleCount <= 0.0) {
    discard;
  }
  gl_FragColor = vColor;

  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;

  // ../aggregation-layers/src/screen-grid-layer/screen-grid-cell-layer.ts
  var DEFAULT_MINCOLOR = [0, 0, 0, 0];
  var DEFAULT_MAXCOLOR = [0, 255, 0, 255];
  var COLOR_PROPS = ["minColor", "maxColor", "colorRange", "colorDomain"];
  var defaultProps43 = {
    cellSizePixels: {
      value: 100,
      min: 1
    },
    cellMarginPixels: {
      value: 2,
      min: 0,
      max: 5
    },
    colorDomain: null,
    colorRange: defaultColorRange
  };
  var ScreenGridCellLayer = class extends Layer {
    static isSupported(gl) {
      return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);
    }
    getShaders() {
      return {
        vs: screen_grid_layer_vertex_glsl_default,
        fs: screen_grid_layer_fragment_glsl_default,
        modules: [picking_default]
      };
    }
    initializeState() {
      const {
        gl
      } = this.context;
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          update: this.calculateInstancePositions
        },
        instanceCounts: {
          size: 4,
          noAlloc: true
        }
      });
      this.setState({
        model: this._getModel(gl)
      });
    }
    shouldUpdateState({
      changeFlags
    }) {
      return changeFlags.somethingChanged;
    }
    updateState(params) {
      super.updateState(params);
      const {
        oldProps,
        props,
        changeFlags
      } = params;
      const attributeManager = this.getAttributeManager();
      if (props.numInstances !== oldProps.numInstances) {
        attributeManager.invalidateAll();
      } else if (oldProps.cellSizePixels !== props.cellSizePixels) {
        attributeManager.invalidate("instancePositions");
      }
      this._updateUniforms(oldProps, props, changeFlags);
    }
    draw({
      uniforms
    }) {
      const {
        parameters: parameters2,
        maxTexture
      } = this.props;
      const minColor = this.props.minColor || DEFAULT_MINCOLOR;
      const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;
      const colorDomain = this.props.colorDomain || [1, 0];
      const {
        model
      } = this.state;
      model.setUniforms(uniforms).setUniforms({
        minColor,
        maxColor,
        maxTexture,
        colorDomain
      }).draw({
        parameters: {
          depthTest: false,
          depthMask: false,
          ...parameters2
        }
      });
    }
    calculateInstancePositions(attribute, {
      numInstances
    }) {
      const {
        width,
        height
      } = this.context.viewport;
      const {
        cellSizePixels
      } = this.props;
      const numCol = Math.ceil(width / cellSizePixels);
      const {
        value,
        size
      } = attribute;
      for (let i3 = 0; i3 < numInstances; i3++) {
        const x2 = i3 % numCol;
        const y2 = Math.floor(i3 / numCol);
        value[i3 * size + 0] = x2 * cellSizePixels / width * 2 - 1;
        value[i3 * size + 1] = 1 - y2 * cellSizePixels / height * 2;
        value[i3 * size + 2] = 0;
      }
    }
    _getModel(gl) {
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new Geometry({
          drawMode: esm_default2.TRIANGLE_FAN,
          attributes: {
            positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])
          }
        }),
        isInstanced: true
      });
    }
    _shouldUseMinMax() {
      const {
        minColor,
        maxColor,
        colorDomain,
        colorRange
      } = this.props;
      if (minColor || maxColor) {
        log_default.deprecated("ScreenGridLayer props: minColor and maxColor", "colorRange, colorDomain")();
        return true;
      }
      if (colorDomain || colorRange) {
        return false;
      }
      return true;
    }
    _updateUniforms(oldProps, props, changeFlags) {
      const {
        model
      } = this.state;
      if (COLOR_PROPS.some((key) => oldProps[key] !== props[key])) {
        model.setUniforms({
          shouldUseMinMax: this._shouldUseMinMax()
        });
      }
      if (oldProps.colorRange !== props.colorRange) {
        model.setUniforms({
          colorRange: colorRangeToFlatArray(props.colorRange)
        });
      }
      if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {
        const {
          width,
          height
        } = this.context.viewport;
        const {
          cellSizePixels,
          cellMarginPixels
        } = this.props;
        const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;
        const cellScale = new Float32Array([(cellSizePixels - margin) / width * 2, -(cellSizePixels - margin) / height * 2, 1]);
        model.setUniforms({
          cellScale
        });
      }
    }
  };
  __publicField(ScreenGridCellLayer, "layerName", "ScreenGridCellLayer");
  __publicField(ScreenGridCellLayer, "defaultProps", defaultProps43);

  // ../aggregation-layers/src/utils/prop-utils.js
  function filterProps(props, filterKeys) {
    const filteredProps = {};
    for (const key in props) {
      if (!filterKeys.includes(key)) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }

  // ../aggregation-layers/src/aggregation-layer.ts
  var AggregationLayer = class extends CompositeLayer {
    initializeAggregationLayer(dimensions) {
      super.initializeState(this.context);
      this.setState({
        ignoreProps: filterProps(this.constructor._propTypes, dimensions.data.props),
        dimensions
      });
    }
    updateState(opts) {
      super.updateState(opts);
      const {
        changeFlags
      } = opts;
      if (changeFlags.extensionsChanged) {
        const shaders = this.getShaders({});
        if (shaders && shaders.defines) {
          shaders.defines.NON_INSTANCED_MODEL = 1;
        }
        this.updateShaders(shaders);
      }
      this._updateAttributes();
    }
    updateAttributes(changedAttributes) {
      this.setState({
        changedAttributes
      });
    }
    getAttributes() {
      return this.getAttributeManager().getShaderAttributes();
    }
    getModuleSettings() {
      const {
        viewport,
        mousePosition,
        gl
      } = this.context;
      const moduleSettings = Object.assign(Object.create(this.props), {
        viewport,
        mousePosition,
        pickingActive: 0,
        devicePixelRatio: cssToDeviceRatio(gl)
      });
      return moduleSettings;
    }
    updateShaders(shaders) {
    }
    isAggregationDirty(updateOpts, params = {}) {
      const {
        props,
        oldProps,
        changeFlags
      } = updateOpts;
      const {
        compareAll = false,
        dimension
      } = params;
      const {
        ignoreProps
      } = this.state;
      const {
        props: dataProps,
        accessors = []
      } = dimension;
      const {
        updateTriggersChanged
      } = changeFlags;
      if (changeFlags.dataChanged) {
        return true;
      }
      if (updateTriggersChanged) {
        if (updateTriggersChanged.all) {
          return true;
        }
        for (const accessor of accessors) {
          if (updateTriggersChanged[accessor]) {
            return true;
          }
        }
      }
      if (compareAll) {
        if (changeFlags.extensionsChanged) {
          return true;
        }
        return compareProps({
          oldProps,
          newProps: props,
          ignoreProps,
          propTypes: this.constructor._propTypes
        });
      }
      for (const name10 of dataProps) {
        if (props[name10] !== oldProps[name10]) {
          return true;
        }
      }
      return false;
    }
    isAttributeChanged(name10) {
      const {
        changedAttributes
      } = this.state;
      if (!name10) {
        return !isObjectEmpty3(changedAttributes);
      }
      return changedAttributes && changedAttributes[name10] !== void 0;
    }
    _getAttributeManager() {
      return new AttributeManager(this.context.gl, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
  };
  __publicField(AggregationLayer, "layerName", "AggregationLayer");
  function isObjectEmpty3(obj) {
    let isEmpty = true;
    for (const key in obj) {
      isEmpty = false;
      break;
    }
    return isEmpty;
  }

  // ../aggregation-layers/src/utils/scale-utils.js
  function getScale2(domain, range, scaleFunction) {
    const scale8 = scaleFunction;
    scale8.domain = () => domain;
    scale8.range = () => range;
    return scale8;
  }
  function getQuantizeScale(domain, range) {
    const scaleFunction = (value) => quantizeScale(domain, range, value);
    return getScale2(domain, range, scaleFunction);
  }
  function getLinearScale(domain, range) {
    const scaleFunction = (value) => linearScale(domain, range, value);
    return getScale2(domain, range, scaleFunction);
  }
  function getQuantileScale(domain, range) {
    const sortedDomain = domain.sort(ascending);
    let i3 = 0;
    const n2 = Math.max(1, range.length);
    const thresholds = new Array(n2 - 1);
    while (++i3 < n2) {
      thresholds[i3 - 1] = threshold(sortedDomain, i3 / n2);
    }
    const scaleFunction = (value) => thresholdsScale(thresholds, range, value);
    scaleFunction.thresholds = () => thresholds;
    return getScale2(domain, range, scaleFunction);
  }
  function ascending(a2, b) {
    return a2 - b;
  }
  function threshold(domain, fraction) {
    const domainLength = domain.length;
    if (fraction <= 0 || domainLength < 2) {
      return domain[0];
    }
    if (fraction >= 1) {
      return domain[domainLength - 1];
    }
    const domainFraction = (domainLength - 1) * fraction;
    const lowIndex = Math.floor(domainFraction);
    const low = domain[lowIndex];
    const high = domain[lowIndex + 1];
    return low + (high - low) * (domainFraction - lowIndex);
  }
  function bisectRight(a2, x2) {
    let lo = 0;
    let hi = a2.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (ascending(a2[mid], x2) > 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return lo;
  }
  function thresholdsScale(thresholds, range, value) {
    return range[bisectRight(thresholds, value)];
  }
  function ordinalScale(domain, domainMap, range, value) {
    const key = `${value}`;
    let d = domainMap.get(key);
    if (d === void 0) {
      d = domain.push(value);
      domainMap.set(key, d);
    }
    return range[(d - 1) % range.length];
  }
  function getOrdinalScale(domain, range) {
    const domainMap = /* @__PURE__ */ new Map();
    const uniqueDomain = [];
    for (const d of domain) {
      const key = `${d}`;
      if (!domainMap.has(key)) {
        domainMap.set(key, uniqueDomain.push(d));
      }
    }
    const scaleFunction = (value) => ordinalScale(uniqueDomain, domainMap, range, value);
    return getScale2(domain, range, scaleFunction);
  }
  function quantizeScale(domain, range, value) {
    const domainRange = domain[1] - domain[0];
    if (domainRange <= 0) {
      log_default.warn("quantizeScale: invalid domain, returning range[0]")();
      return range[0];
    }
    const step = domainRange / range.length;
    const idx = Math.floor((value - domain[0]) / step);
    const clampIdx = Math.max(Math.min(idx, range.length - 1), 0);
    return range[clampIdx];
  }
  function linearScale(domain, range, value) {
    return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];
  }
  function notNullOrUndefined(d) {
    return d !== void 0 && d !== null;
  }
  function unique(values) {
    const results = [];
    values.forEach((v) => {
      if (!results.includes(v) && notNullOrUndefined(v)) {
        results.push(v);
      }
    });
    return results;
  }
  function getTruthyValues(data, valueAccessor) {
    const values = typeof valueAccessor === "function" ? data.map(valueAccessor) : data;
    return values.filter(notNullOrUndefined);
  }
  function getQuantileDomain(data, valueAccessor) {
    return getTruthyValues(data, valueAccessor);
  }
  function getOrdinalDomain(data, valueAccessor) {
    return unique(getTruthyValues(data, valueAccessor));
  }
  function clamp3(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function getScaleFunctionByScaleType(scaleType) {
    switch (scaleType) {
      case "quantize":
        return getQuantizeScale;
      case "linear":
        return getLinearScale;
      case "quantile":
        return getQuantileScale;
      case "ordinal":
        return getOrdinalScale;
      default:
        return getQuantizeScale;
    }
  }

  // ../aggregation-layers/src/utils/bin-sorter.ts
  var defaultGetValue = (points) => points.length;
  var MAX_32_BIT_FLOAT2 = 3402823466e29;
  var defaultGetPoints = (bin) => bin.points;
  var defaultGetIndex = (bin) => bin.index;
  var ascending2 = (a2, b) => a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
  var defaultProps44 = {
    getValue: defaultGetValue,
    getPoints: defaultGetPoints,
    getIndex: defaultGetIndex,
    filterData: null
  };
  var BinSorter = class {
    constructor(bins = [], props = defaultProps44) {
      this.aggregatedBins = this.getAggregatedBins(bins, props);
      this._updateMinMaxValues();
      this.binMap = this.getBinMap();
    }
    getAggregatedBins(bins, props) {
      const {
        getValue: getValue2 = defaultGetValue,
        getPoints: getPoints2 = defaultGetPoints,
        getIndex = defaultGetIndex,
        filterData
      } = props;
      const hasFilter = typeof filterData === "function";
      const binCount = bins.length;
      const aggregatedBins = [];
      let index = 0;
      for (let binIndex = 0; binIndex < binCount; binIndex++) {
        const bin = bins[binIndex];
        const points = getPoints2(bin);
        const i3 = getIndex(bin);
        const filteredPoints = hasFilter ? points.filter(filterData) : points;
        bin.filteredPoints = hasFilter ? filteredPoints : null;
        const value = filteredPoints.length ? getValue2(filteredPoints) : null;
        if (value !== null && value !== void 0) {
          aggregatedBins[index] = {
            i: Number.isFinite(i3) ? i3 : binIndex,
            value,
            counts: filteredPoints.length
          };
          index++;
        }
      }
      return aggregatedBins;
    }
    _percentileToIndex(percentileRange) {
      const len3 = this.sortedBins.length;
      if (len3 < 2) {
        return [0, 0];
      }
      const [lower, upper] = percentileRange.map((n2) => clamp3(n2, 0, 100));
      const lowerIdx = Math.ceil(lower / 100 * (len3 - 1));
      const upperIdx = Math.floor(upper / 100 * (len3 - 1));
      return [lowerIdx, upperIdx];
    }
    getBinMap() {
      const binMap = {};
      for (const bin of this.aggregatedBins) {
        binMap[bin.i] = bin;
      }
      return binMap;
    }
    _updateMinMaxValues() {
      let maxCount = 0;
      let maxValue = 0;
      let minValue = MAX_32_BIT_FLOAT2;
      let totalCount = 0;
      for (const x2 of this.aggregatedBins) {
        maxCount = maxCount > x2.counts ? maxCount : x2.counts;
        maxValue = maxValue > x2.value ? maxValue : x2.value;
        minValue = minValue < x2.value ? minValue : x2.value;
        totalCount += x2.counts;
      }
      this.maxCount = maxCount;
      this.maxValue = maxValue;
      this.minValue = minValue;
      this.totalCount = totalCount;
    }
    getValueRange(percentileRange) {
      if (!this.sortedBins) {
        this.sortedBins = this.aggregatedBins.sort((a2, b) => ascending2(a2.value, b.value));
      }
      if (!this.sortedBins.length) {
        return [];
      }
      let lowerIdx = 0;
      let upperIdx = this.sortedBins.length - 1;
      if (Array.isArray(percentileRange)) {
        const idxRange = this._percentileToIndex(percentileRange);
        lowerIdx = idxRange[0];
        upperIdx = idxRange[1];
      }
      return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];
    }
    getValueDomainByScale(scale8, [lower = 0, upper = 100] = []) {
      if (!this.sortedBins) {
        this.sortedBins = this.aggregatedBins.sort((a2, b) => ascending2(a2.value, b.value));
      }
      if (!this.sortedBins.length) {
        return [];
      }
      const indexEdge = this._percentileToIndex([lower, upper]);
      return this._getScaleDomain(scale8, indexEdge);
    }
    _getScaleDomain(scaleType, [lowerIdx, upperIdx]) {
      const bins = this.sortedBins;
      switch (scaleType) {
        case "quantize":
        case "linear":
          return [bins[lowerIdx].value, bins[upperIdx].value];
        case "quantile":
          return getQuantileDomain(bins.slice(lowerIdx, upperIdx + 1), (d) => d.value);
        case "ordinal":
          return getOrdinalDomain(bins, (d) => d.value);
        default:
          return [bins[lowerIdx].value, bins[upperIdx].value];
      }
    }
  };

  // ../aggregation-layers/src/utils/grid-aggregation-utils.js
  var R_EARTH = 6378e3;
  function toFinite(n2) {
    return Number.isFinite(n2) ? n2 : 0;
  }
  function getBoundingBox3(attributes, vertexCount) {
    const positions = attributes.positions.value;
    let yMin = Infinity;
    let yMax = -Infinity;
    let xMin = Infinity;
    let xMax = -Infinity;
    let y2;
    let x2;
    for (let i3 = 0; i3 < vertexCount; i3++) {
      x2 = positions[i3 * 3];
      y2 = positions[i3 * 3 + 1];
      yMin = y2 < yMin ? y2 : yMin;
      yMax = y2 > yMax ? y2 : yMax;
      xMin = x2 < xMin ? x2 : xMin;
      xMax = x2 > xMax ? x2 : xMax;
    }
    const boundingBox = {
      xMin: toFinite(xMin),
      xMax: toFinite(xMax),
      yMin: toFinite(yMin),
      yMax: toFinite(yMax)
    };
    return boundingBox;
  }
  function getTranslation(boundingBox, gridOffset, coordinateSystem, viewport) {
    const {
      width,
      height
    } = viewport;
    const worldOrigin = coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ? [-width / 2, -height / 2] : [-180, -90];
    log_default.assert(coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.DEFAULT);
    const {
      xMin,
      yMin
    } = boundingBox;
    return [
      -1 * (alignToCell(xMin - worldOrigin[0], gridOffset.xOffset) + worldOrigin[0]),
      -1 * (alignToCell(yMin - worldOrigin[1], gridOffset.yOffset) + worldOrigin[1])
    ];
  }
  function alignToCell(inValue, cellSize) {
    const sign2 = inValue < 0 ? -1 : 1;
    let value = sign2 < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);
    value = Math.floor(value / cellSize) * cellSize;
    return value * sign2;
  }
  function getGridOffset(boundingBox, cellSize, convertToMeters = true) {
    if (!convertToMeters) {
      return {
        xOffset: cellSize,
        yOffset: cellSize
      };
    }
    const {
      yMin,
      yMax
    } = boundingBox;
    const centerLat = (yMin + yMax) / 2;
    return calculateGridLatLonOffset(cellSize, centerLat);
  }
  function getGridParams(boundingBox, cellSize, viewport, coordinateSystem) {
    const gridOffset = getGridOffset(boundingBox, cellSize, coordinateSystem !== COORDINATE_SYSTEM.CARTESIAN);
    const translation = getTranslation(boundingBox, gridOffset, coordinateSystem, viewport);
    const {
      xMin,
      yMin,
      xMax,
      yMax
    } = boundingBox;
    const width = xMax - xMin + gridOffset.xOffset;
    const height = yMax - yMin + gridOffset.yOffset;
    const numCol = Math.ceil(width / gridOffset.xOffset);
    const numRow = Math.ceil(height / gridOffset.yOffset);
    return {
      gridOffset,
      translation,
      width,
      height,
      numCol,
      numRow
    };
  }
  function calculateGridLatLonOffset(cellSize, latitude) {
    const yOffset = calculateLatOffset(cellSize);
    const xOffset = calculateLonOffset(latitude, cellSize);
    return {
      yOffset,
      xOffset
    };
  }
  function calculateLatOffset(dy) {
    return dy / R_EARTH * (180 / Math.PI);
  }
  function calculateLonOffset(lat, dx) {
    return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
  }

  // ../aggregation-layers/src/cpu-grid-layer/grid-aggregator.js
  function pointToDensityGridDataCPU(props, aggregationParams) {
    const hashInfo = pointsToGridHashing(props, aggregationParams);
    const result = getGridLayerDataFromGridHash(hashInfo);
    return {
      gridHash: hashInfo.gridHash,
      gridOffset: hashInfo.gridOffset,
      data: result
    };
  }
  function pointsToGridHashing(props, aggregationParams) {
    const {
      data = [],
      cellSize
    } = props;
    const {
      attributes,
      viewport,
      projectPoints,
      numInstances
    } = aggregationParams;
    const positions = attributes.positions.value;
    const {
      size
    } = attributes.positions.getAccessor();
    const boundingBox = aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);
    const offsets = aggregationParams.posOffset || [180, 90];
    const gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);
    if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {
      return {
        gridHash: {},
        gridOffset
      };
    }
    const {
      width,
      height
    } = viewport;
    const numCol = Math.ceil(width / gridOffset.xOffset);
    const numRow = Math.ceil(height / gridOffset.yOffset);
    const gridHash = {};
    const {
      iterable,
      objectInfo
    } = createIterable(data);
    const position = new Array(3);
    for (const pt of iterable) {
      objectInfo.index++;
      position[0] = positions[objectInfo.index * size];
      position[1] = positions[objectInfo.index * size + 1];
      position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;
      const [x2, y2] = projectPoints ? viewport.project(position) : position;
      if (Number.isFinite(x2) && Number.isFinite(y2)) {
        const yIndex = Math.floor((y2 + offsets[1]) / gridOffset.yOffset);
        const xIndex = Math.floor((x2 + offsets[0]) / gridOffset.xOffset);
        if (!projectPoints || xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow) {
          const key = `${yIndex}-${xIndex}`;
          gridHash[key] = gridHash[key] || {
            count: 0,
            points: [],
            lonIdx: xIndex,
            latIdx: yIndex
          };
          gridHash[key].count += 1;
          gridHash[key].points.push({
            source: pt,
            index: objectInfo.index
          });
        }
      }
    }
    return {
      gridHash,
      gridOffset,
      offsets: [offsets[0] * -1, offsets[1] * -1]
    };
  }
  function getGridLayerDataFromGridHash({
    gridHash,
    gridOffset,
    offsets
  }) {
    const data = new Array(Object.keys(gridHash).length);
    let i3 = 0;
    for (const key in gridHash) {
      const idxs = key.split("-");
      const latIdx = parseInt(idxs[0], 10);
      const lonIdx = parseInt(idxs[1], 10);
      const index = i3++;
      data[index] = {
        index,
        position: [offsets[0] + gridOffset.xOffset * lonIdx, offsets[1] + gridOffset.yOffset * latIdx],
        ...gridHash[key]
      };
    }
    return data;
  }
  function getPositionBoundingBox(positionAttribute, numInstance) {
    const positions = positionAttribute.value;
    const {
      size
    } = positionAttribute.getAccessor();
    let yMin = Infinity;
    let yMax = -Infinity;
    let xMin = Infinity;
    let xMax = -Infinity;
    let y2;
    let x2;
    for (let i3 = 0; i3 < numInstance; i3++) {
      x2 = positions[i3 * size];
      y2 = positions[i3 * size + 1];
      if (Number.isFinite(x2) && Number.isFinite(y2)) {
        yMin = y2 < yMin ? y2 : yMin;
        yMax = y2 > yMax ? y2 : yMax;
        xMin = x2 < xMin ? x2 : xMin;
        xMax = x2 > xMax ? x2 : xMax;
      }
    }
    return {
      xMin,
      xMax,
      yMin,
      yMax
    };
  }

  // ../aggregation-layers/src/grid-aggregation-layer.ts
  var GridAggregationLayer = class extends AggregationLayer {
    initializeAggregationLayer({
      dimensions
    }) {
      const {
        gl
      } = this.context;
      super.initializeAggregationLayer(dimensions);
      this.setState({
        layerData: {},
        gpuGridAggregator: new GPUGridAggregator(gl, {
          id: `${this.id}-gpu-aggregator`
        }),
        cpuGridAggregator: pointToDensityGridDataCPU
      });
    }
    updateState(opts) {
      super.updateState(opts);
      this.updateAggregationState(opts);
      const {
        aggregationDataDirty,
        aggregationWeightsDirty,
        gpuAggregation
      } = this.state;
      if (this.getNumInstances() <= 0) {
        return;
      }
      let aggregationDirty = false;
      if (aggregationDataDirty || gpuAggregation && aggregationWeightsDirty) {
        this._updateAggregation(opts);
        aggregationDirty = true;
      }
      if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {
        this._updateWeightBins();
        this._uploadAggregationResults();
        aggregationDirty = true;
      }
      this.setState({
        aggregationDirty
      });
    }
    finalizeState(context) {
      const {
        count: count2
      } = this.state.weights;
      if (count2 && count2.aggregationBuffer) {
        count2.aggregationBuffer.delete();
      }
      this.state.gpuGridAggregator?.delete();
      super.finalizeState(context);
    }
    updateShaders(shaders) {
      if (this.state.gpuAggregation) {
        this.state.gpuGridAggregator.updateShaders(shaders);
      }
    }
    updateAggregationState(opts) {
      log_default.assert(false);
    }
    allocateResources(numRow, numCol) {
      if (this.state.numRow !== numRow || this.state.numCol !== numCol) {
        const dataBytes = numCol * numRow * 4 * 4;
        const gl = this.context.gl;
        const {
          weights
        } = this.state;
        for (const name10 in weights) {
          const weight = weights[name10];
          if (weight.aggregationBuffer) {
            weight.aggregationBuffer.delete();
          }
          weight.aggregationBuffer = new Buffer2(gl, {
            byteLength: dataBytes,
            accessor: {
              size: 4,
              type: esm_default2.FLOAT,
              divisor: 1
            }
          });
        }
      }
    }
    updateResults({
      aggregationData,
      maxMinData,
      maxData,
      minData
    }) {
      const {
        count: count2
      } = this.state.weights;
      if (count2) {
        count2.aggregationData = aggregationData;
        count2.maxMinData = maxMinData;
        count2.maxData = maxData;
        count2.minData = minData;
      }
    }
    _updateAggregation(opts) {
      const {
        cpuGridAggregator,
        gpuGridAggregator,
        gridOffset,
        posOffset,
        translation = [0, 0],
        scaling = [0, 0, 0],
        boundingBox,
        projectPoints,
        gpuAggregation,
        numCol,
        numRow
      } = this.state;
      const {
        props
      } = opts;
      const {
        viewport
      } = this.context;
      const attributes = this.getAttributes();
      const vertexCount = this.getNumInstances();
      if (!gpuAggregation) {
        const result = cpuGridAggregator(props, {
          gridOffset,
          projectPoints,
          attributes,
          viewport,
          posOffset,
          boundingBox
        });
        this.setState({
          layerData: result
        });
      } else {
        const {
          weights
        } = this.state;
        gpuGridAggregator.run({
          weights,
          cellSize: [gridOffset.xOffset, gridOffset.yOffset],
          numCol,
          numRow,
          translation,
          scaling,
          vertexCount,
          projectPoints,
          attributes,
          moduleSettings: this.getModuleSettings()
        });
      }
    }
    _updateWeightBins() {
      const {
        getValue: getValue2
      } = this.state;
      const sortedBins = new BinSorter(this.state.layerData.data || [], {
        getValue: getValue2
      });
      this.setState({
        sortedBins
      });
    }
    _uploadAggregationResults() {
      const {
        numCol,
        numRow
      } = this.state;
      const {
        data
      } = this.state.layerData;
      const {
        aggregatedBins,
        minValue,
        maxValue,
        totalCount
      } = this.state.sortedBins;
      const ELEMENTCOUNT = 4;
      const aggregationSize = numCol * numRow * ELEMENTCOUNT;
      const aggregationData = new Float32Array(aggregationSize).fill(0);
      for (const bin of aggregatedBins) {
        const {
          lonIdx,
          latIdx
        } = data[bin.i];
        const {
          value,
          counts
        } = bin;
        const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;
        aggregationData[cellIndex] = value;
        aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;
      }
      const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);
      const maxData = new Float32Array([maxValue, 0, 0, totalCount]);
      const minData = new Float32Array([minValue, 0, 0, totalCount]);
      this.updateResults({
        aggregationData,
        maxMinData,
        maxData,
        minData
      });
    }
  };
  __publicField(GridAggregationLayer, "layerName", "GridAggregationLayer");

  // ../aggregation-layers/src/screen-grid-layer/screen-grid-layer.ts
  var defaultProps45 = {
    ...ScreenGridCellLayer.defaultProps,
    getPosition: {
      type: "accessor",
      value: (d) => d.position
    },
    getWeight: {
      type: "accessor",
      value: 1
    },
    gpuAggregation: true,
    aggregation: "SUM"
  };
  var POSITION_ATTRIBUTE_NAME = "positions";
  var DIMENSIONS = {
    data: {
      props: ["cellSizePixels"]
    },
    weights: {
      props: ["aggregation"],
      accessors: ["getWeight"]
    }
  };
  var ScreenGridLayer = class extends GridAggregationLayer {
    initializeState() {
      const {
        gl
      } = this.context;
      if (!ScreenGridCellLayer.isSupported(gl)) {
        this.setState({
          supported: false
        });
        log_default.error(`ScreenGridLayer: ${this.id} is not supported on this browser`)();
        return;
      }
      super.initializeAggregationLayer({
        dimensions: DIMENSIONS,
        getCellSize: (props) => props.cellSizePixels
      });
      const weights = {
        count: {
          size: 1,
          operation: AGGREGATION_OPERATION.SUM,
          needMax: true,
          maxTexture: getFloatTexture(gl, {
            id: `${this.id}-max-texture`
          })
        }
      };
      this.setState({
        supported: true,
        projectPoints: true,
        weights,
        subLayerData: {
          attributes: {}
        },
        maxTexture: weights.count.maxTexture,
        positionAttributeName: "positions",
        posOffset: [0, 0],
        translation: [1, -1]
      });
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        [POSITION_ATTRIBUTE_NAME]: {
          size: 3,
          accessor: "getPosition",
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions()
        },
        count: {
          size: 3,
          accessor: "getWeight"
        }
      });
    }
    shouldUpdateState({
      changeFlags
    }) {
      return this.state.supported && changeFlags.somethingChanged;
    }
    updateState(opts) {
      super.updateState(opts);
    }
    renderLayers() {
      if (!this.state.supported) {
        return [];
      }
      const {
        maxTexture,
        numRow,
        numCol,
        weights
      } = this.state;
      const {
        updateTriggers
      } = this.props;
      const {
        aggregationBuffer
      } = weights.count;
      const CellLayerClass = this.getSubLayerClass("cells", ScreenGridCellLayer);
      return new CellLayerClass(this.props, this.getSubLayerProps({
        id: "cell-layer",
        updateTriggers
      }), {
        data: {
          attributes: {
            instanceCounts: aggregationBuffer
          }
        },
        maxTexture,
        numInstances: numRow * numCol
      });
    }
    finalizeState(context) {
      super.finalizeState(context);
      const {
        aggregationBuffer,
        maxBuffer,
        maxTexture
      } = this.state;
      aggregationBuffer?.delete();
      maxBuffer?.delete();
      maxTexture?.delete();
    }
    getPickingInfo({
      info
    }) {
      const {
        index
      } = info;
      if (index >= 0) {
        const {
          gpuGridAggregator,
          gpuAggregation,
          weights
        } = this.state;
        const aggregationResults = gpuAggregation ? gpuGridAggregator.getData("count") : weights.count;
        info.object = GPUGridAggregator.getAggregationData({
          pixelIndex: index,
          ...aggregationResults
        });
      }
      return info;
    }
    updateResults({
      aggregationData,
      maxData
    }) {
      const {
        count: count2
      } = this.state.weights;
      count2.aggregationData = aggregationData;
      count2.aggregationBuffer.setData({
        data: aggregationData
      });
      count2.maxData = maxData;
      count2.maxTexture.setImageData({
        data: maxData
      });
    }
    updateAggregationState(opts) {
      const cellSize = opts.props.cellSizePixels;
      const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;
      const {
        viewportChanged
      } = opts.changeFlags;
      let gpuAggregation = opts.props.gpuAggregation;
      if (this.state.gpuAggregation !== opts.props.gpuAggregation) {
        if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {
          log_default.warn("GPU Grid Aggregation not supported, falling back to CPU")();
          gpuAggregation = false;
        }
      }
      const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;
      this.setState({
        gpuAggregation
      });
      const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);
      const {
        dimensions
      } = this.state;
      const {
        data,
        weights
      } = dimensions;
      const aggregationDataDirty = positionsChanged || gpuAggregationChanged || viewportChanged || this.isAggregationDirty(opts, {
        compareAll: gpuAggregation,
        dimension: data
      });
      const aggregationWeightsDirty = this.isAggregationDirty(opts, {
        dimension: weights
      });
      this.setState({
        aggregationDataDirty,
        aggregationWeightsDirty
      });
      const {
        viewport
      } = this.context;
      if (viewportChanged || cellSizeChanged) {
        const {
          width,
          height
        } = viewport;
        const numCol = Math.ceil(width / cellSize);
        const numRow = Math.ceil(height / cellSize);
        this.allocateResources(numRow, numCol);
        this.setState({
          scaling: [width / 2, -height / 2, 1],
          gridOffset: {
            xOffset: cellSize,
            yOffset: cellSize
          },
          width,
          height,
          numCol,
          numRow
        });
      }
      if (aggregationWeightsDirty) {
        this._updateAccessors(opts);
      }
      if (aggregationDataDirty || aggregationWeightsDirty) {
        this._resetResults();
      }
    }
    _updateAccessors(opts) {
      const {
        getWeight,
        aggregation,
        data
      } = opts.props;
      const {
        count: count2
      } = this.state.weights;
      if (count2) {
        count2.getWeight = getWeight;
        count2.operation = AGGREGATION_OPERATION[aggregation];
      }
      this.setState({
        getValue: getValueFunc(aggregation, getWeight, {
          data
        })
      });
    }
    _resetResults() {
      const {
        count: count2
      } = this.state.weights;
      if (count2) {
        count2.aggregationData = null;
      }
    }
  };
  __publicField(ScreenGridLayer, "layerName", "ScreenGridLayer");
  __publicField(ScreenGridLayer, "defaultProps", defaultProps45);

  // ../aggregation-layers/src/utils/cpu-aggregator.js
  function nop() {
  }
  var dimensionSteps = ["getBins", "getDomain", "getScaleFunc"];
  var defaultDimensions = [{
    key: "fillColor",
    accessor: "getFillColor",
    pickingInfo: "colorValue",
    getBins: {
      triggers: {
        value: {
          prop: "getColorValue",
          updateTrigger: "getColorValue"
        },
        weight: {
          prop: "getColorWeight",
          updateTrigger: "getColorWeight"
        },
        aggregation: {
          prop: "colorAggregation"
        },
        filterData: {
          prop: "_filterData",
          updateTrigger: "_filterData"
        }
      }
    },
    getDomain: {
      triggers: {
        lowerPercentile: {
          prop: "lowerPercentile"
        },
        upperPercentile: {
          prop: "upperPercentile"
        },
        scaleType: {
          prop: "colorScaleType"
        }
      }
    },
    getScaleFunc: {
      triggers: {
        domain: {
          prop: "colorDomain"
        },
        range: {
          prop: "colorRange"
        }
      },
      onSet: {
        props: "onSetColorDomain"
      }
    },
    nullValue: [0, 0, 0, 0]
  }, {
    key: "elevation",
    accessor: "getElevation",
    pickingInfo: "elevationValue",
    getBins: {
      triggers: {
        value: {
          prop: "getElevationValue",
          updateTrigger: "getElevationValue"
        },
        weight: {
          prop: "getElevationWeight",
          updateTrigger: "getElevationWeight"
        },
        aggregation: {
          prop: "elevationAggregation"
        },
        filterData: {
          prop: "_filterData",
          updateTrigger: "_filterData"
        }
      }
    },
    getDomain: {
      triggers: {
        lowerPercentile: {
          prop: "elevationLowerPercentile"
        },
        upperPercentile: {
          prop: "elevationUpperPercentile"
        },
        scaleType: {
          prop: "elevationScaleType"
        }
      }
    },
    getScaleFunc: {
      triggers: {
        domain: {
          prop: "elevationDomain"
        },
        range: {
          prop: "elevationRange"
        }
      },
      onSet: {
        props: "onSetElevationDomain"
      }
    },
    nullValue: -1
  }];
  var defaultGetCellSize = (props) => props.cellSize;
  var CPUAggregator = class {
    constructor(opts) {
      this.state = {
        layerData: {},
        dimensions: {}
      };
      this.changeFlags = {};
      this.dimensionUpdaters = {};
      this._getCellSize = opts.getCellSize || defaultGetCellSize;
      this._getAggregator = opts.getAggregator;
      this._addDimension(opts.dimensions || defaultDimensions);
    }
    static defaultDimensions() {
      return defaultDimensions;
    }
    updateState(opts, aggregationParams) {
      const {
        oldProps,
        props,
        changeFlags
      } = opts;
      this.updateGetValueFuncs(oldProps, props, changeFlags);
      const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);
      let aggregationDirty = false;
      if (changeFlags.dataChanged || reprojectNeeded) {
        this.getAggregatedData(props, aggregationParams);
        aggregationDirty = true;
      } else {
        const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];
        dimensionChanges.forEach((f2) => typeof f2 === "function" && f2());
        aggregationDirty = true;
      }
      this.setState({
        aggregationDirty
      });
      return this.state;
    }
    setState(updateObject) {
      this.state = {
        ...this.state,
        ...updateObject
      };
    }
    setDimensionState(key, updateObject) {
      this.setState({
        dimensions: {
          ...this.state.dimensions,
          [key]: {
            ...this.state.dimensions[key],
            ...updateObject
          }
        }
      });
    }
    normalizeResult(result = {}) {
      if (result.hexagons) {
        return {
          data: result.hexagons,
          ...result
        };
      } else if (result.layerData) {
        return {
          data: result.layerData,
          ...result
        };
      }
      return result;
    }
    getAggregatedData(props, aggregationParams) {
      const aggregator = this._getAggregator(props);
      const result = aggregator(props, aggregationParams);
      this.setState({
        layerData: this.normalizeResult(result)
      });
      this.changeFlags = {
        layerData: true
      };
      this.getSortedBins(props);
    }
    updateGetValueFuncs(oldProps, props, changeFlags) {
      for (const key in this.dimensionUpdaters) {
        const {
          value,
          weight,
          aggregation
        } = this.dimensionUpdaters[key].getBins.triggers;
        let getValue2 = props[value.prop];
        const getValueChanged = this.needUpdateDimensionStep(this.dimensionUpdaters[key].getBins, oldProps, props, changeFlags);
        if (getValueChanged) {
          if (getValue2) {
            getValue2 = wrapGetValueFunc(getValue2, {
              data: props.data
            });
          } else {
            getValue2 = getValueFunc(props[aggregation.prop], props[weight.prop], {
              data: props.data
            });
          }
        }
        if (getValue2) {
          this.setDimensionState(key, {
            getValue: getValue2
          });
        }
      }
    }
    needsReProjectPoints(oldProps, props, changeFlags) {
      return this._getCellSize(oldProps) !== this._getCellSize(props) || this._getAggregator(oldProps) !== this._getAggregator(props) || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition);
    }
    addDimension(dimensions) {
      this._addDimension(dimensions);
    }
    _addDimension(dimensions = []) {
      dimensions.forEach((dimension) => {
        const {
          key
        } = dimension;
        this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);
        this.state.dimensions[key] = {
          getValue: null,
          domain: null,
          sortedBins: null,
          scaleFunc: nop
        };
      });
    }
    getDimensionUpdaters({
      key,
      accessor,
      pickingInfo,
      getBins,
      getDomain,
      getScaleFunc,
      nullValue
    }) {
      return {
        key,
        accessor,
        pickingInfo,
        getBins: {
          updater: this.getDimensionSortedBins,
          ...getBins
        },
        getDomain: {
          updater: this.getDimensionValueDomain,
          ...getDomain
        },
        getScaleFunc: {
          updater: this.getDimensionScale,
          ...getScaleFunc
        },
        attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)
      };
    }
    needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {
      return Object.values(dimensionStep.triggers).some((item) => {
        if (item.updateTrigger) {
          return changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);
        }
        return oldProps[item.prop] !== props[item.prop];
      });
    }
    getDimensionChanges(oldProps, props, changeFlags) {
      const updaters = [];
      for (const key in this.dimensionUpdaters) {
        const needUpdate = dimensionSteps.find((step) => this.needUpdateDimensionStep(this.dimensionUpdaters[key][step], oldProps, props, changeFlags));
        if (needUpdate) {
          updaters.push(this.dimensionUpdaters[key][needUpdate].updater.bind(this, props, this.dimensionUpdaters[key]));
        }
      }
      return updaters.length ? updaters : null;
    }
    getUpdateTriggers(props) {
      const _updateTriggers = props.updateTriggers || {};
      const updateTriggers = {};
      for (const key in this.dimensionUpdaters) {
        const {
          accessor
        } = this.dimensionUpdaters[key];
        updateTriggers[accessor] = {};
        dimensionSteps.forEach((step) => {
          Object.values(this.dimensionUpdaters[key][step].triggers).forEach(({
            prop,
            updateTrigger
          }) => {
            if (updateTrigger) {
              const fromProp = _updateTriggers[updateTrigger];
              if (typeof fromProp === "object" && !Array.isArray(fromProp)) {
                Object.assign(updateTriggers[accessor], fromProp);
              } else if (fromProp !== void 0) {
                updateTriggers[accessor][prop] = fromProp;
              }
            } else {
              updateTriggers[accessor][prop] = props[prop];
            }
          });
        });
      }
      return updateTriggers;
    }
    getSortedBins(props) {
      for (const key in this.dimensionUpdaters) {
        this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);
      }
    }
    getDimensionSortedBins(props, dimensionUpdater) {
      const {
        key
      } = dimensionUpdater;
      const {
        getValue: getValue2
      } = this.state.dimensions[key];
      const sortedBins = new BinSorter(this.state.layerData.data || [], {
        getValue: getValue2,
        filterData: props._filterData
      });
      this.setDimensionState(key, {
        sortedBins
      });
      this.getDimensionValueDomain(props, dimensionUpdater);
    }
    getDimensionValueDomain(props, dimensionUpdater) {
      const {
        getDomain,
        key
      } = dimensionUpdater;
      const {
        triggers: {
          lowerPercentile,
          upperPercentile,
          scaleType
        }
      } = getDomain;
      const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);
      this.setDimensionState(key, {
        valueDomain
      });
      this.getDimensionScale(props, dimensionUpdater);
    }
    getDimensionScale(props, dimensionUpdater) {
      const {
        key,
        getScaleFunc,
        getDomain
      } = dimensionUpdater;
      const {
        domain,
        range
      } = getScaleFunc.triggers;
      const {
        scaleType
      } = getDomain.triggers;
      const {
        onSet
      } = getScaleFunc;
      const dimensionRange = props[range.prop];
      const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;
      const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);
      const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);
      if (typeof onSet === "object" && typeof props[onSet.props] === "function") {
        props[onSet.props](scaleFunc.domain());
      }
      this.setDimensionState(key, {
        scaleFunc
      });
    }
    getSubLayerDimensionAttribute(key, nullValue) {
      return (cell) => {
        const {
          sortedBins,
          scaleFunc
        } = this.state.dimensions[key];
        const bin = sortedBins.binMap[cell.index];
        if (bin && bin.counts === 0) {
          return nullValue;
        }
        const cv = bin && bin.value;
        const domain = scaleFunc.domain();
        const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];
        return isValueInDomain ? scaleFunc(cv) : nullValue;
      };
    }
    getSubLayerAccessors(props) {
      const accessors = {};
      for (const key in this.dimensionUpdaters) {
        const {
          accessor
        } = this.dimensionUpdaters[key];
        accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);
      }
      return accessors;
    }
    getPickingInfo({
      info
    }) {
      const isPicked = info.picked && info.index > -1;
      let object = null;
      if (isPicked) {
        const cell = this.state.layerData.data[info.index];
        const binInfo = {};
        for (const key in this.dimensionUpdaters) {
          const {
            pickingInfo
          } = this.dimensionUpdaters[key];
          const {
            sortedBins
          } = this.state.dimensions[key];
          const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;
          binInfo[pickingInfo] = value;
        }
        object = Object.assign(binInfo, cell, {
          points: cell.filteredPoints || cell.points
        });
      }
      info.picked = Boolean(object);
      info.object = object;
      return info;
    }
    getAccessor(dimensionKey) {
      if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {
        return nop;
      }
      return this.dimensionUpdaters[dimensionKey].attributeAccessor;
    }
  };

  // ../aggregation-layers/src/cpu-grid-layer/cpu-grid-layer.ts
  function nop2() {
  }
  var defaultProps46 = {
    colorDomain: null,
    colorRange: defaultColorRange,
    getColorValue: {
      type: "accessor",
      value: null
    },
    getColorWeight: {
      type: "accessor",
      value: 1
    },
    colorAggregation: "SUM",
    lowerPercentile: {
      type: "number",
      min: 0,
      max: 100,
      value: 0
    },
    upperPercentile: {
      type: "number",
      min: 0,
      max: 100,
      value: 100
    },
    colorScaleType: "quantize",
    onSetColorDomain: nop2,
    elevationDomain: null,
    elevationRange: [0, 1e3],
    getElevationValue: {
      type: "accessor",
      value: null
    },
    getElevationWeight: {
      type: "accessor",
      value: 1
    },
    elevationAggregation: "SUM",
    elevationLowerPercentile: {
      type: "number",
      min: 0,
      max: 100,
      value: 0
    },
    elevationUpperPercentile: {
      type: "number",
      min: 0,
      max: 100,
      value: 100
    },
    elevationScale: {
      type: "number",
      min: 0,
      value: 1
    },
    elevationScaleType: "linear",
    onSetElevationDomain: nop2,
    gridAggregator: pointToDensityGridDataCPU,
    cellSize: {
      type: "number",
      min: 0,
      max: 1e3,
      value: 1e3
    },
    coverage: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    extruded: false,
    material: true,
    _filterData: {
      type: "function",
      value: null,
      optional: true
    }
  };
  var CPUGridLayer = class extends AggregationLayer {
    initializeState() {
      const cpuAggregator = new CPUAggregator({
        getAggregator: (props) => props.gridAggregator,
        getCellSize: (props) => props.cellSize
      });
      this.state = {
        cpuAggregator,
        aggregatorState: cpuAggregator.state
      };
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          type: esm_default2.DOUBLE,
          accessor: "getPosition"
        }
      });
    }
    updateState(opts) {
      super.updateState(opts);
      this.setState({
        aggregatorState: this.state.cpuAggregator.updateState(opts, {
          viewport: this.context.viewport,
          attributes: this.getAttributes(),
          numInstances: this.getNumInstances()
        })
      });
    }
    getPickingInfo({
      info
    }) {
      return this.state.cpuAggregator.getPickingInfo({
        info
      });
    }
    _onGetSublayerColor(cell) {
      return this.state.cpuAggregator.getAccessor("fillColor")(cell);
    }
    _onGetSublayerElevation(cell) {
      return this.state.cpuAggregator.getAccessor("elevation")(cell);
    }
    _getSublayerUpdateTriggers() {
      return this.state.cpuAggregator.getUpdateTriggers(this.props);
    }
    renderLayers() {
      const {
        elevationScale,
        extruded,
        cellSize,
        coverage,
        material,
        transitions
      } = this.props;
      const {
        cpuAggregator
      } = this.state;
      const SubLayerClass = this.getSubLayerClass("grid-cell", GridCellLayer);
      const updateTriggers = this._getSublayerUpdateTriggers();
      return new SubLayerClass({
        cellSize,
        coverage,
        material,
        elevationScale,
        extruded,
        getFillColor: this._onGetSublayerColor.bind(this),
        getElevation: this._onGetSublayerElevation.bind(this),
        transitions: transitions && {
          getFillColor: transitions.getColorValue || transitions.getColorWeight,
          getElevation: transitions.getElevationValue || transitions.getElevationWeight
        }
      }, this.getSubLayerProps({
        id: "grid-cell",
        updateTriggers
      }), {
        data: cpuAggregator.state.layerData.data
      });
    }
  };
  __publicField(CPUGridLayer, "layerName", "CPUGridLayer");
  __publicField(CPUGridLayer, "defaultProps", defaultProps46);

  // ../../node_modules/d3-hexbin/src/hexbin.js
  var thirdPi = Math.PI / 3;
  var angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];
  function pointX(d) {
    return d[0];
  }
  function pointY(d) {
    return d[1];
  }
  function hexbin_default() {
    var x0 = 0, y0 = 0, x1 = 1, y1 = 1, x2 = pointX, y2 = pointY, r2, dx, dy;
    function hexbin(points) {
      var binsById = {}, bins = [], i3, n2 = points.length;
      for (i3 = 0; i3 < n2; ++i3) {
        if (isNaN(px = +x2.call(null, point = points[i3], i3, points)) || isNaN(py = +y2.call(null, point, i3, points)))
          continue;
        var point, px, py, pj = Math.round(py = py / dy), pi = Math.round(px = px / dx - (pj & 1) / 2), py1 = py - pj;
        if (Math.abs(py1) * 3 > 1) {
          var px1 = px - pi, pi2 = pi + (px < pi ? -1 : 1) / 2, pj2 = pj + (py < pj ? -1 : 1), px2 = px - pi2, py2 = py - pj2;
          if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2)
            pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
        }
        var id = pi + "-" + pj, bin = binsById[id];
        if (bin)
          bin.push(point);
        else {
          bins.push(bin = binsById[id] = [point]);
          bin.x = (pi + (pj & 1) / 2) * dx;
          bin.y = pj * dy;
        }
      }
      return bins;
    }
    function hexagon(radius) {
      var x02 = 0, y02 = 0;
      return angles.map(function(angle2) {
        var x12 = Math.sin(angle2) * radius, y12 = -Math.cos(angle2) * radius, dx2 = x12 - x02, dy2 = y12 - y02;
        x02 = x12, y02 = y12;
        return [dx2, dy2];
      });
    }
    hexbin.hexagon = function(radius) {
      return "m" + hexagon(radius == null ? r2 : +radius).join("l") + "z";
    };
    hexbin.centers = function() {
      var centers = [], j = Math.round(y0 / dy), i3 = Math.round(x0 / dx);
      for (var y3 = j * dy; y3 < y1 + r2; y3 += dy, ++j) {
        for (var x3 = i3 * dx + (j & 1) * dx / 2; x3 < x1 + dx / 2; x3 += dx) {
          centers.push([x3, y3]);
        }
      }
      return centers;
    };
    hexbin.mesh = function() {
      var fragment = hexagon(r2).slice(0, 4).join("l");
      return hexbin.centers().map(function(p2) {
        return "M" + p2 + "m" + fragment;
      }).join("");
    };
    hexbin.x = function(_) {
      return arguments.length ? (x2 = _, hexbin) : x2;
    };
    hexbin.y = function(_) {
      return arguments.length ? (y2 = _, hexbin) : y2;
    };
    hexbin.radius = function(_) {
      return arguments.length ? (r2 = +_, dx = r2 * 2 * Math.sin(thirdPi), dy = r2 * 1.5, hexbin) : r2;
    };
    hexbin.size = function(_) {
      return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];
    };
    hexbin.extent = function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];
    };
    return hexbin.radius(1);
  }

  // ../aggregation-layers/src/hexagon-layer/hexagon-aggregator.js
  function pointToHexbin(props, aggregationParams) {
    const {
      data,
      radius
    } = props;
    const {
      viewport,
      attributes
    } = aggregationParams;
    const centerLngLat = data.length ? getPointsCenter(data, aggregationParams) : null;
    const radiusCommon = getRadiusInCommon(radius, viewport, centerLngLat);
    const screenPoints = [];
    const {
      iterable,
      objectInfo
    } = createIterable(data);
    const positions = attributes.positions.value;
    const {
      size
    } = attributes.positions.getAccessor();
    for (const object of iterable) {
      objectInfo.index++;
      const posIndex = objectInfo.index * size;
      const position = [positions[posIndex], positions[posIndex + 1]];
      const arrayIsFinite = Number.isFinite(position[0]) && Number.isFinite(position[1]);
      if (arrayIsFinite) {
        screenPoints.push({
          screenCoord: viewport.projectFlat(position),
          source: object,
          index: objectInfo.index
        });
      } else {
        log_default.warn("HexagonLayer: invalid position")();
      }
    }
    const newHexbin = hexbin_default().radius(radiusCommon).x((d) => d.screenCoord[0]).y((d) => d.screenCoord[1]);
    const hexagonBins = newHexbin(screenPoints);
    return {
      hexagons: hexagonBins.map((hex, index) => ({
        position: viewport.unprojectFlat([hex.x, hex.y]),
        points: hex,
        index
      })),
      radiusCommon
    };
  }
  function getPointsCenter(data, aggregationParams) {
    const {
      attributes
    } = aggregationParams;
    const positions = attributes.positions.value;
    const {
      size
    } = attributes.positions.getAccessor();
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let i3;
    for (i3 = 0; i3 < size * data.length; i3 += size) {
      const x2 = positions[i3];
      const y2 = positions[i3 + 1];
      const arrayIsFinite = Number.isFinite(x2) && Number.isFinite(y2);
      if (arrayIsFinite) {
        minX = Math.min(x2, minX);
        maxX = Math.max(x2, maxX);
        minY = Math.min(y2, minY);
        maxY = Math.max(y2, maxY);
      }
    }
    return [minX, minY, maxX, maxY].every(Number.isFinite) ? [(minX + maxX) / 2, (minY + maxY) / 2] : null;
  }
  function getRadiusInCommon(radius, viewport, center) {
    const {
      unitsPerMeter: unitsPerMeter2
    } = viewport.getDistanceScales(center);
    return radius * unitsPerMeter2[0];
  }

  // ../aggregation-layers/src/hexagon-layer/hexagon-layer.ts
  function nop3() {
  }
  var defaultProps47 = {
    colorDomain: null,
    colorRange: defaultColorRange,
    getColorValue: {
      type: "accessor",
      value: null
    },
    getColorWeight: {
      type: "accessor",
      value: 1
    },
    colorAggregation: "SUM",
    lowerPercentile: {
      type: "number",
      value: 0,
      min: 0,
      max: 100
    },
    upperPercentile: {
      type: "number",
      value: 100,
      min: 0,
      max: 100
    },
    colorScaleType: "quantize",
    onSetColorDomain: nop3,
    elevationDomain: null,
    elevationRange: [0, 1e3],
    getElevationValue: {
      type: "accessor",
      value: null
    },
    getElevationWeight: {
      type: "accessor",
      value: 1
    },
    elevationAggregation: "SUM",
    elevationLowerPercentile: {
      type: "number",
      value: 0,
      min: 0,
      max: 100
    },
    elevationUpperPercentile: {
      type: "number",
      value: 100,
      min: 0,
      max: 100
    },
    elevationScale: {
      type: "number",
      min: 0,
      value: 1
    },
    elevationScaleType: "linear",
    onSetElevationDomain: nop3,
    radius: {
      type: "number",
      value: 1e3,
      min: 1
    },
    coverage: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    extruded: false,
    hexagonAggregator: pointToHexbin,
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    material: true,
    _filterData: {
      type: "function",
      value: null,
      optional: true
    }
  };
  var HexagonLayer = class extends AggregationLayer {
    initializeState() {
      const cpuAggregator = new CPUAggregator({
        getAggregator: (props) => props.hexagonAggregator,
        getCellSize: (props) => props.radius
      });
      this.state = {
        cpuAggregator,
        aggregatorState: cpuAggregator.state,
        vertices: null
      };
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          type: esm_default2.DOUBLE,
          accessor: "getPosition"
        }
      });
    }
    updateState(opts) {
      super.updateState(opts);
      if (opts.changeFlags.propsOrDataChanged) {
        const aggregatorState = this.state.cpuAggregator.updateState(opts, {
          viewport: this.context.viewport,
          attributes: this.getAttributes()
        });
        if (this.state.aggregatorState.layerData !== aggregatorState.layerData) {
          const {
            hexagonVertices
          } = aggregatorState.layerData || {};
          this.setState({
            vertices: hexagonVertices && this.convertLatLngToMeterOffset(hexagonVertices)
          });
        }
        this.setState({
          aggregatorState
        });
      }
    }
    convertLatLngToMeterOffset(hexagonVertices) {
      const {
        viewport
      } = this.context;
      if (Array.isArray(hexagonVertices) && hexagonVertices.length === 6) {
        const vertex0 = hexagonVertices[0];
        const vertex3 = hexagonVertices[3];
        const centroid = [(vertex0[0] + vertex3[0]) / 2, (vertex0[1] + vertex3[1]) / 2];
        const centroidFlat = viewport.projectFlat(centroid);
        const {
          metersPerUnit
        } = viewport.getDistanceScales(centroid);
        const vertices = hexagonVertices.map((vt) => {
          const vtFlat = viewport.projectFlat(vt);
          return [(vtFlat[0] - centroidFlat[0]) * metersPerUnit[0], (vtFlat[1] - centroidFlat[1]) * metersPerUnit[1]];
        });
        return vertices;
      }
      log_default.error("HexagonLayer: hexagonVertices needs to be an array of 6 points")();
      return null;
    }
    getPickingInfo({
      info
    }) {
      return this.state.cpuAggregator.getPickingInfo({
        info
      });
    }
    _onGetSublayerColor(cell) {
      return this.state.cpuAggregator.getAccessor("fillColor")(cell);
    }
    _onGetSublayerElevation(cell) {
      return this.state.cpuAggregator.getAccessor("elevation")(cell);
    }
    _getSublayerUpdateTriggers() {
      return this.state.cpuAggregator.getUpdateTriggers(this.props);
    }
    renderLayers() {
      const {
        elevationScale,
        extruded,
        coverage,
        material,
        transitions
      } = this.props;
      const {
        aggregatorState,
        vertices
      } = this.state;
      const SubLayerClass = this.getSubLayerClass("hexagon-cell", ColumnLayer);
      const updateTriggers = this._getSublayerUpdateTriggers();
      const geometry = vertices ? {
        vertices,
        radius: 1
      } : {
        radius: aggregatorState.layerData.radiusCommon || 1,
        radiusUnits: "common",
        angle: 90
      };
      return new SubLayerClass({
        ...geometry,
        diskResolution: 6,
        elevationScale,
        extruded,
        coverage,
        material,
        getFillColor: this._onGetSublayerColor.bind(this),
        getElevation: this._onGetSublayerElevation.bind(this),
        transitions: transitions && {
          getFillColor: transitions.getColorValue || transitions.getColorWeight,
          getElevation: transitions.getElevationValue || transitions.getElevationWeight
        }
      }, this.getSubLayerProps({
        id: "hexagon-cell",
        updateTriggers
      }), {
        data: aggregatorState.layerData.data
      });
    }
  };
  __publicField(HexagonLayer, "layerName", "HexagonLayer");
  __publicField(HexagonLayer, "defaultProps", defaultProps47);

  // ../aggregation-layers/src/contour-layer/marching-squares-codes.ts
  var HALF = 0.5;
  var ONE6TH = 1 / 6;
  var OFFSET = {
    N: [0, HALF],
    E: [HALF, 0],
    S: [0, -HALF],
    W: [-HALF, 0],
    NE: [HALF, HALF],
    NW: [-HALF, HALF],
    SE: [HALF, -HALF],
    SW: [-HALF, -HALF]
  };
  var SW_TRIANGLE = [OFFSET.W, OFFSET.SW, OFFSET.S];
  var SE_TRIANGLE = [OFFSET.S, OFFSET.SE, OFFSET.E];
  var NE_TRIANGLE = [OFFSET.E, OFFSET.NE, OFFSET.N];
  var NW_TRIANGLE = [OFFSET.NW, OFFSET.W, OFFSET.N];
  var SW_TRAPEZOID = [[-HALF, ONE6TH], [-HALF, -ONE6TH], [-ONE6TH, -HALF], [ONE6TH, -HALF]];
  var SE_TRAPEZOID = [[-ONE6TH, -HALF], [ONE6TH, -HALF], [HALF, -ONE6TH], [HALF, ONE6TH]];
  var NE_TRAPEZOID = [[HALF, -ONE6TH], [HALF, ONE6TH], [ONE6TH, HALF], [-ONE6TH, HALF]];
  var NW_TRAPEZOID = [[-HALF, ONE6TH], [-HALF, -ONE6TH], [ONE6TH, HALF], [-ONE6TH, HALF]];
  var S_RECTANGLE = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E];
  var E_RECTANGLE = [OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];
  var N_RECTANGLE = [OFFSET.NW, OFFSET.W, OFFSET.E, OFFSET.NE];
  var W_RECTANGLE = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.N];
  var EW_RECTANGEL = [[-HALF, ONE6TH], [-HALF, -ONE6TH], [HALF, -ONE6TH], [HALF, ONE6TH]];
  var SN_RECTANGEL = [[-ONE6TH, -HALF], [ONE6TH, -HALF], [ONE6TH, HALF], [-ONE6TH, HALF]];
  var SQUARE = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.NE];
  var SW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.E, OFFSET.N];
  var SE_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.NE, OFFSET.N];
  var NE_PENTAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.NE];
  var NW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE];
  var NW_N_PENTAGON = [OFFSET.NW, OFFSET.W, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];
  var NE_E_PENTAGON = [[-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE, OFFSET.N];
  var SE_S_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.E];
  var SW_W_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [ONE6TH, HALF], [-ONE6TH, HALF]];
  var NW_W_PENTAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.N];
  var NE_N_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.E, OFFSET.NE, OFFSET.N];
  var SE_E_PENTAGON = [OFFSET.S, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];
  var SW_S_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH]];
  var S_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];
  var E_HEXAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];
  var N_HEXAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE];
  var W_HEXAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];
  var SW_NE_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE, OFFSET.N];
  var NW_SE_HEXAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.E, OFFSET.N];
  var NE_HEPTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE, OFFSET.N];
  var SW_HEPTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH], [ONE6TH, HALF], [-ONE6TH, HALF]];
  var NW_HEPTAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];
  var SE_HEPTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];
  var OCTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], [-ONE6TH, -HALF], [ONE6TH, -HALF], [HALF, -ONE6TH], [HALF, ONE6TH], [ONE6TH, HALF], [-ONE6TH, HALF]];
  var ISOLINES_CODE_OFFSET_MAP = {
    0: [],
    1: [[OFFSET.W, OFFSET.S]],
    2: [[OFFSET.S, OFFSET.E]],
    3: [[OFFSET.W, OFFSET.E]],
    4: [[OFFSET.N, OFFSET.E]],
    5: {
      0: [[OFFSET.W, OFFSET.S], [OFFSET.N, OFFSET.E]],
      1: [[OFFSET.W, OFFSET.N], [OFFSET.S, OFFSET.E]]
    },
    6: [[OFFSET.N, OFFSET.S]],
    7: [[OFFSET.W, OFFSET.N]],
    8: [[OFFSET.W, OFFSET.N]],
    9: [[OFFSET.N, OFFSET.S]],
    10: {
      0: [[OFFSET.W, OFFSET.N], [OFFSET.S, OFFSET.E]],
      1: [[OFFSET.W, OFFSET.S], [OFFSET.N, OFFSET.E]]
    },
    11: [[OFFSET.N, OFFSET.E]],
    12: [[OFFSET.W, OFFSET.E]],
    13: [[OFFSET.S, OFFSET.E]],
    14: [[OFFSET.W, OFFSET.S]],
    15: []
  };
  function ternaryToIndex(ternary) {
    return parseInt(ternary, 4);
  }
  var ISOBANDS_CODE_OFFSET_MAP = {
    [ternaryToIndex("0000")]: [],
    [ternaryToIndex("2222")]: [],
    [ternaryToIndex("2221")]: [SW_TRIANGLE],
    [ternaryToIndex("2212")]: [SE_TRIANGLE],
    [ternaryToIndex("2122")]: [NE_TRIANGLE],
    [ternaryToIndex("1222")]: [NW_TRIANGLE],
    [ternaryToIndex("0001")]: [SW_TRIANGLE],
    [ternaryToIndex("0010")]: [SE_TRIANGLE],
    [ternaryToIndex("0100")]: [NE_TRIANGLE],
    [ternaryToIndex("1000")]: [NW_TRIANGLE],
    [ternaryToIndex("2220")]: [SW_TRAPEZOID],
    [ternaryToIndex("2202")]: [SE_TRAPEZOID],
    [ternaryToIndex("2022")]: [NE_TRAPEZOID],
    [ternaryToIndex("0222")]: [NW_TRAPEZOID],
    [ternaryToIndex("0002")]: [SW_TRAPEZOID],
    [ternaryToIndex("0020")]: [SE_TRAPEZOID],
    [ternaryToIndex("0200")]: [NE_TRAPEZOID],
    [ternaryToIndex("2000")]: [NW_TRAPEZOID],
    [ternaryToIndex("0011")]: [S_RECTANGLE],
    [ternaryToIndex("0110")]: [E_RECTANGLE],
    [ternaryToIndex("1100")]: [N_RECTANGLE],
    [ternaryToIndex("1001")]: [W_RECTANGLE],
    [ternaryToIndex("2211")]: [S_RECTANGLE],
    [ternaryToIndex("2112")]: [E_RECTANGLE],
    [ternaryToIndex("1122")]: [N_RECTANGLE],
    [ternaryToIndex("1221")]: [W_RECTANGLE],
    [ternaryToIndex("2200")]: [EW_RECTANGEL],
    [ternaryToIndex("2002")]: [SN_RECTANGEL],
    [ternaryToIndex("0022")]: [EW_RECTANGEL],
    [ternaryToIndex("0220")]: [SN_RECTANGEL],
    [ternaryToIndex("1111")]: [SQUARE],
    [ternaryToIndex("1211")]: [SW_PENTAGON],
    [ternaryToIndex("2111")]: [SE_PENTAGON],
    [ternaryToIndex("1112")]: [NE_PENTAGON],
    [ternaryToIndex("1121")]: [NW_PENTAGON],
    [ternaryToIndex("1011")]: [SW_PENTAGON],
    [ternaryToIndex("0111")]: [SE_PENTAGON],
    [ternaryToIndex("1110")]: [NE_PENTAGON],
    [ternaryToIndex("1101")]: [NW_PENTAGON],
    [ternaryToIndex("1200")]: [NW_N_PENTAGON],
    [ternaryToIndex("0120")]: [NE_E_PENTAGON],
    [ternaryToIndex("0012")]: [SE_S_PENTAGON],
    [ternaryToIndex("2001")]: [SW_W_PENTAGON],
    [ternaryToIndex("1022")]: [NW_N_PENTAGON],
    [ternaryToIndex("2102")]: [NE_E_PENTAGON],
    [ternaryToIndex("2210")]: [SE_S_PENTAGON],
    [ternaryToIndex("0221")]: [SW_W_PENTAGON],
    [ternaryToIndex("1002")]: [NW_W_PENTAGON],
    [ternaryToIndex("2100")]: [NE_N_PENTAGON],
    [ternaryToIndex("0210")]: [SE_E_PENTAGON],
    [ternaryToIndex("0021")]: [SW_S_PENTAGON],
    [ternaryToIndex("1220")]: [NW_W_PENTAGON],
    [ternaryToIndex("0122")]: [NE_N_PENTAGON],
    [ternaryToIndex("2012")]: [SE_E_PENTAGON],
    [ternaryToIndex("2201")]: [SW_S_PENTAGON],
    [ternaryToIndex("0211")]: [S_HEXAGON],
    [ternaryToIndex("2110")]: [E_HEXAGON],
    [ternaryToIndex("1102")]: [N_HEXAGON],
    [ternaryToIndex("1021")]: [W_HEXAGON],
    [ternaryToIndex("2011")]: [S_HEXAGON],
    [ternaryToIndex("0112")]: [E_HEXAGON],
    [ternaryToIndex("1120")]: [N_HEXAGON],
    [ternaryToIndex("1201")]: [W_HEXAGON],
    [ternaryToIndex("2101")]: [SW_NE_HEXAGON],
    [ternaryToIndex("0121")]: [SW_NE_HEXAGON],
    [ternaryToIndex("1012")]: [NW_SE_HEXAGON],
    [ternaryToIndex("1210")]: [NW_SE_HEXAGON],
    [ternaryToIndex("0101")]: {
      0: [SW_TRIANGLE, NE_TRIANGLE],
      1: [SW_NE_HEXAGON],
      2: [SW_NE_HEXAGON]
    },
    [ternaryToIndex("1010")]: {
      0: [NW_TRIANGLE, SE_TRIANGLE],
      1: [NW_SE_HEXAGON],
      2: [NW_SE_HEXAGON]
    },
    [ternaryToIndex("2121")]: {
      0: [SW_NE_HEXAGON],
      1: [SW_NE_HEXAGON],
      2: [SW_TRIANGLE, NE_TRIANGLE]
    },
    [ternaryToIndex("1212")]: {
      0: [NW_SE_HEXAGON],
      1: [NW_SE_HEXAGON],
      2: [NW_TRIANGLE, SE_TRIANGLE]
    },
    [ternaryToIndex("2120")]: {
      0: [NE_HEPTAGON],
      1: [NE_HEPTAGON],
      2: [SW_TRAPEZOID, NE_TRIANGLE]
    },
    [ternaryToIndex("2021")]: {
      0: [SW_HEPTAGON],
      1: [SW_HEPTAGON],
      2: [SW_TRIANGLE, NE_TRAPEZOID]
    },
    [ternaryToIndex("1202")]: {
      0: [NW_HEPTAGON],
      1: [NW_HEPTAGON],
      2: [NW_TRIANGLE, SE_TRAPEZOID]
    },
    [ternaryToIndex("0212")]: {
      0: [SE_HEPTAGON],
      1: [SE_HEPTAGON],
      2: [SE_TRIANGLE, NW_TRAPEZOID]
    },
    [ternaryToIndex("0102")]: {
      0: [SW_TRAPEZOID, NE_TRIANGLE],
      1: [NE_HEPTAGON],
      2: [NE_HEPTAGON]
    },
    [ternaryToIndex("0201")]: {
      0: [SW_TRIANGLE, NE_TRAPEZOID],
      1: [SW_HEPTAGON],
      2: [SW_HEPTAGON]
    },
    [ternaryToIndex("1020")]: {
      0: [NW_TRIANGLE, SE_TRAPEZOID],
      1: [NW_HEPTAGON],
      2: [NW_HEPTAGON]
    },
    [ternaryToIndex("2010")]: {
      0: [SE_TRIANGLE, NW_TRAPEZOID],
      1: [SE_HEPTAGON],
      2: [SE_HEPTAGON]
    },
    [ternaryToIndex("2020")]: {
      0: [NW_TRAPEZOID, SE_TRAPEZOID],
      1: [OCTAGON],
      2: [SW_TRAPEZOID, NE_TRAPEZOID]
    },
    [ternaryToIndex("0202")]: {
      0: [NE_TRAPEZOID, SW_TRAPEZOID],
      1: [OCTAGON],
      2: [NW_TRAPEZOID, SE_TRAPEZOID]
    }
  };

  // ../aggregation-layers/src/contour-layer/marching-squares.ts
  var CONTOUR_TYPE = {
    ISO_LINES: 1,
    ISO_BANDS: 2
  };
  var DEFAULT_THRESHOLD_DATA = {
    zIndex: 0,
    zOffset: 5e-3
  };
  function getVertexCode(weight, threshold2) {
    if (Array.isArray(threshold2)) {
      if (weight < threshold2[0]) {
        return 0;
      }
      return weight < threshold2[1] ? 1 : 2;
    }
    return weight >= threshold2 ? 1 : 0;
  }
  function getCode(opts) {
    const {
      cellWeights,
      x: x2,
      y: y2,
      width,
      height
    } = opts;
    let threshold2 = opts.threshold;
    if (opts.thresholdValue) {
      log_default.deprecated("thresholdValue", "threshold")();
      threshold2 = opts.thresholdValue;
    }
    const isLeftBoundary = x2 < 0;
    const isRightBoundary = x2 >= width - 1;
    const isBottomBoundary = y2 < 0;
    const isTopBoundary = y2 >= height - 1;
    const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;
    const weights = {};
    const codes = {};
    if (isLeftBoundary || isTopBoundary) {
      codes.top = 0;
    } else {
      weights.top = cellWeights[(y2 + 1) * width + x2];
      codes.top = getVertexCode(weights.top, threshold2);
    }
    if (isRightBoundary || isTopBoundary) {
      codes.topRight = 0;
    } else {
      weights.topRight = cellWeights[(y2 + 1) * width + x2 + 1];
      codes.topRight = getVertexCode(weights.topRight, threshold2);
    }
    if (isRightBoundary || isBottomBoundary) {
      codes.right = 0;
    } else {
      weights.right = cellWeights[y2 * width + x2 + 1];
      codes.right = getVertexCode(weights.right, threshold2);
    }
    if (isLeftBoundary || isBottomBoundary) {
      codes.current = 0;
    } else {
      weights.current = cellWeights[y2 * width + x2];
      codes.current = getVertexCode(weights.current, threshold2);
    }
    const {
      top,
      topRight,
      right,
      current
    } = codes;
    let code = -1;
    if (Number.isFinite(threshold2)) {
      code = top << 3 | topRight << 2 | right << 1 | current;
    }
    if (Array.isArray(threshold2)) {
      code = top << 6 | topRight << 4 | right << 2 | current;
    }
    let meanCode = 0;
    if (!isBoundary) {
      meanCode = getVertexCode((weights.top + weights.topRight + weights.right + weights.current) / 4, threshold2);
    }
    return {
      code,
      meanCode
    };
  }
  function getVertices(opts) {
    const {
      gridOrigin,
      cellSize,
      x: x2,
      y: y2,
      code,
      meanCode,
      type = CONTOUR_TYPE.ISO_LINES
    } = opts;
    const thresholdData = {
      ...DEFAULT_THRESHOLD_DATA,
      ...opts.thresholdData
    };
    let offsets = type === CONTOUR_TYPE.ISO_BANDS ? ISOBANDS_CODE_OFFSET_MAP[code] : ISOLINES_CODE_OFFSET_MAP[code];
    if (!Array.isArray(offsets)) {
      offsets = offsets[meanCode];
    }
    const vZ = thresholdData.zIndex * thresholdData.zOffset;
    const rX = (x2 + 1) * cellSize[0];
    const rY = (y2 + 1) * cellSize[1];
    const refVertexX = gridOrigin[0] + rX;
    const refVertexY = gridOrigin[1] + rY;
    if (type === CONTOUR_TYPE.ISO_BANDS) {
      const polygons = [];
      offsets.forEach((polygonOffsets) => {
        const polygon = [];
        polygonOffsets.forEach((xyOffset) => {
          const vX = refVertexX + xyOffset[0] * cellSize[0];
          const vY = refVertexY + xyOffset[1] * cellSize[1];
          polygon.push([vX, vY, vZ]);
        });
        polygons.push(polygon);
      });
      return polygons;
    }
    const lines = [];
    offsets.forEach((xyOffsets) => {
      xyOffsets.forEach((offset) => {
        const vX = refVertexX + offset[0] * cellSize[0];
        const vY = refVertexY + offset[1] * cellSize[1];
        lines.push([vX, vY, vZ]);
      });
    });
    return lines;
  }

  // ../aggregation-layers/src/contour-layer/contour-utils.ts
  function generateContours({
    thresholdData,
    cellWeights,
    gridSize,
    gridOrigin,
    cellSize
  }) {
    const contourSegments = [];
    const contourPolygons = [];
    const width = gridSize[0];
    const height = gridSize[1];
    let segmentIndex = 0;
    let polygonIndex = 0;
    for (const data of thresholdData) {
      const {
        contour
      } = data;
      const {
        threshold: threshold2
      } = contour;
      for (let x2 = -1; x2 < width; x2++) {
        for (let y2 = -1; y2 < height; y2++) {
          const {
            code,
            meanCode
          } = getCode({
            cellWeights,
            threshold: threshold2,
            x: x2,
            y: y2,
            width,
            height
          });
          const opts = {
            type: CONTOUR_TYPE.ISO_BANDS,
            gridOrigin,
            cellSize,
            x: x2,
            y: y2,
            width,
            height,
            code,
            meanCode,
            thresholdData: data
          };
          if (Array.isArray(threshold2)) {
            opts.type = CONTOUR_TYPE.ISO_BANDS;
            const polygons = getVertices(opts);
            for (const polygon of polygons) {
              contourPolygons[polygonIndex++] = {
                vertices: polygon,
                contour
              };
            }
          } else {
            opts.type = CONTOUR_TYPE.ISO_LINES;
            const vertices = getVertices(opts);
            for (let i3 = 0; i3 < vertices.length; i3 += 2) {
              contourSegments[segmentIndex++] = {
                start: vertices[i3],
                end: vertices[i3 + 1],
                contour
              };
            }
          }
        }
      }
    }
    return {
      contourSegments,
      contourPolygons
    };
  }

  // ../aggregation-layers/src/contour-layer/contour-layer.ts
  var DEFAULT_COLOR12 = [255, 255, 255, 255];
  var DEFAULT_STROKE_WIDTH = 1;
  var DEFAULT_THRESHOLD = 1;
  var defaultProps48 = {
    cellSize: {
      type: "number",
      min: 1,
      max: 1e3,
      value: 1e3
    },
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    getWeight: {
      type: "accessor",
      value: 1
    },
    gpuAggregation: true,
    aggregation: "SUM",
    contours: {
      type: "object",
      value: [{
        threshold: DEFAULT_THRESHOLD
      }],
      optional: true,
      compare: 3
    },
    zOffset: 5e-3
  };
  var POSITION_ATTRIBUTE_NAME2 = "positions";
  var DIMENSIONS2 = {
    data: {
      props: ["cellSize"]
    },
    weights: {
      props: ["aggregation"],
      accessors: ["getWeight"]
    }
  };
  var ContourLayer = class extends GridAggregationLayer {
    initializeState() {
      super.initializeAggregationLayer({
        dimensions: DIMENSIONS2
      });
      this.setState({
        contourData: {},
        projectPoints: false,
        weights: {
          count: {
            size: 1,
            operation: AGGREGATION_OPERATION.SUM
          }
        }
      });
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        [POSITION_ATTRIBUTE_NAME2]: {
          size: 3,
          accessor: "getPosition",
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions()
        },
        count: {
          size: 3,
          accessor: "getWeight"
        }
      });
    }
    updateState(opts) {
      super.updateState(opts);
      let contoursChanged = false;
      const {
        oldProps,
        props
      } = opts;
      const {
        aggregationDirty
      } = this.state;
      if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {
        contoursChanged = true;
        this._updateThresholdData(opts.props);
      }
      if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {
        this._generateContours();
      }
    }
    renderLayers() {
      const {
        contourSegments,
        contourPolygons
      } = this.state.contourData;
      const LinesSubLayerClass = this.getSubLayerClass("lines", LineLayer);
      const BandsSubLayerClass = this.getSubLayerClass("bands", SolidPolygonLayer);
      const lineLayer = contourSegments && contourSegments.length > 0 && new LinesSubLayerClass(this.getSubLayerProps({
        id: "lines"
      }), {
        data: this.state.contourData.contourSegments,
        getSourcePosition: (d) => d.start,
        getTargetPosition: (d) => d.end,
        getColor: (d) => d.contour.color || DEFAULT_COLOR12,
        getWidth: (d) => d.contour.strokeWidth || DEFAULT_STROKE_WIDTH
      });
      const bandsLayer = contourPolygons && contourPolygons.length > 0 && new BandsSubLayerClass(this.getSubLayerProps({
        id: "bands"
      }), {
        data: this.state.contourData.contourPolygons,
        getPolygon: (d) => d.vertices,
        getFillColor: (d) => d.contour.color || DEFAULT_COLOR12
      });
      return [lineLayer, bandsLayer];
    }
    updateAggregationState(opts) {
      const {
        props,
        oldProps
      } = opts;
      const {
        cellSize,
        coordinateSystem
      } = props;
      const {
        viewport
      } = this.context;
      const cellSizeChanged = oldProps.cellSize !== cellSize;
      let gpuAggregation = props.gpuAggregation;
      if (this.state.gpuAggregation !== props.gpuAggregation) {
        if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {
          log_default.warn("GPU Grid Aggregation not supported, falling back to CPU")();
          gpuAggregation = false;
        }
      }
      const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;
      this.setState({
        gpuAggregation
      });
      const {
        dimensions
      } = this.state;
      const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME2);
      const {
        data,
        weights
      } = dimensions;
      let {
        boundingBox
      } = this.state;
      if (positionsChanged) {
        boundingBox = getBoundingBox3(this.getAttributes(), this.getNumInstances());
        this.setState({
          boundingBox
        });
      }
      if (positionsChanged || cellSizeChanged) {
        const {
          gridOffset,
          translation,
          width,
          height,
          numCol,
          numRow
        } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);
        this.allocateResources(numRow, numCol);
        this.setState({
          gridOffset,
          boundingBox,
          translation,
          posOffset: translation.slice(),
          gridOrigin: [-1 * translation[0], -1 * translation[1]],
          width,
          height,
          numCol,
          numRow
        });
      }
      const aggregationDataDirty = positionsChanged || gpuAggregationChanged || this.isAggregationDirty(opts, {
        dimension: data,
        compareAll: gpuAggregation
      });
      const aggregationWeightsDirty = this.isAggregationDirty(opts, {
        dimension: weights
      });
      if (aggregationWeightsDirty) {
        this._updateAccessors(opts);
      }
      if (aggregationDataDirty || aggregationWeightsDirty) {
        this._resetResults();
      }
      this.setState({
        aggregationDataDirty,
        aggregationWeightsDirty
      });
    }
    _updateAccessors(opts) {
      const {
        getWeight,
        aggregation,
        data
      } = opts.props;
      const {
        count: count2
      } = this.state.weights;
      if (count2) {
        count2.getWeight = getWeight;
        count2.operation = AGGREGATION_OPERATION[aggregation];
      }
      this.setState({
        getValue: getValueFunc(aggregation, getWeight, {
          data
        })
      });
    }
    _resetResults() {
      const {
        count: count2
      } = this.state.weights;
      if (count2) {
        count2.aggregationData = null;
      }
    }
    _generateContours() {
      const {
        numCol,
        numRow,
        gridOrigin,
        gridOffset,
        thresholdData
      } = this.state;
      const {
        count: count2
      } = this.state.weights;
      let {
        aggregationData
      } = count2;
      if (!aggregationData) {
        aggregationData = count2.aggregationBuffer.getData();
        count2.aggregationData = aggregationData;
      }
      const {
        cellWeights
      } = GPUGridAggregator.getCellData({
        countsData: aggregationData
      });
      const contourData = generateContours({
        thresholdData,
        cellWeights,
        gridSize: [numCol, numRow],
        gridOrigin,
        cellSize: [gridOffset.xOffset, gridOffset.yOffset]
      });
      this.setState({
        contourData
      });
    }
    _updateThresholdData(props) {
      const {
        contours,
        zOffset
      } = props;
      const count2 = contours.length;
      const thresholdData = new Array(count2);
      for (let i3 = 0; i3 < count2; i3++) {
        const contour = contours[i3];
        thresholdData[i3] = {
          contour,
          zIndex: contour.zIndex || i3,
          zOffset
        };
      }
      this.setState({
        thresholdData
      });
    }
  };
  __publicField(ContourLayer, "layerName", "ContourLayer");
  __publicField(ContourLayer, "defaultProps", defaultProps48);

  // ../aggregation-layers/src/gpu-grid-layer/gpu-grid-cell-layer-vertex.glsl.ts
  var gpu_grid_cell_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME gpu-grid-cell-layer-vertex-shader
#define RANGE_COUNT 6

in vec3 positions;
in vec3 normals;

in vec4 colors;
in vec4 elevations;
in vec3 instancePickingColors;

// Custom uniforms
uniform vec2 offset;
uniform bool extruded;
uniform float cellSize;
uniform float coverage;
uniform float opacity;
uniform float elevationScale;

uniform ivec2 gridSize;
uniform vec2 gridOrigin;
uniform vec2 gridOriginLow;
uniform vec2 gridOffset;
uniform vec2 gridOffsetLow;
uniform vec4 colorRange[RANGE_COUNT];
uniform vec2 elevationRange;

// Domain uniforms
uniform vec2 colorDomain;
uniform bool colorDomainValid;
uniform vec2 elevationDomain;
uniform bool elevationDomainValid;

layout(std140) uniform;
uniform ColorData
{
  vec4 maxMinCount;
} colorData;
uniform ElevationData
{
  vec4 maxMinCount;
} elevationData;

#define EPSILON 0.00001

// Result
out vec4 vColor;

vec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {
  vec4 outColor = vec4(0., 0., 0., 0.);
  if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {
    float domainRange = domain.y - domain.x;
    if (domainRange <= 0.) {
      outColor = colorRange[0];
    } else {
      float rangeCount = float(RANGE_COUNT);
      float rangeStep = domainRange / rangeCount;
      float idx = floor((value - domain.x) / rangeStep);
      idx = clamp(idx, 0., rangeCount - 1.);
      int intIdx = int(idx);
      outColor = colorRange[intIdx];
    }
  }
  return outColor;
}

float linearScale(vec2 domain, vec2 range, float value) {
  if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {
    return ((value - domain.x) / (domain.y - domain.x)) * (range.y - range.x) + range.x;
  }
  return -1.;
}

void main(void) {
  vec2 clrDomain = colorDomainValid ? colorDomain : vec2(colorData.maxMinCount.a, colorData.maxMinCount.r);
  vec4 color = quantizeScale(clrDomain, colorRange, colors.r);

  float elevation = 0.0;

  if (extruded) {
    vec2 elvDomain = elevationDomainValid ? elevationDomain : vec2(elevationData.maxMinCount.a, elevationData.maxMinCount.r);
    elevation = linearScale(elvDomain, elevationRange, elevations.r);
    elevation = elevation  * (positions.z + 1.0) / 2.0 * elevationScale;
  }

  // if aggregated color or elevation is 0 do not render
  float shouldRender = float(color.r > 0.0 && elevations.r >= 0.0);
  float dotRadius = cellSize / 2. * coverage * shouldRender;

  int yIndex = (gl_InstanceID / gridSize[0]);
  int xIndex = gl_InstanceID - (yIndex * gridSize[0]);

  vec2 instancePositionXFP64 = mul_fp64(vec2(gridOffset[0], gridOffsetLow[0]), vec2(float(xIndex), 0.));
  instancePositionXFP64 = sum_fp64(instancePositionXFP64, vec2(gridOrigin[0], gridOriginLow[0]));
  vec2 instancePositionYFP64 = mul_fp64(vec2(gridOffset[1], gridOffsetLow[1]), vec2(float(yIndex), 0.));
  instancePositionYFP64 = sum_fp64(instancePositionYFP64, vec2(gridOrigin[1], gridOriginLow[1]));

  vec3 centroidPosition = vec3(instancePositionXFP64[0], instancePositionYFP64[0], elevation);
  vec3 centroidPosition64Low = vec3(instancePositionXFP64[1], instancePositionYFP64[1], 0.0);
  geometry.worldPosition = centroidPosition;
  vec3 pos = vec3(project_size(positions.xy + offset) * dotRadius, 0.);

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);

  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);

  // Light calculations
  // Worldspace is the linear space after Mercator projection

  vec3 normals_commonspace = project_normal(normals);

   if (extruded) {
    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, normals_commonspace);
    vColor = vec4(lightColor, color.a * opacity) / 255.;
  } else {
    vColor = vec4(color.rgb, color.a * opacity) / 255.;
  }
}
`;

  // ../aggregation-layers/src/gpu-grid-layer/gpu-grid-cell-layer-fragment.glsl.ts
  var gpu_grid_cell_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME gpu-grid-cell-layer-fragment-shader

precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main(void) {
  fragColor = vColor;
  fragColor = picking_filterColor(fragColor);
}
`;

  // ../aggregation-layers/src/gpu-grid-layer/gpu-grid-cell-layer.ts
  var COLOR_DATA_UBO_INDEX = 0;
  var ELEVATION_DATA_UBO_INDEX = 1;
  var defaultProps49 = {
    colorDomain: null,
    colorRange: defaultColorRange,
    elevationDomain: null,
    elevationRange: [0, 1e3],
    elevationScale: {
      type: "number",
      min: 0,
      value: 1
    },
    gridSize: {
      type: "array",
      value: [1, 1]
    },
    gridOrigin: {
      type: "array",
      value: [0, 0]
    },
    gridOffset: {
      type: "array",
      value: [0, 0]
    },
    cellSize: {
      type: "number",
      min: 0,
      max: 1e3,
      value: 1e3
    },
    offset: {
      type: "array",
      value: [1, 1]
    },
    coverage: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    extruded: true,
    material: true
  };
  var GPUGridCellLayer = class extends Layer {
    getShaders() {
      return super.getShaders({
        vs: gpu_grid_cell_layer_vertex_glsl_default,
        fs: gpu_grid_cell_layer_fragment_glsl_default,
        modules: [project32_default, gouraudLighting, picking_default, fp64arithmetic]
      });
    }
    initializeState({
      gl
    }) {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        colors: {
          size: 4,
          noAlloc: true
        },
        elevations: {
          size: 4,
          noAlloc: true
        }
      });
      const model = this._getModel(gl);
      this._setupUniformBuffer(model);
      this.setState({
        model
      });
    }
    _getModel(gl) {
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new CubeGeometry(),
        isInstanced: true
      });
    }
    draw({
      uniforms
    }) {
      const {
        cellSize,
        offset,
        extruded,
        elevationScale,
        coverage,
        gridSize,
        gridOrigin,
        gridOffset,
        elevationRange,
        colorMaxMinBuffer,
        elevationMaxMinBuffer
      } = this.props;
      const gridOriginLow = [fp64LowPart2(gridOrigin[0]), fp64LowPart2(gridOrigin[1])];
      const gridOffsetLow = [fp64LowPart2(gridOffset[0]), fp64LowPart2(gridOffset[1])];
      const domainUniforms = this.getDomainUniforms();
      const colorRange = colorRangeToFlatArray(this.props.colorRange);
      this.bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);
      this.state.model.setUniforms(uniforms).setUniforms(domainUniforms).setUniforms({
        cellSize,
        offset,
        extruded,
        elevationScale,
        coverage,
        gridSize,
        gridOrigin,
        gridOriginLow,
        gridOffset,
        gridOffsetLow,
        colorRange,
        elevationRange
      }).draw();
      this.unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);
    }
    bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {
      colorMaxMinBuffer.bind({
        target: esm_default2.UNIFORM_BUFFER,
        index: COLOR_DATA_UBO_INDEX
      });
      elevationMaxMinBuffer.bind({
        target: esm_default2.UNIFORM_BUFFER,
        index: ELEVATION_DATA_UBO_INDEX
      });
    }
    unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {
      colorMaxMinBuffer.unbind({
        target: esm_default2.UNIFORM_BUFFER,
        index: COLOR_DATA_UBO_INDEX
      });
      elevationMaxMinBuffer.unbind({
        target: esm_default2.UNIFORM_BUFFER,
        index: ELEVATION_DATA_UBO_INDEX
      });
    }
    getDomainUniforms() {
      const {
        colorDomain,
        elevationDomain
      } = this.props;
      const domainUniforms = {};
      if (colorDomain !== null) {
        domainUniforms.colorDomainValid = true;
        domainUniforms.colorDomain = colorDomain;
      } else {
        domainUniforms.colorDomainValid = false;
      }
      if (elevationDomain !== null) {
        domainUniforms.elevationDomainValid = true;
        domainUniforms.elevationDomain = elevationDomain;
      } else {
        domainUniforms.elevationDomainValid = false;
      }
      return domainUniforms;
    }
    _setupUniformBuffer(model) {
      const gl = this.context.gl;
      const programHandle = model.program.handle;
      const colorIndex = gl.getUniformBlockIndex(programHandle, "ColorData");
      const elevationIndex = gl.getUniformBlockIndex(programHandle, "ElevationData");
      gl.uniformBlockBinding(programHandle, colorIndex, COLOR_DATA_UBO_INDEX);
      gl.uniformBlockBinding(programHandle, elevationIndex, ELEVATION_DATA_UBO_INDEX);
    }
  };
  __publicField(GPUGridCellLayer, "layerName", "GPUGridCellLayer");
  __publicField(GPUGridCellLayer, "defaultProps", defaultProps49);

  // ../aggregation-layers/src/gpu-grid-layer/gpu-grid-layer.ts
  var defaultProps50 = {
    colorDomain: null,
    colorRange: defaultColorRange,
    getColorWeight: {
      type: "accessor",
      value: 1
    },
    colorAggregation: "SUM",
    elevationDomain: null,
    elevationRange: [0, 1e3],
    getElevationWeight: {
      type: "accessor",
      value: 1
    },
    elevationAggregation: "SUM",
    elevationScale: {
      type: "number",
      min: 0,
      value: 1
    },
    cellSize: {
      type: "number",
      min: 1,
      max: 1e3,
      value: 1e3
    },
    coverage: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    extruded: false,
    material: true
  };
  var DIMENSIONS3 = {
    data: {
      props: ["cellSize", "colorAggregation", "elevationAggregation"]
    }
  };
  var POSITION_ATTRIBUTE_NAME3 = "positions";
  var GPUGridLayer = class extends GridAggregationLayer {
    initializeState({
      gl
    }) {
      const isSupported = GPUGridAggregator.isSupported(gl);
      if (!isSupported) {
        log_default.error("GPUGridLayer is not supported on this browser, use GridLayer instead")();
      }
      super.initializeAggregationLayer({
        dimensions: DIMENSIONS3
      });
      this.setState({
        gpuAggregation: true,
        projectPoints: false,
        isSupported,
        weights: {
          color: {
            needMin: true,
            needMax: true,
            combineMaxMin: true,
            maxMinBuffer: new Buffer2(gl, {
              byteLength: 4 * 4,
              accessor: {
                size: 4,
                type: esm_default2.FLOAT,
                divisor: 1
              }
            })
          },
          elevation: {
            needMin: true,
            needMax: true,
            combineMaxMin: true,
            maxMinBuffer: new Buffer2(gl, {
              byteLength: 4 * 4,
              accessor: {
                size: 4,
                type: esm_default2.FLOAT,
                divisor: 1
              }
            })
          }
        },
        positionAttributeName: "positions"
      });
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        [POSITION_ATTRIBUTE_NAME3]: {
          size: 3,
          accessor: "getPosition",
          type: esm_default2.DOUBLE,
          fp64: this.use64bitPositions()
        },
        color: {
          size: 3,
          accessor: "getColorWeight"
        },
        elevation: {
          size: 3,
          accessor: "getElevationWeight"
        }
      });
    }
    updateState(opts) {
      if (this.state.isSupported === false) {
        return;
      }
      super.updateState(opts);
      const {
        aggregationDirty
      } = this.state;
      if (aggregationDirty) {
        this.setState({
          gridHash: null
        });
      }
    }
    getHashKeyForIndex(index) {
      const {
        numRow,
        numCol,
        boundingBox,
        gridOffset
      } = this.state;
      const gridSize = [numCol, numRow];
      const gridOrigin = [boundingBox.xMin, boundingBox.yMin];
      const cellSize = [gridOffset.xOffset, gridOffset.yOffset];
      const yIndex = Math.floor(index / gridSize[0]);
      const xIndex = index - yIndex * gridSize[0];
      const latIdx = Math.floor((yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]);
      const lonIdx = Math.floor((xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]);
      return `${latIdx}-${lonIdx}`;
    }
    getPositionForIndex(index) {
      const {
        numRow,
        numCol,
        boundingBox,
        gridOffset
      } = this.state;
      const gridSize = [numCol, numRow];
      const gridOrigin = [boundingBox.xMin, boundingBox.yMin];
      const cellSize = [gridOffset.xOffset, gridOffset.yOffset];
      const yIndex = Math.floor(index / gridSize[0]);
      const xIndex = index - yIndex * gridSize[0];
      const yPos = yIndex * cellSize[1] + gridOrigin[1];
      const xPos = xIndex * cellSize[0] + gridOrigin[0];
      return [xPos, yPos];
    }
    getPickingInfo({
      info,
      mode
    }) {
      const {
        index
      } = info;
      let object = null;
      if (index >= 0) {
        const {
          gpuGridAggregator
        } = this.state;
        const position = this.getPositionForIndex(index);
        const colorInfo = GPUGridAggregator.getAggregationData({
          pixelIndex: index,
          ...gpuGridAggregator.getData("color")
        });
        const elevationInfo = GPUGridAggregator.getAggregationData({
          pixelIndex: index,
          ...gpuGridAggregator.getData("elevation")
        });
        object = {
          colorValue: colorInfo.cellWeight,
          elevationValue: elevationInfo.cellWeight,
          count: colorInfo.cellCount || elevationInfo.cellCount,
          position,
          totalCount: colorInfo.totalCount || elevationInfo.totalCount
        };
        if (mode !== "hover") {
          const {
            props
          } = this;
          let {
            gridHash
          } = this.state;
          if (!gridHash) {
            const {
              gridOffset,
              translation,
              boundingBox
            } = this.state;
            const {
              viewport
            } = this.context;
            const attributes = this.getAttributes();
            const cpuAggregation = pointToDensityGridDataCPU(props, {
              gridOffset,
              attributes,
              viewport,
              translation,
              boundingBox
            });
            gridHash = cpuAggregation.gridHash;
            this.setState({
              gridHash
            });
          }
          const key = this.getHashKeyForIndex(index);
          const cpuAggregationData = gridHash[key];
          Object.assign(object, cpuAggregationData);
        }
      }
      info.picked = Boolean(object);
      info.object = object;
      return info;
    }
    renderLayers() {
      if (!this.state.isSupported) {
        return null;
      }
      const {
        elevationScale,
        extruded,
        cellSize: cellSizeMeters,
        coverage,
        material,
        elevationRange,
        colorDomain,
        elevationDomain
      } = this.props;
      const {
        weights,
        numRow,
        numCol,
        gridOrigin,
        gridOffset
      } = this.state;
      const {
        color,
        elevation
      } = weights;
      const colorRange = colorRangeToFlatArray(this.props.colorRange);
      const SubLayerClass = this.getSubLayerClass("gpu-grid-cell", GPUGridCellLayer);
      return new SubLayerClass({
        gridSize: [numCol, numRow],
        gridOrigin,
        gridOffset: [gridOffset.xOffset, gridOffset.yOffset],
        colorRange,
        elevationRange,
        colorDomain,
        elevationDomain,
        cellSize: cellSizeMeters,
        coverage,
        material,
        elevationScale,
        extruded
      }, this.getSubLayerProps({
        id: "gpu-grid-cell"
      }), {
        data: {
          attributes: {
            colors: color.aggregationBuffer,
            elevations: elevation.aggregationBuffer
          }
        },
        colorMaxMinBuffer: color.maxMinBuffer,
        elevationMaxMinBuffer: elevation.maxMinBuffer,
        numInstances: numCol * numRow
      });
    }
    finalizeState(context) {
      const {
        color,
        elevation
      } = this.state.weights;
      [color, elevation].forEach((weight) => {
        const {
          aggregationBuffer,
          maxMinBuffer
        } = weight;
        maxMinBuffer.delete();
        aggregationBuffer?.delete();
      });
      super.finalizeState(context);
    }
    updateAggregationState(opts) {
      const {
        props,
        oldProps
      } = opts;
      const {
        cellSize,
        coordinateSystem
      } = props;
      const {
        viewport
      } = this.context;
      const cellSizeChanged = oldProps.cellSize !== cellSize;
      const {
        dimensions
      } = this.state;
      const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME3);
      const attributesChanged = positionsChanged || this.isAttributeChanged();
      let {
        boundingBox
      } = this.state;
      if (positionsChanged) {
        boundingBox = getBoundingBox3(this.getAttributes(), this.getNumInstances());
        this.setState({
          boundingBox
        });
      }
      if (positionsChanged || cellSizeChanged) {
        const {
          gridOffset,
          translation,
          width,
          height,
          numCol,
          numRow
        } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);
        this.allocateResources(numRow, numCol);
        this.setState({
          gridOffset,
          translation,
          gridOrigin: [-1 * translation[0], -1 * translation[1]],
          width,
          height,
          numCol,
          numRow
        });
      }
      const aggregationDataDirty = attributesChanged || this.isAggregationDirty(opts, {
        dimension: dimensions.data,
        compareAll: true
      });
      if (aggregationDataDirty) {
        this._updateAccessors(opts);
      }
      this.setState({
        aggregationDataDirty
      });
    }
    _updateAccessors(opts) {
      const {
        colorAggregation,
        elevationAggregation
      } = opts.props;
      const {
        color,
        elevation
      } = this.state.weights;
      color.operation = AGGREGATION_OPERATION[colorAggregation];
      elevation.operation = AGGREGATION_OPERATION[elevationAggregation];
    }
  };
  __publicField(GPUGridLayer, "layerName", "GPUGridLayer");
  __publicField(GPUGridLayer, "defaultProps", defaultProps50);

  // ../aggregation-layers/src/grid-layer/grid-layer.ts
  var defaultProps51 = {
    ...GPUGridLayer.defaultProps,
    ...CPUGridLayer.defaultProps,
    gpuAggregation: false
  };
  var GridLayer = class extends CompositeLayer {
    initializeState() {
      this.state = {
        useGPUAggregation: true
      };
    }
    updateState({
      props
    }) {
      this.setState({
        useGPUAggregation: this.canUseGPUAggregation(props)
      });
    }
    renderLayers() {
      const {
        data,
        updateTriggers
      } = this.props;
      const id = this.state.useGPUAggregation ? "GPU" : "CPU";
      const LayerType = this.state.useGPUAggregation ? this.getSubLayerClass("GPU", GPUGridLayer) : this.getSubLayerClass("CPU", CPUGridLayer);
      return new LayerType(this.props, this.getSubLayerProps({
        id,
        updateTriggers
      }), {
        data
      });
    }
    canUseGPUAggregation(props) {
      const {
        gpuAggregation,
        lowerPercentile,
        upperPercentile,
        getColorValue,
        getElevationValue,
        colorScaleType
      } = props;
      if (!gpuAggregation) {
        return false;
      }
      if (!GPUGridAggregator.isSupported(this.context.gl)) {
        return false;
      }
      if (lowerPercentile !== 0 || upperPercentile !== 100) {
        return false;
      }
      if (getColorValue !== null || getElevationValue !== null) {
        return false;
      }
      if (colorScaleType === "quantile" || colorScaleType === "ordinal") {
        return false;
      }
      return true;
    }
  };
  __publicField(GridLayer, "layerName", "GridLayer");
  __publicField(GridLayer, "defaultProps", defaultProps51);

  // ../aggregation-layers/src/heatmap-layer/heatmap-layer-utils.ts
  function getBounds2(points) {
    const x2 = points.map((p2) => p2[0]);
    const y2 = points.map((p2) => p2[1]);
    const xMin = Math.min.apply(null, x2);
    const xMax = Math.max.apply(null, x2);
    const yMin = Math.min.apply(null, y2);
    const yMax = Math.max.apply(null, y2);
    return [xMin, yMin, xMax, yMax];
  }
  function boundsContain(currentBounds, targetBounds) {
    if (targetBounds[0] >= currentBounds[0] && targetBounds[2] <= currentBounds[2] && targetBounds[1] >= currentBounds[1] && targetBounds[3] <= currentBounds[3]) {
      return true;
    }
    return false;
  }
  var scratchArray2 = new Float32Array(12);
  function packVertices(points, dimensions = 2) {
    let index = 0;
    for (const point of points) {
      for (let i3 = 0; i3 < dimensions; i3++) {
        scratchArray2[index++] = point[i3] || 0;
      }
    }
    return scratchArray2;
  }
  function scaleToAspectRatio(boundingBox, width, height) {
    const [xMin, yMin, xMax, yMax] = boundingBox;
    const currentWidth = xMax - xMin;
    const currentHeight = yMax - yMin;
    let newWidth = currentWidth;
    let newHeight = currentHeight;
    if (currentWidth / currentHeight < width / height) {
      newWidth = width / height * currentHeight;
    } else {
      newHeight = height / width * currentWidth;
    }
    if (newWidth < width) {
      newWidth = width;
      newHeight = height;
    }
    const xCenter = (xMax + xMin) / 2;
    const yCenter = (yMax + yMin) / 2;
    return [xCenter - newWidth / 2, yCenter - newHeight / 2, xCenter + newWidth / 2, yCenter + newHeight / 2];
  }
  function getTextureCoordinates(point, bounds) {
    const [xMin, yMin, xMax, yMax] = bounds;
    return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];
  }
  function getTextureParams({
    gl,
    floatTargetSupport
  }) {
    return floatTargetSupport ? {
      format: isWebGL2(gl) ? esm_default2.RGBA32F : esm_default2.RGBA,
      type: esm_default2.FLOAT
    } : {
      format: esm_default2.RGBA,
      type: esm_default2.UNSIGNED_BYTE
    };
  }

  // ../aggregation-layers/src/heatmap-layer/triangle-layer-vertex.glsl.ts
  var triangle_layer_vertex_glsl_default = `#define SHADER_NAME heatp-map-layer-vertex-shader

uniform sampler2D maxTexture;
uniform float intensity;
uniform vec2 colorDomain;
uniform float threshold;
uniform float aggregationMode;

attribute vec3 positions;
attribute vec2 texCoords;

varying vec2 vTexCoords;
varying float vIntensityMin;
varying float vIntensityMax;

void main(void) {
  gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));
  vTexCoords = texCoords;
  vec4 maxTexture = texture2D(maxTexture, vec2(0.5));
  float maxValue = aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;
  float minValue = maxValue * threshold;
  if (colorDomain[1] > 0.) {
    // if user specified custom domain use it.
    maxValue = colorDomain[1];
    minValue = colorDomain[0];
  }
  vIntensityMax = intensity / maxValue;
  vIntensityMin = intensity / minValue;
}
`;

  // ../aggregation-layers/src/heatmap-layer/triangle-layer-fragment.glsl.ts
  var triangle_layer_fragment_glsl_default = `#define SHADER_NAME triangle-layer-fragment-shader

precision highp float;

uniform float opacity;
uniform sampler2D texture;
uniform sampler2D colorTexture;
uniform float aggregationMode;

varying vec2 vTexCoords;
varying float vIntensityMin;
varying float vIntensityMax;

vec4 getLinearColor(float value) {
  float factor = clamp(value * vIntensityMax, 0., 1.);
  vec4 color = texture2D(colorTexture, vec2(factor, 0.5));
  color.a *= min(value * vIntensityMin, 1.0);
  return color;
}

void main(void) {
  vec4 weights = texture2D(texture, vTexCoords);
  float weight = weights.r;

  if (aggregationMode > 0.5) {
    weight /= max(1.0, weights.a);
  }

  // discard pixels with 0 weight.
  if (weight <= 0.) {
     discard;
  }

  vec4 linearColor = getLinearColor(weight);
  linearColor.a *= opacity;
  gl_FragColor =linearColor;
}
`;

  // ../aggregation-layers/src/heatmap-layer/triangle-layer.ts
  var TriangleLayer = class extends Layer {
    getShaders() {
      return {
        vs: triangle_layer_vertex_glsl_default,
        fs: triangle_layer_fragment_glsl_default,
        modules: [project32_default]
      };
    }
    initializeState({
      gl
    }) {
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          noAlloc: true
        },
        texCoords: {
          size: 2,
          noAlloc: true
        }
      });
      this.setState({
        model: this._getModel(gl)
      });
    }
    _getModel(gl) {
      const {
        vertexCount
      } = this.props;
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new Geometry({
          drawMode: esm_default2.TRIANGLE_FAN,
          vertexCount
        })
      });
    }
    draw({
      uniforms
    }) {
      const {
        model
      } = this.state;
      const {
        texture,
        maxTexture,
        colorTexture,
        intensity,
        threshold: threshold2,
        aggregationMode,
        colorDomain
      } = this.props;
      model.setUniforms({
        ...uniforms,
        texture,
        maxTexture,
        colorTexture,
        intensity,
        threshold: threshold2,
        aggregationMode,
        colorDomain
      }).draw();
    }
  };
  __publicField(TriangleLayer, "layerName", "TriangleLayer");

  // ../aggregation-layers/src/heatmap-layer/weights-vs.glsl.ts
  var weights_vs_glsl_default = `attribute vec3 positions;
attribute vec3 positions64Low;
attribute float weights;
varying vec4 weightsTexture;
uniform float radiusPixels;
uniform float textureWidth;
uniform vec4 commonBounds;
uniform float weightsScale;
void main()
{
  weightsTexture = vec4(weights * weightsScale, 0., 0., 1.);

  float radiusTexels  = project_pixel_size(radiusPixels) * textureWidth / (commonBounds.z - commonBounds.x);
  gl_PointSize = radiusTexels * 2.;

  vec3 commonPosition = project_position(positions, positions64Low);

  // map xy from commonBounds to [-1, 1]
  gl_Position.xy = (commonPosition.xy - commonBounds.xy) / (commonBounds.zw - commonBounds.xy) ;
  gl_Position.xy = (gl_Position.xy * 2.) - (1.);
}
`;

  // ../aggregation-layers/src/heatmap-layer/weights-fs.glsl.ts
  var weights_fs_glsl_default = `varying vec4 weightsTexture;
// Epanechnikov function, keeping for reference
// float epanechnikovKDE(float u) {
//   return 0.75 * (1.0 - u * u);
// }
float gaussianKDE(float u){
  return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);
}
void main()
{
  float dist = length(gl_PointCoord - vec2(0.5, 0.5));
  if (dist > 0.5) {
    discard;
  }
  gl_FragColor = weightsTexture * gaussianKDE(2. * dist);
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`;

  // ../aggregation-layers/src/heatmap-layer/max-vs.glsl.ts
  var max_vs_glsl_default = `attribute vec4 inTexture;
varying vec4 outTexture;

void main()
{
outTexture = inTexture;
gl_Position = vec4(0, 0, 0, 1.);
// Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)
gl_PointSize = 1.0;
}
`;

  // ../aggregation-layers/src/heatmap-layer/max-fs.glsl.ts
  var max_fs_glsl_default = `varying vec4 outTexture;
void main() {
  gl_FragColor = outTexture;
  gl_FragColor.g = outTexture.r / max(1.0, outTexture.a);
}
`;

  // ../aggregation-layers/src/heatmap-layer/heatmap-layer.ts
  var RESOLUTION = 2;
  var TEXTURE_OPTIONS = {
    mipmaps: false,
    parameters: {
      [esm_default2.TEXTURE_MAG_FILTER]: esm_default2.LINEAR,
      [esm_default2.TEXTURE_MIN_FILTER]: esm_default2.LINEAR,
      [esm_default2.TEXTURE_WRAP_S]: esm_default2.CLAMP_TO_EDGE,
      [esm_default2.TEXTURE_WRAP_T]: esm_default2.CLAMP_TO_EDGE
    },
    dataFormat: esm_default2.RGBA
  };
  var DEFAULT_COLOR_DOMAIN = [0, 0];
  var AGGREGATION_MODE = {
    SUM: 0,
    MEAN: 1
  };
  var defaultProps52 = {
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    getWeight: {
      type: "accessor",
      value: 1
    },
    intensity: {
      type: "number",
      min: 0,
      value: 1
    },
    radiusPixels: {
      type: "number",
      min: 1,
      max: 100,
      value: 50
    },
    colorRange: defaultColorRange,
    threshold: {
      type: "number",
      min: 0,
      max: 1,
      value: 0.05
    },
    colorDomain: {
      type: "array",
      value: null,
      optional: true
    },
    aggregation: "SUM",
    weightsTextureSize: {
      type: "number",
      min: 128,
      max: 2048,
      value: 2048
    },
    debounceTimeout: {
      type: "number",
      min: 0,
      max: 1e3,
      value: 500
    }
  };
  var REQUIRED_FEATURES2 = [
    FEATURES.BLEND_EQUATION_MINMAX,
    FEATURES.TEXTURE_FLOAT
  ];
  var FLOAT_TARGET_FEATURES = [
    FEATURES.COLOR_ATTACHMENT_RGBA32F,
    FEATURES.FLOAT_BLEND
  ];
  var DIMENSIONS4 = {
    data: {
      props: ["radiusPixels"]
    }
  };
  var HeatmapLayer = class extends AggregationLayer {
    initializeState() {
      const {
        gl
      } = this.context;
      if (!hasFeatures(gl, REQUIRED_FEATURES2)) {
        this.setState({
          supported: false
        });
        log_default.error(`HeatmapLayer: ${this.id} is not supported on this browser`)();
        return;
      }
      super.initializeAggregationLayer(DIMENSIONS4);
      this.setState({
        supported: true,
        colorDomain: DEFAULT_COLOR_DOMAIN
      });
      this._setupTextureParams();
      this._setupAttributes();
      this._setupResources();
    }
    shouldUpdateState({
      changeFlags
    }) {
      return changeFlags.somethingChanged;
    }
    updateState(opts) {
      if (!this.state.supported) {
        return;
      }
      super.updateState(opts);
      this._updateHeatmapState(opts);
    }
    _updateHeatmapState(opts) {
      const {
        props,
        oldProps
      } = opts;
      const changeFlags = this._getChangeFlags(opts);
      if (changeFlags.dataChanged || changeFlags.viewportChanged) {
        changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);
        this._updateTextureRenderingBounds();
      }
      if (changeFlags.dataChanged || changeFlags.boundsChanged) {
        clearTimeout(this.state.updateTimer);
        this.setState({
          isWeightMapDirty: true
        });
      } else if (changeFlags.viewportZoomChanged) {
        this._debouncedUpdateWeightmap();
      }
      if (props.colorRange !== oldProps.colorRange) {
        this._updateColorTexture(opts);
      }
      if (this.state.isWeightMapDirty) {
        this._updateWeightmap();
      }
      this.setState({
        zoom: opts.context.viewport.zoom
      });
    }
    renderLayers() {
      if (!this.state.supported) {
        return [];
      }
      const {
        weightsTexture,
        triPositionBuffer,
        triTexCoordBuffer,
        maxWeightsTexture,
        colorTexture,
        colorDomain
      } = this.state;
      const {
        updateTriggers,
        intensity,
        threshold: threshold2,
        aggregation
      } = this.props;
      const TriangleLayerClass = this.getSubLayerClass("triangle", TriangleLayer);
      return new TriangleLayerClass(this.getSubLayerProps({
        id: "triangle-layer",
        updateTriggers
      }), {
        coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
        data: {
          attributes: {
            positions: triPositionBuffer,
            texCoords: triTexCoordBuffer
          }
        },
        vertexCount: 4,
        maxTexture: maxWeightsTexture,
        colorTexture,
        aggregationMode: AGGREGATION_MODE[aggregation] || 0,
        texture: weightsTexture,
        intensity,
        threshold: threshold2,
        colorDomain
      });
    }
    finalizeState(context) {
      super.finalizeState(context);
      const {
        weightsTransform,
        weightsTexture,
        maxWeightTransform,
        maxWeightsTexture,
        triPositionBuffer,
        triTexCoordBuffer,
        colorTexture,
        updateTimer
      } = this.state;
      weightsTransform?.delete();
      weightsTexture?.delete();
      maxWeightTransform?.delete();
      maxWeightsTexture?.delete();
      triPositionBuffer?.delete();
      triTexCoordBuffer?.delete();
      colorTexture?.delete();
      if (updateTimer) {
        clearTimeout(updateTimer);
      }
    }
    _getAttributeManager() {
      return new AttributeManager(this.context.gl, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
    _getChangeFlags(opts) {
      const changeFlags = {};
      const {
        dimensions
      } = this.state;
      changeFlags.dataChanged = this.isAttributeChanged() || this.isAggregationDirty(opts, {
        compareAll: true,
        dimension: dimensions.data
      });
      changeFlags.viewportChanged = opts.changeFlags.viewportChanged;
      const {
        zoom
      } = this.state;
      if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {
        changeFlags.viewportZoomChanged = true;
      }
      return changeFlags;
    }
    _createTextures() {
      const {
        gl
      } = this.context;
      const {
        textureSize,
        format,
        type
      } = this.state;
      this.setState({
        weightsTexture: new Texture2D(gl, {
          width: textureSize,
          height: textureSize,
          format,
          type,
          ...TEXTURE_OPTIONS
        }),
        maxWeightsTexture: new Texture2D(gl, {
          format,
          type,
          ...TEXTURE_OPTIONS
        })
      });
    }
    _setupAttributes() {
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          type: esm_default2.DOUBLE,
          accessor: "getPosition"
        },
        weights: {
          size: 1,
          accessor: "getWeight"
        }
      });
      this.setState({
        positionAttributeName: "positions"
      });
    }
    _setupTextureParams() {
      const {
        gl
      } = this.context;
      const {
        weightsTextureSize
      } = this.props;
      const textureSize = Math.min(weightsTextureSize, getParameters(gl, gl.MAX_TEXTURE_SIZE));
      const floatTargetSupport = hasFeatures(gl, FLOAT_TARGET_FEATURES);
      const {
        format,
        type
      } = getTextureParams({
        gl,
        floatTargetSupport
      });
      const weightsScale = floatTargetSupport ? 1 : 1 / 255;
      this.setState({
        textureSize,
        format,
        type,
        weightsScale
      });
      if (!floatTargetSupport) {
        log_default.warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, fallingback to low precession format`)();
      }
    }
    getShaders(type) {
      return super.getShaders(type === "max-weights-transform" ? {
        vs: max_vs_glsl_default,
        _fs: max_fs_glsl_default
      } : {
        vs: weights_vs_glsl_default,
        _fs: weights_fs_glsl_default
      });
    }
    _createWeightsTransform(shaders = {}) {
      const {
        gl
      } = this.context;
      let {
        weightsTransform
      } = this.state;
      const {
        weightsTexture
      } = this.state;
      weightsTransform?.delete();
      weightsTransform = new Transform(gl, {
        id: `${this.id}-weights-transform`,
        elementCount: 1,
        _targetTexture: weightsTexture,
        _targetTextureVarying: "weightsTexture",
        ...shaders
      });
      this.setState({
        weightsTransform
      });
    }
    _setupResources() {
      const {
        gl
      } = this.context;
      this._createTextures();
      const {
        textureSize,
        weightsTexture,
        maxWeightsTexture
      } = this.state;
      const weightsTransformShaders = this.getShaders("weights-transform");
      this._createWeightsTransform(weightsTransformShaders);
      const maxWeightsTransformShaders = this.getShaders("max-weights-transform");
      const maxWeightTransform = new Transform(gl, {
        id: `${this.id}-max-weights-transform`,
        _sourceTextures: {
          inTexture: weightsTexture
        },
        _targetTexture: maxWeightsTexture,
        _targetTextureVarying: "outTexture",
        ...maxWeightsTransformShaders,
        elementCount: textureSize * textureSize
      });
      this.setState({
        weightsTexture,
        maxWeightsTexture,
        maxWeightTransform,
        zoom: null,
        triPositionBuffer: new Buffer2(gl, {
          byteLength: 48,
          accessor: {
            size: 3
          }
        }),
        triTexCoordBuffer: new Buffer2(gl, {
          byteLength: 48,
          accessor: {
            size: 2
          }
        })
      });
    }
    updateShaders(shaderOptions) {
      this._createWeightsTransform(shaderOptions);
    }
    _updateMaxWeightValue() {
      const {
        maxWeightTransform
      } = this.state;
      maxWeightTransform.run({
        parameters: {
          blend: true,
          depthTest: false,
          blendFunc: [esm_default2.ONE, esm_default2.ONE],
          blendEquation: esm_default2.MAX
        }
      });
    }
    _updateBounds(forceUpdate = false) {
      const {
        viewport
      } = this.context;
      const viewportCorners = [viewport.unproject([0, 0]), viewport.unproject([viewport.width, 0]), viewport.unproject([viewport.width, viewport.height]), viewport.unproject([0, viewport.height])].map((p2) => p2.map(Math.fround));
      const visibleWorldBounds = getBounds2(viewportCorners);
      const newState = {
        visibleWorldBounds,
        viewportCorners
      };
      let boundsChanged = false;
      if (forceUpdate || !this.state.worldBounds || !boundsContain(this.state.worldBounds, visibleWorldBounds)) {
        const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);
        const worldBounds = this._commonToWorldBounds(scaledCommonBounds);
        if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
          worldBounds[1] = Math.max(worldBounds[1], -85.051129);
          worldBounds[3] = Math.min(worldBounds[3], 85.051129);
          worldBounds[0] = Math.max(worldBounds[0], -360);
          worldBounds[2] = Math.min(worldBounds[2], 360);
        }
        const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);
        newState.worldBounds = worldBounds;
        newState.normalizedCommonBounds = normalizedCommonBounds;
        boundsChanged = true;
      }
      this.setState(newState);
      return boundsChanged;
    }
    _updateTextureRenderingBounds() {
      const {
        triPositionBuffer,
        triTexCoordBuffer,
        normalizedCommonBounds,
        viewportCorners
      } = this.state;
      const {
        viewport
      } = this.context;
      triPositionBuffer.subData(packVertices(viewportCorners, 3));
      const textureBounds = viewportCorners.map((p2) => getTextureCoordinates(viewport.projectPosition(p2), normalizedCommonBounds));
      triTexCoordBuffer.subData(packVertices(textureBounds, 2));
    }
    _updateColorTexture(opts) {
      const {
        colorRange
      } = opts.props;
      let {
        colorTexture
      } = this.state;
      const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);
      if (colorTexture) {
        colorTexture.setImageData({
          data: colors,
          width: colorRange.length
        });
      } else {
        colorTexture = new Texture2D(this.context.gl, {
          data: colors,
          width: colorRange.length,
          height: 1,
          ...TEXTURE_OPTIONS
        });
      }
      this.setState({
        colorTexture
      });
    }
    _updateWeightmap() {
      const {
        radiusPixels,
        colorDomain,
        aggregation
      } = this.props;
      const {
        weightsTransform,
        worldBounds,
        textureSize,
        weightsTexture,
        weightsScale
      } = this.state;
      this.state.isWeightMapDirty = false;
      const commonBounds = this._worldToCommonBounds(worldBounds, {
        useLayerCoordinateSystem: true
      });
      if (colorDomain && aggregation === "SUM") {
        const {
          viewport
        } = this.context;
        const metersPerPixel = viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0]) / textureSize;
        this.state.colorDomain = colorDomain.map((x2) => x2 * metersPerPixel * weightsScale);
      } else {
        this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;
      }
      const uniforms = {
        radiusPixels,
        commonBounds,
        textureWidth: textureSize,
        weightsScale
      };
      weightsTransform.update({
        elementCount: this.getNumInstances()
      });
      withParameters(this.context.gl, {
        clearColor: [0, 0, 0, 0]
      }, () => {
        weightsTransform.run({
          uniforms,
          parameters: {
            blend: true,
            depthTest: false,
            blendFunc: [esm_default2.ONE, esm_default2.ONE],
            blendEquation: esm_default2.FUNC_ADD
          },
          clearRenderTarget: true,
          attributes: this.getAttributes(),
          moduleSettings: this.getModuleSettings()
        });
      });
      this._updateMaxWeightValue();
      weightsTexture.setParameters({
        [esm_default2.TEXTURE_MAG_FILTER]: esm_default2.LINEAR,
        [esm_default2.TEXTURE_MIN_FILTER]: esm_default2.LINEAR
      });
    }
    _debouncedUpdateWeightmap(fromTimer = false) {
      let {
        updateTimer
      } = this.state;
      const {
        debounceTimeout
      } = this.props;
      if (fromTimer) {
        updateTimer = null;
        this._updateBounds(true);
        this._updateTextureRenderingBounds();
        this.setState({
          isWeightMapDirty: true
        });
      } else {
        this.setState({
          isWeightMapDirty: false
        });
        clearTimeout(updateTimer);
        updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);
      }
      this.setState({
        updateTimer
      });
    }
    _worldToCommonBounds(worldBounds, opts = {}) {
      const {
        useLayerCoordinateSystem = false
      } = opts;
      const [minLong, minLat, maxLong, maxLat] = worldBounds;
      const {
        viewport
      } = this.context;
      const {
        textureSize
      } = this.state;
      const {
        coordinateSystem
      } = this.props;
      const offsetMode = useLayerCoordinateSystem && (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);
      const offsetOriginCommon = offsetMode ? viewport.projectPosition(this.props.coordinateOrigin) : [0, 0];
      const size = textureSize * RESOLUTION / viewport.scale;
      let bottomLeftCommon;
      let topRightCommon;
      if (useLayerCoordinateSystem && !offsetMode) {
        bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);
        topRightCommon = this.projectPosition([maxLong, maxLat, 0]);
      } else {
        bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);
        topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);
      }
      return scaleToAspectRatio([bottomLeftCommon[0] - offsetOriginCommon[0], bottomLeftCommon[1] - offsetOriginCommon[1], topRightCommon[0] - offsetOriginCommon[0], topRightCommon[1] - offsetOriginCommon[1]], size, size);
    }
    _commonToWorldBounds(commonBounds) {
      const [xMin, yMin, xMax, yMax] = commonBounds;
      const {
        viewport
      } = this.context;
      const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);
      const topRightWorld = viewport.unprojectPosition([xMax, yMax]);
      return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));
    }
  };
  __publicField(HeatmapLayer, "layerName", "HeatmapLayer");
  __publicField(HeatmapLayer, "defaultProps", defaultProps52);

  // ../google-maps/src/utils.ts
  var MAX_LATITUDE2 = 85.05113;
  function createDeckInstance(map2, overlay, deck, props) {
    if (deck) {
      if (deck.userData._googleMap === map2) {
        return deck;
      }
      destroyDeckInstance(deck);
    }
    const eventListeners = {
      click: null,
      rightclick: null,
      dblclick: null,
      mousemove: null,
      mouseout: null
    };
    const newDeck = new Deck({
      ...props,
      useDevicePixels: props.interleaved ? true : props.useDevicePixels,
      style: props.interleaved ? null : {
        pointerEvents: "none"
      },
      parent: getContainer(overlay, props.style),
      initialViewState: {
        longitude: 0,
        latitude: 0,
        zoom: 1
      },
      controller: false
    });
    for (const eventType in eventListeners) {
      eventListeners[eventType] = map2.addListener(eventType, (evt) => handleMouseEvent(newDeck, eventType, evt));
    }
    newDeck.userData._googleMap = map2;
    newDeck.userData._eventListeners = eventListeners;
    return newDeck;
  }
  function getContainer(overlay, style) {
    const container = document.createElement("div");
    container.style.position = "absolute";
    Object.assign(container.style, style);
    if ("getPanes" in overlay) {
      overlay.getPanes()?.overlayLayer.appendChild(container);
    } else {
      overlay.getMap()?.getDiv().appendChild(container);
    }
    return container;
  }
  function destroyDeckInstance(deck) {
    const {
      _eventListeners: eventListeners
    } = deck.userData;
    for (const eventType in eventListeners) {
      if (eventListeners[eventType]) {
        eventListeners[eventType].remove();
      }
    }
    deck.finalize();
  }
  function getViewPropsFromOverlay(map2, overlay) {
    const {
      width,
      height
    } = getMapSize(map2);
    const projection = overlay.getProjection();
    const bounds = map2.getBounds();
    if (!bounds) {
      return {
        width,
        height,
        left: 0,
        top: 0
      };
    }
    const ne = bounds.getNorthEast();
    const sw = bounds.getSouthWest();
    const topRight = projection.fromLatLngToDivPixel(ne);
    const bottomLeft = projection.fromLatLngToDivPixel(sw);
    const centerLngLat = pixelToLngLat(projection, width / 2, height / 2);
    const centerH = new google.maps.LatLng(0, centerLngLat[0]);
    const centerContainerPx = projection.fromLatLngToContainerPixel(centerH);
    const centerDivPx = projection.fromLatLngToDivPixel(centerH);
    if (!topRight || !bottomLeft || !centerDivPx || !centerContainerPx) {
      return {
        width,
        height,
        left: 0,
        top: 0
      };
    }
    const leftOffset = Math.round(centerDivPx.x - centerContainerPx.x);
    let topOffset = centerDivPx.y - centerContainerPx.y;
    const topLngLat = pixelToLngLat(projection, width / 2, 0);
    const bottomLngLat = pixelToLngLat(projection, width / 2, height);
    let latitude = centerLngLat[1];
    const longitude = centerLngLat[0];
    if (Math.abs(latitude) > MAX_LATITUDE2) {
      latitude = latitude > 0 ? MAX_LATITUDE2 : -MAX_LATITUDE2;
      const center = new google.maps.LatLng(latitude, longitude);
      const centerPx = projection.fromLatLngToContainerPixel(center);
      topOffset += centerPx.y - height / 2;
    }
    topOffset = Math.round(topOffset);
    const delta = new Vector2(topLngLat).sub(bottomLngLat);
    let bearing = 180 * delta.verticalAngle() / Math.PI;
    if (bearing < 0)
      bearing += 360;
    const heading = map2.getHeading() || 0;
    let zoom = map2.getZoom() - 1;
    let scale8;
    if (bearing === 0) {
      scale8 = height ? (bottomLeft.y - topRight.y) / height : 1;
    } else if (bearing === heading) {
      const viewDiagonal = new Vector2([topRight.x, topRight.y]).sub([bottomLeft.x, bottomLeft.y]).len();
      const mapDiagonal = new Vector2([width, -height]).len();
      scale8 = mapDiagonal ? viewDiagonal / mapDiagonal : 1;
    }
    zoom += Math.log2(scale8 || 1);
    return {
      width,
      height,
      left: leftOffset,
      top: topOffset,
      zoom,
      bearing,
      pitch: map2.getTilt(),
      latitude,
      longitude
    };
  }
  function getViewPropsFromCoordinateTransformer(map2, transformer) {
    const {
      width,
      height
    } = getMapSize(map2);
    const {
      center,
      heading: bearing,
      tilt: pitch,
      zoom
    } = transformer.getCameraParams();
    const fovy = 25;
    const aspect = height ? width / height : 1;
    const near = 0.75;
    const far = 3e14;
    const projectionMatrix = new Matrix4().perspective({
      fovy: fovy * Math.PI / 180,
      aspect,
      near,
      far
    });
    const focalDistance = 0.5 * projectionMatrix[5];
    return {
      width,
      height,
      viewState: {
        altitude: focalDistance,
        bearing,
        latitude: center.lat(),
        longitude: center.lng(),
        pitch,
        projectionMatrix,
        repeat: true,
        zoom: zoom - 1
      }
    };
  }
  function getMapSize(map2) {
    const container = map2.getDiv().firstChild;
    return {
      width: container.offsetWidth,
      height: container.offsetHeight
    };
  }
  function pixelToLngLat(projection, x2, y2) {
    const point = new google.maps.Point(x2, y2);
    const latLng = projection.fromContainerPixelToLatLng(point);
    return [latLng.lng(), latLng.lat()];
  }
  function getEventPixel(event, deck) {
    if (event.pixel) {
      return event.pixel;
    }
    const point = deck.getViewports()[0].project([event.latLng.lng(), event.latLng.lat()]);
    return {
      x: point[0],
      y: point[1]
    };
  }
  function handleMouseEvent(deck, type, event) {
    if (!deck.isInitialized) {
      return;
    }
    const mockEvent = {
      type,
      offsetCenter: getEventPixel(event, deck),
      srcEvent: event
    };
    switch (type) {
      case "click":
      case "rightclick":
        mockEvent.type = "click";
        mockEvent.tapCount = 1;
        deck._onPointerDown(mockEvent);
        deck._onEvent(mockEvent);
        break;
      case "dblclick":
        mockEvent.type = "click";
        mockEvent.tapCount = 2;
        deck._onEvent(mockEvent);
        break;
      case "mousemove":
        mockEvent.type = "pointermove";
        deck._onPointerMove(mockEvent);
        break;
      case "mouseout":
        mockEvent.type = "pointerleave";
        deck._onPointerMove(mockEvent);
        break;
      default:
        return;
    }
  }

  // ../google-maps/src/google-maps-overlay.ts
  var HIDE_ALL_LAYERS = () => false;
  var GL_STATE = {
    depthMask: true,
    depthTest: true,
    blend: true,
    blendFunc: [esm_default2.SRC_ALPHA, esm_default2.ONE_MINUS_SRC_ALPHA, esm_default2.ONE, esm_default2.ONE_MINUS_SRC_ALPHA],
    blendEquation: esm_default2.FUNC_ADD
  };
  function noop7() {
  }
  var defaultProps53 = {
    interleaved: true
  };
  var GoogleMapsOverlay = class {
    props = {};
    _map = null;
    _deck = null;
    _overlay = null;
    constructor(props) {
      this.setProps({
        ...defaultProps53,
        ...props
      });
    }
    setMap(map2) {
      if (map2 === this._map) {
        return;
      }
      const {
        VECTOR,
        UNINITIALIZED
      } = google.maps.RenderingType;
      if (this._map) {
        if (!map2 && this._map.getRenderingType() === VECTOR && this.props.interleaved) {
          this._overlay.requestRedraw();
        }
        this._overlay?.setMap(null);
        this._map = null;
      }
      if (map2) {
        this._map = map2;
        const renderingType = map2.getRenderingType();
        if (renderingType !== UNINITIALIZED) {
          this._createOverlay(map2);
        } else {
          map2.addListener("renderingtype_changed", () => {
            this._createOverlay(map2);
          });
        }
      }
    }
    setProps(props) {
      Object.assign(this.props, props);
      if (this._deck) {
        if (props.style) {
          const parentStyle = this._deck.canvas.parentElement.style;
          Object.assign(parentStyle, props.style);
          props.style = null;
        }
        this._deck.setProps(props);
      }
    }
    pickObject(params) {
      return this._deck && this._deck.pickObject(params);
    }
    pickMultipleObjects(params) {
      return this._deck && this._deck.pickMultipleObjects(params);
    }
    pickObjects(params) {
      return this._deck && this._deck.pickObjects(params);
    }
    finalize() {
      this.setMap(null);
      if (this._deck) {
        destroyDeckInstance(this._deck);
        this._deck = null;
      }
    }
    _createOverlay(map2) {
      const {
        interleaved
      } = this.props;
      const {
        VECTOR,
        UNINITIALIZED
      } = google.maps.RenderingType;
      const renderingType = map2.getRenderingType();
      if (renderingType === UNINITIALIZED) {
        return;
      }
      const isVectorMap = renderingType === VECTOR && google.maps.WebGLOverlayView;
      const OverlayView = isVectorMap ? google.maps.WebGLOverlayView : google.maps.OverlayView;
      const overlay = new OverlayView();
      if (overlay instanceof google.maps.WebGLOverlayView) {
        if (interleaved) {
          overlay.onAdd = noop7;
          overlay.onContextRestored = this._onContextRestored.bind(this);
          overlay.onDraw = this._onDrawVectorInterleaved.bind(this);
        } else {
          overlay.onAdd = this._onAdd.bind(this);
          overlay.onContextRestored = noop7;
          overlay.onDraw = this._onDrawVectorOverlay.bind(this);
        }
        overlay.onContextLost = this._onContextLost.bind(this);
      } else {
        overlay.onAdd = this._onAdd.bind(this);
        overlay.draw = this._onDrawRaster.bind(this);
      }
      overlay.onRemove = this._onRemove.bind(this);
      this._overlay = overlay;
      this._overlay.setMap(map2);
    }
    _onAdd() {
      this._deck = createDeckInstance(this._map, this._overlay, this._deck, this.props);
    }
    _onContextRestored({
      gl
    }) {
      if (!this._map || !this._overlay) {
        return;
      }
      const _customRender = () => {
        if (this._overlay) {
          this._overlay.requestRedraw();
        }
      };
      const deck = createDeckInstance(this._map, this._overlay, this._deck, {
        gl,
        _customRender,
        ...this.props
      });
      this._deck = deck;
      const {
        animationLoop
      } = deck;
      animationLoop._renderFrame = () => {
        const ab = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
        withParameters(gl, {}, () => {
          animationLoop.onRender();
        });
        gl.bindBuffer(gl.ARRAY_BUFFER, ab);
      };
    }
    _onContextLost() {
      if (this._deck) {
        destroyDeckInstance(this._deck);
        this._deck = null;
      }
    }
    _onRemove() {
      this._deck?.setProps({
        layerFilter: HIDE_ALL_LAYERS
      });
    }
    _onDrawRaster() {
      if (!this._deck || !this._map) {
        return;
      }
      const deck = this._deck;
      const {
        width,
        height,
        left,
        top,
        ...rest
      } = getViewPropsFromOverlay(this._map, this._overlay);
      const parentStyle = deck.canvas.parentElement.style;
      parentStyle.left = `${left}px`;
      parentStyle.top = `${top}px`;
      const altitude = 1e4;
      deck.setProps({
        width,
        height,
        viewState: {
          altitude,
          repeat: true,
          ...rest
        }
      });
      deck.redraw();
    }
    _onDrawVectorInterleaved({
      gl,
      transformer
    }) {
      if (!this._deck || !this._map) {
        return;
      }
      const deck = this._deck;
      deck.setProps({
        ...getViewPropsFromCoordinateTransformer(this._map, transformer),
        width: null,
        height: null
      });
      if (deck.isInitialized) {
        const _framebuffer = getParameters(gl, esm_default2.FRAMEBUFFER_BINDING);
        deck.setProps({
          _framebuffer
        });
        deck.needsRedraw({
          clearRedrawFlags: true
        });
        setParameters(gl, {
          viewport: [0, 0, gl.canvas.width, gl.canvas.height],
          scissor: [0, 0, gl.canvas.width, gl.canvas.height],
          stencilFunc: [gl.ALWAYS, 0, 255, gl.ALWAYS, 0, 255]
        });
        withParameters(gl, GL_STATE, () => {
          deck._drawLayers("google-vector", {
            clearCanvas: false
          });
        });
      }
    }
    _onDrawVectorOverlay({
      transformer
    }) {
      if (!this._deck || !this._map) {
        return;
      }
      const deck = this._deck;
      deck.setProps({
        ...getViewPropsFromCoordinateTransformer(this._map, transformer)
      });
      deck.redraw();
    }
  };

  // ../mapbox/src/deck-utils.ts
  var TILE_SIZE6 = 512;
  var DEGREES_TO_RADIANS8 = Math.PI / 180;
  function getDeckInstance({
    map: map2,
    gl,
    deck
  }) {
    if (map2.__deck) {
      return map2.__deck;
    }
    const customRender = deck?.props._customRender;
    const onLoad = deck?.props.onLoad;
    const deckProps = getInterleavedProps({
      ...deck?.props,
      _customRender: () => {
        map2.triggerRepaint();
        customRender?.("");
      }
    });
    let deckInstance;
    if (!deck || deck.props.gl === gl) {
      Object.assign(deckProps, {
        gl,
        width: null,
        height: null,
        touchAction: "unset",
        viewState: getViewState(map2)
      });
      if (deck?.isInitialized) {
        watchMapMove(deck, map2);
      } else {
        deckProps.onLoad = () => {
          onLoad?.();
          watchMapMove(deckInstance, map2);
        };
      }
    }
    if (deck) {
      deckInstance = deck;
      deck.setProps(deckProps);
      deck.userData.isExternal = true;
    } else {
      deckInstance = new Deck(deckProps);
      map2.on("remove", () => {
        removeDeckInstance(map2);
      });
    }
    deckInstance.userData.mapboxLayers = /* @__PURE__ */ new Set();
    map2.__deck = deckInstance;
    map2.on("render", () => {
      if (deckInstance.isInitialized)
        afterRender(deckInstance, map2);
    });
    return deckInstance;
  }
  function watchMapMove(deck, map2) {
    const _handleMapMove = () => {
      if (deck.isInitialized) {
        onMapMove(deck, map2);
      } else {
        map2.off("move", _handleMapMove);
      }
    };
    map2.on("move", _handleMapMove);
  }
  function removeDeckInstance(map2) {
    map2.__deck?.finalize();
    map2.__deck = null;
  }
  function getInterleavedProps(currProps) {
    const nextProps = {
      ...currProps,
      parameters: {
        depthMask: true,
        depthTest: true,
        blend: true,
        blendFunc: [esm_default2.SRC_ALPHA, esm_default2.ONE_MINUS_SRC_ALPHA, esm_default2.ONE, esm_default2.ONE_MINUS_SRC_ALPHA],
        polygonOffsetFill: true,
        depthFunc: esm_default2.LEQUAL,
        blendEquation: esm_default2.FUNC_ADD,
        ...currProps.parameters
      },
      views: currProps.views || [new MapView({
        id: "mapbox"
      })]
    };
    return nextProps;
  }
  function addLayer(deck, layer) {
    deck.userData.mapboxLayers.add(layer);
    updateLayers(deck);
  }
  function removeLayer(deck, layer) {
    deck.userData.mapboxLayers.delete(layer);
    updateLayers(deck);
  }
  function updateLayer(deck, layer) {
    updateLayers(deck);
  }
  function drawLayer(deck, map2, layer) {
    let {
      currentViewport
    } = deck.userData;
    let clearStack = false;
    if (!currentViewport) {
      currentViewport = getViewport(deck, map2, true);
      deck.userData.currentViewport = currentViewport;
      clearStack = true;
    }
    if (!deck.isInitialized) {
      return;
    }
    deck._drawLayers("mapbox-repaint", {
      viewports: [currentViewport],
      layerFilter: ({
        layer: deckLayer
      }) => layer.id === deckLayer.id,
      clearStack,
      clearCanvas: false
    });
  }
  function getViewState(map2) {
    const {
      lng,
      lat
    } = map2.getCenter();
    const viewState = {
      longitude: (lng + 540) % 360 - 180,
      latitude: lat,
      zoom: map2.getZoom(),
      bearing: map2.getBearing(),
      pitch: map2.getPitch(),
      padding: map2.getPadding(),
      repeat: map2.getRenderWorldCopies()
    };
    if (map2.getTerrain?.()) {
      centerCameraOnTerrain(map2, viewState);
    }
    return viewState;
  }
  function centerCameraOnTerrain(map2, viewState) {
    if (map2.getFreeCameraOptions) {
      const {
        position
      } = map2.getFreeCameraOptions();
      if (!position || position.z === void 0) {
        return;
      }
      const height = map2.transform.height;
      const {
        longitude,
        latitude,
        pitch
      } = viewState;
      const cameraX = position.x * TILE_SIZE6;
      const cameraY = (1 - position.y) * TILE_SIZE6;
      const cameraZ = position.z * TILE_SIZE6;
      const center = lngLatToWorld([longitude, latitude]);
      const dx = cameraX - center[0];
      const dy = cameraY - center[1];
      const cameraToCenterDistanceGround = Math.sqrt(dx * dx + dy * dy);
      const pitchRadians = pitch * DEGREES_TO_RADIANS8;
      const altitudePixels = 1.5 * height;
      const scale8 = pitchRadians < 1e-3 ? altitudePixels * Math.cos(pitchRadians) / cameraZ : altitudePixels * Math.sin(pitchRadians) / cameraToCenterDistanceGround;
      viewState.zoom = Math.log2(scale8);
      const cameraZFromSurface = altitudePixels * Math.cos(pitchRadians) / scale8;
      const surfaceElevation = cameraZ - cameraZFromSurface;
      viewState.position = [0, 0, surfaceElevation / unitsPerMeter(latitude)];
    } else if (typeof map2.transform.elevation === "number") {
      viewState.position = [0, 0, map2.transform.elevation];
    }
  }
  function getViewport(deck, map2, useMapboxProjection = true) {
    return new WebMercatorViewport2({
      id: "mapbox",
      x: 0,
      y: 0,
      width: deck.width,
      height: deck.height,
      ...getViewState(map2),
      nearZMultiplier: useMapboxProjection ? 0.02 : 0.1
    });
  }
  function afterRender(deck, map2) {
    const {
      mapboxLayers,
      isExternal
    } = deck.userData;
    if (isExternal) {
      const mapboxLayerIds = Array.from(mapboxLayers, (layer) => layer.id);
      const deckLayers = flatten(deck.props.layers, Boolean);
      const hasNonMapboxLayers = deckLayers.some((layer) => layer && !mapboxLayerIds.includes(layer.id));
      let viewports = deck.getViewports();
      const mapboxViewportIdx = viewports.findIndex((vp) => vp.id === "mapbox");
      const hasNonMapboxViews = viewports.length > 1 || mapboxViewportIdx < 0;
      if (hasNonMapboxLayers || hasNonMapboxViews) {
        if (mapboxViewportIdx >= 0) {
          viewports = viewports.slice();
          viewports[mapboxViewportIdx] = getViewport(deck, map2, false);
        }
        deck._drawLayers("mapbox-repaint", {
          viewports,
          layerFilter: (params) => (!deck.props.layerFilter || deck.props.layerFilter(params)) && (params.viewport.id !== "mapbox" || !mapboxLayerIds.includes(params.layer.id)),
          clearCanvas: false
        });
      }
    }
    deck.userData.currentViewport = null;
  }
  function onMapMove(deck, map2) {
    deck.setProps({
      viewState: getViewState(map2)
    });
    deck.needsRedraw({
      clearRedrawFlags: true
    });
  }
  function updateLayers(deck) {
    if (deck.userData.isExternal) {
      return;
    }
    const layers = [];
    deck.userData.mapboxLayers.forEach((deckLayer) => {
      const LayerType = deckLayer.props.type;
      const layer = new LayerType(deckLayer.props);
      layers.push(layer);
    });
    deck.setProps({
      layers
    });
  }

  // ../mapbox/src/mapbox-layer.ts
  var MapboxLayer = class {
    constructor(props) {
      if (!props.id) {
        throw new Error("Layer must have an unique id");
      }
      this.id = props.id;
      this.type = "custom";
      this.renderingMode = props.renderingMode || "3d";
      this.map = null;
      this.deck = null;
      this.props = props;
    }
    onAdd(map2, gl) {
      this.map = map2;
      this.deck = getDeckInstance({
        map: map2,
        gl,
        deck: this.props.deck
      });
      addLayer(this.deck, this);
    }
    onRemove() {
      if (this.deck) {
        removeLayer(this.deck, this);
      }
    }
    setProps(props) {
      Object.assign(this.props, props, {
        id: this.id
      });
      if (this.deck) {
        updateLayer(this.deck, this);
      }
    }
    render() {
      drawLayer(this.deck, this.map, this);
    }
  };

  // ../mapbox/src/resolve-layers.ts
  var UNDEFINED_BEFORE_ID = "__UNDEFINED__";
  function resolveLayers(map2, deck, oldLayers, newLayers) {
    if (!map2 || !deck || !map2.style || !map2.style._loaded) {
      return;
    }
    const layers = flatten(newLayers, Boolean);
    if (oldLayers !== newLayers) {
      const prevLayers = flatten(oldLayers, Boolean);
      const prevLayerIds = new Set(prevLayers.map((l2) => l2.id));
      for (const layer of layers) {
        prevLayerIds.delete(layer.id);
      }
      for (const id of prevLayerIds) {
        if (map2.getLayer(id)) {
          map2.removeLayer(id);
        }
      }
    }
    for (const layer of layers) {
      const mapboxLayer = map2.getLayer(layer.id);
      if (mapboxLayer) {
        mapboxLayer.implementation.setProps(layer.props);
      } else {
        map2.addLayer(
          new MapboxLayer({
            id: layer.id,
            deck
          }),
          layer.props.beforeId
        );
      }
    }
    const mapLayers = map2.style._order;
    const layerGroups = {};
    for (const layer of layers) {
      let {
        beforeId
      } = layer.props;
      if (!beforeId || !mapLayers.includes(beforeId)) {
        beforeId = UNDEFINED_BEFORE_ID;
      }
      layerGroups[beforeId] = layerGroups[beforeId] || [];
      layerGroups[beforeId].push(layer.id);
    }
    for (const beforeId in layerGroups) {
      const layerGroup = layerGroups[beforeId];
      let lastLayerIndex = beforeId === UNDEFINED_BEFORE_ID ? mapLayers.length : mapLayers.indexOf(beforeId);
      let lastLayerId = beforeId === UNDEFINED_BEFORE_ID ? void 0 : beforeId;
      for (let i3 = layerGroup.length - 1; i3 >= 0; i3--) {
        const layerId = layerGroup[i3];
        const layerIndex = mapLayers.indexOf(layerId);
        if (layerIndex !== lastLayerIndex - 1) {
          map2.moveLayer(layerId, lastLayerId);
          if (layerIndex > lastLayerIndex) {
            lastLayerIndex++;
          }
        }
        lastLayerIndex--;
        lastLayerId = layerId;
      }
    }
  }

  // ../mapbox/src/mapbox-overlay.ts
  var MapboxOverlay = class {
    constructor(props) {
      const {
        interleaved = false,
        ...otherProps
      } = props;
      this._interleaved = interleaved;
      this._props = otherProps;
    }
    setProps(props) {
      if (this._interleaved && props.layers) {
        resolveLayers(this._map, this._deck, this._props.layers, props.layers);
      }
      Object.assign(this._props, props);
      if (this._deck) {
        this._deck.setProps(this._interleaved ? getInterleavedProps(this._props) : this._props);
      }
    }
    onAdd(map2) {
      this._map = map2;
      return this._interleaved ? this._onAddInterleaved(map2) : this._onAddOverlaid(map2);
    }
    _onAddOverlaid(map2) {
      const container = document.createElement("div");
      Object.assign(container.style, {
        position: "absolute",
        left: 0,
        top: 0,
        pointerEvents: "none"
      });
      this._container = container;
      this._deck = new Deck({
        ...this._props,
        parent: container,
        viewState: getViewState(map2)
      });
      map2.on("resize", this._updateContainerSize);
      map2.on("render", this._updateViewState);
      map2.on("mousedown", this._handleMouseEvent);
      map2.on("dragstart", this._handleMouseEvent);
      map2.on("drag", this._handleMouseEvent);
      map2.on("dragend", this._handleMouseEvent);
      map2.on("mousemove", this._handleMouseEvent);
      map2.on("mouseout", this._handleMouseEvent);
      map2.on("click", this._handleMouseEvent);
      map2.on("dblclick", this._handleMouseEvent);
      this._updateContainerSize();
      return container;
    }
    _onAddInterleaved(map2) {
      this._deck = getDeckInstance({
        map: map2,
        gl: map2.painter.context.gl,
        deck: new Deck({
          ...this._props,
          gl: map2.painter.context.gl
        })
      });
      map2.on("styledata", this._handleStyleChange);
      resolveLayers(map2, this._deck, [], this._props.layers);
      return document.createElement("div");
    }
    onRemove() {
      const map2 = this._map;
      if (map2) {
        if (this._interleaved) {
          this._onRemoveInterleaved(map2);
        } else {
          this._onRemoveOverlaid(map2);
        }
      }
      this._deck = void 0;
      this._map = void 0;
      this._container = void 0;
    }
    _onRemoveOverlaid(map2) {
      map2.off("resize", this._updateContainerSize);
      map2.off("render", this._updateViewState);
      map2.off("mousedown", this._handleMouseEvent);
      map2.off("dragstart", this._handleMouseEvent);
      map2.off("drag", this._handleMouseEvent);
      map2.off("dragend", this._handleMouseEvent);
      map2.off("mousemove", this._handleMouseEvent);
      map2.off("mouseout", this._handleMouseEvent);
      map2.off("click", this._handleMouseEvent);
      map2.off("dblclick", this._handleMouseEvent);
      this._deck?.finalize();
    }
    _onRemoveInterleaved(map2) {
      map2.off("styledata", this._handleStyleChange);
      resolveLayers(map2, this._deck, this._props.layers, []);
      removeDeckInstance(map2);
    }
    getDefaultPosition() {
      return "top-left";
    }
    pickObject(params) {
      assert11(this._deck);
      return this._deck.pickObject(params);
    }
    pickMultipleObjects(params) {
      assert11(this._deck);
      return this._deck.pickMultipleObjects(params);
    }
    pickObjects(params) {
      assert11(this._deck);
      return this._deck.pickObjects(params);
    }
    finalize() {
      if (this._map) {
        this._map.removeControl(this);
      }
    }
    _handleStyleChange = () => {
      resolveLayers(this._map, this._deck, this._props.layers, this._props.layers);
    };
    _updateContainerSize = () => {
      if (this._map && this._container) {
        const {
          clientWidth,
          clientHeight
        } = this._map.getContainer();
        Object.assign(this._container.style, {
          width: `${clientWidth}px`,
          height: `${clientHeight}px`
        });
      }
    };
    _updateViewState = () => {
      const deck = this._deck;
      if (deck) {
        deck.setProps({
          viewState: getViewState(this._map)
        });
        if (deck.isInitialized) {
          deck.redraw();
        }
      }
    };
    _handleMouseEvent = (event) => {
      const deck = this._deck;
      if (!deck || !deck.isInitialized) {
        return;
      }
      const mockEvent = {
        type: event.type,
        offsetCenter: event.point,
        srcEvent: event
      };
      const lastDown = this._lastMouseDownPoint;
      if (!event.point && lastDown) {
        mockEvent.deltaX = event.originalEvent.clientX - lastDown.clientX;
        mockEvent.deltaY = event.originalEvent.clientY - lastDown.clientY;
        mockEvent.offsetCenter = {
          x: lastDown.x + mockEvent.deltaX,
          y: lastDown.y + mockEvent.deltaY
        };
      }
      switch (mockEvent.type) {
        case "mousedown":
          deck._onPointerDown(mockEvent);
          this._lastMouseDownPoint = {
            ...event.point,
            clientX: event.originalEvent.clientX,
            clientY: event.originalEvent.clientY
          };
          break;
        case "dragstart":
          mockEvent.type = "panstart";
          deck._onEvent(mockEvent);
          break;
        case "drag":
          mockEvent.type = "panmove";
          deck._onEvent(mockEvent);
          break;
        case "dragend":
          mockEvent.type = "panend";
          deck._onEvent(mockEvent);
          break;
        case "click":
          mockEvent.tapCount = 1;
          deck._onEvent(mockEvent);
          break;
        case "dblclick":
          mockEvent.type = "click";
          mockEvent.tapCount = 2;
          deck._onEvent(mockEvent);
          break;
        case "mousemove":
          mockEvent.type = "pointermove";
          deck._onPointerMove(mockEvent);
          break;
        case "mouseout":
          mockEvent.type = "pointerleave";
          deck._onPointerMove(mockEvent);
          break;
        default:
          return;
      }
    };
  };

  // bundle.ts
  var h3 = __toESM(require_h3_js());
  H3HexagonLayer._checkH3Lib = () => {
    const installHelp = 'include the <script src="https://unpkg.com/h3-js@^3.0.0"><\/script> tag before the deck.gl script tag. https://deck.gl/docs/api-reference/geo-layers/h3-hexagon-layer';
    if (!h3) {
      throw new Error(`To use H3 functionality, ${installHelp}`);
    } else if (!h3.polyfill && h3.polygonToCells) {
      throw new Error(`Incompatible h3-js version. ${installHelp}`);
    }
  };
  return __toCommonJS(bundle_exports);
})();
      return __exports__;
      });

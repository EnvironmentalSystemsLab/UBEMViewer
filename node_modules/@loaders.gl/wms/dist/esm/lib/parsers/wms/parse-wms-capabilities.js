import { XMLLoader } from '@loaders.gl/xml';
import { getXMLArray, getXMLStringArray, getXMLInteger, getXMLFloat, getXMLBoolean } from '../xml/parse-xml-helpers';
export function parseWMSCapabilities(xmlText, options) {
  const parsedXML = XMLLoader.parseTextSync(xmlText, options);
  const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
  const capabilities = extractCapabilities(xmlCapabilities);
  if (options !== null && options !== void 0 && options.inheritedLayerProps) {
    for (const layer of capabilities.layers) {
      addInheritedLayerProps(layer, null);
    }
  }
  if (options !== null && options !== void 0 && options.includeRawData || options !== null && options !== void 0 && options.raw) {
    capabilities.raw = xmlCapabilities;
  }
  if (options !== null && options !== void 0 && options.includeXMLText) {
    capabilities.xml = xmlText;
  }
  return capabilities;
}
function extractCapabilities(xml) {
  var _xml$Service, _xml$Service2, _xml$Service3, _xml$Service4, _xml$Service5, _xml$Service6, _xml$Service6$Keyword, _xml$Service7, _xml$Service8, _xml$Service9, _xml$Service10, _xml$Service11, _xml$Service12, _xml$Service13, _xml$Capability, _xml$Capability2;
  const capabilities = {
    version: String(xml.version || ''),
    name: String(((_xml$Service = xml.Service) === null || _xml$Service === void 0 ? void 0 : _xml$Service.Name) || 'unnamed'),
    title: (_xml$Service2 = xml.Service) !== null && _xml$Service2 !== void 0 && _xml$Service2.Title ? String((_xml$Service3 = xml.Service) === null || _xml$Service3 === void 0 ? void 0 : _xml$Service3.Title) : undefined,
    abstract: (_xml$Service4 = xml.Service) !== null && _xml$Service4 !== void 0 && _xml$Service4.Abstract ? String((_xml$Service5 = xml.Service) === null || _xml$Service5 === void 0 ? void 0 : _xml$Service5.Abstract) : undefined,
    keywords: getXMLStringArray((_xml$Service6 = xml.Service) === null || _xml$Service6 === void 0 ? void 0 : (_xml$Service6$Keyword = _xml$Service6.KeywordList) === null || _xml$Service6$Keyword === void 0 ? void 0 : _xml$Service6$Keyword.Keyword),
    fees: (_xml$Service7 = xml.Service) !== null && _xml$Service7 !== void 0 && _xml$Service7.Fees ? JSON.stringify((_xml$Service8 = xml.Service) === null || _xml$Service8 === void 0 ? void 0 : _xml$Service8.Fees) : undefined,
    accessConstraints: (_xml$Service9 = xml.Service) !== null && _xml$Service9 !== void 0 && _xml$Service9.AccessConstraints ? JSON.stringify((_xml$Service10 = xml.Service) === null || _xml$Service10 === void 0 ? void 0 : _xml$Service10.AccessConstraints) : undefined,
    layerLimit: getXMLInteger((_xml$Service11 = xml.Service) === null || _xml$Service11 === void 0 ? void 0 : _xml$Service11.LayerLimit),
    maxWidth: getXMLInteger((_xml$Service12 = xml.Service) === null || _xml$Service12 === void 0 ? void 0 : _xml$Service12.maxWidth),
    maxHeight: getXMLInteger((_xml$Service13 = xml.Service) === null || _xml$Service13 === void 0 ? void 0 : _xml$Service13.maxHeight),
    layers: [],
    requests: extractRequests((_xml$Capability = xml.Capability) === null || _xml$Capability === void 0 ? void 0 : _xml$Capability.Request),
    exceptions: extractExceptions(xml.Exception)
  };
  const xmlLayers = getXMLArray((_xml$Capability2 = xml.Capability) === null || _xml$Capability2 === void 0 ? void 0 : _xml$Capability2.Layer);
  for (const xmlSubLayer of xmlLayers) {
    capabilities.layers.push(extractLayer(xmlSubLayer));
  }
  for (const [key, value] of Object.entries(capabilities)) {
    if (value === undefined) {
      delete capabilities[key];
    }
  }
  return capabilities;
}
function extractRequests(xmlRequests) {
  const requests = {};
  for (const [name, xmlRequest] of Object.entries(xmlRequests || {})) {
    const mimeTypes = getXMLStringArray(xmlRequest === null || xmlRequest === void 0 ? void 0 : xmlRequest.Format);
    requests[name] = {
      mimeTypes
    };
  }
  return requests;
}
function extractExceptions(xmlException) {
  const xmlExceptionFormats = getXMLArray(xmlException === null || xmlException === void 0 ? void 0 : xmlException.Format);
  if (xmlExceptionFormats.length > 0) {
    return {
      mimeTypes: getXMLStringArray(xmlException)
    };
  }
  return undefined;
}
function extractLayer(xmlLayer) {
  var _xmlLayer$KeywordList;
  const layer = {
    title: String((xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Title) || ''),
    name: (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name) && String(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name),
    abstract: (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name) && String(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Abstract),
    keywords: getXMLStringArray((_xmlLayer$KeywordList = xmlLayer.KeywordList) === null || _xmlLayer$KeywordList === void 0 ? void 0 : _xmlLayer$KeywordList.Keyword)
  };
  const crs = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.CRS) || (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.SRS);
  if (crs && Array.isArray(crs) && crs.every(_ => typeof _ === 'string')) {
    layer.crs = crs;
  }
  let geographicBoundingBox = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.EX_GeographicBoundingBox) && extractEXBoundingBox(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.EX_GeographicBoundingBox);
  if (geographicBoundingBox) {
    layer.geographicBoundingBox = geographicBoundingBox;
  }
  geographicBoundingBox = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.LatLonBoundingBox) && extractLatLonBoundingBox(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.LatLonBoundingBox);
  if (geographicBoundingBox) {
    layer.geographicBoundingBox = geographicBoundingBox;
  }
  const boundingBoxes = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.BoundingBox) && extractWMSBoundingBoxes(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.BoundingBox);
  if (boundingBoxes && boundingBoxes.length > 0) {
    layer.boundingBoxes = boundingBoxes;
  }
  const xmlDimensions = getXMLArray(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Dimension);
  const dimensions = xmlDimensions.map(xml => extractDimension(xml));
  if (dimensions.length) {
    layer.dimensions = dimensions;
  }
  if (xmlLayer !== null && xmlLayer !== void 0 && xmlLayer.opaque) {
    layer.opaque = getXMLBoolean(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.opaque);
  }
  if (xmlLayer !== null && xmlLayer !== void 0 && xmlLayer.cascaded) {
    layer.cascaded = getXMLBoolean(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.cascaded);
  }
  if (xmlLayer !== null && xmlLayer !== void 0 && xmlLayer.queryable) {
    layer.queryable = getXMLBoolean(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.queryable);
  }
  const xmlLayers = getXMLArray(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Layer);
  const layers = [];
  for (const xmlSubLayer of xmlLayers) {
    layers.push(extractLayer(xmlSubLayer));
  }
  if (layers.length > 0) {
    layer.layers = layers;
  }
  for (const [key, value] of Object.entries(layer)) {
    if (value === undefined) {
      delete layer[key];
    }
  }
  return layer;
}
function extractEXBoundingBox(xmlBoundingBox) {
  const {
    westBoundLongitude: w,
    northBoundLatitude: n,
    eastBoundLongitude: e,
    southBoundLatitude: s
  } = xmlBoundingBox;
  return [[w, s], [e, n]];
}
function extractLatLonBoundingBox(xmlBoundingBox) {
  const {
    minx,
    miny,
    maxx,
    maxy
  } = xmlBoundingBox;
  return [[minx, miny], [maxx, maxy]];
}
function extractWMSBoundingBoxes(xmlBoundingBoxes) {
  const xmlBoxes = getXMLArray(xmlBoundingBoxes);
  return xmlBoxes.map(xmlBox => extractWMSBoundingBox(xmlBox));
}
function extractWMSBoundingBox(xmlBoundingBox) {
  const {
    CRS,
    SRS,
    minx,
    miny,
    maxx,
    maxy,
    resx,
    resy
  } = xmlBoundingBox;
  const boundingBox = {
    crs: CRS || SRS,
    boundingBox: [[getXMLFloat(minx), getXMLFloat(miny)], [getXMLFloat(maxx), getXMLFloat(maxy)]]
  };
  if (resx) {
    boundingBox.xResolution = resx;
  }
  if (resy) {
    boundingBox.yResolution = resy;
  }
  return boundingBox;
}
function extractDimension(xmlDimension) {
  const {
    name,
    units,
    value: extent
  } = xmlDimension;
  const dimension = {
    name,
    units,
    extent
  };
  if (xmlDimension.unitSymbol) {
    dimension.unitSymbol = xmlDimension.unitSymbol;
  }
  if (xmlDimension.default) {
    dimension.defaultValue = xmlDimension.default;
  }
  if (xmlDimension.multipleValues) {
    dimension.multipleValues = getXMLBoolean(xmlDimension.multipleValues);
  }
  if (xmlDimension.nearestValue) {
    dimension.nearestValue = getXMLBoolean(xmlDimension.nearestValue);
  }
  if (xmlDimension.current) {
    dimension.current = getXMLBoolean(xmlDimension.current);
  }
  return dimension;
}
function addInheritedLayerProps(layer, parent) {
  if (parent !== null && parent !== void 0 && parent.geographicBoundingBox && !layer.geographicBoundingBox) {
    layer.geographicBoundingBox = [...parent.geographicBoundingBox];
  }
  if (parent !== null && parent !== void 0 && parent.crs && !layer.crs) {
    layer.crs = [...parent.crs];
  }
  if (parent !== null && parent !== void 0 && parent.boundingBoxes && !layer.boundingBoxes) {
    layer.boundingBoxes = [...parent.boundingBoxes];
  }
  if (parent !== null && parent !== void 0 && parent.dimensions && !layer.dimensions) {
    layer.dimensions = [...parent.dimensions];
  }
  for (const subLayer of layer.layers || []) {
    addInheritedLayerProps(subLayer, layer);
  }
}
//# sourceMappingURL=parse-wms-capabilities.js.map
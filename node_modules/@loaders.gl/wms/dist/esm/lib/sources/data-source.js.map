{"version":3,"file":"data-source.js","names":["DataSource","constructor","props","_defineProperty","loadOptions","fetch","getFetchFunction","setProps","Object","assign","setNeedsRefresh","_needsRefresh","getNeedsRefresh","clear","arguments","length","undefined","needsRefresh","options","fetchFunction","url","fetchOptions"],"sources":["../../../../src/lib/sources/data-source.ts"],"sourcesContent":["// loaders.gl, MIT license\n\nimport type {LoaderOptions} from '@loaders.gl/loader-utils';\n\nexport type DataSourceProps = {\n  /** LoaderOptions provide an option to override `fetch`. Will also be passed to any sub loaders */\n  loadOptions?: LoaderOptions;\n};\n\n/** base class of all data sources */\nexport abstract class DataSource<PropsT extends DataSourceProps> {\n  /** A resolved fetch function extracted from loadOptions prop */\n  fetch: (url: string, options?: RequestInit) => Promise<Response>;\n  /** The actual load options, if calling a loaders.gl loader */\n  loadOptions: LoaderOptions;\n  _needsRefresh: boolean = true;\n\n  props: PropsT;\n\n  constructor(props: PropsT) {\n    this.props = {...props};\n    this.loadOptions = {...props.loadOptions};\n    this.fetch = getFetchFunction(this.loadOptions);\n  }\n\n  setProps(props: PropsT) {\n    this.props = Object.assign(this.props, props);\n    // TODO - add a shallow compare to avoid setting refresh if no change?\n    this.setNeedsRefresh();\n  }\n\n  /** Mark this data source as needing a refresh (redraw) */\n  setNeedsRefresh(): void {\n    this._needsRefresh = true;\n  }\n\n  /**\n   * Does this data source need refreshing?\n   * @note The specifics of the refresh mechanism depends on type of data source\n   */\n  getNeedsRefresh(clear: boolean = true) {\n    const needsRefresh = this._needsRefresh;\n    if (clear) {\n      this._needsRefresh = false;\n    }\n    return needsRefresh;\n  }\n}\n\n/**\n * Gets the current fetch function from options\n * @todo - move to loader-utils module\n * @todo - use in core module counterpart\n * @param options\n * @param context\n */\nexport function getFetchFunction(options?: LoaderOptions) {\n  const fetchFunction = options?.fetch;\n\n  // options.fetch can be a function\n  if (fetchFunction && typeof fetchFunction === 'function') {\n    return (url: string, fetchOptions?: RequestInit) => fetchFunction(url, fetchOptions);\n  }\n\n  // options.fetch can be an options object, use global fetch with those options\n  const fetchOptions = options?.fetch;\n  if (fetchOptions && typeof fetchOptions !== 'function') {\n    return (url) => fetch(url, fetchOptions);\n  }\n\n  // else return the global fetch function\n  return (url) => fetch(url);\n}\n"],"mappings":";AAUA,OAAO,MAAeA,UAAU,CAAiC;EAS/DC,WAAWA,CAACC,KAAa,EAAE;IAAAC,eAAA;IAAAA,eAAA;IAAAA,eAAA,wBAJF,IAAI;IAAAA,eAAA;IAK3B,IAAI,CAACD,KAAK,GAAG;MAAC,GAAGA;IAAK,CAAC;IACvB,IAAI,CAACE,WAAW,GAAG;MAAC,GAAGF,KAAK,CAACE;IAAW,CAAC;IACzC,IAAI,CAACC,KAAK,GAAGC,gBAAgB,CAAC,IAAI,CAACF,WAAW,CAAC;EACjD;EAEAG,QAAQA,CAACL,KAAa,EAAE;IACtB,IAAI,CAACA,KAAK,GAAGM,MAAM,CAACC,MAAM,CAAC,IAAI,CAACP,KAAK,EAAEA,KAAK,CAAC;IAE7C,IAAI,CAACQ,eAAe,CAAC,CAAC;EACxB;EAGAA,eAAeA,CAAA,EAAS;IACtB,IAAI,CAACC,aAAa,GAAG,IAAI;EAC3B;EAMAC,eAAeA,CAAA,EAAwB;IAAA,IAAvBC,KAAc,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IACnC,MAAMG,YAAY,GAAG,IAAI,CAACN,aAAa;IACvC,IAAIE,KAAK,EAAE;MACT,IAAI,CAACF,aAAa,GAAG,KAAK;IAC5B;IACA,OAAOM,YAAY;EACrB;AACF;AASA,OAAO,SAASX,gBAAgBA,CAACY,OAAuB,EAAE;EACxD,MAAMC,aAAa,GAAGD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEb,KAAK;EAGpC,IAAIc,aAAa,IAAI,OAAOA,aAAa,KAAK,UAAU,EAAE;IACxD,OAAO,CAACC,GAAW,EAAEC,YAA0B,KAAKF,aAAa,CAACC,GAAG,EAAEC,YAAY,CAAC;EACtF;EAGA,MAAMA,YAAY,GAAGH,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEb,KAAK;EACnC,IAAIgB,YAAY,IAAI,OAAOA,YAAY,KAAK,UAAU,EAAE;IACtD,OAAQD,GAAG,IAAKf,KAAK,CAACe,GAAG,EAAEC,YAAY,CAAC;EAC1C;EAGA,OAAQD,GAAG,IAAKf,KAAK,CAACe,GAAG,CAAC;AAC5B"}
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // ../xml/node_modules/fast-xml-parser/src/util.js
  var require_util = __commonJS({
    "../xml/node_modules/fast-xml-parser/src/util.js"(exports) {
      "use strict";
      var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
      var regexName = new RegExp("^" + nameRegexp + "$");
      var getAllMatches = function(string, regex) {
        const matches2 = [];
        let match = regex.exec(string);
        while (match) {
          const allmatches = [];
          allmatches.startIndex = regex.lastIndex - match[0].length;
          const len = match.length;
          for (let index = 0; index < len; index++) {
            allmatches.push(match[index]);
          }
          matches2.push(allmatches);
          match = regex.exec(string);
        }
        return matches2;
      };
      var isName = function(string) {
        const match = regexName.exec(string);
        return !(match === null || typeof match === "undefined");
      };
      exports.isExist = function(v) {
        return typeof v !== "undefined";
      };
      exports.isEmptyObject = function(obj) {
        return Object.keys(obj).length === 0;
      };
      exports.merge = function(target, a, arrayMode) {
        if (a) {
          const keys = Object.keys(a);
          const len = keys.length;
          for (let i = 0; i < len; i++) {
            if (arrayMode === "strict") {
              target[keys[i]] = [a[keys[i]]];
            } else {
              target[keys[i]] = a[keys[i]];
            }
          }
        }
      };
      exports.getValue = function(v) {
        if (exports.isExist(v)) {
          return v;
        } else {
          return "";
        }
      };
      exports.isName = isName;
      exports.getAllMatches = getAllMatches;
      exports.nameRegexp = nameRegexp;
    }
  });

  // ../xml/node_modules/fast-xml-parser/src/validator.js
  var require_validator = __commonJS({
    "../xml/node_modules/fast-xml-parser/src/validator.js"(exports) {
      "use strict";
      var util = require_util();
      var defaultOptions = {
        allowBooleanAttributes: false,
        unpairedTags: []
      };
      exports.validate = function(xmlData, options) {
        options = Object.assign({}, defaultOptions, options);
        const tags = [];
        let tagFound = false;
        let reachedRoot = false;
        if (xmlData[0] === "\uFEFF") {
          xmlData = xmlData.substr(1);
        }
        for (let i = 0; i < xmlData.length; i++) {
          if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
            i += 2;
            i = readPI(xmlData, i);
            if (i.err)
              return i;
          } else if (xmlData[i] === "<") {
            let tagStartPos = i;
            i++;
            if (xmlData[i] === "!") {
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else {
              let closingTag = false;
              if (xmlData[i] === "/") {
                closingTag = true;
                i++;
              }
              let tagName = "";
              for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
                tagName += xmlData[i];
              }
              tagName = tagName.trim();
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substring(0, tagName.length - 1);
                i--;
              }
              if (!validateTagName(tagName)) {
                let msg;
                if (tagName.trim().length === 0) {
                  msg = "Invalid space after '<'.";
                } else {
                  msg = "Tag '" + tagName + "' is an invalid name.";
                }
                return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
              }
              const result = readAttributeStr(xmlData, i);
              if (result === false) {
                return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
              }
              let attrStr = result.value;
              i = result.index;
              if (attrStr[attrStr.length - 1] === "/") {
                const attrStrStart = i - attrStr.length;
                attrStr = attrStr.substring(0, attrStr.length - 1);
                const isValid = validateAttributeString(attrStr, options);
                if (isValid === true) {
                  tagFound = true;
                } else {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
                }
              } else if (closingTag) {
                if (!result.tagClosed) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
                } else if (attrStr.trim().length > 0) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
                } else {
                  const otg = tags.pop();
                  if (tagName !== otg.tagName) {
                    let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                    return getErrorObject("InvalidTag", "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
                  }
                  if (tags.length == 0) {
                    reachedRoot = true;
                  }
                }
              } else {
                const isValid = validateAttributeString(attrStr, options);
                if (isValid !== true) {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
                }
                if (reachedRoot === true) {
                  return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
                } else if (options.unpairedTags.indexOf(tagName) !== -1) {
                } else {
                  tags.push({ tagName, tagStartPos });
                }
                tagFound = true;
              }
              for (i++; i < xmlData.length; i++) {
                if (xmlData[i] === "<") {
                  if (xmlData[i + 1] === "!") {
                    i++;
                    i = readCommentAndCDATA(xmlData, i);
                    continue;
                  } else if (xmlData[i + 1] === "?") {
                    i = readPI(xmlData, ++i);
                    if (i.err)
                      return i;
                  } else {
                    break;
                  }
                } else if (xmlData[i] === "&") {
                  const afterAmp = validateAmpersand(xmlData, i);
                  if (afterAmp == -1)
                    return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
                  i = afterAmp;
                } else {
                  if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
                    return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
                  }
                }
              }
              if (xmlData[i] === "<") {
                i--;
              }
            }
          } else {
            if (isWhiteSpace(xmlData[i])) {
              continue;
            }
            return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
          }
        }
        if (!tagFound) {
          return getErrorObject("InvalidXml", "Start tag expected.", 1);
        } else if (tags.length == 1) {
          return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
        } else if (tags.length > 0) {
          return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
        }
        return true;
      };
      function isWhiteSpace(char) {
        return char === " " || char === "	" || char === "\n" || char === "\r";
      }
      function readPI(xmlData, i) {
        const start = i;
        for (; i < xmlData.length; i++) {
          if (xmlData[i] == "?" || xmlData[i] == " ") {
            const tagname = xmlData.substr(start, i - start);
            if (i > 5 && tagname === "xml") {
              return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
            } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
              i++;
              break;
            } else {
              continue;
            }
          }
        }
        return i;
      }
      function readCommentAndCDATA(xmlData, i) {
        if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
          for (i += 3; i < xmlData.length; i++) {
            if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
              i += 2;
              break;
            }
          }
        } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
          let angleBracketsCount = 1;
          for (i += 8; i < xmlData.length; i++) {
            if (xmlData[i] === "<") {
              angleBracketsCount++;
            } else if (xmlData[i] === ">") {
              angleBracketsCount--;
              if (angleBracketsCount === 0) {
                break;
              }
            }
          }
        } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
          for (i += 8; i < xmlData.length; i++) {
            if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
              i += 2;
              break;
            }
          }
        }
        return i;
      }
      var doubleQuote = '"';
      var singleQuote = "'";
      function readAttributeStr(xmlData, i) {
        let attrStr = "";
        let startChar = "";
        let tagClosed = false;
        for (; i < xmlData.length; i++) {
          if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
            if (startChar === "") {
              startChar = xmlData[i];
            } else if (startChar !== xmlData[i]) {
            } else {
              startChar = "";
            }
          } else if (xmlData[i] === ">") {
            if (startChar === "") {
              tagClosed = true;
              break;
            }
          }
          attrStr += xmlData[i];
        }
        if (startChar !== "") {
          return false;
        }
        return {
          value: attrStr,
          index: i,
          tagClosed
        };
      }
      var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
      function validateAttributeString(attrStr, options) {
        const matches2 = util.getAllMatches(attrStr, validAttrStrRegxp);
        const attrNames = {};
        for (let i = 0; i < matches2.length; i++) {
          if (matches2[i][1].length === 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches2[i][2] + "' has no space in starting.", getPositionFromMatch(matches2[i]));
          } else if (matches2[i][3] !== void 0 && matches2[i][4] === void 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches2[i][2] + "' is without value.", getPositionFromMatch(matches2[i]));
          } else if (matches2[i][3] === void 0 && !options.allowBooleanAttributes) {
            return getErrorObject("InvalidAttr", "boolean attribute '" + matches2[i][2] + "' is not allowed.", getPositionFromMatch(matches2[i]));
          }
          const attrName = matches2[i][2];
          if (!validateAttrName(attrName)) {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches2[i]));
          }
          if (!attrNames.hasOwnProperty(attrName)) {
            attrNames[attrName] = 1;
          } else {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches2[i]));
          }
        }
        return true;
      }
      function validateNumberAmpersand(xmlData, i) {
        let re = /\d/;
        if (xmlData[i] === "x") {
          i++;
          re = /[\da-fA-F]/;
        }
        for (; i < xmlData.length; i++) {
          if (xmlData[i] === ";")
            return i;
          if (!xmlData[i].match(re))
            break;
        }
        return -1;
      }
      function validateAmpersand(xmlData, i) {
        i++;
        if (xmlData[i] === ";")
          return -1;
        if (xmlData[i] === "#") {
          i++;
          return validateNumberAmpersand(xmlData, i);
        }
        let count = 0;
        for (; i < xmlData.length; i++, count++) {
          if (xmlData[i].match(/\w/) && count < 20)
            continue;
          if (xmlData[i] === ";")
            break;
          return -1;
        }
        return i;
      }
      function getErrorObject(code, message, lineNumber) {
        return {
          err: {
            code,
            msg: message,
            line: lineNumber.line || lineNumber,
            col: lineNumber.col
          }
        };
      }
      function validateAttrName(attrName) {
        return util.isName(attrName);
      }
      function validateTagName(tagname) {
        return util.isName(tagname);
      }
      function getLineNumberForPosition(xmlData, index) {
        const lines = xmlData.substring(0, index).split(/\r?\n/);
        return {
          line: lines.length,
          col: lines[lines.length - 1].length + 1
        };
      }
      function getPositionFromMatch(match) {
        return match.startIndex + match[1].length;
      }
    }
  });

  // ../xml/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
  var require_OptionsBuilder = __commonJS({
    "../xml/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
      var defaultOptions = {
        preserveOrder: false,
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        removeNSPrefix: false,
        allowBooleanAttributes: false,
        parseTagValue: true,
        parseAttributeValue: false,
        trimValues: true,
        cdataPropName: false,
        numberParseOptions: {
          hex: true,
          leadingZeros: true,
          eNotation: true
        },
        tagValueProcessor: function(tagName, val2) {
          return val2;
        },
        attributeValueProcessor: function(attrName, val2) {
          return val2;
        },
        stopNodes: [],
        alwaysCreateTextNode: false,
        isArray: () => false,
        commentPropName: false,
        unpairedTags: [],
        processEntities: true,
        htmlEntities: false,
        ignoreDeclaration: false,
        ignorePiTags: false,
        transformTagName: false,
        transformAttributeName: false,
        updateTag: function(tagName, jPath, attrs) {
          return tagName;
        }
      };
      var buildOptions = function(options) {
        return Object.assign({}, defaultOptions, options);
      };
      exports.buildOptions = buildOptions;
      exports.defaultOptions = defaultOptions;
    }
  });

  // ../xml/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
  var require_xmlNode = __commonJS({
    "../xml/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
      "use strict";
      var XmlNode = class {
        constructor(tagname) {
          this.tagname = tagname;
          this.child = [];
          this[":@"] = {};
        }
        add(key, val2) {
          if (key === "__proto__")
            key = "#__proto__";
          this.child.push({ [key]: val2 });
        }
        addChild(node) {
          if (node.tagname === "__proto__")
            node.tagname = "#__proto__";
          if (node[":@"] && Object.keys(node[":@"]).length > 0) {
            this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
          } else {
            this.child.push({ [node.tagname]: node.child });
          }
        }
      };
      module.exports = XmlNode;
    }
  });

  // ../xml/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
  var require_DocTypeReader = __commonJS({
    "../xml/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
      function readDocType(xmlData, i) {
        const entities = {};
        if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
          i = i + 9;
          let angleBracketsCount = 1;
          let hasBody = false, comment = false;
          let exp = "";
          for (; i < xmlData.length; i++) {
            if (xmlData[i] === "<" && !comment) {
              if (hasBody && isEntity(xmlData, i)) {
                i += 7;
                [entityName, val, i] = readEntityExp(xmlData, i + 1);
                if (val.indexOf("&") === -1)
                  entities[entityName] = {
                    regx: RegExp(`&${entityName};`, "g"),
                    val
                  };
              } else if (hasBody && isElement(xmlData, i))
                i += 8;
              else if (hasBody && isAttlist(xmlData, i))
                i += 8;
              else if (hasBody && isNotation(xmlData, i))
                i += 9;
              else if (isComment)
                comment = true;
              else
                throw new Error("Invalid DOCTYPE");
              angleBracketsCount++;
              exp = "";
            } else if (xmlData[i] === ">") {
              if (comment) {
                if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
                  comment = false;
                  angleBracketsCount--;
                }
              } else {
                angleBracketsCount--;
              }
              if (angleBracketsCount === 0) {
                break;
              }
            } else if (xmlData[i] === "[") {
              hasBody = true;
            } else {
              exp += xmlData[i];
            }
          }
          if (angleBracketsCount !== 0) {
            throw new Error(`Unclosed DOCTYPE`);
          }
        } else {
          throw new Error(`Invalid Tag instead of DOCTYPE`);
        }
        return { entities, i };
      }
      function readEntityExp(xmlData, i) {
        let entityName2 = "";
        for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"'); i++) {
          entityName2 += xmlData[i];
        }
        entityName2 = entityName2.trim();
        if (entityName2.indexOf(" ") !== -1)
          throw new Error("External entites are not supported");
        const startChar = xmlData[i++];
        let val2 = "";
        for (; i < xmlData.length && xmlData[i] !== startChar; i++) {
          val2 += xmlData[i];
        }
        return [entityName2, val2, i];
      }
      function isComment(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "-" && xmlData[i + 3] === "-")
          return true;
        return false;
      }
      function isEntity(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "N" && xmlData[i + 4] === "T" && xmlData[i + 5] === "I" && xmlData[i + 6] === "T" && xmlData[i + 7] === "Y")
          return true;
        return false;
      }
      function isElement(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "L" && xmlData[i + 4] === "E" && xmlData[i + 5] === "M" && xmlData[i + 6] === "E" && xmlData[i + 7] === "N" && xmlData[i + 8] === "T")
          return true;
        return false;
      }
      function isAttlist(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "A" && xmlData[i + 3] === "T" && xmlData[i + 4] === "T" && xmlData[i + 5] === "L" && xmlData[i + 6] === "I" && xmlData[i + 7] === "S" && xmlData[i + 8] === "T")
          return true;
        return false;
      }
      function isNotation(xmlData, i) {
        if (xmlData[i + 1] === "!" && xmlData[i + 2] === "N" && xmlData[i + 3] === "O" && xmlData[i + 4] === "T" && xmlData[i + 5] === "A" && xmlData[i + 6] === "T" && xmlData[i + 7] === "I" && xmlData[i + 8] === "O" && xmlData[i + 9] === "N")
          return true;
        return false;
      }
      module.exports = readDocType;
    }
  });

  // ../../node_modules/strnum/strnum.js
  var require_strnum = __commonJS({
    "../../node_modules/strnum/strnum.js"(exports, module) {
      var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
      var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
      if (!Number.parseInt && window.parseInt) {
        Number.parseInt = window.parseInt;
      }
      if (!Number.parseFloat && window.parseFloat) {
        Number.parseFloat = window.parseFloat;
      }
      var consider = {
        hex: true,
        leadingZeros: true,
        decimalPoint: ".",
        eNotation: true
      };
      function toNumber(str, options = {}) {
        options = Object.assign({}, consider, options);
        if (!str || typeof str !== "string")
          return str;
        let trimmedStr = str.trim();
        if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
          return str;
        else if (options.hex && hexRegex.test(trimmedStr)) {
          return Number.parseInt(trimmedStr, 16);
        } else {
          const match = numRegex.exec(trimmedStr);
          if (match) {
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]);
            const eNotation = match[4] || match[6];
            if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
              return str;
            else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
              return str;
            else {
              const num = Number(trimmedStr);
              const numStr = "" + num;
              if (numStr.search(/[eE]/) !== -1) {
                if (options.eNotation)
                  return num;
                else
                  return str;
              } else if (eNotation) {
                if (options.eNotation)
                  return num;
                else
                  return str;
              } else if (trimmedStr.indexOf(".") !== -1) {
                if (numStr === "0" && numTrimmedByZeros === "")
                  return num;
                else if (numStr === numTrimmedByZeros)
                  return num;
                else if (sign && numStr === "-" + numTrimmedByZeros)
                  return num;
                else
                  return str;
              }
              if (leadingZeros) {
                if (numTrimmedByZeros === numStr)
                  return num;
                else if (sign + numTrimmedByZeros === numStr)
                  return num;
                else
                  return str;
              }
              if (trimmedStr === numStr)
                return num;
              else if (trimmedStr === sign + numStr)
                return num;
              return str;
            }
          } else {
            return str;
          }
        }
      }
      function trimZeros(numStr) {
        if (numStr && numStr.indexOf(".") !== -1) {
          numStr = numStr.replace(/0+$/, "");
          if (numStr === ".")
            numStr = "0";
          else if (numStr[0] === ".")
            numStr = "0" + numStr;
          else if (numStr[numStr.length - 1] === ".")
            numStr = numStr.substr(0, numStr.length - 1);
          return numStr;
        }
        return numStr;
      }
      module.exports = toNumber;
    }
  });

  // ../xml/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
  var require_OrderedObjParser = __commonJS({
    "../xml/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
      "use strict";
      var util = require_util();
      var xmlNode = require_xmlNode();
      var readDocType = require_DocTypeReader();
      var toNumber = require_strnum();
      var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
      var OrderedObjParser = class {
        constructor(options) {
          this.options = options;
          this.currentNode = null;
          this.tagsNodeStack = [];
          this.docTypeEntities = {};
          this.lastEntities = {
            "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
            "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
            "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
            "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
          };
          this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
          this.htmlEntities = {
            "space": { regex: /&(nbsp|#160);/g, val: " " },
            "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
            "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
            "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
            "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
            "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
            "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
            "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" }
          };
          this.addExternalEntities = addExternalEntities;
          this.parseXml = parseXml;
          this.parseTextData = parseTextData;
          this.resolveNameSpace = resolveNameSpace;
          this.buildAttributesMap = buildAttributesMap;
          this.isItStopNode = isItStopNode;
          this.replaceEntitiesValue = replaceEntitiesValue;
          this.readStopNodeData = readStopNodeData;
          this.saveTextToParentTag = saveTextToParentTag;
          this.addChild = addChild;
        }
      };
      function addExternalEntities(externalEntities) {
        const entKeys = Object.keys(externalEntities);
        for (let i = 0; i < entKeys.length; i++) {
          const ent = entKeys[i];
          this.lastEntities[ent] = {
            regex: new RegExp("&" + ent + ";", "g"),
            val: externalEntities[ent]
          };
        }
      }
      function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
        if (val2 !== void 0) {
          if (this.options.trimValues && !dontTrim) {
            val2 = val2.trim();
          }
          if (val2.length > 0) {
            if (!escapeEntities)
              val2 = this.replaceEntitiesValue(val2);
            const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
            if (newval === null || newval === void 0) {
              return val2;
            } else if (typeof newval !== typeof val2 || newval !== val2) {
              return newval;
            } else if (this.options.trimValues) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              const trimmedVal = val2.trim();
              if (trimmedVal === val2) {
                return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
              } else {
                return val2;
              }
            }
          }
        }
      }
      function resolveNameSpace(tagname) {
        if (this.options.removeNSPrefix) {
          const tags = tagname.split(":");
          const prefix = tagname.charAt(0) === "/" ? "/" : "";
          if (tags[0] === "xmlns") {
            return "";
          }
          if (tags.length === 2) {
            tagname = prefix + tags[1];
          }
        }
        return tagname;
      }
      var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
      function buildAttributesMap(attrStr, jPath, tagName) {
        if (!this.options.ignoreAttributes && typeof attrStr === "string") {
          const matches2 = util.getAllMatches(attrStr, attrsRegx);
          const len = matches2.length;
          const attrs = {};
          for (let i = 0; i < len; i++) {
            const attrName = this.resolveNameSpace(matches2[i][1]);
            let oldVal = matches2[i][4];
            let aName = this.options.attributeNamePrefix + attrName;
            if (attrName.length) {
              if (this.options.transformAttributeName) {
                aName = this.options.transformAttributeName(aName);
              }
              if (aName === "__proto__")
                aName = "#__proto__";
              if (oldVal !== void 0) {
                if (this.options.trimValues) {
                  oldVal = oldVal.trim();
                }
                oldVal = this.replaceEntitiesValue(oldVal);
                const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
                if (newVal === null || newVal === void 0) {
                  attrs[aName] = oldVal;
                } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                  attrs[aName] = newVal;
                } else {
                  attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);
                }
              } else if (this.options.allowBooleanAttributes) {
                attrs[aName] = true;
              }
            }
          }
          if (!Object.keys(attrs).length) {
            return;
          }
          if (this.options.attributesGroupName) {
            const attrCollection = {};
            attrCollection[this.options.attributesGroupName] = attrs;
            return attrCollection;
          }
          return attrs;
        }
      }
      var parseXml = function(xmlData) {
        xmlData = xmlData.replace(/\r\n?/g, "\n");
        const xmlObj = new xmlNode("!xml");
        let currentNode = xmlObj;
        let textData = "";
        let jPath = "";
        for (let i = 0; i < xmlData.length; i++) {
          const ch = xmlData[i];
          if (ch === "<") {
            if (xmlData[i + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
              let tagName = xmlData.substring(i + 2, closeIndex).trim();
              if (this.options.removeNSPrefix) {
                const colonIndex = tagName.indexOf(":");
                if (colonIndex !== -1) {
                  tagName = tagName.substr(colonIndex + 1);
                }
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode) {
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
              }
              const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
              if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
                throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
              }
              let propIndex = 0;
              if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
                propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
                this.tagsNodeStack.pop();
              } else {
                propIndex = jPath.lastIndexOf(".");
              }
              jPath = jPath.substring(0, propIndex);
              currentNode = this.tagsNodeStack.pop();
              textData = "";
              i = closeIndex;
            } else if (xmlData[i + 1] === "?") {
              let tagData = readTagExp(xmlData, i, false, "?>");
              if (!tagData)
                throw new Error("Pi Tag is not closed.");
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
              } else {
                const childNode = new xmlNode(tagData.tagName);
                childNode.add(this.options.textNodeName, "");
                if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
                }
                this.addChild(currentNode, childNode, jPath);
              }
              i = tagData.closeIndex + 1;
            } else if (xmlData.substr(i + 1, 3) === "!--") {
              const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
              if (this.options.commentPropName) {
                const comment = xmlData.substring(i + 4, endIndex - 2);
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
                currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
              }
              i = endIndex;
            } else if (xmlData.substr(i + 1, 2) === "!D") {
              const result = readDocType(xmlData, i);
              this.docTypeEntities = result.entities;
              i = result.i;
            } else if (xmlData.substr(i + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
              const tagExp = xmlData.substring(i + 9, closeIndex);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.cdataPropName) {
                currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
              } else {
                let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
                if (val2 == void 0)
                  val2 = "";
                currentNode.add(this.options.textNodeName, val2);
              }
              i = closeIndex + 2;
            } else {
              let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
              let tagName = result.tagName;
              let tagExp = result.tagExp;
              let attrExpPresent = result.attrExpPresent;
              let closeIndex = result.closeIndex;
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode && textData) {
                if (currentNode.tagname !== "!xml") {
                  textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
                }
              }
              const lastTag = currentNode;
              if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
                currentNode = this.tagsNodeStack.pop();
                jPath = jPath.substring(0, jPath.lastIndexOf("."));
              }
              if (tagName !== xmlObj.tagname) {
                jPath += jPath ? "." + tagName : tagName;
              }
              if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
                let tagContent = "";
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  i = result.closeIndex;
                } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                  i = result.closeIndex;
                } else {
                  const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                  if (!result2)
                    throw new Error(`Unexpected end of ${tagName}`);
                  i = result2.i;
                  tagContent = result2.tagContent;
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                if (tagContent) {
                  tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                childNode.add(this.options.textNodeName, tagContent);
                this.addChild(currentNode, childNode, jPath);
              } else {
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  if (tagName[tagName.length - 1] === "/") {
                    tagName = tagName.substr(0, tagName.length - 1);
                    tagExp = tagName;
                  } else {
                    tagExp = tagExp.substr(0, tagExp.length - 1);
                  }
                  if (this.options.transformTagName) {
                    tagName = this.options.transformTagName(tagName);
                  }
                  const childNode = new xmlNode(tagName);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  jPath = jPath.substr(0, jPath.lastIndexOf("."));
                } else {
                  const childNode = new xmlNode(tagName);
                  this.tagsNodeStack.push(currentNode);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  currentNode = childNode;
                }
                textData = "";
                i = closeIndex;
              }
            }
          } else {
            textData += xmlData[i];
          }
        }
        return xmlObj.child;
      };
      function addChild(currentNode, childNode, jPath) {
        const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
        if (result === false) {
        } else if (typeof result === "string") {
          childNode.tagname = result;
          currentNode.addChild(childNode);
        } else {
          currentNode.addChild(childNode);
        }
      }
      var replaceEntitiesValue = function(val2) {
        if (this.options.processEntities) {
          for (let entityName2 in this.docTypeEntities) {
            const entity = this.docTypeEntities[entityName2];
            val2 = val2.replace(entity.regx, entity.val);
          }
          for (let entityName2 in this.lastEntities) {
            const entity = this.lastEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
          if (this.options.htmlEntities) {
            for (let entityName2 in this.htmlEntities) {
              const entity = this.htmlEntities[entityName2];
              val2 = val2.replace(entity.regex, entity.val);
            }
          }
          val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
        }
        return val2;
      };
      function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
        if (textData) {
          if (isLeafNode === void 0)
            isLeafNode = Object.keys(currentNode.child).length === 0;
          textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false, isLeafNode);
          if (textData !== void 0 && textData !== "")
            currentNode.add(this.options.textNodeName, textData);
          textData = "";
        }
        return textData;
      }
      function isItStopNode(stopNodes, jPath, currentTagName) {
        const allNodesExp = "*." + currentTagName;
        for (const stopNodePath in stopNodes) {
          const stopNodeExp = stopNodes[stopNodePath];
          if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
            return true;
        }
        return false;
      }
      function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
        let attrBoundary;
        let tagExp = "";
        for (let index = i; index < xmlData.length; index++) {
          let ch = xmlData[index];
          if (attrBoundary) {
            if (ch === attrBoundary)
              attrBoundary = "";
          } else if (ch === '"' || ch === "'") {
            attrBoundary = ch;
          } else if (ch === closingChar[0]) {
            if (closingChar[1]) {
              if (xmlData[index + 1] === closingChar[1]) {
                return {
                  data: tagExp,
                  index
                };
              }
            } else {
              return {
                data: tagExp,
                index
              };
            }
          } else if (ch === "	") {
            ch = " ";
          }
          tagExp += ch;
        }
      }
      function findClosingIndex(xmlData, str, i, errMsg) {
        const closingIndex = xmlData.indexOf(str, i);
        if (closingIndex === -1) {
          throw new Error(errMsg);
        } else {
          return closingIndex + str.length - 1;
        }
      }
      function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
        const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
        if (!result)
          return;
        let tagExp = result.data;
        const closeIndex = result.index;
        const separatorIndex = tagExp.search(/\s/);
        let tagName = tagExp;
        let attrExpPresent = true;
        if (separatorIndex !== -1) {
          tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
          tagExp = tagExp.substr(separatorIndex + 1);
        }
        if (removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
          }
        }
        return {
          tagName,
          tagExp,
          closeIndex,
          attrExpPresent
        };
      }
      function readStopNodeData(xmlData, tagName, i) {
        const startIndex = i;
        let openTagCount = 1;
        for (; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            if (xmlData[i + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
              let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
              if (closeTagName === tagName) {
                openTagCount--;
                if (openTagCount === 0) {
                  return {
                    tagContent: xmlData.substring(startIndex, i),
                    i: closeIndex
                  };
                }
              }
              i = closeIndex;
            } else if (xmlData[i + 1] === "?") {
              const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
              i = closeIndex;
            } else if (xmlData.substr(i + 1, 3) === "!--") {
              const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
              i = closeIndex;
            } else if (xmlData.substr(i + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
              i = closeIndex;
            } else {
              const tagData = readTagExp(xmlData, i, ">");
              if (tagData) {
                const openTagName = tagData && tagData.tagName;
                if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                  openTagCount++;
                }
                i = tagData.closeIndex;
              }
            }
          }
        }
      }
      function parseValue(val2, shouldParse, options) {
        if (shouldParse && typeof val2 === "string") {
          const newval = val2.trim();
          if (newval === "true")
            return true;
          else if (newval === "false")
            return false;
          else
            return toNumber(val2, options);
        } else {
          if (util.isExist(val2)) {
            return val2;
          } else {
            return "";
          }
        }
      }
      module.exports = OrderedObjParser;
    }
  });

  // ../xml/node_modules/fast-xml-parser/src/xmlparser/node2json.js
  var require_node2json = __commonJS({
    "../xml/node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
      "use strict";
      function prettify(node, options) {
        return compress(node, options);
      }
      function compress(arr, options, jPath) {
        let text;
        const compressedObj = {};
        for (let i = 0; i < arr.length; i++) {
          const tagObj = arr[i];
          const property = propName(tagObj);
          let newJpath = "";
          if (jPath === void 0)
            newJpath = property;
          else
            newJpath = jPath + "." + property;
          if (property === options.textNodeName) {
            if (text === void 0)
              text = tagObj[property];
            else
              text += "" + tagObj[property];
          } else if (property === void 0) {
            continue;
          } else if (tagObj[property]) {
            let val2 = compress(tagObj[property], options, newJpath);
            const isLeaf = isLeafTag(val2, options);
            if (tagObj[":@"]) {
              assignAttributes(val2, tagObj[":@"], newJpath, options);
            } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
              val2 = val2[options.textNodeName];
            } else if (Object.keys(val2).length === 0) {
              if (options.alwaysCreateTextNode)
                val2[options.textNodeName] = "";
              else
                val2 = "";
            }
            if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
              if (!Array.isArray(compressedObj[property])) {
                compressedObj[property] = [compressedObj[property]];
              }
              compressedObj[property].push(val2);
            } else {
              if (options.isArray(property, newJpath, isLeaf)) {
                compressedObj[property] = [val2];
              } else {
                compressedObj[property] = val2;
              }
            }
          }
        }
        if (typeof text === "string") {
          if (text.length > 0)
            compressedObj[options.textNodeName] = text;
        } else if (text !== void 0)
          compressedObj[options.textNodeName] = text;
        return compressedObj;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (key !== ":@")
            return key;
        }
      }
      function assignAttributes(obj, attrMap, jpath, options) {
        if (attrMap) {
          const keys = Object.keys(attrMap);
          const len = keys.length;
          for (let i = 0; i < len; i++) {
            const atrrName = keys[i];
            if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
              obj[atrrName] = [attrMap[atrrName]];
            } else {
              obj[atrrName] = attrMap[atrrName];
            }
          }
        }
      }
      function isLeafTag(obj, options) {
        const { textNodeName } = options;
        const propCount = Object.keys(obj).length;
        if (propCount === 0) {
          return true;
        }
        if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
          return true;
        }
        return false;
      }
      exports.prettify = prettify;
    }
  });

  // ../xml/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
  var require_XMLParser = __commonJS({
    "../xml/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
      var { buildOptions } = require_OptionsBuilder();
      var OrderedObjParser = require_OrderedObjParser();
      var { prettify } = require_node2json();
      var validator = require_validator();
      var XMLParser = class {
        constructor(options) {
          this.externalEntities = {};
          this.options = buildOptions(options);
        }
        parse(xmlData, validationOption) {
          if (typeof xmlData === "string") {
          } else if (xmlData.toString) {
            xmlData = xmlData.toString();
          } else {
            throw new Error("XML data is accepted in String or Bytes[] form.");
          }
          if (validationOption) {
            if (validationOption === true)
              validationOption = {};
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
            }
          }
          const orderedObjParser = new OrderedObjParser(this.options);
          orderedObjParser.addExternalEntities(this.externalEntities);
          const orderedResult = orderedObjParser.parseXml(xmlData);
          if (this.options.preserveOrder || orderedResult === void 0)
            return orderedResult;
          else
            return prettify(orderedResult, this.options);
        }
        addEntity(key, value) {
          if (value.indexOf("&") !== -1) {
            throw new Error("Entity value can't have '&'");
          } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
          } else if (value === "&") {
            throw new Error("An entity with value '&' is not permitted");
          } else {
            this.externalEntities[key] = value;
          }
        }
      };
      module.exports = XMLParser;
    }
  });

  // ../xml/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
  var require_orderedJs2Xml = __commonJS({
    "../xml/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
      var EOL = "\n";
      function toXml(jArray, options) {
        let indentation = "";
        if (options.format && options.indentBy.length > 0) {
          indentation = EOL;
        }
        return arrToStr(jArray, options, "", indentation);
      }
      function arrToStr(arr, options, jPath, indentation) {
        let xmlStr = "";
        let isPreviousElementTag = false;
        for (let i = 0; i < arr.length; i++) {
          const tagObj = arr[i];
          const tagName = propName(tagObj);
          let newJPath = "";
          if (jPath.length === 0)
            newJPath = tagName;
          else
            newJPath = `${jPath}.${tagName}`;
          if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
              tagText = options.tagValueProcessor(tagName, tagText);
              tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
          } else if (tagName[0] === "?") {
            const attStr2 = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
            isPreviousElementTag = true;
            continue;
          }
          let newIdentation = indentation;
          if (newIdentation !== "") {
            newIdentation += options.indentBy;
          }
          const attStr = attr_to_str(tagObj[":@"], options);
          const tagStart = indentation + `<${tagName}${attStr}`;
          const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
          if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode)
              xmlStr += tagStart + ">";
            else
              xmlStr += tagStart + "/>";
          } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
          } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
          } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
              xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
              xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
          }
          isPreviousElementTag = true;
        }
        return xmlStr;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (key !== ":@")
            return key;
        }
      }
      function attr_to_str(attrMap, options) {
        let attrStr = "";
        if (attrMap && !options.ignoreAttributes) {
          for (let attr in attrMap) {
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
          }
        }
        return attrStr;
      }
      function isStopNode(jPath, options) {
        jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
        let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
        for (let index in options.stopNodes) {
          if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
            return true;
        }
        return false;
      }
      function replaceEntitiesValue(textValue, options) {
        if (textValue && textValue.length > 0 && options.processEntities) {
          for (let i = 0; i < options.entities.length; i++) {
            const entity = options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      }
      module.exports = toXml;
    }
  });

  // ../xml/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
  var require_json2xml = __commonJS({
    "../xml/node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
      "use strict";
      var buildFromOrderedJs = require_orderedJs2Xml();
      var defaultOptions = {
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        cdataPropName: false,
        format: false,
        indentBy: "  ",
        suppressEmptyNode: false,
        suppressUnpairedNode: true,
        suppressBooleanAttributes: true,
        tagValueProcessor: function(key, a) {
          return a;
        },
        attributeValueProcessor: function(attrName, a) {
          return a;
        },
        preserveOrder: false,
        commentPropName: false,
        unpairedTags: [],
        entities: [
          { regex: new RegExp("&", "g"), val: "&amp;" },
          { regex: new RegExp(">", "g"), val: "&gt;" },
          { regex: new RegExp("<", "g"), val: "&lt;" },
          { regex: new RegExp("'", "g"), val: "&apos;" },
          { regex: new RegExp('"', "g"), val: "&quot;" }
        ],
        processEntities: true,
        stopNodes: [],
        oneListGroup: false
      };
      function Builder(options) {
        this.options = Object.assign({}, defaultOptions, options);
        if (this.options.ignoreAttributes || this.options.attributesGroupName) {
          this.isAttribute = function() {
            return false;
          };
        } else {
          this.attrPrefixLen = this.options.attributeNamePrefix.length;
          this.isAttribute = isAttribute;
        }
        this.processTextOrObjNode = processTextOrObjNode;
        if (this.options.format) {
          this.indentate = indentate;
          this.tagEndChar = ">\n";
          this.newLine = "\n";
        } else {
          this.indentate = function() {
            return "";
          };
          this.tagEndChar = ">";
          this.newLine = "";
        }
      }
      Builder.prototype.build = function(jObj) {
        if (this.options.preserveOrder) {
          return buildFromOrderedJs(jObj, this.options);
        } else {
          if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
            jObj = {
              [this.options.arrayNodeName]: jObj
            };
          }
          return this.j2x(jObj, 0).val;
        }
      };
      Builder.prototype.j2x = function(jObj, level) {
        let attrStr = "";
        let val2 = "";
        for (let key in jObj) {
          if (typeof jObj[key] === "undefined") {
          } else if (jObj[key] === null) {
            if (key[0] === "?")
              val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            else
              val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          } else if (jObj[key] instanceof Date) {
            val2 += this.buildTextValNode(jObj[key], key, "", level);
          } else if (typeof jObj[key] !== "object") {
            const attr = this.isAttribute(key);
            if (attr) {
              attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
            } else {
              if (key === this.options.textNodeName) {
                let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
                val2 += this.replaceEntitiesValue(newval);
              } else {
                val2 += this.buildTextValNode(jObj[key], key, "", level);
              }
            }
          } else if (Array.isArray(jObj[key])) {
            const arrLen = jObj[key].length;
            let listTagVal = "";
            for (let j = 0; j < arrLen; j++) {
              const item = jObj[key][j];
              if (typeof item === "undefined") {
              } else if (item === null) {
                if (key[0] === "?")
                  val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
                else
                  val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
              } else if (typeof item === "object") {
                if (this.options.oneListGroup) {
                  listTagVal += this.j2x(item, level + 1).val;
                } else {
                  listTagVal += this.processTextOrObjNode(item, key, level);
                }
              } else {
                listTagVal += this.buildTextValNode(item, key, "", level);
              }
            }
            if (this.options.oneListGroup) {
              listTagVal = this.buildObjectNode(listTagVal, key, "", level);
            }
            val2 += listTagVal;
          } else {
            if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
              const Ks = Object.keys(jObj[key]);
              const L = Ks.length;
              for (let j = 0; j < L; j++) {
                attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
              }
            } else {
              val2 += this.processTextOrObjNode(jObj[key], key, level);
            }
          }
        }
        return { attrStr, val: val2 };
      };
      Builder.prototype.buildAttrPairStr = function(attrName, val2) {
        val2 = this.options.attributeValueProcessor(attrName, "" + val2);
        val2 = this.replaceEntitiesValue(val2);
        if (this.options.suppressBooleanAttributes && val2 === "true") {
          return " " + attrName;
        } else
          return " " + attrName + '="' + val2 + '"';
      };
      function processTextOrObjNode(object, key, level) {
        const result = this.j2x(object, level + 1);
        if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
          return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
        } else {
          return this.buildObjectNode(result.val, key, result.attrStr, level);
        }
      }
      Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
        if (val2 === "") {
          if (key[0] === "?")
            return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
          else {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          }
        } else {
          let tagEndExp = "</" + key + this.tagEndChar;
          let piClosingChar = "";
          if (key[0] === "?") {
            piClosingChar = "?";
            tagEndExp = "";
          }
          if (attrStr && val2.indexOf("<") === -1) {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
          } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
            return this.indentate(level) + `<!--${val2}-->` + this.newLine;
          } else {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
          }
        }
      };
      Builder.prototype.closeTag = function(key) {
        let closeTag = "";
        if (this.options.unpairedTags.indexOf(key) !== -1) {
          if (!this.options.suppressUnpairedNode)
            closeTag = "/";
        } else if (this.options.suppressEmptyNode) {
          closeTag = "/";
        } else {
          closeTag = `></${key}`;
        }
        return closeTag;
      };
      Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
        if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
          return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else if (key[0] === "?") {
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        } else {
          let textValue = this.options.tagValueProcessor(key, val2);
          textValue = this.replaceEntitiesValue(textValue);
          if (textValue === "") {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          } else {
            return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
          }
        }
      };
      Builder.prototype.replaceEntitiesValue = function(textValue) {
        if (textValue && textValue.length > 0 && this.options.processEntities) {
          for (let i = 0; i < this.options.entities.length; i++) {
            const entity = this.options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      };
      function indentate(level) {
        return this.options.indentBy.repeat(level);
      }
      function isAttribute(name) {
        if (name.startsWith(this.options.attributeNamePrefix)) {
          return name.substr(this.attrPrefixLen);
        } else {
          return false;
        }
      }
      module.exports = Builder;
    }
  });

  // ../xml/node_modules/fast-xml-parser/src/fxp.js
  var require_fxp = __commonJS({
    "../xml/node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
      "use strict";
      var validator = require_validator();
      var XMLParser = require_XMLParser();
      var XMLBuilder = require_json2xml();
      module.exports = {
        XMLParser,
        XMLValidator: validator,
        XMLBuilder
      };
    }
  });

  // ../xml/src/lib/parsers/parse-xml.ts
  function fastParseXML(text, options) {
    const parser = new import_fast_xml_parser.XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: "",
      ...options
    });
    const parsedXML = parser.parse(text);
    return parsedXML;
  }
  var import_fast_xml_parser;
  var init_parse_xml = __esm({
    "../xml/src/lib/parsers/parse-xml.ts"() {
      import_fast_xml_parser = __toModule(require_fxp());
    }
  });

  // ../xml/src/lib/xml-utils/uncapitalize.ts
  function uncapitalize(str) {
    return typeof str === "string" ? str.charAt(0).toLowerCase() + str.slice(1) : str;
  }
  function uncapitalizeKeys(object) {
    if (Array.isArray(object)) {
      return object.map((element) => uncapitalizeKeys(element));
    }
    if (object && typeof object === "object") {
      const newObject = {};
      for (const [key, value] of Object.entries(object)) {
        newObject[uncapitalize(key)] = uncapitalizeKeys(value);
      }
      return newObject;
    }
    return object;
  }
  var init_uncapitalize = __esm({
    "../xml/src/lib/xml-utils/uncapitalize.ts"() {
    }
  });

  // ../xml/src/xml-loader.ts
  function testXMLFile(text) {
    return text.startsWith("<?xml");
  }
  function parseTextSync(text, options) {
    const xmlOptions = { ...XMLLoader.options.xml, ...options?.xml };
    switch (xmlOptions.parser) {
      case "fast-xml-parser":
        const fastXMLOptions = {
          allowBooleanAttributes: true,
          ignoreDeclaration: true,
          removeNSPrefix: xmlOptions.removeNSPrefix,
          textNodeName: xmlOptions.textNodeName,
          isArray: (name, jpath, isLeafNode, isAttribute) => {
            const array = Boolean(xmlOptions?.arrayPaths?.some((path) => jpath === path));
            return array;
          },
          ...options?._fastXML
        };
        const xml = fastParseXML(text, fastXMLOptions);
        return xmlOptions.uncapitalizeKeys ? uncapitalizeKeys(xml) : xml;
      default:
        throw new Error(options?.xml?.parser);
    }
  }
  var VERSION, XMLLoader;
  var init_xml_loader = __esm({
    "../xml/src/xml-loader.ts"() {
      init_parse_xml();
      init_uncapitalize();
      VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      XMLLoader = {
        name: "XML",
        id: "xml",
        module: "xml",
        version: VERSION,
        worker: false,
        extensions: ["xml"],
        mimeTypes: ["application/xml", "text/xml"],
        testText: testXMLFile,
        options: {
          xml: {
            parser: "fast-xml-parser",
            uncapitalizeKeys: false,
            removeNSPrefix: false,
            textNodeName: "value",
            arrayPaths: []
          }
        },
        parse: async (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: (text, options) => parseTextSync(text, options)
      };
    }
  });

  // ../loader-utils/src/lib/env-utils/assert.ts
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "loader assertion failed.");
    }
  }
  var init_assert = __esm({
    "../loader-utils/src/lib/env-utils/assert.ts"() {
    }
  });

  // ../loader-utils/src/lib/env-utils/globals.ts
  var globals, self_, window_, global_, document_, isBrowser, matches, nodeVersion;
  var init_globals = __esm({
    "../loader-utils/src/lib/env-utils/globals.ts"() {
      globals = {
        self: typeof self !== "undefined" && self,
        window: typeof window !== "undefined" && window,
        global: typeof global !== "undefined" && global,
        document: typeof document !== "undefined" && document
      };
      self_ = globals.self || globals.window || globals.global || {};
      window_ = globals.window || globals.self || globals.global || {};
      global_ = globals.global || globals.self || globals.window || {};
      document_ = globals.document || {};
      isBrowser = Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser);
      matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
      nodeVersion = matches && parseFloat(matches[1]) || 0;
    }
  });

  // ../loader-utils/src/lib/option-utils/merge-loader-options.ts
  function mergeLoaderOptions(baseOptions, newOptions) {
    const options = { ...baseOptions };
    for (const [key, newValue] of Object.entries(newOptions)) {
      if (newValue && typeof newValue === "object") {
        options[key] = options[key] || {};
        Object.assign(options[key], newOptions[key]);
      } else {
        options[key] = newOptions[key];
      }
    }
    return options;
  }
  var init_merge_loader_options = __esm({
    "../loader-utils/src/lib/option-utils/merge-loader-options.ts"() {
    }
  });

  // ../loader-utils/src/index.ts
  var init_src = __esm({
    "../loader-utils/src/index.ts"() {
      init_assert();
      init_globals();
      init_merge_loader_options();
    }
  });

  // ../xml/src/lib/xml-utils/xml-utils.ts
  function convertXMLValueToArray(xmlValue) {
    if (Array.isArray(xmlValue)) {
      return xmlValue;
    }
    if (xmlValue && typeof xmlValue === "object" && xmlValue["0"]) {
    }
    if (xmlValue) {
      return [xmlValue];
    }
    return [];
  }
  function convertXMLFieldToArrayInPlace(xml, key) {
    xml[key] = convertXMLValueToArray(xml[key]);
  }
  var init_xml_utils = __esm({
    "../xml/src/lib/xml-utils/xml-utils.ts"() {
    }
  });

  // ../xml/src/index.ts
  var init_src2 = __esm({
    "../xml/src/index.ts"() {
      init_xml_loader();
      init_xml_utils();
    }
  });

  // src/lib/parsers/csw/parse-exception-report.ts
  function parseExceptionReport(parsedXML) {
    const exceptionReport = parsedXML.exceptionReport;
    if (!exceptionReport) {
      return;
    }
    const errorMessage = exceptionReport.exception?.exceptionText || exceptionReport.exception?.exceptionCode || exceptionReport.exception?.locator || "server error";
    throw new Error(`Catalog Server: ${errorMessage}`);
  }
  var init_parse_exception_report = __esm({
    "src/lib/parsers/csw/parse-exception-report.ts"() {
    }
  });

  // src/lib/parsers/csw/parse-csw-capabilities.ts
  function parseCSWCapabilities(text, options) {
    const parsedXML = XMLLoader.parseTextSync(text, {
      ...options,
      xml: {
        ...options?.xml,
        removeNSPrefix: true,
        uncapitalizeKeys: true
      }
    });
    parseExceptionReport(parsedXML);
    const xmlCapabilities = parsedXML.capabilities || parsedXML;
    return xmlCapabilities;
  }
  var init_parse_csw_capabilities = __esm({
    "src/lib/parsers/csw/parse-csw-capabilities.ts"() {
      init_src2();
      init_parse_exception_report();
    }
  });

  // src/csw-capabilities-loader.ts
  function testXMLFile2(text) {
    return text.startsWith("<?xml");
  }
  var VERSION2, CSWCapabilitiesLoader;
  var init_csw_capabilities_loader = __esm({
    "src/csw-capabilities-loader.ts"() {
      init_parse_csw_capabilities();
      VERSION2 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      CSWCapabilitiesLoader = {
        id: "csw-capabilities",
        name: "CSW Capabilities",
        module: "wms",
        version: VERSION2,
        worker: false,
        extensions: ["xml"],
        mimeTypes: ["application/vnd.ogc.csw_xml", "application/xml", "text/xml"],
        testText: testXMLFile2,
        options: {
          csw: {}
        },
        parse: async (arrayBuffer, options) => parseCSWCapabilities(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: (text, options) => parseCSWCapabilities(text, options)
      };
    }
  });

  // src/lib/parsers/csw/parse-csw-domain.ts
  function parseCSWDomain(text, options) {
    const parsedXML = XMLLoader.parseTextSync(text, {
      ...options,
      xml: {
        ...options?.xml,
        removeNSPrefix: true,
        uncapitalizeKeys: true,
        arrayPaths: [
          "GetDomainResponse.DomainValues",
          "GetDomainResponse.DomainValues.ListOfValues.value"
        ]
      }
    });
    parseExceptionReport(parsedXML);
    const xmlDomain = parsedXML.getDomainResponse;
    for (const domainValue of xmlDomain.domainValues) {
      domainValue.values = domainValue.listOfValues?.value;
      delete domainValue.listOfValues;
    }
    return xmlDomain;
  }
  var init_parse_csw_domain = __esm({
    "src/lib/parsers/csw/parse-csw-domain.ts"() {
      init_src2();
      init_parse_exception_report();
    }
  });

  // src/csw-domain-loader.ts
  function testXMLFile3(text) {
    return text.startsWith("<?xml");
  }
  var VERSION3, CSWDomainLoader;
  var init_csw_domain_loader = __esm({
    "src/csw-domain-loader.ts"() {
      init_parse_csw_domain();
      VERSION3 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      CSWDomainLoader = {
        id: "csw-domain",
        name: "CSW Domain",
        module: "wms",
        version: VERSION3,
        worker: false,
        extensions: ["xml"],
        mimeTypes: ["application/vnd.ogc.csw_xml", "application/xml", "text/xml"],
        testText: testXMLFile3,
        options: {
          csw: {}
        },
        parse: async (arrayBuffer, options) => parseCSWDomain(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: (text, options) => parseCSWDomain(text, options)
      };
    }
  });

  // src/lib/parsers/csw/parse-csw-records.ts
  function parseCSWRecords(text, options) {
    const parsedXML = XMLLoader.parseTextSync(text, {
      ...options,
      xml: {
        ...options?.xml,
        removeNSPrefix: true,
        uncapitalizeKeys: true,
        arrayPaths: []
      },
      _fastXML: {
        ...options?._fastXML,
        parseAttributeValue: true
      }
    });
    parseExceptionReport(parsedXML);
    const xmlRecords = parsedXML.getRecordsResponse;
    const elementSet = xmlRecords.searchResults.elementSet;
    const recordsFieldName = `${elementSet}Record`;
    xmlRecords.records = xmlRecords.searchResults[recordsFieldName];
    delete xmlRecords.searchResults[recordsFieldName];
    convertXMLFieldToArrayInPlace(xmlRecords, "records");
    for (const record of xmlRecords.records) {
      record.boundingBoxes = record.boundingBox;
      delete record.boundingBox;
      convertXMLFieldToArrayInPlace(record, "boundingBoxes");
      for (const boundingBox of record.boundingBoxes) {
        boundingBox.value = [
          boundingBox.upperCorner[0],
          boundingBox.upperCorner[1],
          boundingBox.lowerCorner[0],
          boundingBox.lowerCorner[1]
        ];
        delete boundingBox.upperCorner;
        delete boundingBox.lowerCorner;
      }
    }
    return xmlRecords;
  }
  var init_parse_csw_records = __esm({
    "src/lib/parsers/csw/parse-csw-records.ts"() {
      init_src2();
      init_src2();
      init_parse_exception_report();
    }
  });

  // src/csw-records-loader.ts
  function testXMLFile4(text) {
    return text.startsWith("<?xml");
  }
  var VERSION4, CSWRecordsLoader;
  var init_csw_records_loader = __esm({
    "src/csw-records-loader.ts"() {
      init_parse_csw_records();
      VERSION4 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      CSWRecordsLoader = {
        id: "csw-records",
        name: "CSW Domain",
        module: "wms",
        version: VERSION4,
        worker: false,
        extensions: ["xml"],
        mimeTypes: ["application/vnd.ogc.csw_xml", "application/xml", "text/xml"],
        testText: testXMLFile4,
        options: {
          csw: {}
        },
        parse: async (arrayBuffer, options) => parseCSWRecords(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: (text, options) => parseCSWRecords(text, options)
      };
    }
  });

  // src/lib/parsers/wms/parse-wms-error.ts
  function parseWMSError(text, options) {
    const parsedXML = XMLLoader.parseTextSync?.(text, options);
    const serviceExceptionXML = parsedXML?.ServiceExceptionReport?.ServiceException || parsedXML?.["ogc:ServiceExceptionReport"]?.["ogc:ServiceException"];
    const message = typeof serviceExceptionXML === "string" ? serviceExceptionXML : serviceExceptionXML.value || serviceExceptionXML.code || "Unknown error";
    return message;
  }
  var init_parse_wms_error = __esm({
    "src/lib/parsers/wms/parse-wms-error.ts"() {
      init_src2();
    }
  });

  // src/wms-error-loader.ts
  function testXMLFile5(text) {
    return text.startsWith("<?xml");
  }
  function parseTextSync2(text, options) {
    const wmsOptions = { ...WMSErrorLoader.options.wms, ...options?.wms };
    const error = parseWMSError(text, wmsOptions);
    const message = wmsOptions.minimalErrors ? error : `WMS Service error: ${error}`;
    if (wmsOptions.throwOnError) {
      throw new Error(message);
    }
    return message;
  }
  var VERSION5, WMSErrorLoader;
  var init_wms_error_loader = __esm({
    "src/wms-error-loader.ts"() {
      init_parse_wms_error();
      VERSION5 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      WMSErrorLoader = {
        id: "wms-error",
        name: "WMS Error",
        module: "wms",
        version: VERSION5,
        worker: false,
        extensions: ["xml"],
        mimeTypes: ["application/vnd.ogc.se_xml", "application/xml", "text/xml"],
        testText: testXMLFile5,
        options: {
          wms: {
            throwOnError: false
          }
        },
        parse: async (arrayBuffer, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer), options),
        parseSync: (arrayBuffer, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: (text, options) => parseTextSync2(text, options)
      };
    }
  });

  // src/lib/parsers/xml/parse-xml-helpers.ts
  function getXMLArray(xmlValue) {
    if (Array.isArray(xmlValue)) {
      return xmlValue;
    }
    if (xmlValue) {
      return [xmlValue];
    }
    return [];
  }
  function getXMLStringArray(xmlValue) {
    const xmlArray = getXMLArray(xmlValue);
    if (xmlArray.length > 0 && xmlArray.every((_) => typeof _ === "string")) {
      return xmlArray;
    }
    return [];
  }
  function getXMLFloat(xmlValue, defaultValue = void 0) {
    switch (typeof xmlValue) {
      case "number":
        return xmlValue;
      case "string":
        return parseFloat(xmlValue);
      default:
        return void 0;
    }
  }
  function getXMLInteger(xmlValue, defaultValue = void 0) {
    switch (typeof xmlValue) {
      case "number":
        return xmlValue;
      case "string":
        return parseInt(xmlValue, 10);
      default:
        return void 0;
    }
  }
  function getXMLBoolean(xmlValue) {
    switch (xmlValue) {
      case "true":
        return true;
      case "false":
        return false;
      case "1":
        return true;
      case "0":
        return false;
      default:
        return false;
    }
  }
  var init_parse_xml_helpers = __esm({
    "src/lib/parsers/xml/parse-xml-helpers.ts"() {
    }
  });

  // src/lib/parsers/wms/parse-wms-capabilities.ts
  function parseWMSCapabilities(xmlText, options) {
    const parsedXML = XMLLoader.parseTextSync(xmlText, options);
    const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
    const capabilities = extractCapabilities(xmlCapabilities);
    if (options?.inheritedLayerProps) {
      for (const layer of capabilities.layers) {
        addInheritedLayerProps(layer, null);
      }
    }
    if (options?.includeRawData || options?.raw) {
      capabilities.raw = xmlCapabilities;
    }
    if (options?.includeXMLText) {
      capabilities.xml = xmlText;
    }
    return capabilities;
  }
  function extractCapabilities(xml) {
    const capabilities = {
      version: String(xml.version || ""),
      name: String(xml.Service?.Name || "unnamed"),
      title: xml.Service?.Title ? String(xml.Service?.Title) : void 0,
      abstract: xml.Service?.Abstract ? String(xml.Service?.Abstract) : void 0,
      keywords: getXMLStringArray(xml.Service?.KeywordList?.Keyword),
      fees: xml.Service?.Fees ? JSON.stringify(xml.Service?.Fees) : void 0,
      accessConstraints: xml.Service?.AccessConstraints ? JSON.stringify(xml.Service?.AccessConstraints) : void 0,
      layerLimit: getXMLInteger(xml.Service?.LayerLimit),
      maxWidth: getXMLInteger(xml.Service?.maxWidth),
      maxHeight: getXMLInteger(xml.Service?.maxHeight),
      layers: [],
      requests: extractRequests(xml.Capability?.Request),
      exceptions: extractExceptions(xml.Exception)
    };
    const xmlLayers = getXMLArray(xml.Capability?.Layer);
    for (const xmlSubLayer of xmlLayers) {
      capabilities.layers.push(extractLayer(xmlSubLayer));
    }
    for (const [key, value] of Object.entries(capabilities)) {
      if (value === void 0) {
        delete capabilities[key];
      }
    }
    return capabilities;
  }
  function extractRequests(xmlRequests) {
    const requests = {};
    for (const [name, xmlRequest] of Object.entries(xmlRequests || {})) {
      const mimeTypes = getXMLStringArray(xmlRequest?.Format);
      requests[name] = { mimeTypes };
    }
    return requests;
  }
  function extractExceptions(xmlException) {
    const xmlExceptionFormats = getXMLArray(xmlException?.Format);
    if (xmlExceptionFormats.length > 0) {
      return {
        mimeTypes: getXMLStringArray(xmlException)
      };
    }
    return void 0;
  }
  function extractLayer(xmlLayer) {
    const layer = {
      title: String(xmlLayer?.Title || ""),
      name: xmlLayer?.Name && String(xmlLayer?.Name),
      abstract: xmlLayer?.Name && String(xmlLayer?.Abstract),
      keywords: getXMLStringArray(xmlLayer.KeywordList?.Keyword)
    };
    const crs = xmlLayer?.CRS || xmlLayer?.SRS;
    if (crs && Array.isArray(crs) && crs.every((_) => typeof _ === "string")) {
      layer.crs = crs;
    }
    let geographicBoundingBox = xmlLayer?.EX_GeographicBoundingBox && extractEXBoundingBox(xmlLayer?.EX_GeographicBoundingBox);
    if (geographicBoundingBox) {
      layer.geographicBoundingBox = geographicBoundingBox;
    }
    geographicBoundingBox = xmlLayer?.LatLonBoundingBox && extractLatLonBoundingBox(xmlLayer?.LatLonBoundingBox);
    if (geographicBoundingBox) {
      layer.geographicBoundingBox = geographicBoundingBox;
    }
    const boundingBoxes = xmlLayer?.BoundingBox && extractWMSBoundingBoxes(xmlLayer?.BoundingBox);
    if (boundingBoxes && boundingBoxes.length > 0) {
      layer.boundingBoxes = boundingBoxes;
    }
    const xmlDimensions = getXMLArray(xmlLayer?.Dimension);
    const dimensions = xmlDimensions.map((xml) => extractDimension(xml));
    if (dimensions.length) {
      layer.dimensions = dimensions;
    }
    if (xmlLayer?.opaque) {
      layer.opaque = getXMLBoolean(xmlLayer?.opaque);
    }
    if (xmlLayer?.cascaded) {
      layer.cascaded = getXMLBoolean(xmlLayer?.cascaded);
    }
    if (xmlLayer?.queryable) {
      layer.queryable = getXMLBoolean(xmlLayer?.queryable);
    }
    const xmlLayers = getXMLArray(xmlLayer?.Layer);
    const layers = [];
    for (const xmlSubLayer of xmlLayers) {
      layers.push(extractLayer(xmlSubLayer));
    }
    if (layers.length > 0) {
      layer.layers = layers;
    }
    for (const [key, value] of Object.entries(layer)) {
      if (value === void 0) {
        delete layer[key];
      }
    }
    return layer;
  }
  function extractEXBoundingBox(xmlBoundingBox) {
    const {
      westBoundLongitude: w,
      northBoundLatitude: n,
      eastBoundLongitude: e,
      southBoundLatitude: s
    } = xmlBoundingBox;
    return [
      [w, s],
      [e, n]
    ];
  }
  function extractLatLonBoundingBox(xmlBoundingBox) {
    const { minx, miny, maxx, maxy } = xmlBoundingBox;
    return [
      [minx, miny],
      [maxx, maxy]
    ];
  }
  function extractWMSBoundingBoxes(xmlBoundingBoxes) {
    const xmlBoxes = getXMLArray(xmlBoundingBoxes);
    return xmlBoxes.map((xmlBox) => extractWMSBoundingBox(xmlBox));
  }
  function extractWMSBoundingBox(xmlBoundingBox) {
    const { CRS, SRS, minx, miny, maxx, maxy, resx, resy } = xmlBoundingBox;
    const boundingBox = {
      crs: CRS || SRS,
      boundingBox: [
        [getXMLFloat(minx), getXMLFloat(miny)],
        [getXMLFloat(maxx), getXMLFloat(maxy)]
      ]
    };
    if (resx) {
      boundingBox.xResolution = resx;
    }
    if (resy) {
      boundingBox.yResolution = resy;
    }
    return boundingBox;
  }
  function extractDimension(xmlDimension) {
    const { name, units, value: extent } = xmlDimension;
    const dimension = { name, units, extent };
    if (xmlDimension.unitSymbol) {
      dimension.unitSymbol = xmlDimension.unitSymbol;
    }
    if (xmlDimension.default) {
      dimension.defaultValue = xmlDimension.default;
    }
    if (xmlDimension.multipleValues) {
      dimension.multipleValues = getXMLBoolean(xmlDimension.multipleValues);
    }
    if (xmlDimension.nearestValue) {
      dimension.nearestValue = getXMLBoolean(xmlDimension.nearestValue);
    }
    if (xmlDimension.current) {
      dimension.current = getXMLBoolean(xmlDimension.current);
    }
    return dimension;
  }
  function addInheritedLayerProps(layer, parent) {
    if (parent?.geographicBoundingBox && !layer.geographicBoundingBox) {
      layer.geographicBoundingBox = [...parent.geographicBoundingBox];
    }
    if (parent?.crs && !layer.crs) {
      layer.crs = [...parent.crs];
    }
    if (parent?.boundingBoxes && !layer.boundingBoxes) {
      layer.boundingBoxes = [...parent.boundingBoxes];
    }
    if (parent?.dimensions && !layer.dimensions) {
      layer.dimensions = [...parent.dimensions];
    }
    for (const subLayer of layer.layers || []) {
      addInheritedLayerProps(subLayer, layer);
    }
  }
  var init_parse_wms_capabilities = __esm({
    "src/lib/parsers/wms/parse-wms-capabilities.ts"() {
      init_src2();
      init_parse_xml_helpers();
    }
  });

  // src/wms-capabilities-loader.ts
  function testXMLFile6(text) {
    return text.startsWith("<?xml");
  }
  var VERSION6, WMSCapabilitiesLoader;
  var init_wms_capabilities_loader = __esm({
    "src/wms-capabilities-loader.ts"() {
      init_parse_wms_capabilities();
      VERSION6 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      WMSCapabilitiesLoader = {
        id: "wms-capabilities",
        name: "WMS Capabilities",
        module: "wms",
        version: VERSION6,
        worker: false,
        extensions: ["xml"],
        mimeTypes: ["application/vnd.ogc.wms_xml", "application/xml", "text/xml"],
        testText: testXMLFile6,
        options: {
          wms: {}
        },
        parse: async (arrayBuffer, options) => parseWMSCapabilities(new TextDecoder().decode(arrayBuffer), options?.wms),
        parseTextSync: (text, options) => parseWMSCapabilities(text, options?.wms)
      };
    }
  });

  // src/lib/parsers/wms/parse-wms-features.ts
  function parseWMSFeatureInfo(text, options) {
    const parsedXML = XMLLoader.parseTextSync(text, options);
    const xmlFeatureInfo = parsedXML.FeatureInfoResponse?.FIELDS || [];
    const xmlFeatures = Array.isArray(xmlFeatureInfo) ? xmlFeatureInfo : [xmlFeatureInfo];
    return {
      features: xmlFeatures.map((xmlFeature) => extractFeature(xmlFeature))
    };
  }
  function extractFeature(xmlFeature) {
    const xmlFields = xmlFeature || {};
    return {
      attributes: xmlFields,
      type: "",
      bounds: { bottom: 0, top: 0, left: 0, right: 0 }
    };
  }
  var init_parse_wms_features = __esm({
    "src/lib/parsers/wms/parse-wms-features.ts"() {
      init_src2();
    }
  });

  // src/wip/wms-feature-info-loader.ts
  var WMSFeatureInfoLoader;
  var init_wms_feature_info_loader = __esm({
    "src/wip/wms-feature-info-loader.ts"() {
      init_wms_capabilities_loader();
      init_parse_wms_features();
      WMSFeatureInfoLoader = {
        ...WMSCapabilitiesLoader,
        id: "wms-feature-info",
        name: "WMS FeatureInfo",
        parse: async (arrayBuffer, options) => parseWMSFeatureInfo(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: (text, options) => parseWMSFeatureInfo(text, options)
      };
    }
  });

  // src/lib/parsers/wms/parse-wms-layer-description.ts
  function parseWMSLayerDescription(text, options) {
    const parsedXML = XMLLoader.parseTextSync?.(text, options);
    return parsedXML;
  }
  var init_parse_wms_layer_description = __esm({
    "src/lib/parsers/wms/parse-wms-layer-description.ts"() {
      init_src2();
    }
  });

  // src/wip/wms-layer-description-loader.ts
  var WMSLayerDescriptionLoader;
  var init_wms_layer_description_loader = __esm({
    "src/wip/wms-layer-description-loader.ts"() {
      init_wms_capabilities_loader();
      init_parse_wms_layer_description();
      WMSLayerDescriptionLoader = {
        ...WMSCapabilitiesLoader,
        id: "wms-layer-description",
        name: "WMS DescribeLayer",
        parse: async (arrayBuffer, options) => parseWMSLayerDescription(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: (text, options) => parseWMSLayerDescription(text, options)
      };
    }
  });

  // src/wip/lib/wfs/parse-wfs-capabilities.ts
  function parseWFSCapabilities(text, options) {
    const parsedXML = XMLLoader.parseTextSync(text, { ...options, xml: {
      ...options?.xml,
      removeNSPrefix: true,
      uncapitalizeKeys: true
    } });
    const xmlCapabilities = parsedXML.Capabilities || parsedXML;
    return xmlCapabilities;
  }
  var init_parse_wfs_capabilities = __esm({
    "src/wip/lib/wfs/parse-wfs-capabilities.ts"() {
      init_src2();
    }
  });

  // src/wip/wfs-capabilities-loader.ts
  function testXMLFile7(text) {
    return text.startsWith("<?xml");
  }
  var VERSION7, WFSCapabilitiesLoader;
  var init_wfs_capabilities_loader = __esm({
    "src/wip/wfs-capabilities-loader.ts"() {
      init_parse_wfs_capabilities();
      VERSION7 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      WFSCapabilitiesLoader = {
        id: "wfs-capabilities",
        name: "WFS Capabilities",
        module: "wms",
        version: VERSION7,
        worker: false,
        extensions: ["xml"],
        mimeTypes: ["application/vnd.ogc.wfs_xml", "application/xml", "text/xml"],
        testText: testXMLFile7,
        options: {
          wms: {}
        },
        parse: async (arrayBuffer, options) => parseWFSCapabilities(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: (text, options) => parseWFSCapabilities(text, options)
      };
    }
  });

  // src/lib/parsers/gml/deep-strict-equal.ts
  function deepStrictEqual(actual, expected, strict) {
    if (actual === expected) {
      return true;
    } else if (actual instanceof Date && expected instanceof Date) {
      return actual.getTime() === expected.getTime();
    } else if (actual instanceof RegExp && expected instanceof RegExp) {
      return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
    } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
      return strict ? actual === expected : actual == expected;
    }
    return objEquiv(actual, expected, strict);
  }
  function isPrimitive(arg) {
    return arg === null || typeof arg !== "object" && typeof arg !== "function";
  }
  function isArguments(object) {
    return Object.prototype.toString.call(object) == "[object Arguments]";
  }
  function objEquiv(a, b, strict) {
    if (a === null || a === void 0 || b === null || b === void 0)
      return false;
    if (isPrimitive(a) || isPrimitive(b))
      return a === b;
    if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
      return false;
    const aIsArgs = isArguments(a);
    const bIsArgs = isArguments(b);
    if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
      return false;
    if (aIsArgs) {
      a = pSlice.call(a);
      b = pSlice.call(b);
      return deepStrictEqual(a, b, strict);
    }
    const ka = Object.keys(a);
    const kb = Object.keys(b);
    let key;
    let i;
    if (ka.length !== kb.length)
      return false;
    ka.sort();
    kb.sort();
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] !== kb[i])
        return false;
    }
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!deepStrictEqual(a[key], b[key], strict))
        return false;
    }
    return true;
  }
  var pSlice;
  var init_deep_strict_equal = __esm({
    "src/lib/parsers/gml/deep-strict-equal.ts"() {
      pSlice = Array.prototype.slice;
    }
  });

  // ../../node_modules/@turf/clone/main.es.js
  function clone(geojson) {
    if (!geojson)
      throw new Error("geojson is required");
    switch (geojson.type) {
      case "Feature":
        return cloneFeature(geojson);
      case "FeatureCollection":
        return cloneFeatureCollection(geojson);
      case "Point":
      case "LineString":
      case "Polygon":
      case "MultiPoint":
      case "MultiLineString":
      case "MultiPolygon":
      case "GeometryCollection":
        return cloneGeometry(geojson);
      default:
        throw new Error("unknown GeoJSON type");
    }
  }
  function cloneFeature(geojson) {
    var cloned = { type: "Feature" };
    Object.keys(geojson).forEach(function(key) {
      switch (key) {
        case "type":
        case "properties":
        case "geometry":
          return;
        default:
          cloned[key] = geojson[key];
      }
    });
    cloned.properties = cloneProperties(geojson.properties);
    cloned.geometry = cloneGeometry(geojson.geometry);
    return cloned;
  }
  function cloneProperties(properties) {
    var cloned = {};
    if (!properties)
      return cloned;
    Object.keys(properties).forEach(function(key) {
      var value = properties[key];
      if (typeof value === "object") {
        if (value === null) {
          cloned[key] = null;
        } else if (value.length) {
          cloned[key] = value.map(function(item) {
            return item;
          });
        } else {
          cloned[key] = cloneProperties(value);
        }
      } else
        cloned[key] = value;
    });
    return cloned;
  }
  function cloneFeatureCollection(geojson) {
    var cloned = { type: "FeatureCollection" };
    Object.keys(geojson).forEach(function(key) {
      switch (key) {
        case "type":
        case "features":
          return;
        default:
          cloned[key] = geojson[key];
      }
    });
    cloned.features = geojson.features.map(function(feature2) {
      return cloneFeature(feature2);
    });
    return cloned;
  }
  function cloneGeometry(geometry) {
    var geom = { type: geometry.type };
    if (geometry.bbox)
      geom.bbox = geometry.bbox;
    if (geometry.type === "GeometryCollection") {
      geom.geometries = geometry.geometries.map(function(geom2) {
        return cloneGeometry(geom2);
      });
      return geom;
    }
    geom.coordinates = deepSlice(geometry.coordinates);
    return geom;
  }
  function deepSlice(coords) {
    if (typeof coords[0] !== "object") {
      return coords.slice();
    }
    return coords.map(function(coord) {
      return deepSlice(coord);
    });
  }
  var main_es_default;
  var init_main_es = __esm({
    "../../node_modules/@turf/clone/main.es.js"() {
      main_es_default = clone;
    }
  });

  // ../../node_modules/@turf/helpers/main.es.js
  function featureCollection(features, options) {
    options = options || {};
    if (!isObject(options))
      throw new Error("options is invalid");
    var bbox = options.bbox;
    var id = options.id;
    if (!features)
      throw new Error("No features passed");
    if (!Array.isArray(features))
      throw new Error("features must be an Array");
    if (bbox)
      validateBBox(bbox);
    if (id)
      validateId(id);
    var fc = { type: "FeatureCollection" };
    if (id)
      fc.id = id;
    if (bbox)
      fc.bbox = bbox;
    fc.features = features;
    return fc;
  }
  function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
  }
  function isObject(input) {
    return !!input && input.constructor === Object;
  }
  function validateBBox(bbox) {
    if (!bbox)
      throw new Error("bbox is required");
    if (!Array.isArray(bbox))
      throw new Error("bbox must be an Array");
    if (bbox.length !== 4 && bbox.length !== 6)
      throw new Error("bbox must be an Array of 4 or 6 numbers");
    bbox.forEach(function(num) {
      if (!isNumber(num))
        throw new Error("bbox must only contain numbers");
    });
  }
  function validateId(id) {
    if (!id)
      throw new Error("id is required");
    if (["string", "number"].indexOf(typeof id) === -1)
      throw new Error("id must be a number or a string");
  }
  var earthRadius, factors, unitsFactors;
  var init_main_es2 = __esm({
    "../../node_modules/@turf/helpers/main.es.js"() {
      earthRadius = 63710088e-1;
      factors = {
        meters: earthRadius,
        metres: earthRadius,
        millimeters: earthRadius * 1e3,
        millimetres: earthRadius * 1e3,
        centimeters: earthRadius * 100,
        centimetres: earthRadius * 100,
        kilometers: earthRadius / 1e3,
        kilometres: earthRadius / 1e3,
        miles: earthRadius / 1609.344,
        nauticalmiles: earthRadius / 1852,
        inches: earthRadius * 39.37,
        yards: earthRadius / 1.0936,
        feet: earthRadius * 3.28084,
        radians: 1,
        degrees: earthRadius / 111325
      };
      unitsFactors = {
        meters: 1,
        metres: 1,
        millimeters: 1e3,
        millimetres: 1e3,
        centimeters: 100,
        centimetres: 100,
        kilometers: 1 / 1e3,
        kilometres: 1 / 1e3,
        miles: 1 / 1609.344,
        nauticalmiles: 1 / 1852,
        inches: 39.37,
        yards: 1 / 1.0936,
        feet: 3.28084,
        radians: 1 / earthRadius,
        degrees: 1 / 111325
      };
    }
  });

  // ../../node_modules/@turf/invariant/main.es.js
  function getCoords(coords) {
    if (!coords)
      throw new Error("coords is required");
    if (coords.type === "Feature" && coords.geometry !== null)
      return coords.geometry.coordinates;
    if (coords.coordinates)
      return coords.coordinates;
    if (Array.isArray(coords))
      return coords;
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
  }
  var init_main_es3 = __esm({
    "../../node_modules/@turf/invariant/main.es.js"() {
      init_main_es2();
    }
  });

  // ../../node_modules/@turf/boolean-clockwise/main.es.js
  function booleanClockwise(line) {
    if (!line)
      throw new Error("line is required");
    var type = line.geometry ? line.geometry.type : line.type;
    if (!Array.isArray(line) && type !== "LineString")
      throw new Error("geometry must be a LineString");
    var ring = getCoords(line);
    var sum = 0;
    var i = 1;
    var prev, cur;
    while (i < ring.length) {
      prev = cur || ring[0];
      cur = ring[i];
      sum += (cur[0] - prev[0]) * (cur[1] + prev[1]);
      i++;
    }
    return sum > 0;
  }
  var main_es_default2;
  var init_main_es4 = __esm({
    "../../node_modules/@turf/boolean-clockwise/main.es.js"() {
      init_main_es3();
      main_es_default2 = booleanClockwise;
    }
  });

  // ../../node_modules/@turf/meta/main.es.js
  function featureEach(geojson, callback) {
    if (geojson.type === "Feature") {
      callback(geojson, 0);
    } else if (geojson.type === "FeatureCollection") {
      for (var i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i], i) === false)
          break;
      }
    }
  }
  function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (i = 0; i < stop; i++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
      featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
      featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
      featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (g = 0; g < stopG; g++) {
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
        if (geometry === null) {
          if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false)
            return false;
          continue;
        }
        switch (geometry.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false)
              return false;
            break;
          }
          case "GeometryCollection": {
            for (j = 0; j < geometry.geometries.length; j++) {
              if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false)
                return false;
            }
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      featureIndex++;
    }
  }
  var init_main_es5 = __esm({
    "../../node_modules/@turf/meta/main.es.js"() {
      init_main_es2();
    }
  });

  // ../../node_modules/@turf/rewind/main.es.js
  function rewind(geojson, options) {
    options = options || {};
    if (!isObject(options))
      throw new Error("options is invalid");
    var reverse = options.reverse || false;
    var mutate = options.mutate || false;
    if (!geojson)
      throw new Error("<geojson> is required");
    if (typeof reverse !== "boolean")
      throw new Error("<reverse> must be a boolean");
    if (typeof mutate !== "boolean")
      throw new Error("<mutate> must be a boolean");
    if (mutate === false)
      geojson = main_es_default(geojson);
    var results = [];
    switch (geojson.type) {
      case "GeometryCollection":
        geomEach(geojson, function(geometry) {
          rewindFeature(geometry, reverse);
        });
        return geojson;
      case "FeatureCollection":
        featureEach(geojson, function(feature2) {
          featureEach(rewindFeature(feature2, reverse), function(result) {
            results.push(result);
          });
        });
        return featureCollection(results);
    }
    return rewindFeature(geojson, reverse);
  }
  function rewindFeature(geojson, reverse) {
    var type = geojson.type === "Feature" ? geojson.geometry.type : geojson.type;
    switch (type) {
      case "GeometryCollection":
        geomEach(geojson, function(geometry) {
          rewindFeature(geometry, reverse);
        });
        return geojson;
      case "LineString":
        rewindLineString(getCoords(geojson), reverse);
        return geojson;
      case "Polygon":
        rewindPolygon(getCoords(geojson), reverse);
        return geojson;
      case "MultiLineString":
        getCoords(geojson).forEach(function(lineCoords) {
          rewindLineString(lineCoords, reverse);
        });
        return geojson;
      case "MultiPolygon":
        getCoords(geojson).forEach(function(lineCoords) {
          rewindPolygon(lineCoords, reverse);
        });
        return geojson;
      case "Point":
      case "MultiPoint":
        return geojson;
    }
  }
  function rewindLineString(coords, reverse) {
    if (main_es_default2(coords) === reverse)
      coords.reverse();
  }
  function rewindPolygon(coords, reverse) {
    if (main_es_default2(coords[0]) !== reverse) {
      coords[0].reverse();
    }
    for (var i = 1; i < coords.length; i++) {
      if (main_es_default2(coords[i]) === reverse) {
        coords[i].reverse();
      }
    }
  }
  var main_es_default3;
  var init_main_es6 = __esm({
    "../../node_modules/@turf/rewind/main.es.js"() {
      init_main_es();
      init_main_es4();
      init_main_es5();
      init_main_es3();
      init_main_es2();
      main_es_default3 = rewind;
    }
  });

  // src/lib/parsers/gml/parse-gml.ts
  function noTransform(...coords) {
    return coords;
  }
  function parseGML(text, options) {
    const parsedXML = XMLLoader.parseTextSync(text, options);
    options = { transformCoords: noTransform, stride: 2, ...options };
    const context = createChildContext(parsedXML, options, {});
    return parseGMLToGeometry(parsedXML, options, context);
  }
  function parseGMLToGeometry(inputXML, options, context) {
    const childContext = createChildContext(inputXML, options, context);
    let geometry = null;
    const [name, xml] = getFirstKeyValue(inputXML);
    switch (name) {
      case "gml:LineString":
        geometry = {
          type: "LineString",
          coordinates: parseLinearRingOrLineString(xml, options, childContext)
        };
        break;
      case "gml:Polygon":
      case "gml:Rectangle":
        geometry = {
          type: "Polygon",
          coordinates: parsePolygonOrRectangle(xml, options, childContext)
        };
        break;
      case "gml:Surface":
        geometry = {
          type: "MultiPolygon",
          coordinates: parseSurface(xml, options, childContext)
        };
        break;
      case "gml:MultiSurface":
        geometry = {
          type: "MultiPolygon",
          coordinates: parseMultiSurface(xml, options, childContext)
        };
        break;
      default:
        return null;
    }
    return main_es_default3(geometry, { mutate: true });
  }
  function parseCoords(s, options, context) {
    const stride = context.srsDimension || options.stride || 2;
    const coords = s.replace(/\s+/g, " ").trim().split(" ");
    if (coords.length === 0 || coords.length % stride !== 0) {
      throw new Error(`invalid coordinates list (stride ${stride})`);
    }
    const points = [];
    for (let i = 0; i < coords.length - 1; i += stride) {
      const point2 = coords.slice(i, i + stride).map(parseFloat);
      points.push(options.transformCoords?.(...point2) || point2);
    }
    return points;
  }
  function parsePosList(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    const coords = textOf(xml);
    if (!coords) {
      throw new Error("invalid gml:posList element");
    }
    return parseCoords(coords, options, childContext);
  }
  function parsePos(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    const coords = textOf(xml);
    if (!coords) {
      throw new Error("invalid gml:pos element");
    }
    const points = parseCoords(coords, options, childContext);
    if (points.length !== 1) {
      throw new Error("gml:pos must have 1 point");
    }
    return points[0];
  }
  function parsePoint(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    const pos = findIn(xml, "gml:pos");
    if (!pos) {
      throw new Error("invalid gml:Point element, expected a gml:pos subelement");
    }
    return parsePos(pos, options, childContext);
  }
  function parseLinearRingOrLineString(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    let points = [];
    const posList = findIn(xml, "gml:posList");
    if (posList) {
      points = parsePosList(posList, options, childContext);
    } else {
      for (const [childName, childXML] of Object.entries(xml)) {
        switch (childName) {
          case "gml:Point":
            points.push(parsePoint(childXML, options, childContext));
            break;
          case "gml:pos":
            points.push(parsePos(childXML, options, childContext));
            break;
          default:
            continue;
        }
      }
    }
    if (points.length === 0) {
      throw new Error(`${xml.name} must have > 0 points`);
    }
    return points;
  }
  function parseCurveSegments(xml, options, context) {
    const points = [];
    for (const [childName, childXML] of Object.entries(xml)) {
      switch (childName) {
        case "gml:LineStringSegment":
          const points2 = parseLinearRingOrLineString(childXML, options, context);
          const end = points[points.length - 1];
          const start = points2[0];
          if (end && start && deepStrictEqual(end, start)) {
            points2.shift();
          }
          points.push(...points2);
          break;
        default:
          continue;
      }
    }
    if (points.length === 0) {
      throw new Error("gml:Curve > gml:segments must have > 0 points");
    }
    return points;
  }
  function parseRing(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    const points = [];
    for (const [childName, childXML] of Object.entries(xml)) {
      switch (childName) {
        case "gml:curveMember":
          let points2;
          const lineString2 = findIn(childXML, "gml:LineString");
          if (lineString2) {
            points2 = parseLinearRingOrLineString(lineString2, options, childContext);
          } else {
            const segments = findIn(childXML, "gml:Curve", "gml:segments");
            if (!segments) {
              throw new Error(`invalid ${childName} element`);
            }
            points2 = parseCurveSegments(segments, options, childContext);
          }
          const end = points[points.length - 1];
          const start = points2[0];
          if (end && start && deepStrictEqual(end, start)) {
            points2.shift();
          }
          points.push(...points2);
          break;
      }
    }
    if (points.length < 4) {
      throw new Error(`${xml.name} must have >= 4 points`);
    }
    return points;
  }
  function parseExteriorOrInterior(xml, options, context) {
    const linearRing = findIn(xml, "gml:LinearRing");
    if (linearRing) {
      return parseLinearRingOrLineString(linearRing, options, context);
    }
    const ring = findIn(xml, "gml:Ring");
    if (!ring) {
      throw new Error(`invalid ${xml.name} element`);
    }
    return parseRing(ring, options, context);
  }
  function parsePolygonOrRectangle(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    const exterior = findIn(xml, "gml:exterior");
    if (!exterior) {
      throw new Error(`invalid ${xml.name} element`);
    }
    const pointLists = [parseExteriorOrInterior(exterior, options, childContext)];
    for (const [childName, childXML] of Object.entries(xml)) {
      switch (childName) {
        case "gml:interior":
          pointLists.push(parseExteriorOrInterior(childXML, options, childContext));
          break;
      }
    }
    return pointLists;
  }
  function parseSurface(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    const patches = findIn(xml, "gml:patches");
    if (!patches) {
      throw new Error(`invalid ${xml.name} element`);
    }
    const polygons = [];
    for (const [childName, childXML] of Object.entries(xml)) {
      switch (childName) {
        case "gml:PolygonPatch":
        case "gml:Rectangle":
          polygons.push(parsePolygonOrRectangle(childXML, options, childContext));
          break;
        default:
          continue;
      }
    }
    if (polygons.length === 0) {
      throw new Error(`${xml.name} must have > 0 polygons`);
    }
    return polygons;
  }
  function parseCompositeSurface(xml, options, context) {
    const childContext = createChildContext(xml, options, context);
    const polygons = [];
    for (const [childName, childXML] of Object.entries(xml)) {
      switch (childName) {
        case "gml:surfaceMember":
        case "gml:surfaceMembers":
          const [c2Name, c2Xml] = getFirstKeyValue(childXML);
          switch (c2Name) {
            case "gml:Surface":
              polygons.push(...parseSurface(c2Xml, options, childContext));
              break;
            case "gml:Polygon":
              polygons.push(parsePolygonOrRectangle(c2Xml, options, childContext));
              break;
          }
          break;
      }
    }
    if (polygons.length === 0) {
      throw new Error(`${xml.name} must have > 0 polygons`);
    }
    return polygons;
  }
  function parseMultiSurface(xml, options, context) {
    let el = xml;
    const surfaceMembers = findIn(xml, "gml:LinearRing");
    if (surfaceMembers) {
      el = surfaceMembers;
    }
    const polygons = [];
    for (const [childName, childXML] of Object.entries(el)) {
      switch (childName) {
        case "gml:Surface":
          const polygons2 = parseSurface(childXML, options, context);
          polygons.push(...polygons2);
          break;
        case "gml:surfaceMember":
          const polygons3 = parseSurfaceMember(childXML, options, context);
          polygons.push(...polygons3);
          break;
        case "gml:surfaceMembers":
          const polygonXML = findIn(childXML, "gml:Polygon");
          for (const surfaceMemberXML of polygonXML) {
            const polygons32 = parseSurfaceMember(surfaceMemberXML, options, context);
            polygons.push(...polygons32);
          }
          break;
      }
    }
    if (polygons.length === 0) {
      throw new Error(`${xml.name} must have > 0 polygons`);
    }
    return polygons;
  }
  function parseSurfaceMember(xml, options, context) {
    const [childName, childXml] = getFirstKeyValue(xml);
    switch (childName) {
      case "gml:CompositeSurface":
        return parseCompositeSurface(childXml, options, context);
      case "gml:Surface":
        return parseSurface(childXml, options, context);
      case "gml:Polygon":
        return [parsePolygonOrRectangle(childXml, options, context)];
    }
    throw new Error(`${childName} must have polygons`);
  }
  function textOf(el) {
    if (typeof el !== "string") {
      throw new Error("expected string");
    }
    return el;
  }
  function findIn(root, ...tags) {
    let el = root;
    for (const tag of tags) {
      const child = el[tag];
      if (!child) {
        return null;
      }
      el = child;
    }
    return el;
  }
  function getFirstKeyValue(object) {
    if (object && typeof object === "object") {
      for (const [key, value] of Object.entries(object)) {
        return [key, value];
      }
    }
    return ["", null];
  }
  function createChildContext(xml, options, context) {
    const srsDimensionAttribute = xml.attributes && xml.attributes.srsDimension;
    if (srsDimensionAttribute) {
      const srsDimension = parseInt(srsDimensionAttribute);
      if (Number.isNaN(srsDimension) || srsDimension <= 0) {
        throw new Error(`invalid srsDimension attribute value "${srsDimensionAttribute}", expected a positive integer`);
      }
      const childContext = Object.create(context);
      childContext.srsDimension = srsDimension;
      return childContext;
    }
    return context;
  }
  var init_parse_gml = __esm({
    "src/lib/parsers/gml/parse-gml.ts"() {
      init_src2();
      init_deep_strict_equal();
      init_main_es6();
    }
  });

  // src/gml-loader.ts
  function testXMLFile8(text) {
    return text.startsWith("<?xml");
  }
  var VERSION8, GMLLoader;
  var init_gml_loader = __esm({
    "src/gml-loader.ts"() {
      init_parse_gml();
      VERSION8 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
      GMLLoader = {
        name: "GML",
        id: "gml",
        module: "wms",
        version: VERSION8,
        worker: false,
        extensions: ["xml"],
        mimeTypes: ["application/vnd.ogc.gml", "application/xml", "text/xml"],
        testText: testXMLFile8,
        options: {
          gml: {}
        },
        parse: async (arrayBuffer, options) => parseGML(new TextDecoder().decode(arrayBuffer), options),
        parseTextSync: (text, options) => parseGML(text, options)
      };
    }
  });

  // src/lib/sources/data-source.ts
  function getFetchFunction(options) {
    const fetchFunction = options?.fetch;
    if (fetchFunction && typeof fetchFunction === "function") {
      return (url, fetchOptions2) => fetchFunction(url, fetchOptions2);
    }
    const fetchOptions = options?.fetch;
    if (fetchOptions && typeof fetchOptions !== "function") {
      return (url) => fetch(url, fetchOptions);
    }
    return (url) => fetch(url);
  }
  var DataSource;
  var init_data_source = __esm({
    "src/lib/sources/data-source.ts"() {
      DataSource = class {
        constructor(props) {
          this._needsRefresh = true;
          this.props = { ...props };
          this.loadOptions = { ...props.loadOptions };
          this.fetch = getFetchFunction(this.loadOptions);
        }
        setProps(props) {
          this.props = Object.assign(this.props, props);
          this.setNeedsRefresh();
        }
        setNeedsRefresh() {
          this._needsRefresh = true;
        }
        getNeedsRefresh(clear = true) {
          const needsRefresh = this._needsRefresh;
          if (clear) {
            this._needsRefresh = false;
          }
          return needsRefresh;
        }
      };
    }
  });

  // src/lib/sources/image-source.ts
  var ImageSource;
  var init_image_source = __esm({
    "src/lib/sources/image-source.ts"() {
      init_data_source();
      ImageSource = class extends DataSource {
      };
    }
  });

  // ../images/src/lib/utils/version.ts
  var VERSION9;
  var init_version = __esm({
    "../images/src/lib/utils/version.ts"() {
      VERSION9 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
    }
  });

  // ../images/src/lib/category-api/image-type.ts
  function isImageTypeSupported(type) {
    switch (type) {
      case "auto":
        return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
      case "imagebitmap":
        return IMAGE_BITMAP_SUPPORTED;
      case "image":
        return IMAGE_SUPPORTED;
      case "data":
        return DATA_SUPPORTED;
      default:
        throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
    }
  }
  function getDefaultImageType() {
    if (IMAGE_BITMAP_SUPPORTED) {
      return "imagebitmap";
    }
    if (IMAGE_SUPPORTED) {
      return "image";
    }
    if (DATA_SUPPORTED) {
      return "data";
    }
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
  }
  var _parseImageNode, IMAGE_SUPPORTED, IMAGE_BITMAP_SUPPORTED, NODE_IMAGE_SUPPORTED, DATA_SUPPORTED;
  var init_image_type = __esm({
    "../images/src/lib/category-api/image-type.ts"() {
      init_src();
      ({ _parseImageNode } = globalThis);
      IMAGE_SUPPORTED = typeof Image !== "undefined";
      IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
      NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
      DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
    }
  });

  // ../images/src/lib/category-api/parsed-image-api.ts
  function getImageType(image) {
    const format = getImageTypeOrNull(image);
    if (!format) {
      throw new Error("Not an image");
    }
    return format;
  }
  function getImageData(image) {
    switch (getImageType(image)) {
      case "data":
        return image;
      case "image":
      case "imagebitmap":
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        if (!context) {
          throw new Error("getImageData");
        }
        canvas.width = image.width;
        canvas.height = image.height;
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, image.width, image.height);
      default:
        throw new Error("getImageData");
    }
  }
  function getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return "imagebitmap";
    }
    if (typeof Image !== "undefined" && image instanceof Image) {
      return "image";
    }
    if (image && typeof image === "object" && image.data && image.width && image.height) {
      return "data";
    }
    return null;
  }
  var init_parsed_image_api = __esm({
    "../images/src/lib/category-api/parsed-image-api.ts"() {
    }
  });

  // ../images/src/lib/parsers/svg-utils.ts
  function isSVG(url) {
    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
  }
  function getBlobOrSVGDataUrl(arrayBuffer, url) {
    if (isSVG(url)) {
      const textDecoder = new TextDecoder();
      let xmlText = textDecoder.decode(arrayBuffer);
      try {
        if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
          xmlText = unescape(encodeURIComponent(xmlText));
        }
      } catch (error) {
        throw new Error(error.message);
      }
      const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
      return src;
    }
    return getBlob(arrayBuffer, url);
  }
  function getBlob(arrayBuffer, url) {
    if (isSVG(url)) {
      throw new Error("SVG cannot be parsed directly to imagebitmap");
    }
    return new Blob([new Uint8Array(arrayBuffer)]);
  }
  var SVG_DATA_URL_PATTERN, SVG_URL_PATTERN;
  var init_svg_utils = __esm({
    "../images/src/lib/parsers/svg-utils.ts"() {
      SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
      SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
    }
  });

  // ../images/src/lib/parsers/parse-to-image.ts
  async function parseToImage(arrayBuffer, options, url) {
    const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);
    const URL = self.URL || self.webkitURL;
    const objectUrl = typeof blobOrDataUrl !== "string" && URL.createObjectURL(blobOrDataUrl);
    try {
      return await loadToImage(objectUrl || blobOrDataUrl, options);
    } finally {
      if (objectUrl) {
        URL.revokeObjectURL(objectUrl);
      }
    }
  }
  async function loadToImage(url, options) {
    const image = new Image();
    image.src = url;
    if (options.image && options.image.decode && image.decode) {
      await image.decode();
      return image;
    }
    return await new Promise((resolve, reject) => {
      try {
        image.onload = () => resolve(image);
        image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));
      } catch (error) {
        reject(error);
      }
    });
  }
  var init_parse_to_image = __esm({
    "../images/src/lib/parsers/parse-to-image.ts"() {
      init_svg_utils();
    }
  });

  // ../images/src/lib/parsers/parse-to-image-bitmap.ts
  async function parseToImageBitmap(arrayBuffer, options, url) {
    let blob;
    if (isSVG(url)) {
      const image = await parseToImage(arrayBuffer, options, url);
      blob = image;
    } else {
      blob = getBlob(arrayBuffer, url);
    }
    const imagebitmapOptions = options && options.imagebitmap;
    return await safeCreateImageBitmap(blob, imagebitmapOptions);
  }
  async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
      imagebitmapOptions = null;
    }
    if (imagebitmapOptions) {
      try {
        return await createImageBitmap(blob, imagebitmapOptions);
      } catch (error) {
        console.warn(error);
        imagebitmapOptionsSupported = false;
      }
    }
    return await createImageBitmap(blob);
  }
  function isEmptyObject(object) {
    for (const key in object || EMPTY_OBJECT) {
      return false;
    }
    return true;
  }
  var EMPTY_OBJECT, imagebitmapOptionsSupported;
  var init_parse_to_image_bitmap = __esm({
    "../images/src/lib/parsers/parse-to-image-bitmap.ts"() {
      init_svg_utils();
      init_parse_to_image();
      EMPTY_OBJECT = {};
      imagebitmapOptionsSupported = true;
    }
  });

  // ../images/src/lib/category-api/parse-isobmff-binary.ts
  function getISOBMFFMediaType(buffer) {
    if (!checkString(buffer, "ftyp", 4)) {
      return null;
    }
    if ((buffer[8] & 96) === 0) {
      return null;
    }
    return decodeMajorBrand(buffer);
  }
  function decodeMajorBrand(buffer) {
    const brandMajor = getUTF8String(buffer, 8, 12).replace("\0", " ").trim();
    switch (brandMajor) {
      case "avif":
      case "avis":
        return { extension: "avif", mimeType: "image/avif" };
      default:
        return null;
    }
  }
  function getUTF8String(array, start, end) {
    return String.fromCharCode(...array.slice(start, end));
  }
  function stringToBytes(string) {
    return [...string].map((character) => character.charCodeAt(0));
  }
  function checkString(buffer, header, offset = 0) {
    const headerBytes = stringToBytes(header);
    for (let i = 0; i < headerBytes.length; ++i) {
      if (headerBytes[i] !== buffer[i + offset]) {
        return false;
      }
    }
    return true;
  }
  var init_parse_isobmff_binary = __esm({
    "../images/src/lib/category-api/parse-isobmff-binary.ts"() {
    }
  });

  // ../images/src/lib/category-api/binary-image-api.ts
  function getBinaryImageMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
  }
  function getISOBMFFMetadata(binaryData) {
    const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
    const mediaType = getISOBMFFMediaType(buffer);
    if (!mediaType) {
      return null;
    }
    return {
      mimeType: mediaType.mimeType,
      width: 0,
      height: 0
    };
  }
  function getPngMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
    if (!isPng) {
      return null;
    }
    return {
      mimeType: "image/png",
      width: dataView.getUint32(16, BIG_ENDIAN),
      height: dataView.getUint32(20, BIG_ENDIAN)
    };
  }
  function getGifMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
    if (!isGif) {
      return null;
    }
    return {
      mimeType: "image/gif",
      width: dataView.getUint16(6, LITTLE_ENDIAN),
      height: dataView.getUint16(8, LITTLE_ENDIAN)
    };
  }
  function getBmpMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) {
      return null;
    }
    return {
      mimeType: "image/bmp",
      width: dataView.getUint32(18, LITTLE_ENDIAN),
      height: dataView.getUint32(22, LITTLE_ENDIAN)
    };
  }
  function getJpegMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
    if (!isJpeg) {
      return null;
    }
    const { tableMarkers, sofMarkers } = getJpegMarkers();
    let i = 2;
    while (i + 9 < dataView.byteLength) {
      const marker = dataView.getUint16(i, BIG_ENDIAN);
      if (sofMarkers.has(marker)) {
        return {
          mimeType: "image/jpeg",
          height: dataView.getUint16(i + 5, BIG_ENDIAN),
          width: dataView.getUint16(i + 7, BIG_ENDIAN)
        };
      }
      if (!tableMarkers.has(marker)) {
        return null;
      }
      i += 2;
      i += dataView.getUint16(i, BIG_ENDIAN);
    }
    return null;
  }
  function getJpegMarkers() {
    const tableMarkers = new Set([65499, 65476, 65484, 65501, 65534]);
    for (let i = 65504; i < 65520; ++i) {
      tableMarkers.add(i);
    }
    const sofMarkers = new Set([
      65472,
      65473,
      65474,
      65475,
      65477,
      65478,
      65479,
      65481,
      65482,
      65483,
      65485,
      65486,
      65487,
      65502
    ]);
    return { tableMarkers, sofMarkers };
  }
  function toDataView(data) {
    if (data instanceof DataView) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      return new DataView(data.buffer);
    }
    if (data instanceof ArrayBuffer) {
      return new DataView(data);
    }
    throw new Error("toDataView");
  }
  var BIG_ENDIAN, LITTLE_ENDIAN;
  var init_binary_image_api = __esm({
    "../images/src/lib/category-api/binary-image-api.ts"() {
      init_parse_isobmff_binary();
      BIG_ENDIAN = false;
      LITTLE_ENDIAN = true;
    }
  });

  // ../images/src/lib/parsers/parse-to-node-image.ts
  async function parseToNodeImage(arrayBuffer, options) {
    const { mimeType } = getBinaryImageMetadata(arrayBuffer) || {};
    const _parseImageNode2 = globalThis._parseImageNode;
    assert(_parseImageNode2);
    return await _parseImageNode2(arrayBuffer, mimeType);
  }
  var init_parse_to_node_image = __esm({
    "../images/src/lib/parsers/parse-to-node-image.ts"() {
      init_src();
      init_binary_image_api();
    }
  });

  // ../images/src/lib/parsers/parse-image.ts
  async function parseImage(arrayBuffer, options, context) {
    options = options || {};
    const imageOptions = options.image || {};
    const imageType = imageOptions.type || "auto";
    const { url } = context || {};
    const loadType = getLoadableImageType(imageType);
    let image;
    switch (loadType) {
      case "imagebitmap":
        image = await parseToImageBitmap(arrayBuffer, options, url);
        break;
      case "image":
        image = await parseToImage(arrayBuffer, options, url);
        break;
      case "data":
        image = await parseToNodeImage(arrayBuffer, options);
        break;
      default:
        assert(false);
    }
    if (imageType === "data") {
      image = getImageData(image);
    }
    return image;
  }
  function getLoadableImageType(type) {
    switch (type) {
      case "auto":
      case "data":
        return getDefaultImageType();
      default:
        isImageTypeSupported(type);
        return type;
    }
  }
  var init_parse_image = __esm({
    "../images/src/lib/parsers/parse-image.ts"() {
      init_src();
      init_image_type();
      init_parsed_image_api();
      init_parse_to_image();
      init_parse_to_image_bitmap();
      init_parse_to_node_image();
    }
  });

  // ../images/src/image-loader.ts
  var EXTENSIONS, MIME_TYPES, DEFAULT_IMAGE_LOADER_OPTIONS, ImageLoader;
  var init_image_loader = __esm({
    "../images/src/image-loader.ts"() {
      init_version();
      init_parse_image();
      init_binary_image_api();
      EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"];
      MIME_TYPES = [
        "image/png",
        "image/jpeg",
        "image/gif",
        "image/webp",
        "image/avif",
        "image/bmp",
        "image/vnd.microsoft.icon",
        "image/svg+xml"
      ];
      DEFAULT_IMAGE_LOADER_OPTIONS = {
        image: {
          type: "auto",
          decode: true
        }
      };
      ImageLoader = {
        id: "image",
        module: "images",
        name: "Images",
        version: VERSION9,
        mimeTypes: MIME_TYPES,
        extensions: EXTENSIONS,
        parse: parseImage,
        tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],
        options: DEFAULT_IMAGE_LOADER_OPTIONS
      };
    }
  });

  // ../images/src/index.ts
  var init_src3 = __esm({
    "../images/src/index.ts"() {
      init_image_loader();
    }
  });

  // src/lib/services/generic/image-service.ts
  var ImageService;
  var init_image_service = __esm({
    "src/lib/services/generic/image-service.ts"() {
      init_src3();
      init_image_source();
      ImageService = class extends ImageSource {
        constructor(props) {
          super(props);
        }
        async getMetadata() {
          throw new Error("ImageSource.getMetadata not implemented");
        }
        async getImage(parameters) {
          const granularParameters = this.getGranularParameters(parameters);
          const url = this.getURLFromTemplate(granularParameters);
          const response = await this.fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          return await ImageLoader.parse(arrayBuffer);
        }
        getGranularParameters(parameters) {
          const [east, north, west, south] = parameters.bbox;
          return { ...parameters, east, north, south, west };
        }
        getURLFromTemplate(parameters) {
          let url = this.props.url;
          for (const [key, value] of Object.entries(parameters)) {
            url = url.replace(`\${${key}}`, String(value));
            url = url.replace(`{${key}}`, String(value));
          }
          return url;
        }
      };
      ImageService.type = "template";
      ImageService.testURL = (url) => url.toLowerCase().includes("{");
    }
  });

  // src/lib/services/ogc/wms-service.ts
  var WMSService;
  var init_wms_service = __esm({
    "src/lib/services/ogc/wms-service.ts"() {
      init_src3();
      init_src();
      init_image_source();
      init_wms_capabilities_loader();
      init_wms_feature_info_loader();
      init_wms_layer_description_loader();
      init_wms_error_loader();
      WMSService = class extends ImageSource {
        constructor(props) {
          super(props);
          this.capabilities = null;
          this.loaders = [
            ImageLoader,
            WMSErrorLoader,
            WMSCapabilitiesLoader,
            WMSFeatureInfoLoader,
            WMSLayerDescriptionLoader
          ];
          this.url = props.url;
          this.substituteCRS84 = props.substituteCRS84 ?? false;
          this.flipCRS = ["EPSG:4326"];
          this.wmsParameters = {
            layers: void 0,
            query_layers: void 0,
            styles: void 0,
            version: "1.3.0",
            crs: "EPSG:4326",
            format: "image/png",
            info_format: "text/plain",
            transparent: void 0,
            time: void 0,
            elevation: void 0,
            ...props.wmsParameters
          };
          this.vendorParameters = props.vendorParameters || {};
        }
        async getMetadata() {
          const capabilities = await this.getCapabilities();
          return this.normalizeMetadata(capabilities);
        }
        async getImage(parameters) {
          return await this.getMap(parameters);
        }
        normalizeMetadata(capabilities) {
          return capabilities;
        }
        async getCapabilities(wmsParameters, vendorParameters) {
          const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
          const response = await this.fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          this._checkResponse(response, arrayBuffer);
          const capabilities = await WMSCapabilitiesLoader.parse(arrayBuffer, this.loadOptions);
          this.capabilities = capabilities;
          return capabilities;
        }
        async getMap(wmsParameters, vendorParameters) {
          const url = this.getMapURL(wmsParameters, vendorParameters);
          const response = await this.fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          this._checkResponse(response, arrayBuffer);
          try {
            return await ImageLoader.parse(arrayBuffer, this.loadOptions);
          } catch {
            throw this._parseError(arrayBuffer);
          }
        }
        async getFeatureInfo(wmsParameters, vendorParameters) {
          const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
          const response = await this.fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          this._checkResponse(response, arrayBuffer);
          return await WMSFeatureInfoLoader.parse(arrayBuffer, this.loadOptions);
        }
        async getFeatureInfoText(wmsParameters, vendorParameters) {
          const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
          const response = await this.fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          this._checkResponse(response, arrayBuffer);
          return new TextDecoder().decode(arrayBuffer);
        }
        async describeLayer(wmsParameters, vendorParameters) {
          const url = this.describeLayerURL(wmsParameters, vendorParameters);
          const response = await this.fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          this._checkResponse(response, arrayBuffer);
          return await WMSLayerDescriptionLoader.parse(arrayBuffer, this.loadOptions);
        }
        async getLegendGraphic(wmsParameters, vendorParameters) {
          const url = this.getLegendGraphicURL(wmsParameters, vendorParameters);
          const response = await this.fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          this._checkResponse(response, arrayBuffer);
          try {
            return await ImageLoader.parse(arrayBuffer, this.loadOptions);
          } catch {
            throw this._parseError(arrayBuffer);
          }
        }
        getCapabilitiesURL(wmsParameters, vendorParameters) {
          const options = {
            version: this.wmsParameters.version,
            ...wmsParameters
          };
          return this._getWMSUrl("GetCapabilities", options, vendorParameters);
        }
        getMapURL(wmsParameters, vendorParameters) {
          wmsParameters = this._getWMS130Parameters(wmsParameters);
          const options = {
            version: this.wmsParameters.version,
            format: this.wmsParameters.format,
            transparent: this.wmsParameters.transparent,
            time: this.wmsParameters.time,
            elevation: this.wmsParameters.elevation,
            layers: this.wmsParameters.layers,
            styles: this.wmsParameters.styles,
            crs: this.wmsParameters.crs,
            ...wmsParameters
          };
          return this._getWMSUrl("GetMap", options, vendorParameters);
        }
        getFeatureInfoURL(wmsParameters, vendorParameters) {
          const options = {
            version: this.wmsParameters.version,
            info_format: this.wmsParameters.info_format,
            layers: this.wmsParameters.layers,
            query_layers: this.wmsParameters.query_layers,
            styles: this.wmsParameters.styles,
            crs: this.wmsParameters.crs,
            ...wmsParameters
          };
          return this._getWMSUrl("GetFeatureInfo", options, vendorParameters);
        }
        describeLayerURL(wmsParameters, vendorParameters) {
          const options = {
            version: this.wmsParameters.version,
            ...wmsParameters
          };
          return this._getWMSUrl("DescribeLayer", options, vendorParameters);
        }
        getLegendGraphicURL(wmsParameters, vendorParameters) {
          const options = {
            version: this.wmsParameters.version,
            ...wmsParameters
          };
          return this._getWMSUrl("GetLegendGraphic", options, vendorParameters);
        }
        _parseWMSUrl(url) {
          const [baseUrl, search] = url.split("?");
          const searchParams = search.split("&");
          const parameters = {};
          for (const parameter of searchParams) {
            const [key, value] = parameter.split("=");
            parameters[key] = value;
          }
          return { url: baseUrl, parameters };
        }
        _getWMSUrl(request, wmsParameters, vendorParameters) {
          let url = this.url;
          let first = true;
          const allParameters = {
            service: "WMS",
            version: wmsParameters.version,
            request,
            ...wmsParameters,
            ...this.vendorParameters,
            ...vendorParameters
          };
          const IGNORE_EMPTY_KEYS = ["transparent", "time", "elevation"];
          for (const [key, value] of Object.entries(allParameters)) {
            if (!IGNORE_EMPTY_KEYS.includes(key) || value) {
              url += first ? "?" : "&";
              first = false;
              url += this._getURLParameter(key, value, wmsParameters);
            }
          }
          return encodeURI(url);
        }
        _getWMS130Parameters(wmsParameters) {
          const newParameters = { ...wmsParameters };
          if (newParameters.srs) {
            newParameters.crs = newParameters.crs || newParameters.srs;
            delete newParameters.srs;
          }
          return newParameters;
        }
        _getURLParameter(key, value, wmsParameters) {
          switch (key) {
            case "crs":
              if (wmsParameters.version !== "1.3.0") {
                key = "srs";
              } else if (this.substituteCRS84 && value === "EPSG:4326") {
                value = "CRS:84";
              }
              break;
            case "srs":
              if (wmsParameters.version === "1.3.0") {
                key = "crs";
              }
              break;
            case "bbox":
              const bbox = this._flipBoundingBox(value, wmsParameters);
              if (bbox) {
                value = bbox;
              }
              break;
            default:
          }
          key = key.toUpperCase();
          return Array.isArray(value) ? `${key}=${value.join(",")}` : `${key}=${value ? String(value) : ""}`;
        }
        _flipBoundingBox(bboxValue, wmsParameters) {
          if (!Array.isArray(bboxValue) || bboxValue.length !== 4) {
            return null;
          }
          const flipCoordinates = wmsParameters.version === "1.3.0" && this.flipCRS.includes(wmsParameters.crs || "") && !(this.substituteCRS84 && wmsParameters.crs === "EPSG:4326");
          const bbox = bboxValue;
          return flipCoordinates ? [bbox[1], bbox[0], bbox[3], bbox[2]] : bbox;
        }
        async _fetchArrayBuffer(url) {
          const response = await this.fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          this._checkResponse(response, arrayBuffer);
          return arrayBuffer;
        }
        _checkResponse(response, arrayBuffer) {
          const contentType = response.headers["content-type"];
          if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
            const loadOptions = mergeLoaderOptions(this.loadOptions, {
              wms: { throwOnError: true }
            });
            const error = WMSErrorLoader.parseSync(arrayBuffer, loadOptions);
            throw new Error(error);
          }
        }
        _parseError(arrayBuffer) {
          const error = WMSErrorLoader.parseSync(arrayBuffer, this.loadOptions);
          return new Error(error);
        }
      };
      WMSService.type = "wms";
      WMSService.testURL = (url) => url.toLowerCase().includes("wms");
    }
  });

  // src/lib/services/arcgis/arcgis-image-service.ts
  var ArcGISImageServer;
  var init_arcgis_image_service = __esm({
    "src/lib/services/arcgis/arcgis-image-service.ts"() {
      init_image_source();
      ArcGISImageServer = class extends ImageSource {
        constructor(props) {
          super(props);
        }
        async getMetadata() {
          return await this.metadata();
        }
        async getImage(parameters) {
          throw new Error("not implemented");
        }
        async metadata() {
          throw new Error("not implemented");
        }
        exportImage(options) {
          throw new Error("not implemented");
        }
        metadataURL(options) {
          return `${this.props.url}?f=pjson`;
        }
        exportImageURL(options) {
          const bbox = `bbox=${options.bbox[0]},${options.bbox[1]},${options.bbox[2]},${options.bbox[3]}`;
          const size = `size=${options.width},${options.height}`;
          const arcgisOptions = { ...options, bbox, size };
          delete arcgisOptions.width;
          delete arcgisOptions.height;
          return this.getUrl("exportImage", arcgisOptions);
        }
        getUrl(path, options, extra) {
          let url = `${this.props.url}/${path}`;
          let first = true;
          for (const [key, value] of Object.entries(options)) {
            url += first ? "?" : "&";
            first = false;
            if (Array.isArray(value)) {
              url += `${key.toUpperCase()}=${value.join(",")}`;
            } else {
              url += `${key.toUpperCase()}=${value ? String(value) : ""}`;
            }
          }
          return url;
        }
        async checkResponse(response) {
          if (!response.ok) {
            throw new Error("error");
          }
        }
      };
      ArcGISImageServer.type = "arcgis-image-server";
      ArcGISImageServer.testURL = (url) => url.toLowerCase().includes("ImageServer");
    }
  });

  // src/lib/create-image-source.ts
  function createImageSource(props) {
    const { type = "auto" } = props;
    const serviceType = type === "auto" ? guessServiceType(props.url) : type;
    switch (serviceType) {
      case "template":
        return new ImageService(props);
      case "wms":
        return new WMSService(props);
      default:
        throw new Error("Not a valid image source type");
    }
  }
  function guessServiceType(url) {
    for (const Service of SERVICES) {
      if (Service.testURL && Service.testURL(url)) {
        return Service.type;
      }
    }
    return "wms";
  }
  var SERVICES;
  var init_create_image_source = __esm({
    "src/lib/create-image-source.ts"() {
      init_image_service();
      init_wms_service();
      init_arcgis_image_service();
      SERVICES = [WMSService, ArcGISImageServer, ImageService];
    }
  });

  // src/lib/services/ogc/csw-service.ts
  var CSWService;
  var init_csw_service = __esm({
    "src/lib/services/ogc/csw-service.ts"() {
      init_data_source();
      init_csw_capabilities_loader();
      init_csw_records_loader();
      init_csw_domain_loader();
      init_wms_error_loader();
      CSWService = class extends DataSource {
        constructor(props) {
          super(props);
          this.capabilities = null;
          this.loaders = [WMSErrorLoader, CSWCapabilitiesLoader];
        }
        async getMetadata() {
          const capabilities = await this.getCapabilities();
          return this.normalizeMetadata(capabilities);
        }
        normalizeMetadata(capabilities) {
          return capabilities;
        }
        async getServiceDirectory(options) {
          const services = [];
          const unknownServices = [];
          const records = await this.getRecords();
          for (const record of records.records) {
            for (const reference of record.references) {
              const url = reference.value;
              switch (reference.scheme) {
                case "OGC:WMS":
                  services.push({ name: record.title, type: "ogc-wms-service", ...this._parseOGCUrl(url) });
                  break;
                case "OGC:WMTS":
                  services.push({
                    name: record.title,
                    type: "ogc-wmts-service",
                    ...this._parseOGCUrl(url)
                  });
                  break;
                case "OGC:WFS":
                  services.push({ name: record.title, type: "ogc-wfs-service", ...this._parseOGCUrl(url) });
                  break;
                default:
                  unknownServices.push({
                    name: record.title,
                    type: "unknown",
                    url: reference.value,
                    scheme: reference.scheme
                  });
              }
            }
          }
          return options?.includeUnknown ? services.concat(unknownServices) : services;
        }
        _parseOGCUrl(url) {
          const parts = url.split("?");
          return {
            url: parts[0],
            params: parts[1] || ""
          };
        }
        async getCapabilities(wmsParameters, vendorParameters) {
          const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
          const response = await this.fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          this._checkResponse(response, arrayBuffer);
          const capabilities = await CSWCapabilitiesLoader.parse(arrayBuffer, this.props.loadOptions);
          return capabilities;
        }
        async getRecords(wmsParameters, vendorParameters) {
          const url = this.getRecordsURL(wmsParameters, vendorParameters);
          const response = await this.fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          this._checkResponse(response, arrayBuffer);
          return await CSWRecordsLoader.parse(arrayBuffer, this.props.loadOptions);
        }
        async getDomain(wmsParameters, vendorParameters) {
          const url = this.getDomainURL(wmsParameters, vendorParameters);
          const response = await this.fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          this._checkResponse(response, arrayBuffer);
          return await CSWDomainLoader.parse(arrayBuffer, this.props.loadOptions);
        }
        getCapabilitiesURL(wmsParameters, vendorParameters) {
          const options = {
            version: "3.0.0",
            ...wmsParameters,
            ...vendorParameters,
            service: "CSW",
            request: "GetCapabilities"
          };
          return this._getCSWUrl(options, vendorParameters);
        }
        getRecordsURL(wmsParameters, vendorParameters) {
          const options = {
            version: "3.0.0",
            typenames: "csw:Record",
            ...wmsParameters,
            ...vendorParameters,
            service: "CSW",
            request: "GetRecords"
          };
          return this._getCSWUrl(options, vendorParameters);
        }
        getDomainURL(wmsParameters, vendorParameters) {
          const options = {
            version: "3.0.0",
            ...wmsParameters,
            ...vendorParameters,
            service: "CSW",
            request: "GetDomain"
          };
          return this._getCSWUrl(options, vendorParameters);
        }
        _getCSWUrl(options, vendorParameters) {
          let url = this.props.url;
          let first = true;
          for (const [key, value] of Object.entries(options)) {
            url += first ? "?" : "&";
            first = false;
            if (Array.isArray(value)) {
              url += `${key.toUpperCase()}=${value.join(",")}`;
            } else {
              url += `${key.toUpperCase()}=${value ? String(value) : ""}`;
            }
          }
          return encodeURI(url);
        }
        _checkResponse(response, arrayBuffer) {
          const contentType = response.headers["content-type"];
          if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
            const error = WMSErrorLoader.parseSync(arrayBuffer, this.props.loadOptions);
            throw new Error(error);
          }
        }
        _parseError(arrayBuffer) {
          const error = WMSErrorLoader.parseSync(arrayBuffer, this.props.loadOptions);
          return new Error(error);
        }
      };
      CSWService.type = "csw";
      CSWService.testURL = (url) => url.toLowerCase().includes("csw");
    }
  });

  // src/lib/services/arcgis/arcgis-server.ts
  async function getArcGISServices(url, fetchFile = fetch) {
    if (url.includes("rest/services")) {
      const serverUrl = url.replace(/rest\/services.*$/i, "rest/services");
      return loadServiceDirectory(serverUrl, fetchFile, []);
    }
    return null;
  }
  async function loadServiceDirectory(serverUrl, fetch2, path) {
    const serviceUrl = `${serverUrl}/${path.join("/")}`;
    const response = await fetch2(`${serviceUrl}?f=pjson`);
    const directory = await response.json();
    const services = extractServices(directory, serviceUrl);
    const folders = directory.folders || [];
    const promises = folders.map((folder) => loadServiceDirectory(`${serverUrl}`, fetch2, [...path, folder]));
    for (const folderServices of await Promise.all(promises)) {
      services.push(...folderServices);
    }
    return services;
  }
  function extractServices(directory, url) {
    const arcgisServices = directory.services || [];
    const services = [];
    for (const service of arcgisServices) {
      services.push({
        name: service.name,
        type: `arcgis-${service.type.toLocaleLowerCase().replace("server", "-server")}`,
        url: `${url}${service.name}/${service.type}`
      });
    }
    return services;
  }
  var init_arcgis_server = __esm({
    "src/lib/services/arcgis/arcgis-server.ts"() {
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    CSWCapabilitiesLoader: () => CSWCapabilitiesLoader,
    CSWDomainLoader: () => CSWDomainLoader,
    CSWRecordsLoader: () => CSWRecordsLoader,
    CSWService: () => CSWService,
    ImageService: () => ImageService,
    ImageSource: () => ImageSource,
    WMSCapabilitiesLoader: () => WMSCapabilitiesLoader,
    WMSErrorLoader: () => WMSErrorLoader,
    WMSService: () => WMSService,
    _ArcGISImageServer: () => ArcGISImageServer,
    _GMLLoader: () => GMLLoader,
    _WFSCapabilitiesLoader: () => WFSCapabilitiesLoader,
    _WMSFeatureInfoLoader: () => WMSFeatureInfoLoader,
    _WMSLayerDescriptionLoader: () => WMSLayerDescriptionLoader,
    _getArcGISServices: () => getArcGISServices,
    createImageSource: () => createImageSource
  });
  var init_src4 = __esm({
    "src/index.ts"() {
      init_csw_capabilities_loader();
      init_csw_domain_loader();
      init_csw_records_loader();
      init_wms_error_loader();
      init_wms_capabilities_loader();
      init_wms_feature_info_loader();
      init_wms_layer_description_loader();
      init_wfs_capabilities_loader();
      init_gml_loader();
      init_image_source();
      init_create_image_source();
      init_image_service();
      init_csw_service();
      init_wms_service();
      init_arcgis_server();
      init_arcgis_image_service();
    }
  });

  // src/bundle.ts
  var require_bundle = __commonJS({
    "src/bundle.ts"(exports, module) {
      var moduleExports = (init_src4(), src_exports);
      globalThis.loaders = globalThis.loaders || {};
      module.exports = Object.assign(globalThis.loaders, moduleExports);
    }
  });
  require_bundle();
})();

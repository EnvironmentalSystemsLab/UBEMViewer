"use strict";
// loaders.gl, MIT license
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseWMTSCapabilities = void 0;
const xml_1 = require("@loaders.gl/xml");
/**
 * Parses a typed data structure from raw XML for `GetCapabilities` response
 * @note Error handlings is fairly weak
 */
function parseWMTSCapabilities(text, options) {
    const parsedXML = xml_1.XMLLoader.parseTextSync(text, { ...options, xml: {
            ...options?.xml,
            removeNSPrefix: true,
            uncapitalizeKeys: true
        } });
    const xmlCapabilities = parsedXML.Capabilities || parsedXML;
    return xmlCapabilities;
}
exports.parseWMTSCapabilities = parseWMTSCapabilities;
/**
 * Parses a typed data structure from raw XML for `GetCapabilities` response
 * @note Error handlings is fairly weak
 */
// export function parseWMTSCapabilities(text: string, options): WMTSCapabilities {
//   const parsedXML = XMLLoader.parseTextSync(text, options);
//   const xmlCapabilities: any =
//     parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
//   return extractCapabilities(xmlCapabilities);
// }
/** Extract typed capability data from XML */
// function extractCapabilities(xml: any): WMTSCapabilities {
//   const capabilities: WMTSCapabilities = {
//     name: xml.Service?.Name || 'unnamed',
//     title: xml.Service?.Title,
//     keywords: [],
//     requests: {},
//     layer: extractLayer(xml.Capability?.Layer),
//     raw: xml
//   };
//   for (const keyword of xml.Service?.KeywordList?.Keyword || []) {
//     capabilities.keywords.push(keyword);
//   }
//   for (const [name, xmlRequest] of Object.entries(xml.Capability?.Request || {})) {
//     capabilities.requests[name] = extractRequest(name, xmlRequest);
//   }
//   return capabilities;
// }
// /** Extract typed request data from XML */
// function extractRequest(name: string, xmlRequest: any): WMSRequest {
//   const format: string | string[] = xmlRequest?.Format;
//   const mimeTypes: string[] = Array.isArray(format) ? format : [format];
//   return {name, mimeTypes};
// }
// /** Extract request data */
// function extractLayer(xmlLayer: any): WMSLayer {
//   const layer: WMSLayer = {
//     name: xmlLayer?.Name,
//     title: xmlLayer?.Title,
//     srs: xmlLayer?.SRS || [],
//     layers: []
//   };
//   // Single layer is not represented as array in XML
//   const xmlLayers = getXMLArray(xmlLayer?.Layer);
//   for (const xmlSubLayer of xmlLayers) {
//     layer.layers?.push(extractLayer(xmlSubLayer));
//   }
//   return layer;
// }
// function getXMLArray(xmlValue: any) {
//   if (Array.isArray(xmlValue)) {
//     return xmlValue;
//   }
//   if (xmlValue) {
//     return [xmlValue];
//   }
//   return [];
// }

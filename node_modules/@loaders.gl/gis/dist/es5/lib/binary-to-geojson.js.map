{"version":3,"file":"binary-to-geojson.js","names":["binaryToGeojson","data","options","globalFeatureId","undefined","getSingleFeature","parseFeatures","type","binaryToGeoJson","format","arguments","length","binaryToGeometry","Error","dataArray","normalizeInput","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","lastIndex","lastValue","featureIds","i","currValue","globalFeatureIds","parseFeature","err","e","f","concat","parseFeatureCollection","startIndex","endIndex","pointToGeoJson","lineStringToGeoJson","polygonToGeoJson","unexpectedInput","isHeterogeneousType","Boolean","points","lines","polygons","parseType","features","push","_iterator2","_step2","geometry","properties","parseProperties","fields","parseFields","_objectSpread","Object","assign","key","numericProps","Infinity","positions","polygonIndices","filter","x","primitivePolygonIndices","multi","coordinates","startRingIndex","endRingIndex","ringCoordinates","ringToGeoJson","startPolygonIndex","endPolygonIndex","polygonCoordinates","pathIndices","size","j","coord","Array","k","Number"],"sources":["../../../src/lib/binary-to-geojson.ts"],"sourcesContent":["import type {\n  BinaryGeometry,\n  BinaryFeatures,\n  BinaryGeometryType,\n  BinaryPointFeatures,\n  BinaryLineFeatures,\n  BinaryPolygonFeatures,\n  BinaryAttribute\n} from '@loaders.gl/schema';\nimport type {Feature, Geometry, Position, GeoJsonProperties} from '@loaders.gl/schema';\nimport type {\n  Point,\n  MultiPoint,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon\n} from '@loaders.gl/schema';\n\n// Note:L We do not handle GeometryCollection, define a limited Geometry type that always has coordinates.\n// type FeatureGeometry = Point | MultiPoint | LineString | MultiLineString | Polygon | MultiPolygon;\n\ntype BinaryToGeoJsonOptions = {\n  type?: BinaryGeometryType;\n  globalFeatureId?: number;\n};\n\n/**\n * Convert binary geometry representation to GeoJSON\n * @param data   geometry data in binary representation\n * @param options\n * @param options.type  Input data type: Point, LineString, or Polygon\n * @param options.featureId  Global feature id. If specified, only a single feature is extracted\n * @return GeoJSON objects\n */\nexport function binaryToGeojson(\n  data: BinaryFeatures,\n  options?: BinaryToGeoJsonOptions\n): Feature[] | Feature {\n  const globalFeatureId = options?.globalFeatureId;\n  if (globalFeatureId !== undefined) {\n    return getSingleFeature(data, globalFeatureId);\n  }\n  return parseFeatures(data, options?.type);\n}\n\n/** @deprecated use `binaryToGeojson` or `binaryToGeometry` instead */\nexport function binaryToGeoJson(\n  data: BinaryGeometry | BinaryFeatures,\n  type?: BinaryGeometryType,\n  format: 'feature' | 'geometry' = 'feature'\n): Geometry | Feature[] {\n  switch (format) {\n    case 'feature':\n      return parseFeatures(data as BinaryFeatures, type);\n    case 'geometry':\n      return binaryToGeometry(data as BinaryGeometry);\n    default:\n      throw new Error(format);\n  }\n}\n\n/**\n * Return a single feature from a binary geometry representation as GeoJSON\n * @param data   geometry data in binary representation\n * @return GeoJSON feature\n */\nfunction getSingleFeature(data: BinaryFeatures, globalFeatureId: number): Feature {\n  const dataArray = normalizeInput(data);\n  for (const data of dataArray) {\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Scan through data until we find matching feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n        return parseFeature(data, lastIndex, i);\n      }\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n      return parseFeature(data, lastIndex, data.featureIds.value.length);\n    }\n  }\n\n  throw new Error(`featureId:${globalFeatureId} not found`);\n}\n\nfunction parseFeatures(data: BinaryFeatures, type?: BinaryGeometryType): Feature[] {\n  const dataArray = normalizeInput(data, type);\n  return parseFeatureCollection(dataArray);\n}\n\n/** Parse input binary data and return a valid GeoJSON geometry object */\nexport function binaryToGeometry(\n  data: BinaryGeometry,\n  startIndex?: number,\n  endIndex?: number\n): Geometry {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n    default:\n      const unexpectedInput: never = data;\n      throw new Error(`Unsupported geometry type: ${(unexpectedInput as any)?.type}`);\n  }\n}\n\ntype BinaryFeature = BinaryPointFeatures | BinaryLineFeatures | BinaryPolygonFeatures;\ntype BinaryFeaturesArray = BinaryFeature[];\n\n// Normalize features\n// Return an array of data objects, each of which have a type key\nfunction normalizeInput(data: BinaryFeatures, type?: BinaryGeometryType): BinaryFeaturesArray {\n  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n\n  if (!isHeterogeneousType) {\n    // @ts-expect-error This is a legacy check which allowed `data` to be an instance of the values\n    // here. Aka the new data.points, data.lines, or data.polygons.\n    data.type = type || parseType(data);\n    return [data] as BinaryFeaturesArray;\n  }\n\n  const features: BinaryFeaturesArray = [];\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n\n  return features;\n}\n\n/** Parse input binary data and return an array of GeoJSON Features */\nfunction parseFeatureCollection(dataArray): Feature[] {\n  const features: Feature[] = [];\n  for (const data of dataArray) {\n    if (data.featureIds.value.length === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Need to deduce start, end indices of each feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      features.push(parseFeature(data, lastIndex, i));\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    // Last feature\n    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n  }\n  return features;\n}\n\n/** Parse input binary data and return a single GeoJSON Feature */\nfunction parseFeature(data, startIndex?: number, endIndex?: number): Feature {\n  const geometry = binaryToGeometry(data, startIndex, endIndex);\n  const properties = parseProperties(data, startIndex, endIndex);\n  const fields = parseFields(data, startIndex, endIndex);\n  return {type: 'Feature', geometry, properties, ...fields};\n}\n\n/** Parse input binary data and return an object of fields */\nfunction parseFields(data, startIndex: number = 0, endIndex?: number): GeoJsonProperties {\n  return data.fields && data.fields[data.featureIds.value[startIndex]];\n}\n\n/** Parse input binary data and return an object of properties */\nfunction parseProperties(data, startIndex: number = 0, endIndex?: number): GeoJsonProperties {\n  const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);\n  for (const key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n  return properties;\n}\n\n/** Parse binary data of type Polygon */\nfunction polygonToGeoJson(\n  data,\n  startIndex: number = -Infinity,\n  endIndex: number = Infinity\n): Polygon | MultiPolygon {\n  const {positions} = data;\n  const polygonIndices = data.polygonIndices.value.filter((x) => x >= startIndex && x <= endIndex);\n  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter(\n    (x) => x >= startIndex && x <= endIndex\n  );\n  const multi = polygonIndices.length > 2;\n\n  // Polygon\n  if (!multi) {\n    const coordinates: Position[][] = [];\n    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      const startRingIndex = primitivePolygonIndices[i];\n      const endRingIndex = primitivePolygonIndices[i + 1];\n      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n\n    return {type: 'Polygon', coordinates};\n  }\n\n  // MultiPolygon\n  const coordinates: Position[][][] = [];\n  for (let i = 0; i < polygonIndices.length - 1; i++) {\n    const startPolygonIndex = polygonIndices[i];\n    const endPolygonIndex = polygonIndices[i + 1];\n    const polygonCoordinates = polygonToGeoJson(\n      data,\n      startPolygonIndex,\n      endPolygonIndex\n    ).coordinates;\n    coordinates.push(polygonCoordinates as Position[][]);\n  }\n\n  return {type: 'MultiPolygon', coordinates};\n}\n\n/** Parse binary data of type LineString */\nfunction lineStringToGeoJson(\n  data,\n  startIndex: number = -Infinity,\n  endIndex: number = Infinity\n): LineString | MultiLineString {\n  const {positions} = data;\n  const pathIndices = data.pathIndices.value.filter((x) => x >= startIndex && x <= endIndex);\n  const multi = pathIndices.length > 2;\n\n  if (!multi) {\n    const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {type: 'LineString', coordinates};\n  }\n\n  const coordinates: Position[][] = [];\n  for (let i = 0; i < pathIndices.length - 1; i++) {\n    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n\n  return {type: 'MultiLineString', coordinates};\n}\n\n/** Parse binary data of type Point */\nfunction pointToGeoJson(data, startIndex, endIndex): Point | MultiPoint {\n  const {positions} = data;\n  const coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  const multi = coordinates.length > 1;\n\n  if (multi) {\n    return {type: 'MultiPoint', coordinates};\n  }\n\n  return {type: 'Point', coordinates: coordinates[0]};\n}\n\n/**\n * Parse a linear ring of positions to a GeoJSON linear ring\n *\n * @param positions Positions TypedArray\n * @param startIndex Start index to include in ring\n * @param endIndex End index to include in ring\n * @returns GeoJSON ring\n */\nfunction ringToGeoJson(\n  positions: BinaryAttribute,\n  startIndex?: number,\n  endIndex?: number\n): Position[] {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n\n  const ringCoordinates: Position[] = [];\n  for (let j = startIndex; j < endIndex; j++) {\n    const coord = Array<number>();\n    for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {\n      coord.push(Number(positions.value[k]));\n    }\n    ringCoordinates.push(coord);\n  }\n  return ringCoordinates;\n}\n\n// Deduce geometry type of data object\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n\n  return 'Point';\n}\n"],"mappings":"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"}
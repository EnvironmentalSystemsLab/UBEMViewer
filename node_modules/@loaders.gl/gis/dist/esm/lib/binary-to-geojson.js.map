{"version":3,"file":"binary-to-geojson.js","names":["binaryToGeojson","data","options","globalFeatureId","undefined","getSingleFeature","parseFeatures","type","binaryToGeoJson","format","arguments","length","binaryToGeometry","Error","dataArray","normalizeInput","lastIndex","lastValue","featureIds","value","i","currValue","globalFeatureIds","parseFeature","concat","parseFeatureCollection","startIndex","endIndex","pointToGeoJson","lineStringToGeoJson","polygonToGeoJson","unexpectedInput","isHeterogeneousType","Boolean","points","lines","polygons","parseType","features","push","geometry","properties","parseProperties","fields","parseFields","Object","assign","key","numericProps","Infinity","positions","polygonIndices","filter","x","primitivePolygonIndices","multi","coordinates","startRingIndex","endRingIndex","ringCoordinates","ringToGeoJson","startPolygonIndex","endPolygonIndex","polygonCoordinates","pathIndices","size","j","coord","Array","k","Number"],"sources":["../../../src/lib/binary-to-geojson.ts"],"sourcesContent":["import type {\n  BinaryGeometry,\n  BinaryFeatures,\n  BinaryGeometryType,\n  BinaryPointFeatures,\n  BinaryLineFeatures,\n  BinaryPolygonFeatures,\n  BinaryAttribute\n} from '@loaders.gl/schema';\nimport type {Feature, Geometry, Position, GeoJsonProperties} from '@loaders.gl/schema';\nimport type {\n  Point,\n  MultiPoint,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon\n} from '@loaders.gl/schema';\n\n// Note:L We do not handle GeometryCollection, define a limited Geometry type that always has coordinates.\n// type FeatureGeometry = Point | MultiPoint | LineString | MultiLineString | Polygon | MultiPolygon;\n\ntype BinaryToGeoJsonOptions = {\n  type?: BinaryGeometryType;\n  globalFeatureId?: number;\n};\n\n/**\n * Convert binary geometry representation to GeoJSON\n * @param data   geometry data in binary representation\n * @param options\n * @param options.type  Input data type: Point, LineString, or Polygon\n * @param options.featureId  Global feature id. If specified, only a single feature is extracted\n * @return GeoJSON objects\n */\nexport function binaryToGeojson(\n  data: BinaryFeatures,\n  options?: BinaryToGeoJsonOptions\n): Feature[] | Feature {\n  const globalFeatureId = options?.globalFeatureId;\n  if (globalFeatureId !== undefined) {\n    return getSingleFeature(data, globalFeatureId);\n  }\n  return parseFeatures(data, options?.type);\n}\n\n/** @deprecated use `binaryToGeojson` or `binaryToGeometry` instead */\nexport function binaryToGeoJson(\n  data: BinaryGeometry | BinaryFeatures,\n  type?: BinaryGeometryType,\n  format: 'feature' | 'geometry' = 'feature'\n): Geometry | Feature[] {\n  switch (format) {\n    case 'feature':\n      return parseFeatures(data as BinaryFeatures, type);\n    case 'geometry':\n      return binaryToGeometry(data as BinaryGeometry);\n    default:\n      throw new Error(format);\n  }\n}\n\n/**\n * Return a single feature from a binary geometry representation as GeoJSON\n * @param data   geometry data in binary representation\n * @return GeoJSON feature\n */\nfunction getSingleFeature(data: BinaryFeatures, globalFeatureId: number): Feature {\n  const dataArray = normalizeInput(data);\n  for (const data of dataArray) {\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Scan through data until we find matching feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n        return parseFeature(data, lastIndex, i);\n      }\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n      return parseFeature(data, lastIndex, data.featureIds.value.length);\n    }\n  }\n\n  throw new Error(`featureId:${globalFeatureId} not found`);\n}\n\nfunction parseFeatures(data: BinaryFeatures, type?: BinaryGeometryType): Feature[] {\n  const dataArray = normalizeInput(data, type);\n  return parseFeatureCollection(dataArray);\n}\n\n/** Parse input binary data and return a valid GeoJSON geometry object */\nexport function binaryToGeometry(\n  data: BinaryGeometry,\n  startIndex?: number,\n  endIndex?: number\n): Geometry {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n    default:\n      const unexpectedInput: never = data;\n      throw new Error(`Unsupported geometry type: ${(unexpectedInput as any)?.type}`);\n  }\n}\n\ntype BinaryFeature = BinaryPointFeatures | BinaryLineFeatures | BinaryPolygonFeatures;\ntype BinaryFeaturesArray = BinaryFeature[];\n\n// Normalize features\n// Return an array of data objects, each of which have a type key\nfunction normalizeInput(data: BinaryFeatures, type?: BinaryGeometryType): BinaryFeaturesArray {\n  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n\n  if (!isHeterogeneousType) {\n    // @ts-expect-error This is a legacy check which allowed `data` to be an instance of the values\n    // here. Aka the new data.points, data.lines, or data.polygons.\n    data.type = type || parseType(data);\n    return [data] as BinaryFeaturesArray;\n  }\n\n  const features: BinaryFeaturesArray = [];\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n\n  return features;\n}\n\n/** Parse input binary data and return an array of GeoJSON Features */\nfunction parseFeatureCollection(dataArray): Feature[] {\n  const features: Feature[] = [];\n  for (const data of dataArray) {\n    if (data.featureIds.value.length === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Need to deduce start, end indices of each feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      features.push(parseFeature(data, lastIndex, i));\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    // Last feature\n    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n  }\n  return features;\n}\n\n/** Parse input binary data and return a single GeoJSON Feature */\nfunction parseFeature(data, startIndex?: number, endIndex?: number): Feature {\n  const geometry = binaryToGeometry(data, startIndex, endIndex);\n  const properties = parseProperties(data, startIndex, endIndex);\n  const fields = parseFields(data, startIndex, endIndex);\n  return {type: 'Feature', geometry, properties, ...fields};\n}\n\n/** Parse input binary data and return an object of fields */\nfunction parseFields(data, startIndex: number = 0, endIndex?: number): GeoJsonProperties {\n  return data.fields && data.fields[data.featureIds.value[startIndex]];\n}\n\n/** Parse input binary data and return an object of properties */\nfunction parseProperties(data, startIndex: number = 0, endIndex?: number): GeoJsonProperties {\n  const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);\n  for (const key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n  return properties;\n}\n\n/** Parse binary data of type Polygon */\nfunction polygonToGeoJson(\n  data,\n  startIndex: number = -Infinity,\n  endIndex: number = Infinity\n): Polygon | MultiPolygon {\n  const {positions} = data;\n  const polygonIndices = data.polygonIndices.value.filter((x) => x >= startIndex && x <= endIndex);\n  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter(\n    (x) => x >= startIndex && x <= endIndex\n  );\n  const multi = polygonIndices.length > 2;\n\n  // Polygon\n  if (!multi) {\n    const coordinates: Position[][] = [];\n    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      const startRingIndex = primitivePolygonIndices[i];\n      const endRingIndex = primitivePolygonIndices[i + 1];\n      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n\n    return {type: 'Polygon', coordinates};\n  }\n\n  // MultiPolygon\n  const coordinates: Position[][][] = [];\n  for (let i = 0; i < polygonIndices.length - 1; i++) {\n    const startPolygonIndex = polygonIndices[i];\n    const endPolygonIndex = polygonIndices[i + 1];\n    const polygonCoordinates = polygonToGeoJson(\n      data,\n      startPolygonIndex,\n      endPolygonIndex\n    ).coordinates;\n    coordinates.push(polygonCoordinates as Position[][]);\n  }\n\n  return {type: 'MultiPolygon', coordinates};\n}\n\n/** Parse binary data of type LineString */\nfunction lineStringToGeoJson(\n  data,\n  startIndex: number = -Infinity,\n  endIndex: number = Infinity\n): LineString | MultiLineString {\n  const {positions} = data;\n  const pathIndices = data.pathIndices.value.filter((x) => x >= startIndex && x <= endIndex);\n  const multi = pathIndices.length > 2;\n\n  if (!multi) {\n    const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {type: 'LineString', coordinates};\n  }\n\n  const coordinates: Position[][] = [];\n  for (let i = 0; i < pathIndices.length - 1; i++) {\n    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n\n  return {type: 'MultiLineString', coordinates};\n}\n\n/** Parse binary data of type Point */\nfunction pointToGeoJson(data, startIndex, endIndex): Point | MultiPoint {\n  const {positions} = data;\n  const coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  const multi = coordinates.length > 1;\n\n  if (multi) {\n    return {type: 'MultiPoint', coordinates};\n  }\n\n  return {type: 'Point', coordinates: coordinates[0]};\n}\n\n/**\n * Parse a linear ring of positions to a GeoJSON linear ring\n *\n * @param positions Positions TypedArray\n * @param startIndex Start index to include in ring\n * @param endIndex End index to include in ring\n * @returns GeoJSON ring\n */\nfunction ringToGeoJson(\n  positions: BinaryAttribute,\n  startIndex?: number,\n  endIndex?: number\n): Position[] {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n\n  const ringCoordinates: Position[] = [];\n  for (let j = startIndex; j < endIndex; j++) {\n    const coord = Array<number>();\n    for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {\n      coord.push(Number(positions.value[k]));\n    }\n    ringCoordinates.push(coord);\n  }\n  return ringCoordinates;\n}\n\n// Deduce geometry type of data object\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n\n  return 'Point';\n}\n"],"mappings":"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"}
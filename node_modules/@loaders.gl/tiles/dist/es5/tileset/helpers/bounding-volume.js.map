{"version":3,"file":"bounding-volume.js","names":["_core","require","_culling","_geospatial","_loaderUtils","defined","x","undefined","scratchPoint","Vector3","scratchScale","scratchNorthWest","scratchSouthEast","createBoundingVolume","boundingVolumeHeader","transform","result","assert","box","createBox","region","_boundingVolumeHeader","_slicedToArray2","default","west","south","east","north","minHeight","maxHeight","northWest","Ellipsoid","WGS84","cartographicToCartesian","degrees","southEast","centerInCartesian","addVectors","multiplyScalar","radius","subVectors","len","createSphere","Matrix4","sphere","Error","getCartographicBounds","boundingVolume","orientedBoundingBoxToCartographicBounds","_boundingVolumeHeader2","boundingSphereToCartographicBounds","center","origin","length","halfSize","slice","quaternion","Quaternion","fromArray","y","z","transformByQuaternion","scale","concat","_toConsumableArray2","toArray","xAxis","transformAsVector","yAxis","zAxis","halfAxes","Matrix3","OrientedBoundingBox","getScale","uniformScale","Math","max","BoundingSphere","emptyCartographicBounds","_ref","getColumn","copy","add","addToCartographicBounds","negate","_ref2","point","scaleToGeodeticSurface","geodeticSurfaceNormal","normalize","clone","cross","_i","_arr","axis","dir","Infinity","target","cartesian","cartesianToCartographic","min"],"sources":["../../../../src/tileset/helpers/bounding-volume.ts"],"sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Quaternion, Vector3, Matrix3, Matrix4, degrees} from '@math.gl/core';\nimport {BoundingSphere, OrientedBoundingBox} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {assert} from '@loaders.gl/loader-utils';\n\n// const scratchProjectedBoundingSphere = new BoundingSphere();\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\n// const scratchMatrix = new Matrix3();\nconst scratchPoint = new Vector3();\nconst scratchScale = new Vector3();\nconst scratchNorthWest = new Vector3();\nconst scratchSouthEast = new Vector3();\n// const scratchRectangle = new Rectangle();\n// const scratchOrientedBoundingBox = new OrientedBoundingBox();\n// const scratchTransform = new Matrix4();\n\n/**\n * Create a bounding volume from the tile's bounding volume header.\n * @param {Object} boundingVolumeHeader The tile's bounding volume header.\n * @param {Matrix4} transform The transform to apply to the bounding volume.\n * @param [result] The object onto which to store the result.\n * @returns The modified result parameter or a new TileBoundingVolume instance if none was provided.\n */\nexport function createBoundingVolume(boundingVolumeHeader, transform, result) {\n  assert(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n\n  // boundingVolume schema:\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/schema/boundingVolume.schema.json\n  if (boundingVolumeHeader.box) {\n    return createBox(boundingVolumeHeader.box, transform, result);\n  }\n  if (boundingVolumeHeader.region) {\n    // [west, south, east, north, minimum height, maximum height]\n    // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.\n    // Heights are in meters above (or below) the WGS 84 ellipsoid.\n    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;\n\n    const northWest = Ellipsoid.WGS84.cartographicToCartesian(\n      [degrees(west), degrees(north), minHeight],\n      scratchNorthWest\n    );\n    const southEast = Ellipsoid.WGS84.cartographicToCartesian(\n      [degrees(east), degrees(south), maxHeight],\n      scratchSouthEast\n    );\n    const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);\n    const radius = new Vector3().subVectors(northWest, southEast).len() / 2.0;\n\n    // TODO improve region boundingVolume\n    // for now, create a sphere as the boundingVolume instead of box\n    return createSphere(\n      [centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius],\n      new Matrix4()\n    );\n  }\n\n  if (boundingVolumeHeader.sphere) {\n    return createSphere(boundingVolumeHeader.sphere, transform, result);\n  }\n\n  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\n\n/** [min, max] each in [longitude, latitude, altitude] */\nexport type CartographicBounds = [min: number[], max: number[]];\n\n/**\n * Calculate the cartographic bounding box the tile's bounding volume.\n * @param {Object} boundingVolumeHeader The tile's bounding volume header.\n * @param {BoundingVolume} boundingVolume The bounding volume.\n * @returns {CartographicBounds}\n */\nexport function getCartographicBounds(\n  boundingVolumeHeader,\n  boundingVolume: OrientedBoundingBox | BoundingSphere\n): CartographicBounds {\n  // boundingVolume schema:\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/schema/boundingVolume.schema.json\n  if (boundingVolumeHeader.box) {\n    return orientedBoundingBoxToCartographicBounds(boundingVolume as OrientedBoundingBox);\n  }\n  if (boundingVolumeHeader.region) {\n    // [west, south, east, north, minimum height, maximum height]\n    // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.\n    // Heights are in meters above (or below) the WGS 84 ellipsoid.\n    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;\n\n    return [\n      [degrees(west), degrees(south), minHeight],\n      [degrees(east), degrees(north), maxHeight]\n    ];\n  }\n\n  if (boundingVolumeHeader.sphere) {\n    return boundingSphereToCartographicBounds(boundingVolume as BoundingSphere);\n  }\n\n  throw new Error('Unkown boundingVolume type');\n}\n\nfunction createBox(box, transform, result) {\n  // https://math.gl/modules/culling/docs/api-reference/oriented-bounding-box\n  // 1. A half-axes based representation.\n  // box: An array of 12 numbers that define an oriented bounding box.\n  // The first three elements define the x, y, and z values for the center of the box.\n  // The next three elements (with indices 3, 4, and 5) define the x axis direction and half-length.\n  // The next three elements (indices 6, 7, and 8) define the y axis direction and half-length.\n  // The last three elements (indices 9, 10, and 11) define the z axis direction and half-length.\n  // 2. A half-size-quaternion based representation.\n  // box: An array of 10 numbers that define an oriented bounding box.\n  // The first three elements define the x, y, and z values for the center of the box in a right-handed 3-axis (x, y, z) Cartesian coordinate system where the z-axis is up.\n  // The next three elements (with indices 3, 4, and 5) define the halfSize.\n  // The last four elements (indices 6, 7, 8 and 10) define the quaternion.\n  const center = new Vector3(box[0], box[1], box[2]);\n  transform.transform(center, center);\n  let origin: number[] = [];\n  if (box.length === 10) {\n    const halfSize = box.slice(3, 6);\n    const quaternion = new Quaternion();\n    quaternion.fromArray(box, 6);\n    const x = new Vector3([1, 0, 0]);\n    const y = new Vector3([0, 1, 0]);\n    const z = new Vector3([0, 0, 1]);\n    x.transformByQuaternion(quaternion);\n    x.scale(halfSize[0]);\n    y.transformByQuaternion(quaternion);\n    y.scale(halfSize[1]);\n    z.transformByQuaternion(quaternion);\n    z.scale(halfSize[2]);\n    origin = [...x.toArray(), ...y.toArray(), ...z.toArray()];\n  } else {\n    origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];\n  }\n  const xAxis = transform.transformAsVector(origin.slice(0, 3));\n  const yAxis = transform.transformAsVector(origin.slice(3, 6));\n  const zAxis = transform.transformAsVector(origin.slice(6, 9));\n  const halfAxes = new Matrix3([\n    xAxis[0],\n    xAxis[1],\n    xAxis[2],\n    yAxis[0],\n    yAxis[1],\n    yAxis[2],\n    zAxis[0],\n    zAxis[1],\n    zAxis[2]\n  ]);\n\n  if (defined(result)) {\n    result.center = center;\n    result.halfAxes = halfAxes;\n    return result;\n  }\n\n  return new OrientedBoundingBox(center, halfAxes);\n}\n\n/*\nfunction createBoxFromTransformedRegion(region, transform, initialTransform, result) {\n  const rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  const minimumHeight = region[4];\n  const maximumHeight = region[5];\n\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    Ellipsoid.WGS84,\n    scratchOrientedBoundingBox\n  );\n  const center = orientedBoundingBox.center;\n  const halfAxes = orientedBoundingBox.halfAxes;\n\n  // A region bounding volume is not transformed by the transform in the tileset JSON,\n  // but may be transformed by additional transforms applied in Cesium.\n  // This is why the transform is calculated as the difference between the initial transform and the current transform.\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.inverseTransformation(initialTransform, scratchTransform),\n    scratchTransform\n  );\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const rotationScale = Matrix4.getRotation(transform, scratchMatrix);\n  halfAxes = Matrix3.multiply(rotationScale, halfAxes, halfAxes);\n\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\nfunction createRegion(region, transform, initialTransform, result) {\n  if (!Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {\n    return createBoxFromTransformedRegion(region, transform, initialTransform, result);\n  }\n\n  if (defined(result)) {\n    return result;\n  }\n\n  const rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5]\n  });\n}\n*/\n\nfunction createSphere(sphere, transform, result?) {\n  // Find the transformed center\n  const center = new Vector3(sphere[0], sphere[1], sphere[2]);\n  transform.transform(center, center);\n  const scale = transform.getScale(scratchScale);\n\n  const uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n  const radius = sphere[3] * uniformScale;\n\n  if (defined(result)) {\n    result.center = center;\n    result.radius = radius;\n    return result;\n  }\n\n  return new BoundingSphere(center, radius);\n}\n\n/**\n * Convert a bounding volume defined by OrientedBoundingBox to cartographic bounds\n * @returns {CartographicBounds}\n */\nfunction orientedBoundingBoxToCartographicBounds(\n  boundingVolume: OrientedBoundingBox\n): CartographicBounds {\n  const result = emptyCartographicBounds();\n\n  const {halfAxes} = boundingVolume as OrientedBoundingBox;\n  const xAxis = new Vector3(halfAxes.getColumn(0));\n  const yAxis = new Vector3(halfAxes.getColumn(1));\n  const zAxis = new Vector3(halfAxes.getColumn(2));\n\n  // Test all 8 corners of the box\n  for (let x = 0; x < 2; x++) {\n    for (let y = 0; y < 2; y++) {\n      for (let z = 0; z < 2; z++) {\n        scratchPoint.copy(boundingVolume.center);\n        scratchPoint.add(xAxis);\n        scratchPoint.add(yAxis);\n        scratchPoint.add(zAxis);\n\n        addToCartographicBounds(result, scratchPoint);\n        zAxis.negate();\n      }\n      yAxis.negate();\n    }\n    xAxis.negate();\n  }\n  return result;\n}\n\n/**\n * Convert a bounding volume defined by BoundingSphere to cartographic bounds\n * @returns {CartographicBounds}\n */\nfunction boundingSphereToCartographicBounds(boundingVolume: BoundingSphere): CartographicBounds {\n  const result = emptyCartographicBounds();\n\n  const {center, radius} = boundingVolume as BoundingSphere;\n  const point = Ellipsoid.WGS84.scaleToGeodeticSurface(center, scratchPoint);\n\n  let zAxis: Vector3;\n  if (point) {\n    zAxis = Ellipsoid.WGS84.geodeticSurfaceNormal(point) as Vector3;\n  } else {\n    zAxis = new Vector3(0, 0, 1);\n  }\n  let xAxis = new Vector3(zAxis[2], -zAxis[1], 0);\n  if (xAxis.len() > 0) {\n    xAxis.normalize();\n  } else {\n    xAxis = new Vector3(0, 1, 0);\n  }\n  const yAxis = xAxis.clone().cross(zAxis);\n\n  // Test 6 end points of the 3 axes\n  for (const axis of [xAxis, yAxis, zAxis]) {\n    scratchScale.copy(axis).scale(radius);\n    for (let dir = 0; dir < 2; dir++) {\n      scratchPoint.copy(center);\n      scratchPoint.add(scratchScale);\n      addToCartographicBounds(result, scratchPoint);\n      // Flip the axis\n      scratchScale.negate();\n    }\n  }\n  return result;\n}\n\n/**\n * Create a new cartographic bounds that contains no points\n * @returns {CartographicBounds}\n */\nfunction emptyCartographicBounds(): CartographicBounds {\n  return [\n    [Infinity, Infinity, Infinity],\n    [-Infinity, -Infinity, -Infinity]\n  ];\n}\n\n/**\n * Add a point to the target cartographic bounds\n * @param {CartographicBounds} target\n * @param {Vector3} cartesian coordinates of the point to add\n */\nfunction addToCartographicBounds(target: CartographicBounds, cartesian: Readonly<Vector3>) {\n  Ellipsoid.WGS84.cartesianToCartographic(cartesian, scratchPoint);\n  target[0][0] = Math.min(target[0][0], scratchPoint[0]);\n  target[0][1] = Math.min(target[0][1], scratchPoint[1]);\n  target[0][2] = Math.min(target[0][2], scratchPoint[2]);\n\n  target[1][0] = Math.max(target[1][0], scratchPoint[0]);\n  target[1][1] = Math.max(target[1][1], scratchPoint[1]);\n  target[1][2] = Math.max(target[1][2], scratchPoint[2]);\n}\n"],"mappings":"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"}
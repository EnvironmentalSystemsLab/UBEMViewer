{"version":3,"sources":["../../../src/layers/h3-tileset-2d.ts"],"names":["_Tileset2D","Tileset2D","polyfill","geoToH3","h3GetResolution","h3ToGeoBoundary","h3ToParent","kRing","getHexagonsInBoundingBox","west","north","east","south","resolution","longitudeSpan","Math","abs","nSegments","ceil","h3Indices","s","segmentEast","segmentWest","min","concat","Set","oversample","map","i","tileToBoundingBox","index","coordinates","latitudes","c","longitudes","max","BIAS","getHexagonResolution","viewport","hexagonScaleFactor","zoom","latitudeScaleFactor","log","cos","PI","latitude","floor","H3Tileset2D","getTileIndices","minZoom","maxZoom","undefined","getBounds","z","indices","Number","isFinite","center","longitude","getTileId","getTileMetadata","bbox","getTileZoom","getParentIndex"],"mappings":"AAAA,SAAQA,UAAU,IAAIC,SAAtB,QAAsD,qBAAtD;AACA,SAAQC,QAAR,EAAkBC,OAAlB,EAA2BC,eAA3B,EAA4CC,eAA5C,EAA6DC,UAA7D,EAAyEC,KAAzE,QAAqF,OAArF;;AAIA,SAASC,wBAAT,CACE;AAACC,EAAAA,IAAD;AAAOC,EAAAA,KAAP;AAAcC,EAAAA,IAAd;AAAoBC,EAAAA;AAApB,CADF,EAEEC,UAFF,EAGY;AACV,QAAMC,aAAa,GAAGC,IAAI,CAACC,GAAL,CAASL,IAAI,GAAGF,IAAhB,CAAtB;;AACA,MAAIK,aAAa,GAAG,GAApB,EAAyB;AAGvB,UAAMG,SAAS,GAAGF,IAAI,CAACG,IAAL,CAAUJ,aAAa,GAAG,GAA1B,CAAlB;AACA,QAAIK,SAAmB,GAAG,EAA1B;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+BG,CAAC,EAAhC,EAAoC;AAClC,YAAMC,WAAW,GAAGV,IAAI,GAAGS,CAAC,GAAG,GAA/B;AACA,YAAME,WAAW,GAAGP,IAAI,CAACQ,GAAL,CAASF,WAAW,GAAG,WAAvB,EAAoCZ,IAApC,CAApB;AACAU,MAAAA,SAAS,GAAGA,SAAS,CAACK,MAAV,CACVhB,wBAAwB,CAAC;AAACC,QAAAA,IAAI,EAAEa,WAAP;AAAoBZ,QAAAA,KAApB;AAA2BC,QAAAA,IAAI,EAAEU,WAAjC;AAA8CT,QAAAA;AAA9C,OAAD,EAAuDC,UAAvD,CADd,CAAZ;AAGD;;AACD,WAAO,CAAC,GAAG,IAAIY,GAAJ,CAAQN,SAAR,CAAJ,CAAP;AACD;;AAID,QAAMO,UAAU,GAAG,CAAnB;AACA,QAAMP,SAAS,GAAGjB,QAAQ,CACxB,CACE,CACE,CAACO,IAAD,EAAOC,KAAP,CADF,EAEE,CAACD,IAAD,EAAOG,KAAP,CAFF,EAGE,CAACD,IAAD,EAAOC,KAAP,CAHF,EAIE,CAACD,IAAD,EAAOD,KAAP,CAJF,EAKE,CAACD,IAAD,EAAOC,KAAP,CALF,CADF,CADwB,EAUxBG,UAAU,GAAGa,UAVW,EAWxB,IAXwB,CAA1B;AAcA,SAAOA,UAAU,GAAG,CAAC,GAAG,IAAID,GAAJ,CAAQN,SAAS,CAACQ,GAAV,CAAcC,CAAC,IAAItB,UAAU,CAACsB,CAAD,EAAIf,UAAJ,CAA7B,CAAR,CAAJ,CAAH,GAAiEM,SAAlF;AACD;;AAED,SAASU,iBAAT,CAA2BC,KAA3B,EAA0D;AACxD,QAAMC,WAAW,GAAG1B,eAAe,CAACyB,KAAD,CAAnC;AACA,QAAME,SAAS,GAAGD,WAAW,CAACJ,GAAZ,CAAgBM,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAtB,CAAlB;AACA,QAAMC,UAAU,GAAGH,WAAW,CAACJ,GAAZ,CAAgBM,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAtB,CAAnB;AACA,QAAMxB,IAAI,GAAGM,IAAI,CAACQ,GAAL,CAAS,GAAGW,UAAZ,CAAb;AACA,QAAMtB,KAAK,GAAGG,IAAI,CAACQ,GAAL,CAAS,GAAGS,SAAZ,CAAd;AACA,QAAMrB,IAAI,GAAGI,IAAI,CAACoB,GAAL,CAAS,GAAGD,UAAZ,CAAb;AACA,QAAMxB,KAAK,GAAGK,IAAI,CAACoB,GAAL,CAAS,GAAGH,SAAZ,CAAd;AACA,SAAO;AAACvB,IAAAA,IAAD;AAAOG,IAAAA,KAAP;AAAcD,IAAAA,IAAd;AAAoBD,IAAAA;AAApB,GAAP;AACD;;AAMD,MAAM0B,IAAI,GAAG,CAAb;AACA,OAAO,SAASC,oBAAT,CAA8BC,QAA9B,EAAgD;AACrD,QAAMC,kBAAkB,GAAI,IAAI,CAAL,GAAUD,QAAQ,CAACE,IAA9C;AACA,QAAMC,mBAAmB,GAAG1B,IAAI,CAAC2B,GAAL,CAAS,IAAI3B,IAAI,CAAC4B,GAAL,CAAU5B,IAAI,CAAC6B,EAAL,GAAUN,QAAQ,CAACO,QAApB,GAAgC,GAAzC,CAAb,CAA5B;AAGA,SAAO9B,IAAI,CAACoB,GAAL,CAAS,CAAT,EAAYpB,IAAI,CAAC+B,KAAL,CAAWP,kBAAkB,GAAGE,mBAArB,GAA2CL,IAAtD,CAAZ,CAAP;AACD;AAED,eAAe,MAAMW,WAAN,SAA0B9C,SAA1B,CAAoC;AAOjD+C,EAAAA,cAAc,CAAC;AAACV,IAAAA,QAAD;AAAWW,IAAAA,OAAX;AAAoBC,IAAAA;AAApB,GAAD,EAA8C;AAC1D,QAAIZ,QAAQ,CAACO,QAAT,KAAsBM,SAA1B,EAAqC,OAAO,EAAP;AACrC,UAAM,CAACxC,IAAD,EAAOC,KAAP,EAAcH,IAAd,EAAoBC,KAApB,IAA6B4B,QAAQ,CAACc,SAAT,EAAnC;AAEA,QAAIC,CAAC,GAAGhB,oBAAoB,CAACC,QAAD,CAA5B;AACA,QAAIgB,OAAJ;;AACA,QAAI,OAAOL,OAAP,KAAmB,QAAnB,IAA+BM,MAAM,CAACC,QAAP,CAAgBP,OAAhB,CAA/B,IAA2DI,CAAC,GAAGJ,OAAnE,EAA4E;AAE1E,aAAO,EAAP;AACD;;AACD,QAAI,OAAOC,OAAP,KAAmB,QAAnB,IAA+BK,MAAM,CAACC,QAAP,CAAgBN,OAAhB,CAA/B,IAA2DG,CAAC,GAAGH,OAAnE,EAA4E;AAC1EG,MAAAA,CAAC,GAAGH,OAAJ;AAIA,YAAMO,MAAM,GAAGtD,OAAO,CAACmC,QAAQ,CAACO,QAAV,EAAoBP,QAAQ,CAACoB,SAA7B,EAAwCR,OAAxC,CAAtB;AACAI,MAAAA,OAAO,GAAG/C,KAAK,CAACkD,MAAD,EAAS,CAAT,CAAf;AACD,KAPD,MAOO;AACLH,MAAAA,OAAO,GAAG9C,wBAAwB,CAAC;AAACC,QAAAA,IAAD;AAAOC,QAAAA,KAAP;AAAcC,QAAAA,IAAd;AAAoBC,QAAAA;AAApB,OAAD,EAA6ByC,CAA7B,CAAlC;AACD;;AAED,WAAOC,OAAO,CAAC3B,GAAR,CAAYC,CAAC,KAAK;AAACA,MAAAA;AAAD,KAAL,CAAb,CAAP;AACD;;AAGD+B,EAAAA,SAAS,CAAC;AAAC/B,IAAAA;AAAD,GAAD,EAA2B;AAClC,WAAOA,CAAP;AACD;;AAGDgC,EAAAA,eAAe,CAAC;AAAChC,IAAAA;AAAD,GAAD,EAAmB;AAChC,WAAO;AAACiC,MAAAA,IAAI,EAAEhC,iBAAiB,CAACD,CAAD;AAAxB,KAAP;AACD;;AAGDkC,EAAAA,WAAW,CAAC;AAAClC,IAAAA;AAAD,GAAD,EAA2B;AACpC,WAAOxB,eAAe,CAACwB,CAAD,CAAtB;AACD;;AAGDmC,EAAAA,cAAc,CAACjC,KAAD,EAAkC;AAC9C,UAAMjB,UAAU,GAAGT,eAAe,CAAC0B,KAAK,CAACF,CAAP,CAAlC;AACA,UAAMA,CAAC,GAAGtB,UAAU,CAACwB,KAAK,CAACF,CAAP,EAAUf,UAAU,GAAG,CAAvB,CAApB;AACA,WAAO;AAACe,MAAAA;AAAD,KAAP;AACD;;AAnDgD","sourcesContent":["import {_Tileset2D as Tileset2D, GeoBoundingBox} from '@deck.gl/geo-layers';\nimport {polyfill, geoToH3, h3GetResolution, h3ToGeoBoundary, h3ToParent, kRing} from 'h3-js';\n\nexport type H3TileIndex = {i: string};\n\nfunction getHexagonsInBoundingBox(\n  {west, north, east, south}: GeoBoundingBox,\n  resolution: number\n): string[] {\n  const longitudeSpan = Math.abs(east - west);\n  if (longitudeSpan > 180) {\n    // This is a known issue in h3-js: polyfill does not work correctly\n    // when longitude span is larger than 180 degrees.\n    const nSegments = Math.ceil(longitudeSpan / 180);\n    let h3Indices: string[] = [];\n    for (let s = 0; s < nSegments; s++) {\n      const segmentEast = east + s * 180;\n      const segmentWest = Math.min(segmentEast + 179.9999999, west);\n      h3Indices = h3Indices.concat(\n        getHexagonsInBoundingBox({west: segmentWest, north, east: segmentEast, south}, resolution)\n      );\n    }\n    return [...new Set(h3Indices)];\n  }\n\n  // `polyfill()` fills based on hexagon center, which means tiles vanish\n  // prematurely. Get more accurate coverage by oversampling\n  const oversample = 2;\n  const h3Indices = polyfill(\n    [\n      [\n        [west, north],\n        [west, south],\n        [east, south],\n        [east, north],\n        [west, north]\n      ]\n    ],\n    resolution + oversample,\n    true\n  );\n\n  return oversample ? [...new Set(h3Indices.map(i => h3ToParent(i, resolution)))] : h3Indices;\n}\n\nfunction tileToBoundingBox(index: string): GeoBoundingBox {\n  const coordinates = h3ToGeoBoundary(index);\n  const latitudes = coordinates.map(c => c[0]);\n  const longitudes = coordinates.map(c => c[1]);\n  const west = Math.min(...longitudes);\n  const south = Math.min(...latitudes);\n  const east = Math.max(...longitudes);\n  const north = Math.max(...latitudes);\n  return {west, south, east, north};\n}\n\n// Resolution conversion function. Takes a WebMercatorViewport and returns\n// a H3 resolution such that the screen space size of the hexagons is\n// similar\n// Relative scale factor (0 = no biasing, 2 = a few hexagons cover view)\nconst BIAS = 2;\nexport function getHexagonResolution(viewport): number {\n  const hexagonScaleFactor = (2 / 3) * viewport.zoom;\n  const latitudeScaleFactor = Math.log(1 / Math.cos((Math.PI * viewport.latitude) / 180));\n\n  // Clip and bias\n  return Math.max(0, Math.floor(hexagonScaleFactor + latitudeScaleFactor - BIAS));\n}\n\nexport default class H3Tileset2D extends Tileset2D {\n  /**\n   * Returns all tile indices in the current viewport. If the current zoom level is smaller\n   * than minZoom, return an empty array. If the current zoom level is greater than maxZoom,\n   * return tiles that are on maxZoom.\n   */\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileIndices({viewport, minZoom, maxZoom}): H3TileIndex[] {\n    if (viewport.latitude === undefined) return [];\n    const [east, south, west, north] = viewport.getBounds();\n\n    let z = getHexagonResolution(viewport);\n    let indices: string[];\n    if (typeof minZoom === 'number' && Number.isFinite(minZoom) && z < minZoom) {\n      // TODO support `extent` prop\n      return [];\n    }\n    if (typeof maxZoom === 'number' && Number.isFinite(maxZoom) && z > maxZoom) {\n      z = maxZoom;\n\n      // Once we are at max zoom, getHexagonsInBoundingBox doesn't work, simply\n      // get a ring centered on the hexagon in the viewport center\n      const center = geoToH3(viewport.latitude, viewport.longitude, maxZoom);\n      indices = kRing(center, 1);\n    } else {\n      indices = getHexagonsInBoundingBox({west, north, east, south}, z);\n    }\n\n    return indices.map(i => ({i}));\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileId({i}: H3TileIndex): string {\n    return i;\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileMetadata({i}: H3TileIndex) {\n    return {bbox: tileToBoundingBox(i)};\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileZoom({i}: H3TileIndex): number {\n    return h3GetResolution(i);\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getParentIndex(index: H3TileIndex): H3TileIndex {\n    const resolution = h3GetResolution(index.i);\n    const i = h3ToParent(index.i, resolution - 1);\n    return {i};\n  }\n}\n"],"file":"h3-tileset-2d.js"}
import type Deck from './deck';
import type Viewport from '../viewports/viewport';
import type { PickingInfo } from './picking/pick-info';
import type { MjolnirPointerEvent, MjolnirGestureEvent } from 'mjolnir.js';
import type Layer from './layer';
export interface Widget<PropsT = any> {
    _element?: HTMLDivElement | null;
    _viewId?: string | null;
    /** Called when the widget is added to a Deck instance.
     * @returns an optional UI element that should be appended to the Deck container */
    onAdd: (params: {
        /** The Deck instance that the widget is attached to */
        deck: Deck;
        /** The id of the view that the widget is attached to */
        viewId: string | null;
    }) => HTMLDivElement | null;
    /** Called when the widget is removed */
    onRemove: () => void;
    /** Called to update widget options */
    setProps?: (props: Partial<PropsT>) => void;
    /** Called when the containing view is changed */
    onViewportChange?: (viewport: Viewport) => void;
    /** Called when the containing view is redrawn */
    onRedraw?: (params: {
        viewports: Viewport[];
        layers: Layer[];
    }) => void;
    /** Called when a hover event occurs */
    onHover?: (info: PickingInfo, event: MjolnirPointerEvent) => void;
    /** Called when a click event occurs */
    onClick?: (info: PickingInfo, event: MjolnirGestureEvent) => void;
    /** Called when a drag event occurs */
    onDrag?: (info: PickingInfo, event: MjolnirGestureEvent) => void;
    /** Called when a dragstart event occurs */
    onDragStart?: (info: PickingInfo, event: MjolnirGestureEvent) => void;
    /** Called when a dragend event occurs */
    onDragEnd?: (info: PickingInfo, event: MjolnirGestureEvent) => void;
}
declare const PLACEMENTS: {
    readonly 'top-left': {
        readonly top: 0;
        readonly left: 0;
    };
    readonly 'top-right': {
        readonly top: 0;
        readonly right: 0;
    };
    readonly 'bottom-left': {
        readonly bottom: 0;
        readonly left: 0;
    };
    readonly 'bottom-right': {
        readonly bottom: 0;
        readonly right: 0;
    };
    readonly fill: {
        readonly top: 0;
        readonly left: 0;
        readonly bottom: 0;
        readonly right: 0;
    };
};
export declare type WidgetPlacement = keyof typeof PLACEMENTS;
export declare class WidgetManager {
    deck: Deck;
    parent?: HTMLElement | null;
    containers: {
        [id: string]: HTMLDivElement;
    };
    widgets: Widget[];
    lastViewports: {
        [id: string]: Viewport;
    };
    constructor({ deck, parent }: {
        deck: Deck;
        parent?: HTMLElement | null;
    });
    finalize(): void;
    add(widget: Widget, opts?: {
        viewId?: string | null;
        placement?: WidgetPlacement;
    }): void;
    remove(widget: Widget): void;
    private _getContainer;
    private _updateContainers;
    onRedraw({ viewports, layers }: {
        viewports: Viewport[];
        layers: Layer[];
    }): void;
    onHover(info: PickingInfo, event: MjolnirPointerEvent): void;
    onEvent(info: PickingInfo, event: MjolnirGestureEvent): void;
}
export {};
//# sourceMappingURL=widget-manager.d.ts.map
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // external-global-plugin:@deck.gl/core
  var require_core = __commonJS({
    "external-global-plugin:@deck.gl/core"(exports, module) {
      module.exports = globalThis.deck;
    }
  });

  // ../../node_modules/jsep/build/jsep.js
  var require_jsep = __commonJS({
    "../../node_modules/jsep/build/jsep.js"(exports, module) {
      (function(root) {
        "use strict";
        var COMPOUND = "Compound", IDENTIFIER = "Identifier", MEMBER_EXP = "MemberExpression", LITERAL = "Literal", THIS_EXP = "ThisExpression", CALL_EXP = "CallExpression", UNARY_EXP = "UnaryExpression", BINARY_EXP = "BinaryExpression", LOGICAL_EXP = "LogicalExpression", CONDITIONAL_EXP = "ConditionalExpression", ARRAY_EXP = "ArrayExpression", PERIOD_CODE = 46, COMMA_CODE = 44, SQUOTE_CODE = 39, DQUOTE_CODE = 34, OPAREN_CODE = 40, CPAREN_CODE = 41, OBRACK_CODE = 91, CBRACK_CODE = 93, QUMARK_CODE = 63, SEMCOL_CODE = 59, COLON_CODE = 58, throwError = function(message, index) {
          var error = new Error(message + " at character " + index);
          error.index = index;
          error.description = message;
          throw error;
        }, t = true, unary_ops = { "-": t, "!": t, "~": t, "+": t }, binary_ops = {
          "||": 1,
          "&&": 2,
          "|": 3,
          "^": 4,
          "&": 5,
          "==": 6,
          "!=": 6,
          "===": 6,
          "!==": 6,
          "<": 7,
          ">": 7,
          "<=": 7,
          ">=": 7,
          "<<": 8,
          ">>": 8,
          ">>>": 8,
          "+": 9,
          "-": 9,
          "*": 10,
          "/": 10,
          "%": 10
        }, getMaxKeyLen = function(obj) {
          var max_len = 0, len;
          for (var key in obj) {
            if ((len = key.length) > max_len && obj.hasOwnProperty(key)) {
              max_len = len;
            }
          }
          return max_len;
        }, max_unop_len = getMaxKeyLen(unary_ops), max_binop_len = getMaxKeyLen(binary_ops), literals = {
          "true": true,
          "false": false,
          "null": null
        }, this_str = "this", binaryPrecedence = function(op_val) {
          return binary_ops[op_val] || 0;
        }, createBinaryExpression = function(operator, left, right) {
          var type = operator === "||" || operator === "&&" ? LOGICAL_EXP : BINARY_EXP;
          return {
            type,
            operator,
            left,
            right
          };
        }, isDecimalDigit = function(ch) {
          return ch >= 48 && ch <= 57;
        }, isIdentifierStart = function(ch) {
          return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 128 && !binary_ops[String.fromCharCode(ch)];
        }, isIdentifierPart = function(ch) {
          return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57 || ch >= 128 && !binary_ops[String.fromCharCode(ch)];
        }, jsep = function(expr) {
          var index = 0, charAtFunc = expr.charAt, charCodeAtFunc = expr.charCodeAt, exprI = function(i) {
            return charAtFunc.call(expr, i);
          }, exprICode = function(i) {
            return charCodeAtFunc.call(expr, i);
          }, length = expr.length, gobbleSpaces = function() {
            var ch = exprICode(index);
            while (ch === 32 || ch === 9 || ch === 10 || ch === 13) {
              ch = exprICode(++index);
            }
          }, gobbleExpression = function() {
            var test = gobbleBinaryExpression(), consequent, alternate;
            gobbleSpaces();
            if (exprICode(index) === QUMARK_CODE) {
              index++;
              consequent = gobbleExpression();
              if (!consequent) {
                throwError("Expected expression", index);
              }
              gobbleSpaces();
              if (exprICode(index) === COLON_CODE) {
                index++;
                alternate = gobbleExpression();
                if (!alternate) {
                  throwError("Expected expression", index);
                }
                return {
                  type: CONDITIONAL_EXP,
                  test,
                  consequent,
                  alternate
                };
              } else {
                throwError("Expected :", index);
              }
            } else {
              return test;
            }
          }, gobbleBinaryOp = function() {
            gobbleSpaces();
            var biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;
            while (tc_len > 0) {
              if (binary_ops.hasOwnProperty(to_check) && (!isIdentifierStart(exprICode(index)) || index + to_check.length < expr.length && !isIdentifierPart(exprICode(index + to_check.length)))) {
                index += tc_len;
                return to_check;
              }
              to_check = to_check.substr(0, --tc_len);
            }
            return false;
          }, gobbleBinaryExpression = function() {
            var ch_i2, node2, biop, prec, stack, biop_info, left, right, i;
            left = gobbleToken();
            biop = gobbleBinaryOp();
            if (!biop) {
              return left;
            }
            biop_info = { value: biop, prec: binaryPrecedence(biop) };
            right = gobbleToken();
            if (!right) {
              throwError("Expected expression after " + biop, index);
            }
            stack = [left, biop_info, right];
            while (biop = gobbleBinaryOp()) {
              prec = binaryPrecedence(biop);
              if (prec === 0) {
                break;
              }
              biop_info = { value: biop, prec };
              while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
                right = stack.pop();
                biop = stack.pop().value;
                left = stack.pop();
                node2 = createBinaryExpression(biop, left, right);
                stack.push(node2);
              }
              node2 = gobbleToken();
              if (!node2) {
                throwError("Expected expression after " + biop, index);
              }
              stack.push(biop_info, node2);
            }
            i = stack.length - 1;
            node2 = stack[i];
            while (i > 1) {
              node2 = createBinaryExpression(stack[i - 1].value, stack[i - 2], node2);
              i -= 2;
            }
            return node2;
          }, gobbleToken = function() {
            var ch, to_check, tc_len;
            gobbleSpaces();
            ch = exprICode(index);
            if (isDecimalDigit(ch) || ch === PERIOD_CODE) {
              return gobbleNumericLiteral();
            } else if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {
              return gobbleStringLiteral();
            } else if (ch === OBRACK_CODE) {
              return gobbleArray();
            } else {
              to_check = expr.substr(index, max_unop_len);
              tc_len = to_check.length;
              while (tc_len > 0) {
                if (unary_ops.hasOwnProperty(to_check) && (!isIdentifierStart(exprICode(index)) || index + to_check.length < expr.length && !isIdentifierPart(exprICode(index + to_check.length)))) {
                  index += tc_len;
                  return {
                    type: UNARY_EXP,
                    operator: to_check,
                    argument: gobbleToken(),
                    prefix: true
                  };
                }
                to_check = to_check.substr(0, --tc_len);
              }
              if (isIdentifierStart(ch) || ch === OPAREN_CODE) {
                return gobbleVariable();
              }
            }
            return false;
          }, gobbleNumericLiteral = function() {
            var number = "", ch, chCode;
            while (isDecimalDigit(exprICode(index))) {
              number += exprI(index++);
            }
            if (exprICode(index) === PERIOD_CODE) {
              number += exprI(index++);
              while (isDecimalDigit(exprICode(index))) {
                number += exprI(index++);
              }
            }
            ch = exprI(index);
            if (ch === "e" || ch === "E") {
              number += exprI(index++);
              ch = exprI(index);
              if (ch === "+" || ch === "-") {
                number += exprI(index++);
              }
              while (isDecimalDigit(exprICode(index))) {
                number += exprI(index++);
              }
              if (!isDecimalDigit(exprICode(index - 1))) {
                throwError("Expected exponent (" + number + exprI(index) + ")", index);
              }
            }
            chCode = exprICode(index);
            if (isIdentifierStart(chCode)) {
              throwError("Variable names cannot start with a number (" + number + exprI(index) + ")", index);
            } else if (chCode === PERIOD_CODE) {
              throwError("Unexpected period", index);
            }
            return {
              type: LITERAL,
              value: parseFloat(number),
              raw: number
            };
          }, gobbleStringLiteral = function() {
            var str = "", quote = exprI(index++), closed = false, ch;
            while (index < length) {
              ch = exprI(index++);
              if (ch === quote) {
                closed = true;
                break;
              } else if (ch === "\\") {
                ch = exprI(index++);
                switch (ch) {
                  case "n":
                    str += "\n";
                    break;
                  case "r":
                    str += "\r";
                    break;
                  case "t":
                    str += "	";
                    break;
                  case "b":
                    str += "\b";
                    break;
                  case "f":
                    str += "\f";
                    break;
                  case "v":
                    str += "\v";
                    break;
                  default:
                    str += ch;
                }
              } else {
                str += ch;
              }
            }
            if (!closed) {
              throwError('Unclosed quote after "' + str + '"', index);
            }
            return {
              type: LITERAL,
              value: str,
              raw: quote + str + quote
            };
          }, gobbleIdentifier = function() {
            var ch = exprICode(index), start = index, identifier;
            if (isIdentifierStart(ch)) {
              index++;
            } else {
              throwError("Unexpected " + exprI(index), index);
            }
            while (index < length) {
              ch = exprICode(index);
              if (isIdentifierPart(ch)) {
                index++;
              } else {
                break;
              }
            }
            identifier = expr.slice(start, index);
            if (literals.hasOwnProperty(identifier)) {
              return {
                type: LITERAL,
                value: literals[identifier],
                raw: identifier
              };
            } else if (identifier === this_str) {
              return { type: THIS_EXP };
            } else {
              return {
                type: IDENTIFIER,
                name: identifier
              };
            }
          }, gobbleArguments = function(termination) {
            var ch_i2, args = [], node2, closed = false;
            while (index < length) {
              gobbleSpaces();
              ch_i2 = exprICode(index);
              if (ch_i2 === termination) {
                closed = true;
                index++;
                break;
              } else if (ch_i2 === COMMA_CODE) {
                index++;
              } else {
                node2 = gobbleExpression();
                if (!node2 || node2.type === COMPOUND) {
                  throwError("Expected comma", index);
                }
                args.push(node2);
              }
            }
            if (!closed) {
              throwError("Expected " + String.fromCharCode(termination), index);
            }
            return args;
          }, gobbleVariable = function() {
            var ch_i2, node2;
            ch_i2 = exprICode(index);
            if (ch_i2 === OPAREN_CODE) {
              node2 = gobbleGroup();
            } else {
              node2 = gobbleIdentifier();
            }
            gobbleSpaces();
            ch_i2 = exprICode(index);
            while (ch_i2 === PERIOD_CODE || ch_i2 === OBRACK_CODE || ch_i2 === OPAREN_CODE) {
              index++;
              if (ch_i2 === PERIOD_CODE) {
                gobbleSpaces();
                node2 = {
                  type: MEMBER_EXP,
                  computed: false,
                  object: node2,
                  property: gobbleIdentifier()
                };
              } else if (ch_i2 === OBRACK_CODE) {
                node2 = {
                  type: MEMBER_EXP,
                  computed: true,
                  object: node2,
                  property: gobbleExpression()
                };
                gobbleSpaces();
                ch_i2 = exprICode(index);
                if (ch_i2 !== CBRACK_CODE) {
                  throwError("Unclosed [", index);
                }
                index++;
              } else if (ch_i2 === OPAREN_CODE) {
                node2 = {
                  type: CALL_EXP,
                  "arguments": gobbleArguments(CPAREN_CODE),
                  callee: node2
                };
              }
              gobbleSpaces();
              ch_i2 = exprICode(index);
            }
            return node2;
          }, gobbleGroup = function() {
            index++;
            var node2 = gobbleExpression();
            gobbleSpaces();
            if (exprICode(index) === CPAREN_CODE) {
              index++;
              return node2;
            } else {
              throwError("Unclosed (", index);
            }
          }, gobbleArray = function() {
            index++;
            return {
              type: ARRAY_EXP,
              elements: gobbleArguments(CBRACK_CODE)
            };
          }, nodes = [], ch_i, node;
          while (index < length) {
            ch_i = exprICode(index);
            if (ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {
              index++;
            } else {
              if (node = gobbleExpression()) {
                nodes.push(node);
              } else if (index < length) {
                throwError('Unexpected "' + exprI(index) + '"', index);
              }
            }
          }
          if (nodes.length === 1) {
            return nodes[0];
          } else {
            return {
              type: COMPOUND,
              body: nodes
            };
          }
        };
        jsep.version = "0.3.4";
        jsep.toString = function() {
          return "JavaScript Expression Parser (JSEP) v" + jsep.version;
        };
        jsep.addUnaryOp = function(op_name) {
          max_unop_len = Math.max(op_name.length, max_unop_len);
          unary_ops[op_name] = t;
          return this;
        };
        jsep.addBinaryOp = function(op_name, precedence) {
          max_binop_len = Math.max(op_name.length, max_binop_len);
          binary_ops[op_name] = precedence;
          return this;
        };
        jsep.addLiteral = function(literal_name, literal_value) {
          literals[literal_name] = literal_value;
          return this;
        };
        jsep.removeUnaryOp = function(op_name) {
          delete unary_ops[op_name];
          if (op_name.length === max_unop_len) {
            max_unop_len = getMaxKeyLen(unary_ops);
          }
          return this;
        };
        jsep.removeAllUnaryOps = function() {
          unary_ops = {};
          max_unop_len = 0;
          return this;
        };
        jsep.removeBinaryOp = function(op_name) {
          delete binary_ops[op_name];
          if (op_name.length === max_binop_len) {
            max_binop_len = getMaxKeyLen(binary_ops);
          }
          return this;
        };
        jsep.removeAllBinaryOps = function() {
          binary_ops = {};
          max_binop_len = 0;
          return this;
        };
        jsep.removeLiteral = function(literal_name) {
          delete literals[literal_name];
          return this;
        };
        jsep.removeAllLiterals = function() {
          literals = {};
          return this;
        };
        if (typeof exports === "undefined") {
          var old_jsep = root.jsep;
          root.jsep = jsep;
          jsep.noConflict = function() {
            if (root.jsep === jsep) {
              root.jsep = old_jsep;
            }
            return jsep;
          };
        } else {
          if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = jsep;
          } else {
            exports.parse = jsep;
          }
        }
      })(exports);
    }
  });

  // ../../node_modules/expression-eval/index.js
  var require_expression_eval = __commonJS({
    "../../node_modules/expression-eval/index.js"(exports, module) {
      var jsep = require_jsep();
      var binops = {
        "||": function(a, b) {
          return a || b;
        },
        "&&": function(a, b) {
          return a && b;
        },
        "|": function(a, b) {
          return a | b;
        },
        "^": function(a, b) {
          return a ^ b;
        },
        "&": function(a, b) {
          return a & b;
        },
        "==": function(a, b) {
          return a == b;
        },
        "!=": function(a, b) {
          return a != b;
        },
        "===": function(a, b) {
          return a === b;
        },
        "!==": function(a, b) {
          return a !== b;
        },
        "<": function(a, b) {
          return a < b;
        },
        ">": function(a, b) {
          return a > b;
        },
        "<=": function(a, b) {
          return a <= b;
        },
        ">=": function(a, b) {
          return a >= b;
        },
        "<<": function(a, b) {
          return a << b;
        },
        ">>": function(a, b) {
          return a >> b;
        },
        ">>>": function(a, b) {
          return a >>> b;
        },
        "+": function(a, b) {
          return a + b;
        },
        "-": function(a, b) {
          return a - b;
        },
        "*": function(a, b) {
          return a * b;
        },
        "/": function(a, b) {
          return a / b;
        },
        "%": function(a, b) {
          return a % b;
        }
      };
      var unops = {
        "-": function(a) {
          return -a;
        },
        "+": function(a) {
          return +a;
        },
        "~": function(a) {
          return ~a;
        },
        "!": function(a) {
          return !a;
        }
      };
      function evaluateArray(list, context) {
        return list.map(function(v) {
          return evaluate(v, context);
        });
      }
      async function evaluateArrayAsync(list, context) {
        const res = await Promise.all(list.map((v) => evaluateAsync(v, context)));
        return res;
      }
      function evaluateMember(node, context) {
        const object = evaluate(node.object, context);
        if (node.computed) {
          return [object, object[evaluate(node.property, context)]];
        } else {
          return [object, object[node.property.name]];
        }
      }
      async function evaluateMemberAsync(node, context) {
        const object = await evaluateAsync(node.object, context);
        if (node.computed) {
          return [object, object[await evaluateAsync(node.property, context)]];
        } else {
          return [object, object[node.property.name]];
        }
      }
      function evaluate(node, context) {
        switch (node.type) {
          case "ArrayExpression":
            return evaluateArray(node.elements, context);
          case "BinaryExpression":
            return binops[node.operator](evaluate(node.left, context), evaluate(node.right, context));
          case "CallExpression":
            let caller, fn, assign;
            if (node.callee.type === "MemberExpression") {
              assign = evaluateMember(node.callee, context);
              caller = assign[0];
              fn = assign[1];
            } else {
              fn = evaluate(node.callee, context);
            }
            if (typeof fn !== "function") {
              return void 0;
            }
            return fn.apply(caller, evaluateArray(node.arguments, context));
          case "ConditionalExpression":
            return evaluate(node.test, context) ? evaluate(node.consequent, context) : evaluate(node.alternate, context);
          case "Identifier":
            return context[node.name];
          case "Literal":
            return node.value;
          case "LogicalExpression":
            if (node.operator === "||") {
              return evaluate(node.left, context) || evaluate(node.right, context);
            } else if (node.operator === "&&") {
              return evaluate(node.left, context) && evaluate(node.right, context);
            }
            return binops[node.operator](evaluate(node.left, context), evaluate(node.right, context));
          case "MemberExpression":
            return evaluateMember(node, context)[1];
          case "ThisExpression":
            return context;
          case "UnaryExpression":
            return unops[node.operator](evaluate(node.argument, context));
          default:
            return void 0;
        }
      }
      async function evaluateAsync(node, context) {
        switch (node.type) {
          case "ArrayExpression":
            return await evaluateArrayAsync(node.elements, context);
          case "BinaryExpression": {
            const [left, right] = await Promise.all([
              evaluateAsync(node.left, context),
              evaluateAsync(node.right, context)
            ]);
            return binops[node.operator](left, right);
          }
          case "CallExpression":
            let caller, fn, assign;
            if (node.callee.type === "MemberExpression") {
              assign = await evaluateMemberAsync(node.callee, context);
              caller = assign[0];
              fn = assign[1];
            } else {
              fn = await evaluateAsync(node.callee, context);
            }
            if (typeof fn !== "function") {
              return void 0;
            }
            return await fn.apply(
              caller,
              await evaluateArrayAsync(node.arguments, context)
            );
          case "ConditionalExpression":
            return await evaluateAsync(node.test, context) ? await evaluateAsync(node.consequent, context) : await evaluateAsync(node.alternate, context);
          case "Identifier":
            return context[node.name];
          case "Literal":
            return node.value;
          case "LogicalExpression": {
            if (node.operator === "||") {
              return await evaluateAsync(node.left, context) || await evaluateAsync(node.right, context);
            } else if (node.operator === "&&") {
              return await evaluateAsync(node.left, context) && await evaluateAsync(node.right, context);
            }
            const [left, right] = await Promise.all([
              evaluateAsync(node.left, context),
              evaluateAsync(node.right, context)
            ]);
            return binops[node.operator](left, right);
          }
          case "MemberExpression":
            return (await evaluateMemberAsync(node, context))[1];
          case "ThisExpression":
            return context;
          case "UnaryExpression":
            return unops[node.operator](await evaluateAsync(node.argument, context));
          default:
            return void 0;
        }
      }
      function compile(expression) {
        return evaluate.bind(null, jsep(expression));
      }
      function compileAsync(expression) {
        return evaluateAsync.bind(null, jsep(expression));
      }
      module.exports = {
        parse: jsep,
        eval: evaluate,
        evalAsync: evaluateAsync,
        compile,
        compileAsync
      };
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    JSONConfiguration: () => JSONConfiguration,
    JSONConverter: () => JSONConverter,
    Transport: () => Transport,
    _convertFunctions: () => convertFunctions,
    _parseExpressionString: () => parseExpressionString,
    _shallowEqualObjects: () => shallowEqualObjects
  });

  // ../core/bundle/peer-dependency.ts
  var peer_dependency_exports = {};
  var import_core = __toESM(require_core());
  __reExport(peer_dependency_exports, __toESM(require_core()));
  if (!import_core.Layer) {
    throw new Error("@deck.gl/core is not found");
  }

  // bundle.ts
  __reExport(bundle_exports, peer_dependency_exports);

  // src/utils/assert.js
  function assert(condition, message = "") {
    if (!condition) {
      throw new Error(`JSON conversion error ${message}`);
    }
  }

  // src/utils/get.js
  function get(container, compositeKey) {
    const keyList = getKeys(compositeKey);
    let value = container;
    for (const key of keyList) {
      value = isObject(value) ? value[key] : void 0;
    }
    return value;
  }
  function isObject(value) {
    return value !== null && typeof value === "object";
  }
  var keyMap = {};
  function getKeys(compositeKey) {
    if (typeof compositeKey === "string") {
      let keyList = keyMap[compositeKey];
      if (!keyList) {
        keyList = compositeKey.split(".");
        keyMap[compositeKey] = keyList;
      }
      return keyList;
    }
    return Array.isArray(compositeKey) ? compositeKey : [compositeKey];
  }

  // src/helpers/parse-expression-string.js
  var import_expression_eval = __toESM(require_expression_eval());
  var cachedExpressionMap = {
    "-": (object) => object
  };
  function parseExpressionString(propValue, configuration) {
    if (propValue in cachedExpressionMap) {
      return cachedExpressionMap[propValue];
    }
    let func;
    const ast = import_expression_eval.default.parse(propValue);
    if (!ast.right && !ast.left && ast.type === "Identifier") {
      func = (row) => {
        return get(row, propValue);
      };
    } else {
      traverse(ast, (node) => {
        if (node.type === "CallExpression") {
          throw new Error("Function calls not allowed in JSON expressions");
        }
      });
      func = (row) => {
        return import_expression_eval.default.eval(ast, row);
      };
    }
    cachedExpressionMap[propValue] = func;
    return func;
  }
  function traverse(node, visitor) {
    if (Array.isArray(node)) {
      node.forEach((element) => traverse(element, visitor));
    } else if (node && typeof node === "object") {
      if (node.type) {
        visitor(node);
      }
      for (const key in node) {
        traverse(node[key], visitor);
      }
    }
  }

  // src/syntactic-sugar.js
  var FUNCTION_IDENTIFIER = "@@=";
  var CONSTANT_IDENTIFIER = "@@#";
  var TYPE_KEY = "@@type";
  var FUNCTION_KEY = "@@function";

  // src/json-configuration.js
  var isObject2 = (value) => value && typeof value === "object";
  var JSONConfiguration = class {
    constructor(...configurations) {
      this.typeKey = TYPE_KEY;
      this.functionKey = FUNCTION_KEY;
      this.log = console;
      this.classes = {};
      this.reactComponents = {};
      this.enumerations = {};
      this.constants = {};
      this.functions = {};
      this.convertFunction = parseExpressionString;
      this.preProcessClassProps = (Class, props) => props;
      this.postProcessConvertedJson = (json) => json;
      for (const configuration of configurations) {
        this.merge(configuration);
      }
    }
    merge(configuration) {
      for (const key in configuration) {
        switch (key) {
          case "layers":
          case "views":
            Object.assign(this.classes, configuration[key]);
            break;
          default:
            if (key in this) {
              const value = configuration[key];
              this[key] = isObject2(this[key]) ? Object.assign(this[key], value) : value;
            }
        }
      }
    }
    validate(configuration) {
      assert(!this.typeKey || typeof this.typeKey === "string");
      assert(isObject2(this.classes));
      return true;
    }
  };

  // src/helpers/convert-functions.js
  function hasFunctionIdentifier(value) {
    return typeof value === "string" && value.startsWith(FUNCTION_IDENTIFIER);
  }
  function trimFunctionIdentifier(value) {
    return value.replace(FUNCTION_IDENTIFIER, "");
  }
  function convertFunctions(props, configuration) {
    const replacedProps = {};
    for (const propName in props) {
      let propValue = props[propName];
      const isFunction = hasFunctionIdentifier(propValue);
      if (isFunction) {
        propValue = trimFunctionIdentifier(propValue);
        propValue = parseExpressionString(propValue, configuration);
      }
      replacedProps[propName] = propValue;
    }
    return replacedProps;
  }

  // src/helpers/instantiate-class.js
  function instantiateClass(type, props, configuration) {
    const Class = configuration.classes[type];
    const Component = configuration.reactComponents[type];
    if (!Class && !Component) {
      const {
        log
      } = configuration;
      if (log) {
        const stringProps = JSON.stringify(props, null, 0).slice(0, 40);
        log.warn(`JSON converter: No registered class of type ${type}(${stringProps}...)  `);
      }
      return null;
    }
    if (Class) {
      return instantiateJavaScriptClass(Class, props, configuration);
    }
    return instantiateReactComponent(Component, props, configuration);
  }
  function instantiateJavaScriptClass(Class, props, configuration) {
    if (configuration.preProcessClassProps) {
      props = configuration.preProcessClassProps(Class, props, configuration);
    }
    props = convertFunctions(props, configuration);
    return new Class(props);
  }
  function instantiateReactComponent(Component, props, configuration) {
    const {
      React
    } = configuration;
    const {
      children = []
    } = props;
    delete props.children;
    if (configuration.preProcessClassProps) {
      props = configuration.preProcessClassProps(Component, props, configuration);
    }
    props = convertFunctions(props, configuration);
    return React.createElement(Component, props, children);
  }

  // src/helpers/execute-function.js
  function executeFunction(targetFunction, props, configuration) {
    const matchedFunction = configuration.functions[targetFunction];
    if (!matchedFunction) {
      const {
        log
      } = configuration;
      if (log) {
        const stringProps = JSON.stringify(props, null, 0).slice(0, 40);
        log.warn(`JSON converter: No registered function ${targetFunction}(${stringProps}...)  `);
      }
      return null;
    }
    return matchedFunction(props);
  }

  // src/helpers/parse-json.js
  function parseJSON(json) {
    return typeof json === "string" ? JSON.parse(json) : json;
  }

  // src/json-converter.js
  var isObject3 = (value) => value && typeof value === "object";
  var JSONConverter = class {
    constructor(props) {
      this.log = console;
      this.configuration = {};
      this.onJSONChange = () => {
      };
      this.json = null;
      this.convertedJson = null;
      this.setProps(props);
    }
    finalize() {
    }
    setProps(props) {
      if ("configuration" in props) {
        this.configuration = props.configuration instanceof JSONConfiguration ? props.configuration : new JSONConfiguration(props.configuration);
      }
      if ("onJSONChange" in props) {
        this.onJSONChange = props.onJSONChange;
      }
    }
    mergeConfiguration(config) {
      this.configuration.merge(config);
    }
    convert(json) {
      if (!json || json === this.json) {
        return this.convertedJson;
      }
      this.json = json;
      const parsedJSON = parseJSON(json);
      let convertedJson = convertJSON(parsedJSON, this.configuration);
      convertedJson = this.configuration.postProcessConvertedJson(convertedJson);
      this.convertedJson = convertedJson;
      return convertedJson;
    }
    convertJson(json) {
      return this.convert(json);
    }
  };
  function convertJSON(json, configuration) {
    configuration = new JSONConfiguration(configuration);
    return convertJSONRecursively(json, "", configuration);
  }
  function convertJSONRecursively(json, key, configuration) {
    if (Array.isArray(json)) {
      return json.map((element, i) => convertJSONRecursively(element, String(i), configuration));
    }
    if (isClassInstance(json, configuration)) {
      return convertClassInstance(json, configuration);
    }
    if (isObject3(json)) {
      if (FUNCTION_KEY in json) {
        return convertFunctionObject(json, configuration);
      }
      return convertPlainObject(json, configuration);
    }
    if (typeof json === "string") {
      return convertString(json, key, configuration);
    }
    return json;
  }
  function isClassInstance(json, configuration) {
    const {
      typeKey
    } = configuration;
    const isClass = isObject3(json) && Boolean(json[typeKey]);
    return isClass;
  }
  function convertClassInstance(json, configuration) {
    const {
      typeKey
    } = configuration;
    const type = json[typeKey];
    let props = {
      ...json
    };
    delete props[typeKey];
    props = convertPlainObject(props, configuration);
    return instantiateClass(type, props, configuration);
  }
  function convertFunctionObject(json, configuration) {
    const {
      functionKey
    } = configuration;
    const targetFunction = json[functionKey];
    let props = {
      ...json
    };
    delete props[functionKey];
    props = convertPlainObject(props, configuration);
    return executeFunction(targetFunction, props, configuration);
  }
  function convertPlainObject(json, configuration) {
    assert(isObject3(json));
    const result = {};
    for (const key in json) {
      const value = json[key];
      result[key] = convertJSONRecursively(value, key, configuration);
    }
    return result;
  }
  function convertString(string, key, configuration) {
    if (string.startsWith(FUNCTION_IDENTIFIER) && configuration.convertFunction) {
      string = string.replace(FUNCTION_IDENTIFIER, "");
      return configuration.convertFunction(string, configuration);
    }
    if (string.startsWith(CONSTANT_IDENTIFIER)) {
      string = string.replace(CONSTANT_IDENTIFIER, "");
      if (configuration.constants[string]) {
        return configuration.constants[string];
      }
      const [enumVarName, enumValName] = string.split(".");
      return configuration.enumerations[enumVarName][enumValName];
    }
    return string;
  }

  // src/transports/transport.js
  var state = {
    onIninitialize: (_) => _,
    onFinalize: (_) => _,
    onMessage: null
  };
  var Transport = class {
    static setCallbacks({
      onInitialize,
      onFinalize,
      onMessage
    }) {
      if (onInitialize) {
        state.onInitialize = onInitialize;
      }
      if (onFinalize) {
        state.onFinalize = onFinalize;
      }
      if (onMessage) {
        state.onMessage = onMessage;
      }
    }
    constructor(name = "Transport") {
      this.name = name;
      this._messageQueue = [];
      this.userData = {};
    }
    getRootDOMElement() {
      return typeof document !== "undefined" ? document.body : null;
    }
    sendJSONMessage() {
      console.error("Back-channel not implemented for this transport");
    }
    sendBinaryMessage() {
      console.error("Back-channel not implemented for this transport");
    }
    _initialize(options = {}) {
      const message = {
        transport: this,
        ...options
      };
      state.onInitialize(message);
    }
    _finalize(options = {}) {
      const message = {
        transport: this,
        ...options
      };
      state.onFinalize(message);
      this._destroyed = true;
    }
    _messageReceived(message = {}) {
      message = {
        transport: this,
        ...message
      };
      console.debug("Delivering transport message", message);
      state.onMessage(message);
    }
    static _stringifyJSONSafe(v) {
      const cache = /* @__PURE__ */ new Set();
      return JSON.stringify(v, (key, value) => {
        if (typeof value === "object" && value !== null) {
          if (cache.has(value)) {
            try {
              return JSON.parse(JSON.stringify(value));
            } catch (err) {
              return void 0;
            }
          }
          cache.add(value);
        }
        return value;
      });
    }
  };

  // src/utils/shallow-equal-objects.js
  function shallowEqualObjects(a, b) {
    if (a === b) {
      return true;
    }
    if (typeof a !== "object" || a === null || typeof b !== "object" || b === null) {
      return false;
    }
    if (Object.keys(a).length !== Object.keys(b).length) {
      return false;
    }
    for (const key in a) {
      if (!(key in b) || a[key] !== b[key]) {
        return false;
      }
    }
    for (const key in b) {
      if (!(key in a)) {
        return false;
      }
    }
    return true;
  }
  return __toCommonJS(bundle_exports);
})();
      return __exports__;
      });
